/** ***********************************************************************************************
* @class        MainSensorUserFunctionParameters
* @brief        Parameter class for MainSensorUserFunction
*
* @author       Gerstmayr Johannes
* @date         2019-07-01 (generated)
* @date         2024-02-03  15:37:36 (last modified)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#ifndef MAINSENSORUSERFUNCTIONPARAMETERS__H
#define MAINSENSORUSERFUNCTIONPARAMETERS__H

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include <pybind11/functional.h> //! AUTO: for function handling ... otherwise gives a python error (no compilation error in C++ !)
#include "Autogenerated/CSensorUserFunction.h"

#include "Autogenerated/VisuSensorUserFunction.h"

//! AUTO: Parameters for class MainSensorUserFunctionParameters
class MainSensorUserFunctionParameters // AUTO: 
{
public: // AUTO: 
};


/** ***********************************************************************************************
* @class        MainSensorUserFunction
* @brief        A sensor defined by a user function. The sensor is intended to collect sensor values of a list of given sensors and recombine the output into a new value for output or control purposes. It is also possible to use this sensor without any dependence on other sensors in order to generate output for, e.g., any quantities in mbs or solvers.
*
* @author       Gerstmayr Johannes
* @date         2019-07-01 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

//! AUTO: MainSensorUserFunction
class MainSensorUserFunction: public MainSensor // AUTO: 
{
protected: // AUTO: 
    CSensorUserFunction* cSensorUserFunction; //pointer to computational object (initialized in object factory) AUTO:
    VisualizationSensorUserFunction* visualizationSensorUserFunction; //pointer to computational object (initialized in object factory) AUTO:

public: // AUTO: 
    //! AUTO: default constructor with parameter initialization
    MainSensorUserFunction()
    {
        name = "";
    };

    // AUTO: access functions
    //! AUTO: Get pointer to computational class
    CSensorUserFunction* GetCSensorUserFunction() { return cSensorUserFunction; }
    //! AUTO: Get const pointer to computational class
    const CSensorUserFunction* GetCSensorUserFunction() const { return cSensorUserFunction; }
    //! AUTO: Set pointer to computational class (do this only in object factory!!!)
    void SetCSensorUserFunction(CSensorUserFunction* pCSensorUserFunction) { cSensorUserFunction = pCSensorUserFunction; }

    //! AUTO: Get pointer to visualization class
    VisualizationSensorUserFunction* GetVisualizationSensorUserFunction() { return visualizationSensorUserFunction; }
    //! AUTO: Get const pointer to visualization class
    const VisualizationSensorUserFunction* GetVisualizationSensorUserFunction() const { return visualizationSensorUserFunction; }
    //! AUTO: Set pointer to visualization class (do this only in object factory!!!)
    void SetVisualizationSensorUserFunction(VisualizationSensorUserFunction* pVisualizationSensorUserFunction) { visualizationSensorUserFunction = pVisualizationSensorUserFunction; }

    //! AUTO: Get const pointer to computational base class object
    virtual CSensor* GetCSensor() const { return cSensorUserFunction; }
    //! AUTO: Set pointer to computational base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetCSensor(CSensor* pCSensor) { cSensorUserFunction = (CSensorUserFunction*)pCSensor; }

    //! AUTO: Get const pointer to visualization base class object
    virtual VisualizationSensor* GetVisualizationSensor() const { return visualizationSensorUserFunction; }
    //! AUTO: Set pointer to visualization base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetVisualizationSensor(VisualizationSensor* pVisualizationSensor) { visualizationSensorUserFunction = (VisualizationSensorUserFunction*)pVisualizationSensor; }

    //! AUTO:  Get type name of sensor (without keyword 'Sensor'...!)
    virtual const char* GetTypeName() const override
    {
        return "UserFunction";
    }


    //! AUTO:  dictionary write access
    virtual void SetWithDictionary(const py::dict& d) override
    {
        cSensorUserFunction->GetParameters().sensorNumbers = EPyUtils::GetArraySensorIndexSafely(d["sensorNumbers"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cSensorUserFunction->GetParameters().factors = py::cast<std::vector<Real>>(d["factors"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cSensorUserFunction->GetParameters().writeToFile = py::cast<bool>(d["writeToFile"]); /* AUTO:  read out dictionary and cast to C++ type*/
        EPyUtils::SetStringSafely(d, "fileName", cSensorUserFunction->GetParameters().fileName); /*! AUTO:  safely cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "sensorUserFunction")) { cSensorUserFunction->GetParameters().sensorUserFunction = d["sensorUserFunction"]; /* AUTO:  read out dictionary and cast to C++ type*/} 
        cSensorUserFunction->GetParameters().storeInternal = py::cast<bool>(d["storeInternal"]); /* AUTO:  read out dictionary and cast to C++ type*/
        EPyUtils::SetStringSafely(d, "name", name); /*! AUTO:  safely cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "Vshow")) { visualizationSensorUserFunction->GetShow() = py::cast<bool>(d["Vshow"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
    }

    //! AUTO:  dictionary read access
    virtual py::dict GetDictionary() const override
    {
        auto d = py::dict();
        d["sensorType"] = (std::string)GetTypeName();
        d["sensorNumbers"] = EPyUtils::GetArraySensorIndex(cSensorUserFunction->GetParameters().sensorNumbers); //! AUTO: cast variables into python (not needed for standard types) 
        d["factors"] = EPyUtils::Vector2NumPy(cSensorUserFunction->GetParameters().factors); //! AUTO: cast variables into python (not needed for standard types) 
        d["writeToFile"] = (bool)cSensorUserFunction->GetParameters().writeToFile; //! AUTO: cast variables into python (not needed for standard types) 
        d["fileName"] = (std::string)cSensorUserFunction->GetParameters().fileName; //! AUTO: cast variables into python (not needed for standard types) 
        d["sensorUserFunction"] = (py::object)cSensorUserFunction->GetParameters().sensorUserFunction; //! AUTO: cast variables into python (not needed for standard types) 
        d["storeInternal"] = (bool)cSensorUserFunction->GetParameters().storeInternal; //! AUTO: cast variables into python (not needed for standard types) 
        d["name"] = (std::string)name; //! AUTO: cast variables into python (not needed for standard types) 
        d["Vshow"] = (bool)visualizationSensorUserFunction->GetShow(); //! AUTO: cast variables into python (not needed for standard types) 
        return d; 
    }

    //! AUTO:  parameter read access
    virtual py::object GetParameter(const STDstring& parameterName) const override 
    {
        if (parameterName.compare("name") == 0) { return py::cast((std::string)name);} //! AUTO: get parameter
        else if (parameterName.compare("sensorNumbers") == 0) { return py::cast(EPyUtils::GetArraySensorIndex(cSensorUserFunction->GetParameters().sensorNumbers));} //! AUTO: get parameter
        else if (parameterName.compare("factors") == 0) { return EPyUtils::Vector2NumPy(cSensorUserFunction->GetParameters().factors);} //! AUTO: get parameter
        else if (parameterName.compare("writeToFile") == 0) { return py::cast((bool)cSensorUserFunction->GetParameters().writeToFile);} //! AUTO: get parameter
        else if (parameterName.compare("fileName") == 0) { return py::cast((std::string)cSensorUserFunction->GetParameters().fileName);} //! AUTO: get parameter
        else if (parameterName.compare("sensorUserFunction") == 0) { return cSensorUserFunction->GetParameters().sensorUserFunction.GetPythonDictionary();;} //! AUTO: get parameter
        else if (parameterName.compare("storeInternal") == 0) { return py::cast((bool)cSensorUserFunction->GetParameters().storeInternal);} //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { return py::cast((bool)visualizationSensorUserFunction->GetShow());} //! AUTO: get parameter
        else  {PyError(STDstring("SensorUserFunction::GetParameter(...): illegal parameter name ")+parameterName+" cannot be read");} // AUTO: add warning for user
        return py::object();
    }


    //! AUTO:  parameter write access
    virtual void SetParameter(const STDstring& parameterName, const py::object& value) override 
    {
        if (parameterName.compare("name") == 0) { EPyUtils::SetStringSafely(value, name); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("sensorNumbers") == 0) { cSensorUserFunction->GetParameters().sensorNumbers = EPyUtils::GetArraySensorIndexSafely(value); /* AUTO:  read out dictionary, check if correct index used and store (converted) Index to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("factors") == 0) { cSensorUserFunction->GetParameters().factors = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("writeToFile") == 0) { cSensorUserFunction->GetParameters().writeToFile = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("fileName") == 0) { EPyUtils::SetStringSafely(value, cSensorUserFunction->GetParameters().fileName); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("sensorUserFunction") == 0) { cSensorUserFunction->GetParameters().sensorUserFunction = value; } //! AUTO: get parameter
        else if (parameterName.compare("storeInternal") == 0) { cSensorUserFunction->GetParameters().storeInternal = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { visualizationSensorUserFunction->GetShow() = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else  {PyError(STDstring("SensorUserFunction::SetParameter(...): illegal parameter name ")+parameterName+" cannot be modified");} // AUTO: add warning for user
    }

};



#endif //#ifdef include once...
