/** ***********************************************************************************************
* @class        MainObjectKinematicTreeParameters
* @brief        Parameter class for MainObjectKinematicTree
*
* @author       Gerstmayr Johannes
* @date         2019-07-01 (generated)
* @date         2022-05-16  11:24:35 (last modified)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#ifndef MAINOBJECTKINEMATICTREEPARAMETERS__H
#define MAINOBJECTKINEMATICTREEPARAMETERS__H

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include <pybind11/functional.h> //! AUTO: for function handling ... otherwise gives a python error (no compilation error in C++ !)
#include "Autogenerated/CObjectKinematicTree.h"

#include "Autogenerated/VisuObjectKinematicTree.h"

//! AUTO: Parameters for class MainObjectKinematicTreeParameters
class MainObjectKinematicTreeParameters // AUTO: 
{
public: // AUTO: 
};


/** ***********************************************************************************************
* @class        MainObjectKinematicTree
* @brief        A special object to represent open kinematic trees using minimum coordinate formulation (UNDER DEVELOPMENT!). The kinematic tree is defined by lists of joint types, parents, inertia parameters (w.r.t. COM), etc.\ per link (body). Every link is defined by a previous joint and a coordinate transformation from the previous link to this link's joint coordinates. Use specialized settings in VisualizationSettings.bodies.kinematicTree for showing joint frames and other properties.
*
* @author       Gerstmayr Johannes
* @date         2019-07-01 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

//! AUTO: MainObjectKinematicTree
class MainObjectKinematicTree: public MainObjectBody // AUTO: 
{
protected: // AUTO: 
    CObjectKinematicTree* cObjectKinematicTree; //pointer to computational object (initialized in object factory) AUTO:
    VisualizationObjectKinematicTree* visualizationObjectKinematicTree; //pointer to computational object (initialized in object factory) AUTO:

public: // AUTO: 
    //! AUTO: default constructor with parameter initialization
    MainObjectKinematicTree()
    {
        name = "";
    };

    // AUTO: access functions
    //! AUTO: Get pointer to computational class
    CObjectKinematicTree* GetCObjectKinematicTree() { return cObjectKinematicTree; }
    //! AUTO: Get const pointer to computational class
    const CObjectKinematicTree* GetCObjectKinematicTree() const { return cObjectKinematicTree; }
    //! AUTO: Set pointer to computational class (do this only in object factory!!!)
    void SetCObjectKinematicTree(CObjectKinematicTree* pCObjectKinematicTree) { cObjectKinematicTree = pCObjectKinematicTree; }

    //! AUTO: Get pointer to visualization class
    VisualizationObjectKinematicTree* GetVisualizationObjectKinematicTree() { return visualizationObjectKinematicTree; }
    //! AUTO: Get const pointer to visualization class
    const VisualizationObjectKinematicTree* GetVisualizationObjectKinematicTree() const { return visualizationObjectKinematicTree; }
    //! AUTO: Set pointer to visualization class (do this only in object factory!!!)
    void SetVisualizationObjectKinematicTree(VisualizationObjectKinematicTree* pVisualizationObjectKinematicTree) { visualizationObjectKinematicTree = pVisualizationObjectKinematicTree; }

    //! AUTO: Get const pointer to computational base class object
    virtual CObject* GetCObject() const { return cObjectKinematicTree; }
    //! AUTO: Set pointer to computational base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetCObject(CObject* pCObject) { cObjectKinematicTree = (CObjectKinematicTree*)pCObject; }

    //! AUTO: Get const pointer to visualization base class object
    virtual VisualizationObject* GetVisualizationObject() const { return visualizationObjectKinematicTree; }
    //! AUTO: Set pointer to visualization base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetVisualizationObject(VisualizationObject* pVisualizationObject) { visualizationObjectKinematicTree = (VisualizationObjectKinematicTree*)pVisualizationObject; }

    //! AUTO:  Get type name of object; could also be realized via a string -> type conversion?
    virtual const char* GetTypeName() const override
    {
        return "KinematicTree";
    }

    //! AUTO:  provide requested nodeType for objects; used for automatic checks in CheckSystemIntegrity()
    virtual Node::Type GetRequestedNodeType() const override
    {
        return Node::GenericODE2;
    }

    //! AUTO:  Check consistency prior to CSystem::Assemble(); needs to find all possible violations such that Assemble() would fail
    virtual bool CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const override;


    //! AUTO:  dictionary write access
    virtual void SetWithDictionary(const py::dict& d) override
    {
        cObjectKinematicTree->GetParameters().nodeNumber = EPyUtils::GetNodeIndexSafely(d["nodeNumber"]); /* AUTO:  read out dictionary and cast to C++ type*/
        EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(d, "gravity", cObjectKinematicTree->GetParameters().gravity); /*! AUTO:  safely cast to C++ type*/
        EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(d, "baseOffset", cObjectKinematicTree->GetParameters().baseOffset); /*! AUTO:  safely cast to C++ type*/
        cObjectKinematicTree->GetParameters().jointTypes = py::cast<std::vector<Joint::Type>>(d["jointTypes"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cObjectKinematicTree->GetParameters().linkParents = py::cast<std::vector<Index>>(d["linkParents"]); /* AUTO:  read out dictionary and cast to C++ type*/
        EPyUtils::SetMatrix3DListSafely(d, "jointTransformations", cObjectKinematicTree->GetParameters().jointTransformations); /*! AUTO:  safely cast to C++ type*/
        EPyUtils::SetVector3DListSafely(d, "jointOffsets", cObjectKinematicTree->GetParameters().jointOffsets); /*! AUTO:  safely cast to C++ type*/
        EPyUtils::SetMatrix3DListSafely(d, "linkInertiasCOM", cObjectKinematicTree->GetParameters().linkInertiasCOM); /*! AUTO:  safely cast to C++ type*/
        EPyUtils::SetVector3DListSafely(d, "linkCOMs", cObjectKinematicTree->GetParameters().linkCOMs); /*! AUTO:  safely cast to C++ type*/
        cObjectKinematicTree->GetParameters().linkMasses = py::cast<std::vector<Real>>(d["linkMasses"]); /* AUTO:  read out dictionary and cast to C++ type*/
        EPyUtils::SetVector3DListSafely(d, "linkForces", cObjectKinematicTree->GetParameters().linkForces); /*! AUTO:  safely cast to C++ type*/
        EPyUtils::SetVector3DListSafely(d, "linkTorques", cObjectKinematicTree->GetParameters().linkTorques); /*! AUTO:  safely cast to C++ type*/
        cObjectKinematicTree->GetParameters().jointForceVector = py::cast<std::vector<Real>>(d["jointForceVector"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cObjectKinematicTree->GetParameters().jointPositionOffsetVector = py::cast<std::vector<Real>>(d["jointPositionOffsetVector"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cObjectKinematicTree->GetParameters().jointVelocityOffsetVector = py::cast<std::vector<Real>>(d["jointVelocityOffsetVector"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cObjectKinematicTree->GetParameters().jointPControlVector = py::cast<std::vector<Real>>(d["jointPControlVector"]); /* AUTO:  read out dictionary and cast to C++ type*/
        cObjectKinematicTree->GetParameters().jointDControlVector = py::cast<std::vector<Real>>(d["jointDControlVector"]); /* AUTO:  read out dictionary and cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "forceUserFunction")) { if (EPyUtils::CheckForValidFunction(d["forceUserFunction"])) 
            { cObjectKinematicTree->GetParameters().forceUserFunction = py::cast<std::function<StdVector(const MainSystem&,Real,Index,StdVector,StdVector)>>((py::function)d["forceUserFunction"]); /* AUTO:  read out dictionary and cast to C++ type*/}
            else {cObjectKinematicTree->GetParameters().forceUserFunction = 0;  /*AUTO: otherwise assign with zero!*/ }} 
        EPyUtils::SetStringSafely(d, "name", name); /*! AUTO:  safely cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "Vshow")) { visualizationObjectKinematicTree->GetShow() = py::cast<bool>(d["Vshow"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "VshowLinks")) { visualizationObjectKinematicTree->GetShowLinks() = py::cast<bool>(d["VshowLinks"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "VshowJoints")) { visualizationObjectKinematicTree->GetShowJoints() = py::cast<bool>(d["VshowJoints"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "Vcolor")) { visualizationObjectKinematicTree->GetColor() = py::cast<std::vector<float>>(d["Vcolor"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "VgraphicsDataList")) { PyWriteBodyGraphicsDataList(d, "VgraphicsDataList", visualizationObjectKinematicTree->GetGraphicsDataList()); /*! AUTO: convert dict to BodyGraphicsDataList*/} 
        GetCObject()->ParametersHaveChanged();
    }

    //! AUTO:  dictionary read access
    virtual py::dict GetDictionary() const override
    {
        auto d = py::dict();
        d["objectType"] = (std::string)GetTypeName();
        d["nodeNumber"] = (NodeIndex)cObjectKinematicTree->GetParameters().nodeNumber; //! AUTO: cast variables into python (not needed for standard types) 
        d["gravity"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().gravity; //! AUTO: cast variables into python (not needed for standard types) 
        d["baseOffset"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().baseOffset; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointTypes"] = (std::vector<Joint::Type>)cObjectKinematicTree->GetParameters().jointTypes; //! AUTO: cast variables into python (not needed for standard types) 
        d["linkParents"] = (std::vector<Index>)cObjectKinematicTree->GetParameters().linkParents; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointTransformations"] = (Matrix3DList)cObjectKinematicTree->GetParameters().jointTransformations; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointOffsets"] = (Vector3DList)cObjectKinematicTree->GetParameters().jointOffsets; //! AUTO: cast variables into python (not needed for standard types) 
        d["linkInertiasCOM"] = (Matrix3DList)cObjectKinematicTree->GetParameters().linkInertiasCOM; //! AUTO: cast variables into python (not needed for standard types) 
        d["linkCOMs"] = (Vector3DList)cObjectKinematicTree->GetParameters().linkCOMs; //! AUTO: cast variables into python (not needed for standard types) 
        d["linkMasses"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().linkMasses; //! AUTO: cast variables into python (not needed for standard types) 
        d["linkForces"] = (Vector3DList)cObjectKinematicTree->GetParameters().linkForces; //! AUTO: cast variables into python (not needed for standard types) 
        d["linkTorques"] = (Vector3DList)cObjectKinematicTree->GetParameters().linkTorques; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointForceVector"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().jointForceVector; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointPositionOffsetVector"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().jointPositionOffsetVector; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointVelocityOffsetVector"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().jointVelocityOffsetVector; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointPControlVector"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().jointPControlVector; //! AUTO: cast variables into python (not needed for standard types) 
        d["jointDControlVector"] = (std::vector<Real>)cObjectKinematicTree->GetParameters().jointDControlVector; //! AUTO: cast variables into python (not needed for standard types) 
        if (cObjectKinematicTree->GetParameters().forceUserFunction)
            {d["forceUserFunction"] = (std::function<StdVector(const MainSystem&,Real,Index,StdVector,StdVector)>)cObjectKinematicTree->GetParameters().forceUserFunction;}
        else
            {d["forceUserFunction"] = 0;}
 //! AUTO: cast variables into python (not needed for standard types) 
        d["jointTransformations"] = (Transformations66List)cObjectKinematicTree->GetJointTransformations(); //! AUTO: cast variables into python (not needed for standard types) 
        d["linkInertiasT66"] = (Transformations66List)cObjectKinematicTree->GetLinkInertiasT66(); //! AUTO: cast variables into python (not needed for standard types) 
        d["tempListT66"] = (Transformations66List)cObjectKinematicTree->GetTempListT66(); //! AUTO: cast variables into python (not needed for standard types) 
        d["motionSubspaces"] = (Vector6DList)cObjectKinematicTree->GetMotionSubspaces(); //! AUTO: cast variables into python (not needed for standard types) 
        d["jointVelocities"] = (Vector6DList)cObjectKinematicTree->GetJointVelocities(); //! AUTO: cast variables into python (not needed for standard types) 
        d["jointAccelerations"] = (Vector6DList)cObjectKinematicTree->GetJointAccelerations(); //! AUTO: cast variables into python (not needed for standard types) 
        d["jointForces"] = (Vector6DList)cObjectKinematicTree->GetJointForces(); //! AUTO: cast variables into python (not needed for standard types) 
        d["name"] = (std::string)name; //! AUTO: cast variables into python (not needed for standard types) 
        d["Vshow"] = (bool)visualizationObjectKinematicTree->GetShow(); //! AUTO: cast variables into python (not needed for standard types) 
        d["VshowLinks"] = (bool)visualizationObjectKinematicTree->GetShowLinks(); //! AUTO: cast variables into python (not needed for standard types) 
        d["VshowJoints"] = (bool)visualizationObjectKinematicTree->GetShowJoints(); //! AUTO: cast variables into python (not needed for standard types) 
        d["Vcolor"] = (std::vector<float>)visualizationObjectKinematicTree->GetColor(); //! AUTO: cast variables into python (not needed for standard types) 
        d["VgraphicsDataList"] = PyGetBodyGraphicsDataList(visualizationObjectKinematicTree->GetGraphicsDataList()); //! AUTO: generate dictionary with special function
        return d; 
    }

    //! AUTO:  parameter read access
    virtual py::object GetParameter(const STDstring& parameterName) const override 
    {
        if (parameterName.compare("name") == 0) { return py::cast((std::string)name);} //! AUTO: get parameter
        else if (parameterName.compare("nodeNumber") == 0) { return py::cast((NodeIndex)cObjectKinematicTree->GetParameters().nodeNumber);} //! AUTO: get parameter
        else if (parameterName.compare("gravity") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().gravity);} //! AUTO: get parameter
        else if (parameterName.compare("baseOffset") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().baseOffset);} //! AUTO: get parameter
        else if (parameterName.compare("jointTypes") == 0) { return py::cast((std::vector<Joint::Type>)cObjectKinematicTree->GetParameters().jointTypes);} //! AUTO: get parameter
        else if (parameterName.compare("linkParents") == 0) { return py::cast((std::vector<Index>)cObjectKinematicTree->GetParameters().linkParents);} //! AUTO: get parameter
        else if (parameterName.compare("jointTransformations") == 0) { return py::cast((Matrix3DList)cObjectKinematicTree->GetParameters().jointTransformations);} //! AUTO: get parameter
        else if (parameterName.compare("jointOffsets") == 0) { return py::cast((Vector3DList)cObjectKinematicTree->GetParameters().jointOffsets);} //! AUTO: get parameter
        else if (parameterName.compare("linkInertiasCOM") == 0) { return py::cast((Matrix3DList)cObjectKinematicTree->GetParameters().linkInertiasCOM);} //! AUTO: get parameter
        else if (parameterName.compare("linkCOMs") == 0) { return py::cast((Vector3DList)cObjectKinematicTree->GetParameters().linkCOMs);} //! AUTO: get parameter
        else if (parameterName.compare("linkMasses") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().linkMasses);} //! AUTO: get parameter
        else if (parameterName.compare("linkForces") == 0) { return py::cast((Vector3DList)cObjectKinematicTree->GetParameters().linkForces);} //! AUTO: get parameter
        else if (parameterName.compare("linkTorques") == 0) { return py::cast((Vector3DList)cObjectKinematicTree->GetParameters().linkTorques);} //! AUTO: get parameter
        else if (parameterName.compare("jointForceVector") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().jointForceVector);} //! AUTO: get parameter
        else if (parameterName.compare("jointPositionOffsetVector") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().jointPositionOffsetVector);} //! AUTO: get parameter
        else if (parameterName.compare("jointVelocityOffsetVector") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().jointVelocityOffsetVector);} //! AUTO: get parameter
        else if (parameterName.compare("jointPControlVector") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().jointPControlVector);} //! AUTO: get parameter
        else if (parameterName.compare("jointDControlVector") == 0) { return py::cast((std::vector<Real>)cObjectKinematicTree->GetParameters().jointDControlVector);} //! AUTO: get parameter
        else if (parameterName.compare("forceUserFunction") == 0) { return py::cast((std::function<StdVector(const MainSystem&,Real,Index,StdVector,StdVector)>)cObjectKinematicTree->GetParameters().forceUserFunction);} //! AUTO: get parameter
        else if (parameterName.compare("jointTransformations") == 0) { return py::cast((Transformations66List)cObjectKinematicTree->GetJointTransformations());} //! AUTO: get parameter
        else if (parameterName.compare("linkInertiasT66") == 0) { return py::cast((Transformations66List)cObjectKinematicTree->GetLinkInertiasT66());} //! AUTO: get parameter
        else if (parameterName.compare("tempListT66") == 0) { return py::cast((Transformations66List)cObjectKinematicTree->GetTempListT66());} //! AUTO: get parameter
        else if (parameterName.compare("motionSubspaces") == 0) { return py::cast((Vector6DList)cObjectKinematicTree->GetMotionSubspaces());} //! AUTO: get parameter
        else if (parameterName.compare("jointVelocities") == 0) { return py::cast((Vector6DList)cObjectKinematicTree->GetJointVelocities());} //! AUTO: get parameter
        else if (parameterName.compare("jointAccelerations") == 0) { return py::cast((Vector6DList)cObjectKinematicTree->GetJointAccelerations());} //! AUTO: get parameter
        else if (parameterName.compare("jointForces") == 0) { return py::cast((Vector6DList)cObjectKinematicTree->GetJointForces());} //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { return py::cast((bool)visualizationObjectKinematicTree->GetShow());} //! AUTO: get parameter
        else if (parameterName.compare("VshowLinks") == 0) { return py::cast((bool)visualizationObjectKinematicTree->GetShowLinks());} //! AUTO: get parameter
        else if (parameterName.compare("VshowJoints") == 0) { return py::cast((bool)visualizationObjectKinematicTree->GetShowJoints());} //! AUTO: get parameter
        else if (parameterName.compare("Vcolor") == 0) { return py::cast((std::vector<float>)visualizationObjectKinematicTree->GetColor());} //! AUTO: get parameter
        else  {PyError(STDstring("ObjectKinematicTree::GetParameter(...): illegal parameter name ")+parameterName+" cannot be read");} // AUTO: add warning for user
        return py::object();
    }


    //! AUTO:  parameter write access
    virtual void SetParameter(const STDstring& parameterName, const py::object& value) override 
    {
        if (parameterName.compare("name") == 0) { EPyUtils::SetStringSafely(value, name); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("nodeNumber") == 0) { cObjectKinematicTree->GetParameters().nodeNumber = EPyUtils::GetNodeIndexSafely(value); /* AUTO:  read out dictionary, check if correct index used and store (converted) Index to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("gravity") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(value, cObjectKinematicTree->GetParameters().gravity); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("baseOffset") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(value, cObjectKinematicTree->GetParameters().baseOffset); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointTypes") == 0) { cObjectKinematicTree->GetParameters().jointTypes = py::cast<std::vector<Joint::Type>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("linkParents") == 0) { cObjectKinematicTree->GetParameters().linkParents = py::cast<std::vector<Index>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointTransformations") == 0) { EPyUtils::SetMatrix3DListSafely(value, cObjectKinematicTree->GetParameters().jointTransformations); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointOffsets") == 0) { EPyUtils::SetVector3DListSafely(value, cObjectKinematicTree->GetParameters().jointOffsets); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("linkInertiasCOM") == 0) { EPyUtils::SetMatrix3DListSafely(value, cObjectKinematicTree->GetParameters().linkInertiasCOM); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("linkCOMs") == 0) { EPyUtils::SetVector3DListSafely(value, cObjectKinematicTree->GetParameters().linkCOMs); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("linkMasses") == 0) { cObjectKinematicTree->GetParameters().linkMasses = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("linkForces") == 0) { EPyUtils::SetVector3DListSafely(value, cObjectKinematicTree->GetParameters().linkForces); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("linkTorques") == 0) { EPyUtils::SetVector3DListSafely(value, cObjectKinematicTree->GetParameters().linkTorques); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointForceVector") == 0) { cObjectKinematicTree->GetParameters().jointForceVector = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointPositionOffsetVector") == 0) { cObjectKinematicTree->GetParameters().jointPositionOffsetVector = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointVelocityOffsetVector") == 0) { cObjectKinematicTree->GetParameters().jointVelocityOffsetVector = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointPControlVector") == 0) { cObjectKinematicTree->GetParameters().jointPControlVector = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("jointDControlVector") == 0) { cObjectKinematicTree->GetParameters().jointDControlVector = py::cast<std::vector<Real>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("forceUserFunction") == 0) { if (py::isinstance<py::function>(value)) {cObjectKinematicTree->GetParameters().forceUserFunction = py::cast<std::function<StdVector(const MainSystem&,Real,Index,StdVector,StdVector)>>(value); /* AUTO:  read out dictionary and cast to C++ type*/} else
            if (!EPyUtils::IsPyTypeInteger(value) || (py::cast<int>(value) != 0)) {PyError(STDstring("Failed to convert PyFunction: must be either valid python function or 0, but got ")+EXUstd::ToString(value)); }; } //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { visualizationObjectKinematicTree->GetShow() = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("VshowLinks") == 0) { visualizationObjectKinematicTree->GetShowLinks() = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("VshowJoints") == 0) { visualizationObjectKinematicTree->GetShowJoints() = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("Vcolor") == 0) { visualizationObjectKinematicTree->GetColor() = py::cast<std::vector<float>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else  {PyError(STDstring("ObjectKinematicTree::SetParameter(...): illegal parameter name ")+parameterName+" cannot be modified");} // AUTO: add warning for user
        GetCObject()->ParametersHaveChanged();
    }

};



#endif //#ifdef include once...
