/** ***********************************************************************************************
* @class        MainNodeRigidBodyRotVecDataLGParameters
* @brief        Parameter class for MainNodeRigidBodyRotVecDataLG
*
* @author       Gerstmayr Johannes, Holzinger Stefan
* @date         2019-07-01 (generated)
* @date         2022-08-26  12:15:52 (last modified)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#ifndef MAINNODERIGIDBODYROTVECDATALGPARAMETERS__H
#define MAINNODERIGIDBODYROTVECDATALGPARAMETERS__H

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include "Autogenerated/CNodeRigidBodyRotVecDataLG.h"

#include "Autogenerated/VisuNodeRigidBodyRotVecDataLG.h"

//! AUTO: Parameters for class MainNodeRigidBodyRotVecDataLGParameters
class MainNodeRigidBodyRotVecDataLGParameters // AUTO: 
{
public: // AUTO: 
    Vector6D initialCoordinates;                  //!< AUTO: initial displacement coordinates \f$\uv\f$ and rotation vector \f$\tnu\f$ relative to reference coordinates; these coordinates are mapped to the data coordiantes!
    Vector6D initialCoordinates_t;                //!< AUTO: initial velocity coordinate: time derivatives of displacement and angular velocity vector; these coordinates are mapped to the ODE2 velocity coordinates!
    //! AUTO: default constructor with parameter initialization
    MainNodeRigidBodyRotVecDataLGParameters()
    {
        initialCoordinates = Vector6D({0.,0.,0., 0.,0.,0.});
        initialCoordinates_t = Vector6D({0.,0.,0., 0.,0.,0.});
    };
};


/** ***********************************************************************************************
* @class        MainNodeRigidBodyRotVecDataLG
* @brief        A 3D rigid body node based on rotation vector and Lie group methods for rigid bodies or beams; the node has 3 displacement coordinates and three rotation coordinates (rotation vector) and additionally data coordinates for configuration at start of a computation step. External operations (initial coordinates, graphics, ...) operate on data coordinates, which represent the global frame. Internally, ODE2 coordinates represent the local frame and they must be updated using (implicit) Lie group methods. UNDER CONSTRUCTION, DO NOT USE!!!
*
* @author       Gerstmayr Johannes, Holzinger Stefan
* @date         2019-07-01 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

//! AUTO: MainNodeRigidBodyRotVecDataLG
class MainNodeRigidBodyRotVecDataLG: public MainNode // AUTO: 
{
protected: // AUTO: 
    CNodeRigidBodyRotVecDataLG* cNodeRigidBodyRotVecDataLG; //pointer to computational object (initialized in object factory) AUTO:
    VisualizationNodeRigidBodyRotVecDataLG* visualizationNodeRigidBodyRotVecDataLG; //pointer to computational object (initialized in object factory) AUTO:
    MainNodeRigidBodyRotVecDataLGParameters parameters; //! AUTO: contains all parameters for MainNodeRigidBodyRotVecDataLG

public: // AUTO: 
    //! AUTO: default constructor with parameter initialization
    MainNodeRigidBodyRotVecDataLG()
    {
        name = "";
    };

    // AUTO: access functions
    //! AUTO: Get pointer to computational class
    CNodeRigidBodyRotVecDataLG* GetCNodeRigidBodyRotVecDataLG() { return cNodeRigidBodyRotVecDataLG; }
    //! AUTO: Get const pointer to computational class
    const CNodeRigidBodyRotVecDataLG* GetCNodeRigidBodyRotVecDataLG() const { return cNodeRigidBodyRotVecDataLG; }
    //! AUTO: Set pointer to computational class (do this only in object factory!!!)
    void SetCNodeRigidBodyRotVecDataLG(CNodeRigidBodyRotVecDataLG* pCNodeRigidBodyRotVecDataLG) { cNodeRigidBodyRotVecDataLG = pCNodeRigidBodyRotVecDataLG; }

    //! AUTO: Get pointer to visualization class
    VisualizationNodeRigidBodyRotVecDataLG* GetVisualizationNodeRigidBodyRotVecDataLG() { return visualizationNodeRigidBodyRotVecDataLG; }
    //! AUTO: Get const pointer to visualization class
    const VisualizationNodeRigidBodyRotVecDataLG* GetVisualizationNodeRigidBodyRotVecDataLG() const { return visualizationNodeRigidBodyRotVecDataLG; }
    //! AUTO: Set pointer to visualization class (do this only in object factory!!!)
    void SetVisualizationNodeRigidBodyRotVecDataLG(VisualizationNodeRigidBodyRotVecDataLG* pVisualizationNodeRigidBodyRotVecDataLG) { visualizationNodeRigidBodyRotVecDataLG = pVisualizationNodeRigidBodyRotVecDataLG; }

    //! AUTO: Get const pointer to computational base class object
    virtual CNode* GetCNode() const { return cNodeRigidBodyRotVecDataLG; }
    //! AUTO: Set pointer to computational base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetCNode(CNode* pCNode) { cNodeRigidBodyRotVecDataLG = (CNodeRigidBodyRotVecDataLG*)pCNode; }

    //! AUTO: Get const pointer to visualization base class object
    virtual VisualizationNode* GetVisualizationNode() const { return visualizationNodeRigidBodyRotVecDataLG; }
    //! AUTO: Set pointer to visualization base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetVisualizationNode(VisualizationNode* pVisualizationNode) { visualizationNodeRigidBodyRotVecDataLG = (VisualizationNodeRigidBodyRotVecDataLG*)pVisualizationNode; }

    //! AUTO: Write (Reference) access to parameters
    virtual MainNodeRigidBodyRotVecDataLGParameters& GetParameters() { return parameters; }
    //! AUTO: Read access to parameters
    virtual const MainNodeRigidBodyRotVecDataLGParameters& GetParameters() const { return parameters; }

    //! AUTO:  Get type name of node (without keyword 'Node'...!); could also be realized via a string -> type conversion?
    virtual const char* GetTypeName() const override
    {
        return "RigidBodyRotVecLG";
    }

    //! AUTO:  return internally stored initial coordinates (displacements) of node
    virtual LinkedDataVector GetInitialCoordinateVector() const override
    {
        return parameters.initialCoordinates;
    }

    //! AUTO:  return internally stored initial coordinates (velocities) of node
    virtual LinkedDataVector GetInitialCoordinateVector_t() const override
    {
        return parameters.initialCoordinates_t;
    }

    //! AUTO:  set initial ODE2 coordinates of node
    virtual void SetInitialCoordinateVector(LinkedDataVector& initialVector) override
    {
        initialVector.SetAll(0);
    }


    //! AUTO:  dictionary write access
    virtual void SetWithDictionary(const py::dict& d) override
    {
        EPyUtils::SetSlimVectorTemplateSafely<Real, 6>(d, "referenceCoordinates", cNodeRigidBodyRotVecDataLG->GetParameters().referenceCoordinates); /*! AUTO:  safely cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "initialCoordinates")) { EPyUtils::SetSlimVectorTemplateSafely<Real, 6>(d, "initialCoordinates", GetParameters().initialCoordinates); /*! AUTO:  safely cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "initialVelocities")) { EPyUtils::SetSlimVectorTemplateSafely<Real, 6>(d, "initialVelocities", GetParameters().initialCoordinates_t); /*! AUTO:  safely cast to C++ type*/} 
        EPyUtils::SetStringSafely(d, "name", name); /*! AUTO:  safely cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "Vshow")) { visualizationNodeRigidBodyRotVecDataLG->GetShow() = py::cast<bool>(d["Vshow"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "VdrawSize")) { visualizationNodeRigidBodyRotVecDataLG->GetDrawSize() = py::cast<float>(d["VdrawSize"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "Vcolor")) { visualizationNodeRigidBodyRotVecDataLG->GetColor() = py::cast<std::vector<float>>(d["Vcolor"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
    }

    //! AUTO:  dictionary read access
    virtual py::dict GetDictionary() const override
    {
        auto d = py::dict();
        d["nodeType"] = (std::string)GetTypeName();
        d["referenceCoordinates"] = EPyUtils::SlimVector2NumPy(cNodeRigidBodyRotVecDataLG->GetParameters().referenceCoordinates); //! AUTO: cast variables into python (not needed for standard types) 
        d["initialCoordinates"] = EPyUtils::SlimVector2NumPy(GetParameters().initialCoordinates); //! AUTO: cast variables into python (not needed for standard types) 
        d["initialVelocities"] = EPyUtils::SlimVector2NumPy(GetParameters().initialCoordinates_t); //! AUTO: cast variables into python (not needed for standard types) 
        d["name"] = (std::string)name; //! AUTO: cast variables into python (not needed for standard types) 
        d["Vshow"] = (bool)visualizationNodeRigidBodyRotVecDataLG->GetShow(); //! AUTO: cast variables into python (not needed for standard types) 
        d["VdrawSize"] = (float)visualizationNodeRigidBodyRotVecDataLG->GetDrawSize(); //! AUTO: cast variables into python (not needed for standard types) 
        d["Vcolor"] = (std::vector<float>)visualizationNodeRigidBodyRotVecDataLG->GetColor(); //! AUTO: cast variables into python (not needed for standard types) 
        return d; 
    }

    //! AUTO:  parameter read access
    virtual py::object GetParameter(const STDstring& parameterName) const override 
    {
        if (parameterName.compare("name") == 0) { return py::cast((std::string)name);} //! AUTO: get parameter
        else if (parameterName.compare("referenceCoordinates") == 0) { return EPyUtils::SlimVector2NumPy(cNodeRigidBodyRotVecDataLG->GetParameters().referenceCoordinates);} //! AUTO: get parameter
        else if (parameterName.compare("initialCoordinates") == 0) { return EPyUtils::SlimVector2NumPy(GetParameters().initialCoordinates);} //! AUTO: get parameter
        else if (parameterName.compare("initialVelocities") == 0) { return EPyUtils::SlimVector2NumPy(GetParameters().initialCoordinates_t);} //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { return py::cast((bool)visualizationNodeRigidBodyRotVecDataLG->GetShow());} //! AUTO: get parameter
        else if (parameterName.compare("VdrawSize") == 0) { return py::cast((float)visualizationNodeRigidBodyRotVecDataLG->GetDrawSize());} //! AUTO: get parameter
        else if (parameterName.compare("Vcolor") == 0) { return py::cast((std::vector<float>)visualizationNodeRigidBodyRotVecDataLG->GetColor());} //! AUTO: get parameter
        else  {PyError(STDstring("NodeRigidBodyRotVecDataLG::GetParameter(...): illegal parameter name ")+parameterName+" cannot be read");} // AUTO: add warning for user
        return py::object();
    }


    //! AUTO:  parameter write access
    virtual void SetParameter(const STDstring& parameterName, const py::object& value) override 
    {
        if (parameterName.compare("name") == 0) { EPyUtils::SetStringSafely(value, name); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("referenceCoordinates") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 6>(value, cNodeRigidBodyRotVecDataLG->GetParameters().referenceCoordinates); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("initialCoordinates") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 6>(value, GetParameters().initialCoordinates); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("initialVelocities") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 6>(value, GetParameters().initialCoordinates_t); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { visualizationNodeRigidBodyRotVecDataLG->GetShow() = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("VdrawSize") == 0) { visualizationNodeRigidBodyRotVecDataLG->GetDrawSize() = py::cast<float>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("Vcolor") == 0) { visualizationNodeRigidBodyRotVecDataLG->GetColor() = py::cast<std::vector<float>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else  {PyError(STDstring("NodeRigidBodyRotVecDataLG::SetParameter(...): illegal parameter name ")+parameterName+" cannot be modified");} // AUTO: add warning for user
    }

};



#endif //#ifdef include once...
