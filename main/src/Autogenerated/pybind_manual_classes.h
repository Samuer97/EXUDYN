// AUTO:  ++++++++++++++++++++++
// AUTO:  pybind11 manual module includes; generated by Johannes Gerstmayr
// AUTO:  last modified = 2025-07-09
// AUTO:  ++++++++++++++++++++++

//        pybinding to enum classes:
  py::enum_<OutputVariableType>(m, "OutputVariableType")
		.value("_None", OutputVariableType::_None)    //no value; used, e.g., to select no output variable in contour plot
		.value("Distance", OutputVariableType::Distance)    //e.g., measure distance in spring damper connector
		.value("Position", OutputVariableType::Position)    //measure 3D position, e.g., of node or body
		.value("Displacement", OutputVariableType::Displacement)    //measure displacement; usually difference between current position and reference position
		.value("DisplacementLocal", OutputVariableType::DisplacementLocal)    //measure local displacement, e.g. in local joint coordinates
		.value("Velocity", OutputVariableType::Velocity)    //measure (translational) velocity of node or object
		.value("VelocityLocal", OutputVariableType::VelocityLocal)    //measure local (translational) velocity, e.g. in local body or joint coordinates
		.value("Acceleration", OutputVariableType::Acceleration)    //measure (translational) acceleration of node or object
		.value("AccelerationLocal", OutputVariableType::AccelerationLocal)    //measure (translational) acceleration of node or object in local coordinates
		.value("RotationMatrix", OutputVariableType::RotationMatrix)    //measure rotation matrix of rigid body node or object
		.value("Rotation", OutputVariableType::Rotation)    //measure, e.g., scalar rotation of 2D body, Euler angles of a 3D object or rotation within a joint
		.value("AngularVelocity", OutputVariableType::AngularVelocity)    //measure angular velocity of node or object
		.value("AngularVelocityLocal", OutputVariableType::AngularVelocityLocal)    //measure local (body-fixed) angular velocity of node or object
		.value("AngularAcceleration", OutputVariableType::AngularAcceleration)    //measure angular acceleration of node or object
		.value("AngularAccelerationLocal", OutputVariableType::AngularAccelerationLocal)    //measure angular acceleration of node or object in local coordinates
		.value("CoordinatesTotal", OutputVariableType::CoordinatesTotal)    //measure the total coordinates (including reference configuration) of a node or object; otherwise the same as Coordinates
		.value("Coordinates", OutputVariableType::Coordinates)    //measure the coordinates of a node or object; coordinates just contain displacements, but not the reference (position or rotation) values - see also definition of respective nodes or objects
		.value("Coordinates_t", OutputVariableType::Coordinates_t)    //measure the time derivative of coordinates (= velocity coordinates) of a node or object
		.value("Coordinates_tt", OutputVariableType::Coordinates_tt)    //measure the second time derivative of coordinates (= acceleration coordinates) of a node or object
		.value("SlidingCoordinate", OutputVariableType::SlidingCoordinate)    //measure sliding coordinate in sliding joint
		.value("Director1", OutputVariableType::Director1)    //measure a director (e.g. of a rigid body frame), or a slope vector in local 1 or x-direction
		.value("Director2", OutputVariableType::Director2)    //measure a director (e.g. of a rigid body frame), or a slope vector in local 2 or y-direction
		.value("Director3", OutputVariableType::Director3)    //measure a director (e.g. of a rigid body frame), or a slope vector in local 3 or z-direction
		.value("Force", OutputVariableType::Force)    //measure global force, e.g., in joint or beam (resultant force), or generalized forces; see description of according object
		.value("ForceLocal", OutputVariableType::ForceLocal)    //measure local force, e.g., in joint or beam (resultant force)
		.value("Torque", OutputVariableType::Torque)    //measure torque, e.g., in joint or beam (resultant couple/moment)
		.value("TorqueLocal", OutputVariableType::TorqueLocal)    //measure local torque, e.g., in joint or beam (resultant couple/moment)
		.value("StrainLocal", OutputVariableType::StrainLocal)    //measure local strain, e.g., axial strain in cross section frame of beam or Green-Lagrange strain
		.value("StressLocal", OutputVariableType::StressLocal)    //measure local stress, e.g., axial stress in cross section frame of beam or Second Piola-Kirchoff stress; choosing component==-1 will result in the computation of the Mises stress
		.value("CurvatureLocal", OutputVariableType::CurvatureLocal)    //measure local curvature; may be scalar or vectorial: twist and curvature of beam in cross section frame
		.value("ConstraintEquation", OutputVariableType::ConstraintEquation)    //evaluates constraint equation (=current deviation or drift of constraint equation)
		;

  py::enum_<ConfigurationType>(m, "ConfigurationType")
		.value("_None", ConfigurationType::_None)    //no configuration; usually not valid, but may be used, e.g., if no configurationType is required
		.value("Initial", ConfigurationType::Initial)    //initial configuration prior to static or dynamic solver; is computed during mbs.Assemble() or AssembleInitializeSystemCoordinates()
		.value("Current", ConfigurationType::Current)    //current configuration during and at the end of the computation of a step (static or dynamic)
		.value("Reference", ConfigurationType::Reference)    //configuration used to define deformable bodies (reference configuration for finite elements) or joints (configuration for which some joints are defined)
		.value("StartOfStep", ConfigurationType::StartOfStep)    //during computation, this refers to the solution at the start of the step = end of last step, to which the solver falls back if convergence fails
		.value("Visualization", ConfigurationType::Visualization)    //this is a state completely de-coupled from computation, used for visualization
		.value("EndOfEnumList", ConfigurationType::EndOfEnumList)    //this marks the end of the list, usually not important to the user
		;

  py::enum_<ItemType>(m, "ItemType")
		.value("_None", ItemType::_None)    //item has no type
		.value("Node", ItemType::Node)    //item or index is of type Node
		.value("Object", ItemType::Object)    //item or index is of type Object
		.value("Marker", ItemType::Marker)    //item or index is of type Marker
		.value("Load", ItemType::Load)    //item or index is of type Load
		.value("Sensor", ItemType::Sensor)    //item or index is of type Sensor
		;

  py::enum_<Node::Type>(m, "NodeType")
		.value("_None", Node::_None)    //node has no type
		.value("Ground", Node::Ground)    //ground node
		.value("Position2D", Node::Position2D)    //2D position node 
		.value("Orientation2D", Node::Orientation2D)    //node with 2D rotation
		.value("Point2DSlope1", Node::Point2DSlope1)    //2D node with 1 slope vector
		.value("Position", Node::Position)    //3D position node
		.value("Orientation", Node::Orientation)    //3D orientation node
		.value("RigidBody", Node::RigidBody)    //node that can be used for rigid bodies
		.value("RotationEulerParameters", Node::RotationEulerParameters)    //node with 3D orientations that are modelled with Euler parameters (unit quaternions)
		.value("RotationRxyz", Node::RotationRxyz)    //node with 3D orientations that are modelled with Tait-Bryan angles
		.value("RotationRotationVector", Node::RotationRotationVector)    //node with 3D orientations that are modelled with the rotation vector
		.value("LieGroupWithDirectUpdate", Node::LieGroupWithDirectUpdate)    //node to be solved with Lie group methods, without data coordinates
		.value("GenericODE2", Node::GenericODE2)    //node with general ODE2 variables
		.value("GenericODE1", Node::GenericODE1)    //node with general ODE1 variables
		.value("GenericAE", Node::GenericAE)    //node with general algebraic variables
		.value("GenericData", Node::GenericData)    //node with general data variables
		.value("PointSlope1", Node::PointSlope1)    //node with 1 slope vector
		.value("PointSlope12", Node::PointSlope12)    //node with 2 slope vectors in x and y direction
		.value("PointSlope23", Node::PointSlope23)    //node with 2 slope vectors in y and z direction
		;

  py::enum_<Joint::Type>(m, "JointType")
		.value("_None", Joint::_None)    //node has no type
		.value("RevoluteX", Joint::RevoluteX)    //revolute joint type with rotation around local X axis
		.value("RevoluteY", Joint::RevoluteY)    //revolute joint type with rotation around local Y axis
		.value("RevoluteZ", Joint::RevoluteZ)    //revolute joint type with rotation around local Z axis
		.value("PrismaticX", Joint::PrismaticX)    //prismatic joint type with translation along local X axis
		.value("PrismaticY", Joint::PrismaticY)    //prismatic joint type with translation along local Y axis
		.value("PrismaticZ", Joint::PrismaticZ)    //prismatic joint type with translation along local Z axis
		;

  py::enum_<DynamicSolverType>(m, "DynamicSolverType")
		.value("GeneralizedAlpha", DynamicSolverType::GeneralizedAlpha)    //an implicit solver for index 3 problems; intended to be used for solving directly the index 3 constraints using the spectralRadius sufficiently small (usually 0.5 .. 1)
		.value("TrapezoidalIndex2", DynamicSolverType::TrapezoidalIndex2)    //an implicit solver for index 3 problems with index2 reduction; uses generalized alpha solver with settings for Newmark with index2 reduction
		.value("ExplicitEuler", DynamicSolverType::ExplicitEuler)    //an explicit 1st order solver (generally not compatible with constraints)
		.value("ExplicitMidpoint", DynamicSolverType::ExplicitMidpoint)    //an explicit 2nd order solver (generally not compatible with constraints)
		.value("RK33", DynamicSolverType::RK33)    //an explicit 3 stage 3rd order Runge-Kutta method, aka "Heun third order"; (generally not compatible with constraints)
		.value("RK44", DynamicSolverType::RK44)    //an explicit 4 stage 4th order Runge-Kutta method, aka "classical Runge Kutta" (generally not compatible with constraints), compatible with Lie group integration and elimination of CoordinateConstraints
		.value("RK67", DynamicSolverType::RK67)    //an explicit 7 stage 6th order Runge-Kutta method, see 'On Runge-Kutta Processes of High Order', J. C. Butcher, J. Austr Math Soc 4, (1964); can be used for very accurate (reference) solutions, but without step size control!
		.value("ODE23", DynamicSolverType::ODE23)    //an explicit Runge Kutta method with automatic step size selection with 3rd order of accuracy and 2nd order error estimation, see Bogacki and Shampine, 1989; also known as ODE23 in MATLAB
		.value("DOPRI5", DynamicSolverType::DOPRI5)    //an explicit Runge Kutta method with automatic step size selection with 5th order of accuracy and 4th order error estimation, see  Dormand and Prince, 'A Family of Embedded Runge-Kutta Formulae.', J. Comp. Appl. Math. 6, 1980
		.value("DVERK6", DynamicSolverType::DVERK6)    //[NOT IMPLEMENTED YET] an explicit Runge Kutta solver of 6th order with 5th order error estimation; includes adaptive step selection
		.value("VelocityVerlet", DynamicSolverType::VelocityVerlet)    //[TEST phase] a special explicit time integration scheme, the 'velocity Verlet' method (similar to leap frog method), with second order accuracy for conservative second order differential equations, often used for particle dynamics and contact; implementation uses Explicit Euler for ODE1 equations
		;

  py::enum_<CrossSectionType>(m, "CrossSectionType")
		.value("Polygon", CrossSectionType::Polygon)    //cross section profile defined by polygon
		.value("Circular", CrossSectionType::Circular)    //cross section is circle or elliptic
		;

  py::enum_<KeyCode>(m, "KeyCode")
		.value("SPACE", KeyCode::SPACE)    //space key
		.value("ENTER", KeyCode::ENTER)    //enter (return) key
		.value("TAB", KeyCode::TAB)    //
		.value("BACKSPACE", KeyCode::BACKSPACE)    //
		.value("RIGHT", KeyCode::RIGHT)    //cursor right
		.value("LEFT", KeyCode::LEFT)    //cursor left
		.value("DOWN", KeyCode::DOWN)    //cursor down
		.value("UP", KeyCode::UP)    //cursor up
		.value("F1", KeyCode::F1)    //function key F1
		.value("F2", KeyCode::F2)    //function key F2
		.value("F3", KeyCode::F3)    //function key F3
		.value("F4", KeyCode::F4)    //function key F4
		.value("F5", KeyCode::F5)    //function key F5
		.value("F6", KeyCode::F6)    //function key F6
		.value("F7", KeyCode::F7)    //function key F7
		.value("F8", KeyCode::F8)    //function key F8
		.value("F9", KeyCode::F9)    //function key F9
		.value("F10", KeyCode::F10)    //function key F10
		;

  py::enum_<LinearSolverType>(m, "LinearSolverType")
		.value("_None", LinearSolverType::_None)    //no value; used, e.g., if no solver is selected
		.value("EXUdense", LinearSolverType::EXUdense)    //use dense matrices and according solvers for densly populated matrices (usually the CPU time grows cubically with the number of unknowns)
		.value("EigenSparse", LinearSolverType::EigenSparse)    //use sparse matrices and according solvers; additional overhead for very small multibody systems; specifically, memory allocation is performed during a factorization process
		.value("EigenSparseSymmetric", LinearSolverType::EigenSparseSymmetric)    //use sparse matrices and according solvers; NOTE: this is the symmetric mode, which assumes symmetric system matrices; this is EXPERIMENTAL and should only be used of user knows that the system matrices are (nearly) symmetric; does not work with scaled GeneralizedAlpha matrices; does not work with constraints, as it must be symmetric positive definite
		.value("EigenDense", LinearSolverType::EigenDense)    //use Eigen's LU factorization with partial pivoting (faster than EXUdense) or full pivot (if linearSolverSettings.ignoreSingularJacobian=True; is much slower)
		;

  py::enum_<Contact::TypeIndex>(m, "ContactTypeIndex")
		.value("IndexSpheresMarkerBased", Contact::IndexSpheresMarkerBased)    //spheres attached to markers
		.value("IndexANCFCable2D", Contact::IndexANCFCable2D)    //ANCFCable2D contact items
		.value("IndexTrigsRigidBodyBased", Contact::IndexTrigsRigidBodyBased)    //triangles attached to rigid body (or rigid body marker)
		.value("IndexEndOfEnumList", Contact::IndexEndOfEnumList)    //signals end of list
		;


        m.def("Help", &PyHelp, "Show basic help information");
        m.def("StartRenderer", &PyStartOpenGLRenderer, "DEPRECATED; Start OpenGL rendering engine (in separate thread) for visualization of rigid or flexible multibody system; use verbose=1 to output information during OpenGL window creation; verbose=2 produces more output and verbose=3 gives a debug level; some of the information will only be seen in windows command (powershell) windows or linux shell, but not inside iPython of e.g. Spyder", py::arg("verbose") = 0, py::arg("deprecationWarning") = true);
        m.def("StopRenderer", &PyStopOpenGLRenderer, "DEPRECATED; Stop OpenGL rendering engine", py::arg("deprecationWarning") = true);
        m.def("IsRendererActive", &PyIsRendererActive, "DEPRECATED; returns True if GLFW renderer is available and running; otherwise False", py::arg("deprecationWarning") = true);
        m.def("DoRendererIdleTasks", &PyDoRendererIdleTasks, "DEPRECATED; Call this function in order to interact with Renderer window; use waitSeconds in order to run this idle tasks while animating a model (e.g. waitSeconds=0.04), use waitSeconds=0 without waiting, or use waitSeconds=-1 (default) to wait until window is closed", py::arg("waitSeconds") = 0, py::arg("deprecationWarning") = true);
        m.def("SetWriteToFile", &PySetWriteToFile, "set flag to write (True) or not write to console; default value of flagWriteToFile = False; flagAppend appends output to file, if set True; in order to finalize the file, write \texttt{exu.SetWriteToFile('', False)} to close the output file; in case of flagFlushAlways=True, file will be finalized immediately in every print command, but may be slower;", py::arg("filename"), py::arg("flagWriteToFile") = true, py::arg("flagAppend") = false, py::arg("flagFlushAlways") = false);
        m.def("Print", &PyPrint, "this allows printing via exudyn with similar syntax as in Python print(args) except for keyword arguments: exu.Print('test=',42,sep=' ',end='',flush=True); allows to redirect all output to file given by SetWriteToFile(...); does not print to console in case that exudyn.config.printToConsole eis set to False");
        m.def("SetOutputPrecision", &PySetOutputPrecisionOld, "DEPRECATED; use set exudyn.config.precision instead", py::arg("numberOfDigits"));
        m.def("SetLinalgOutputFormatPython", &PySetLinalgOutputFormatPython, "DEPRECATED; True: use Python format for output of vectors and matrices; False: use Matlab format", py::arg("flagPythonFormat"));
        m.def("GetVersionString", &PyGetVersionString, "DEPRECATED; Get Exudyn built version as string (if addDetails=True, adds more information on compilation Python version, platform, etc.; the Python micro version may differ from that you are working with; AVX2 shows that you are running a AVX2 compiled version)", py::arg("addDetails") = false);
        m.def("SetPrintDelayMilliSeconds", &PySetPrintDelayMilliSeconds, "DEPRECATED; add some delay (in milliSeconds) to printing to console, in order to let Spyder process the output; default = 0", py::arg("delayMilliSeconds"));
        m.def("SuppressWarnings", &PySuppressWarningsOld, "DEPRECATED; set flag to suppress (=True) or enable (=False) warnings", py::arg("flag"));
        m.def("InfoStat", &PythonInfoStatOld, "DEPRECATED; Retrieve list of global information on memory allocation and other counts as list:[array_new_counts, array_delete_counts, vector_new_counts, vector_delete_counts, matrix_new_counts, matrix_delete_counts, linkedDataVectorCast_counts]; May be extended in future; if writeOutput==True, it additionally prints the statistics; counts for new vectors and matrices should not depend on numberOfSteps, except for some objects such as ObjectGenericODE2 and for (sensor) output to files; Not available if code is compiled with __FAST_EXUDYN_LINALG flag", py::arg("writeOutput") = true);
        m.def("SetWriteToConsole", &PySetWriteToConsole, "DEPRECATED; set flag to write (True) or not write to console; default = True", py::arg("flag"));
        m.def("InvalidIndex", &GetInvalidIndex, "This function provides the invalid index, which may depend on the kind of 32-bit, 64-bit signed or unsigned integer; e.g. node index or item index in list; currently, the InvalidIndex() gives -1, but it may be changed in future versions, therefore you should use this function");
        m.attr("config") = py::cast(&pyConfig);
        m.attr("experimental") = py::cast(&pyExperimental);
        m.attr("special") = py::cast(&pySpecial);
        m.attr("variables") = exudynVariables;
        m.attr("sys") = exudynSystemVariables;

    py::class_<MainRenderer>(m, "Renderer")
        .def(py::init(&MainRenderer::ForbidConstructor))
        .def("Start", &MainRenderer::Start, "Start OpenGL rendering engine (in separate thread) for visualization of rigid or flexible multibody system; use verbose=1 to output information during OpenGL window creation; verbose=2 produces more output and verbose=3 gives a debug level; some of the information will only be seen in windows command (powershell) windows or linux shell, but not inside iPython of e.g. Spyder", py::arg("verbose") = 0)
        .def("Stop", &MainRenderer::Stop, "Stop OpenGL rendering engine; uses timeout in multithreading.")
        .def("IsActive", &MainRenderer::IsActive, "returns True if GLFW renderer is available and running; otherwise False")
        .def("Attach", &MainRenderer::Attach, "Links the SystemContainer to the render engine, such that the changes in the graphics structure drawn upon updates, etc.; done automatically on creation of SystemContainer; return False, if no renderer exists (e.g., compiled without GLFW) or cannot be linked (if other SystemContainer already linked)")
        .def("Detach", &MainRenderer::Detach, "DEPRECATED; Releases the SystemContainer from the render engine; return True if successfully released, False if no GLFW available or detaching failed")
        .def("DoIdleTasks", &MainRenderer::DoIdleTasks, "Interrupt further computation until user input (Space, 'Q', Escape-key), representing a PAUSE function; this command runs a loop in the background to have active response of the render window, e.g., to open the visualization dialog or use the right-mouse-button; replaces former SC.WaitForRenderEngineStopFlag() and mbs.WaitForUserToContinue(); call this function in order to interact with Renderer window; use waitSeconds in order to run this idle tasks while animating a model (e.g. waitSeconds=0.04), use waitSeconds=0 without waiting, or use waitSeconds=-1 (default) to wait until window is closed", py::arg("waitSeconds") = -1., py::arg("printPauseMessage") = true)
        .def("ZoomAll", &MainRenderer::ZoomAll, "Send zoom all signal, which will perform zoom all at next redraw request")
        .def("RedrawAndSaveImage", &MainRenderer::RedrawAndSaveImage, "Redraw openGL scene and save image (command waits until process is finished)")
        .def("SendRedrawSignal", &MainRenderer::SendRedrawSignal, "This function is used to send a signal to the renderer that all MainSystems (mbs) shall be redrawn")
        .def("GetRenderCount", &MainRenderer::GetRedrawCount, "Returns the number of rendered OpenGL images; can be used to determine if image has been drawn by comparing to previous counter; also shows that first image has been drawn (needed for zoom all)")
        .def("GetState", &MainRenderer::GetState, "Get dictionary with current render state (openGL zoom, modelview, etc.); will have no effect if GLFW_GRAPHICS is deactivated")
        .def("SetState", &MainRenderer::SetState, "Set current render state (openGL zoom, modelview, etc.) with given dictionary; usually, this dictionary has been obtained with GetRenderState; waitForRendererFullStartup is used to wait at startup for the first frame to be drawn (and zoom all to be set), but be be set False in case of performance issues; will have no effect if GLFW_GRAPHICS is deactivated", py::arg("renderState"), py::arg("waitForRendererFullStartup") = true)
        .def("GetMouseCoordinates", &MainRenderer::GetMouseCoordinates, "Get current mouse coordinates as list [x, y]; x and y being floats, as returned by GLFW, measured from top left corner of window; use GetCurrentMouseCoordinates(useOpenGLcoordinates=True) to obtain OpenGLcoordinates of projected plane", py::arg("useOpenGLcoordinates") = false)
        .def("GetItemSelection", &MainRenderer::GetItemSelection, "Get selected item in render state; option to reset selected item afterwards; item is selected in render window by clicking left mouse button; returns [mbs number, ItemType, ItemIndex, depth] where depth is the Z-depth in the current view; note that only items of the categories activated in visualizationSettings.interactive.selectionLeftMouseItemTypes are returned; if itemType == 0 if no item has been selected", py::arg("resetSelection") = true)
        .def_readwrite("materials", &MainRenderer::materials, py::return_value_policy::reference);
        ; // end of Renderer pybind definitions


    py::class_<MainSystem>(m, "MainSystem")
        .def(py::init<>())
        .def("Assemble", &MainSystem::Assemble, "assemble items (nodes, bodies, markers, loads, ...) of multibody system; Calls CheckSystemIntegrity(...), AssembleCoordinates(), AssembleLTGLists(), AssembleInitializeSystemCoordinates(), and AssembleSystemInitialize()")
        .def("AssembleCoordinates", &MainSystem::AssembleCoordinates, "assemble coordinates: assign computational coordinates to nodes and constraints (algebraic variables)")
        .def("AssembleLTGLists", &MainSystem::AssembleLTGLists, "build \ac{LTG} coordinate lists for objects (used to build global ODE2RHS, MassMatrix, etc. vectors and matrices) and store special object lists (body, connector, constraint, ...)")
        .def("AssembleInitializeSystemCoordinates", &MainSystem::AssembleInitializeSystemCoordinates, "initialize all system-wide coordinates based on initial values given in nodes")
        .def("AssembleSystemInitialize", &MainSystem::AssembleSystemInitialize, "initialize some system data, e.g., generalContact objects (searchTree, etc.)")
        .def("Reset", &MainSystem::Reset, "reset all lists of items (nodes, bodies, markers, loads, ...) and temporary vectors; deallocate memory")
        .def("GetSystemContainer", &MainSystem::GetMainSystemContainer, "return the systemContainer where the mainSystem (mbs) was created")
        .def("WaitForUserToContinue", &MainSystem::WaitForUserToContinue, "interrupt further computation until user input --> 'pause' function; this command runs a loop in the background to have active response of the render window, e.g., to open the visualization dialog or use the right-mouse-button; behaves similar as SC.WaitForRenderEngineStopFlag()", py::arg("printMessage") = true, py::arg("deprecationWarning") = true)
        .def("SendRedrawSignal", &MainSystem::SendRedrawSignal, "this function is used to send a signal to the renderer that the scene shall be redrawn because the visualization state has been updated")
        .def("GetRenderEngineStopFlag", &MainSystem::GetRenderEngineStopFlag, "get the current stop simulation flag; True=user wants to stop simulation")
        .def("SetRenderEngineStopFlag", &MainSystem::SetRenderEngineStopFlag, "set the current stop simulation flag; set to False, in order to continue a previously user-interrupted simulation", py::arg("stopFlag"))
        .def("ActivateRendering", &MainSystem::ActivateRendering, "activate (flag=True) or deactivate (flag=False) rendering for this system", py::arg("flag") = true)
        .def("SetPreStepUserFunction", &MainSystem::PySetPreStepUserFunction, "Sets a user function PreStepUserFunction(mbs, t) executed at beginning of every computation step; in normal case return True; return False to stop simulation after current step; set to 0 (integer) in order to erase user function. Note that the time returned is already the end of the step, which allows to compute forces consistently with trapezoidal integrators; for higher order Runge-Kutta methods, step time will be available only in object-user functions.", py::arg("value"))
        .def("GetPreStepUserFunction", &MainSystem::PyGetPreStepUserFunction, "Returns the preStepUserFunction.", py::arg("asDict") = false)
        .def("SetPostStepUserFunction", &MainSystem::PySetPostStepUserFunction, "Sets a user function PostStepUserFunction(mbs, t) executed at beginning of every computation step; in normal case return True; return False to stop simulation after current step; set to 0 (integer) in order to erase user function.", py::arg("value"))
        .def("GetPostStepUserFunction", &MainSystem::PyGetPostStepUserFunction, "Returns the postStepUserFunction.", py::arg("asDict") = false)
        .def("SetPostNewtonUserFunction", &MainSystem::PySetPostNewtonUserFunction, "Sets a user function PostNewtonUserFunction(mbs, t) executed after successful Newton iteration in implicit or static solvers and after step update of explicit solvers, but BEFORE PostNewton functions are called by the solver; function returns list [discontinuousError, recommendedStepSize], containing a error of the PostNewtonStep, which is compared to [solver].discontinuous.iterationTolerance. The recommendedStepSize shall be negative, if no recommendation is given, 0 in order to enforce minimum step size or a specific value to which the current step size will be reduced and the step will be repeated; use this function, e.g., to reduce step size after impact or change of data variables; set to 0 (integer) in order to erase user function. Similar described by Flores and Ambrosio, https://doi.org/10.1007/s11044-010-9209-8", py::arg("value"))
        .def("GetPostNewtonUserFunction", &MainSystem::PyGetPostNewtonUserFunction, "Returns the postNewtonUserFunction.", py::arg("asDict") = false)
        .def("SetPreNewtonResidualUserFunction", &MainSystem::PySetPreNewtonResidualUserFunction, "Sets a user function PreNewtonResidualUserFunction(mbs, t, newtonIt, discontinuousIt) executed prior to computation of the Newton residual in implicit or static solvers. This function returns nothing. The arguments newtonIt and discontinuousIt may be used to distinguish if the call is done at the beginning of a discontinuous iteration (newtonIt=0) or during Newton iterations (newtonIt>0). The typical use case would be to modify objects or loads in every iteration. Note that this user function is not called during Jacobian computation. If needed, the jacobian can be modified with the user function set by SetSystemJacobianUserFunction.", py::arg("value"))
        .def("GetPreNewtonResidualUserFunction", &MainSystem::PyGetPreNewtonResidualUserFunction, "Returns the preNewtonResidualUserFunction.", py::arg("asDict") = false)
        .def("SetSystemJacobianUserFunction", &MainSystem::PySetSystemJacobianUserFunction, "Sets a user function SystemJacobianUserFunction(mbs, t, factorODE2, factorODE2_t, factorODE1) executed after computation of the Newton jacobian of a static solver or an implicit timeintegrator; The function shall return additional terms for the jacobian at RHS, e.g., related to dependencies that are added by the user in the PreNewtonResidualUserFunction; RHS means that for a spring with stiffness K, the jacobian would be -K as it is computed for the RHS, see the RHS-LHS convention. If you like to completely replace the jacobian, consider using the solver's user function SetUserFunctionComputeNewtonJacobian which can be used to replace the jacobian computation; the factors factorODE2, factorODE2_t, factorODE1 must be multiplied with quantities related to ODE2 coordinates (like stiffness terms), ODE2_t velocity coordinates (like damping terms) and ODE1 quantities. The functions returns a MatrixContainer, for which the sparse format is recommended for efficiency reasons.", py::arg("value"))
        .def("GetSystemJacobianUserFunction", &MainSystem::PyGetSystemJacobianUserFunction, "Returns the systemJacobianUserFunction.", py::arg("asDict") = false)
        .def("AddGeneralContact", &MainSystem::AddGeneralContact, "add a new general contact, used to enable efficient contact computation between objects (nodes or markers)", py::return_value_policy::reference)
        .def("GetGeneralContact", &MainSystem::GetGeneralContact, "get read/write access to GeneralContact with index generalContactNumber stored in mbs; Examples shows how to access the GeneralContact object added with last AddGeneralContact() command:", py::return_value_policy::reference, py::arg("generalContactNumber"))
        .def("DeleteGeneralContact", &MainSystem::DeleteGeneralContact, "delete GeneralContact with index generalContactNumber in mbs; other general contacts are resorted (index changes!)", py::arg("generalContactNumber"))
        .def("NumberOfGeneralContacts", &MainSystem::NumberOfGeneralContacts, "Return number of GeneralContact objects in mbs")
        .def("GetAvailableFactoryItems", &MainSystem::GetAvailableFactoryItems, "get all available items to be added (nodes, objects, etc.); this is useful in particular in case of additional user elements to check if they are available; the available items are returned as dictionary, containing lists of strings for Node, Object, etc.")
        .def("GetDictionary", &MainSystem::GetDictionary, "[UNDER DEVELOPMENT]: return the dictionary of the system data (todo: and state), e.g., to copy the system or for pickling")
        .def("SetDictionary", &MainSystem::SetDictionary, "[UNDER DEVELOPMENT]: set system data (todo: and state) from given dictionary; used for pickling", py::arg("systemDict"))
        .def(py::pickle(
            [](const MainSystem& self) {
                return py::make_tuple(self.GetDictionary());
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "MainSystem: loading data with pickle received invalid data structure!");
                MainSystem* self = new MainSystem();
                self->SetDictionary(py::cast<py::dict>(t[0]));
                return self;
            }))
        .def("__repr__", [](const MainSystem &ms) {
            return "<systemData: \n" + ms.GetMainSystemData().PyInfoSummary() + "\nFor details see mbs.systemData, mbs.sys and mbs.variables\n>\n"; }, "return the representation of the system, which can be, e.g., printed")
        .def_property("systemIsConsistent", &MainSystem::GetFlagSystemIsConsistent, &MainSystem::SetFlagSystemIsConsistent)
        .def_property("interactiveMode", &MainSystem::GetInteractiveMode, &MainSystem::SetInteractiveMode)
        .def_readwrite("variables", &MainSystem::variables, py::return_value_policy::reference)
        .def_readwrite("sys", &MainSystem::systemVariables, py::return_value_policy::reference)
        .def_property("solverSignalJacobianUpdate", &MainSystem::GetFlagSolverSignalJacobianUpdate, &MainSystem::SetFlagSolverSignalJacobianUpdate)
        .def_readwrite("systemData", &MainSystem::mainSystemData, py::return_value_policy::reference)

//        NODES:
        .def("AddNode", &MainSystem::AddMainNodePyClass, "add a node with nodeDefinition from Python node class; returns (global) node index (type NodeIndex) of newly added node; use int(nodeIndex) to convert to int, if needed (but not recommended in order not to mix up index types of nodes, objects, markers, ...)", py::arg("pyObject"))
        .def("DeleteNode", &MainSystem::PyDeleteNode, "delete the node with nodeNumber in MainSystem; consistently renames nodes according to their new node numbers; adapts node numbers in sensors and in markers; items using deleted nodeNumber obtain invalid nodeNumber", py::arg("nodeNumber"), py::arg("suppressWarnings") = false)
        .def("GetNodeNumber", &MainSystem::PyGetNodeNumber, "get node's number by name (string)", py::arg("nodeName"))
        .def("GetNode", &MainSystem::PyGetNode, "get node's dictionary by node number (type NodeIndex)", py::arg("nodeNumber"))
        .def("ModifyNode", &MainSystem::PyModifyNode, "modify node's dictionary by node number (type NodeIndex)", py::arg("nodeNumber"), py::arg("nodeDict"))
        .def("GetNodeDefaults", &MainSystem::PyGetNodeDefaults, "get node's default values for a certain nodeType as (dictionary)", py::arg("typeName"))
        .def("GetNodeOutput", &MainSystem::PyGetNodeOutputVariable, "get the ouput of the node specified with the OutputVariableType; output may be scalar or array (e.g. displacement vector)", py::arg("nodeNumber"), py::arg("variableType"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetNodeODE2Index", &MainSystem::PyGetNodeODE2Index, "get index in the global ODE2 coordinate vector for the first node coordinate of the specified node", py::arg("nodeNumber"))
        .def("GetNodeODE1Index", &MainSystem::PyGetNodeODE1Index, "get index in the global ODE1 coordinate vector for the first node coordinate of the specified node", py::arg("nodeNumber"))
        .def("GetNodeAEIndex", &MainSystem::PyGetNodeAEIndex, "get index in the global AE coordinate vector for the first node coordinate of the specified node", py::arg("nodeNumber"))
        .def("GetNodeParameter", &MainSystem::PyGetNodeParameter, "get nodes's parameter from node number (type NodeIndex) and parameterName; parameter names can be found for the specific items in the reference manual; for visualization parameters, use a 'V' as a prefix", py::arg("nodeNumber"), py::arg("parameterName"))
        .def("SetNodeParameter", &MainSystem::PySetNodeParameter, "set parameter 'parameterName' of node with node number (type NodeIndex) to value; parameter names can be found for the specific items in the reference manual; for visualization parameters, use a 'V' as a prefix", py::arg("nodeNumber"), py::arg("parameterName"), py::arg("value"))

//        OBJECTS:
        .def("AddObject", &MainSystem::AddMainObjectPyClass, "add an object with objectDefinition from Python object class; returns (global) object number (type ObjectIndex) of newly added object", py::arg("pyObject"))
        .def("DeleteObject", &MainSystem::PyDeleteObject, "delete the object with objectNumber in MainSystem; consistently renames objects according to their new object numbers; adapts object numbers in sensors and in markers; items using deleted objectNumber obtain invalid objectNumber; with the option deleteDependentItems (default=True) the function also delete nodes and markers which are used by the object", py::arg("objectNumber"), py::arg("deleteDependentItems") = true, py::arg("suppressWarnings") = false)
        .def("GetObjectNumber", &MainSystem::PyGetObjectNumber, "get object's number by name (string)", py::arg("objectName"))
        .def("GetObject", &MainSystem::PyGetObject, "get object's dictionary by object number (type ObjectIndex); NOTE: visualization parameters have a prefix 'V'; in order to also get graphicsData written, use addGraphicsData=True (which is by default False, as it would spoil the information)", py::arg("objectNumber"), py::arg("addGraphicsData") = false)
        .def("ModifyObject", &MainSystem::PyModifyObject, "modify object's dictionary by object number (type ObjectIndex); NOTE: visualization parameters have a prefix 'V'", py::arg("objectNumber"), py::arg("objectDict"))
        .def("GetObjectDefaults", &MainSystem::PyGetObjectDefaults, "get object's default values for a certain objectType as (dictionary)", py::arg("typeName"))
        .def("GetObjectOutput", &MainSystem::PyGetObjectOutputVariable, "get object's current output variable from object number (type ObjectIndex) and OutputVariableType; for connectors, it can only be computed for exu.ConfigurationType.Current configuration!", py::arg("objectNumber"), py::arg("variableType"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetObjectOutputBody", &MainSystem::PyGetObjectOutputVariableBody, "get body's output variable from object number (type ObjectIndex) and OutputVariableType, using the localPosition as defined in the body, and as used in MarkerBody and SensorBody", py::arg("objectNumber"), py::arg("variableType"), py::arg("localPosition") = (std::vector<Real>)Vector3D({0,0,0}), py::arg("configuration") = ConfigurationType::Current)
        .def("GetObjectOutputSuperElement", &MainSystem::PyGetObjectOutputVariableSuperElement, "get output variable from mesh node number of object with type SuperElement (GenericODE2, FFRF, FFRFreduced - CMS) with specific OutputVariableType; the meshNodeNumber is the object's local node number, not the global node number!", py::arg("objectNumber"), py::arg("variableType"), py::arg("meshNodeNumber"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetObjectParameter", &MainSystem::PyGetObjectParameter, "get objects's parameter from object number (type ObjectIndex) and parameterName; parameter names can be found for the specific items in the reference manual; for visualization parameters, use a 'V' as a prefix; NOTE that BodyGraphicsData cannot be get or set, use dictionary access instead", py::arg("objectNumber"), py::arg("parameterName"))
        .def("SetObjectParameter", &MainSystem::PySetObjectParameter, "set parameter 'parameterName' of object with object number (type ObjectIndex) to value;; parameter names can be found for the specific items in the reference manual; for visualization parameters, use a 'V' as a prefix; NOTE that BodyGraphicsData cannot be get or set, use dictionary access instead", py::arg("objectNumber"), py::arg("parameterName"), py::arg("value"))

//        MARKER:
        .def("AddMarker", &MainSystem::AddMainMarkerPyClass, "add a marker with markerDefinition from Python marker class; returns (global) marker number (type MarkerIndex) of newly added marker", py::arg("pyObject"))
        .def("DeleteMarker", &MainSystem::PyDeleteMarker, "delete the marker with markerNumber in MainSystem; consistently renames markers according to their new marker numbers; adapts marker numbers in objects, loads and sensors; items using deleted markerNumber obtain invalid markerNumber", py::arg("markerNumber"), py::arg("suppressWarnings") = false)
        .def("GetMarkerNumber", &MainSystem::PyGetMarkerNumber, "get marker's number by name (string)", py::arg("markerName"))
        .def("GetMarker", &MainSystem::PyGetMarker, "get marker's dictionary by index", py::arg("markerNumber"))
        .def("ModifyMarker", &MainSystem::PyModifyMarker, "modify marker's dictionary by index", py::arg("markerNumber"), py::arg("markerDict"))
        .def("GetMarkerDefaults", &MainSystem::PyGetMarkerDefaults, "get marker's default values for a certain markerType as (dictionary)", py::arg("typeName"))
        .def("GetMarkerParameter", &MainSystem::PyGetMarkerParameter, "get markers's parameter from markerNumber and parameterName; parameter names can be found for the specific items in the reference manual", py::arg("markerNumber"), py::arg("parameterName"))
        .def("SetMarkerParameter", &MainSystem::PySetMarkerParameter, "set parameter 'parameterName' of marker with markerNumber to value; parameter names can be found for the specific items in the reference manual", py::arg("markerNumber"), py::arg("parameterName"), py::arg("value"))
        .def("GetMarkerOutput", &MainSystem::PyGetMarkerOutputVariable, "get the ouput of the marker specified with the OutputVariableType; currently only provides Displacement, Position and Velocity for position based markers, and RotationMatrix, Rotation and AngularVelocity(Local) for markers providing orientation; Coordinates and Coordinates_t available for coordinate markers", py::arg("markerNumber"), py::arg("variableType"), py::arg("configuration") = ConfigurationType::Current)

//        LOADS:
        .def("AddLoad", &MainSystem::AddMainLoadPyClass, "add a load with loadDefinition from Python load class; returns (global) load number (type LoadIndex) of newly added load", py::arg("pyObject"))
        .def("DeleteLoad", &MainSystem::PyDeleteLoad, "delete the load with loadNumber in MainSystem; consistently renames loads according to their new load numbers; deleteDependentMarkers (default=True) also deletes the corresponding marker", py::arg("loadNumber"), py::arg("deleteDependentMarkers") = true, py::arg("suppressWarnings") = false)
        .def("GetLoadNumber", &MainSystem::PyGetLoadNumber, "get load's number by name (string)", py::arg("loadName"))
        .def("GetLoad", &MainSystem::PyGetLoad, "get load's dictionary by index", py::arg("loadNumber"))
        .def("ModifyLoad", &MainSystem::PyModifyLoad, "modify load's dictionary by index", py::arg("loadNumber"), py::arg("loadDict"))
        .def("GetLoadDefaults", &MainSystem::PyGetLoadDefaults, "get load's default values for a certain loadType as (dictionary)", py::arg("typeName"))
        .def("GetLoadValues", &MainSystem::PyGetLoadValues, "Get current load values, specifically if user-defined loads are used; can be scalar or vector-valued return value", py::arg("loadNumber"))
        .def("GetLoadParameter", &MainSystem::PyGetLoadParameter, "get loads's parameter from loadNumber and parameterName; parameter names can be found for the specific items in the reference manual", py::arg("loadNumber"), py::arg("parameterName"))
        .def("SetLoadParameter", &MainSystem::PySetLoadParameter, "set parameter 'parameterName' of load with loadNumber to value; parameter names can be found for the specific items in the reference manual", py::arg("loadNumber"), py::arg("parameterName"), py::arg("value"))

//        SENSORS:
        .def("AddSensor", &MainSystem::AddMainSensorPyClass, "add a sensor with sensor definition from Python sensor class; returns (global) sensor number (type SensorIndex) of newly added sensor", py::arg("pyObject"))
        .def("DeleteSensor", &MainSystem::PyDeleteSensor, "delete the marker with sensorNumber in MainSystem; consistently renames sensors according to their new sensor numbers; adapts sensor numbers in sensors; items using deleted sensorNumber obtain invalid sensorNumber", py::arg("sensorNumber"), py::arg("suppressWarnings") = false)
        .def("GetSensorNumber", &MainSystem::PyGetSensorNumber, "get sensor's number by name (string)", py::arg("sensorName"))
        .def("GetSensor", &MainSystem::PyGetSensor, "get sensor's dictionary by index", py::arg("sensorNumber"))
        .def("ModifySensor", &MainSystem::PyModifySensor, "modify sensor's dictionary by index", py::arg("sensorNumber"), py::arg("sensorDict"))
        .def("GetSensorDefaults", &MainSystem::PyGetSensorDefaults, "get sensor's default values for a certain sensorType as (dictionary)", py::arg("typeName"))
        .def("GetSensorValues", &MainSystem::PyGetSensorValues, "get sensors's values for configuration; can be a scalar or vector-valued return value!", py::arg("sensorNumber"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetSensorStoredData", &MainSystem::PyGetSensorStoredData, "get sensors's internally stored data as matrix (all time points stored); rows are containing time and sensor values as obtained by sensor (e.g., time, and x, y, and z value of position)", py::arg("sensorNumber"))
        .def("GetSensorParameter", &MainSystem::PyGetSensorParameter, "get sensors's parameter from sensorNumber and parameterName; parameter names can be found for the specific items in the reference manual", py::arg("sensorNumber"), py::arg("parameterName"))
        .def("SetSensorParameter", &MainSystem::PySetSensorParameter, "set parameter 'parameterName' of sensor with sensorNumber to value; parameter names can be found for the specific items in the reference manual", py::arg("sensorNumber"), py::arg("parameterName"), py::arg("value"))
        ; // end of MainSystem pybind definitions


    py::class_<MainSystemData>(m, "SystemData")
        .def(py::init(&MainSystemData::ForbidConstructor))

//        General functions:
        .def("NumberOfLoads", [](const MainSystemData& msd) {return msd.GetMainLoads().NumberOfItems(); }, "return number of loads in system")
        .def("NumberOfMarkers", [](const MainSystemData& msd) {return msd.GetMainMarkers().NumberOfItems(); }, "return number of markers in system")
        .def("NumberOfNodes", [](const MainSystemData& msd) {return msd.GetMainNodes().NumberOfItems(); }, "return number of nodes in system")
        .def("NumberOfObjects", [](const MainSystemData& msd) {return msd.GetMainObjects().NumberOfItems(); }, "return number of objects in system")
        .def("NumberOfSensors", [](const MainSystemData& msd) {return msd.GetMainSensors().NumberOfItems(); }, "return number of sensors in system")
        .def("ODE2Size", &MainSystemData::PyODE2Size, "get size of ODE2 coordinate vector for given configuration (only works correctly after mbs.Assemble() )", py::arg("configurationType") = ConfigurationType::Current)
        .def("ODE1Size", &MainSystemData::PyODE1Size, "get size of ODE1 coordinate vector for given configuration (only works correctly after mbs.Assemble() )", py::arg("configurationType") = ConfigurationType::Current)
        .def("AEsize", &MainSystemData::PyAEsize, "get size of AE coordinate vector for given configuration (only works correctly after mbs.Assemble() )", py::arg("configurationType") = ConfigurationType::Current)
        .def("DataSize", &MainSystemData::PyDataSize, "get size of Data coordinate vector for given configuration (only works correctly after mbs.Assemble() )", py::arg("configurationType") = ConfigurationType::Current)
        .def("SystemSize", &MainSystemData::PySystemSize, "get size of System coordinate vector for given configuration (only works correctly after mbs.Assemble() )", py::arg("configurationType") = ConfigurationType::Current)
        .def("GetTime", &MainSystemData::PyGetStateTime, "get configuration dependent time.", py::arg("configurationType") = ConfigurationType::Current)
        .def("SetTime", &MainSystemData::PySetStateTime, "set configuration dependent time; use this access with care, e.g. in user-defined solvers.", py::arg("newTime"), py::arg("configurationType") = ConfigurationType::Current)
        .def("AddODE2LoadDependencies", &MainSystemData::PyAddODE2LoadDependencies, "advanced function for adding special dependencies of loads onto ODE2 coordinates, taking a list / numpy array of global ODE2 coordinates; this function needs to be called after Assemble() and needs to contain global ODE2 coordinate indices; this list only affects implicit or static solvers if timeIntegration.computeLoadsJacobian or staticSolver.computeLoadsJacobian is set to 1 (ODE2) or 2 (ODE2 and ODE2_t dependencies); if set, it may greatly improve convergence if loads with user functions depend on some system states, such as in a load with feedback control loop; the additional dependencies are not required, if doSystemWideDifferentiation=True, however the latter option being much less efficient. For more details, consider the file doublePendulum2DControl.py in the examples directory.", py::arg("loadNumber"), py::arg("globalODE2coordinates"))
        .def("Info", [](const MainSystemData& msd) {pout << msd.PyInfoDetailed(); }, "print detailed information on every item; for short information use print(mbs)")
        .def("InfoLTG", [](const MainSystemData& msd) {pout << msd.PyInfoLTG(); }, "print LTG information of objects and load dependencies")

//        Coordinate access:
        .def("GetODE2CoordinatesTotal", &MainSystemData::GetODE2CoordsTotal, "get ODE2 system coordinates (displacements/rotation) including reference values for given configuration (default: exu.Configuration.Current); in case of exu.ConfigurationType.Reference, it only includes reference values once and is identical to GetODE2Coordinates; note that faster access to coordinates is possibly with GetODE2Coordinates(copy=False), which is not possible with GetODE2CoordinatesTotal !", py::arg("configuration") = ConfigurationType::Current)
        .def("GetODE2Coordinates", &MainSystemData::GetODE2Coords, "get ODE2 system coordinates (displacements/rotations) for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetODE2Coordinates", &MainSystemData::SetODE2Coords, "set ODE2 system coordinates (displacements/rotations) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetODE2Coordinates_t", &MainSystemData::GetODE2Coords_t, "get ODE2 system coordinates (velocities) for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetODE2Coordinates_t", &MainSystemData::SetODE2Coords_t, "set ODE2 system coordinates (velocities) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetODE2Coordinates_tt", &MainSystemData::GetODE2Coords_tt, "get ODE2 system coordinates (accelerations) for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetODE2Coordinates_tt", &MainSystemData::SetODE2Coords_tt, "set ODE2 system coordinates (accelerations) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetODE1Coordinates", &MainSystemData::GetODE1Coords, "get ODE1 system coordinates (displacements) for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetODE1Coordinates", &MainSystemData::SetODE1Coords, "set ODE1 system coordinates (velocities) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetODE1Coordinates_t", &MainSystemData::GetODE1Coords_t, "get ODE1 system coordinates (velocities) for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetODE1Coordinates_t", &MainSystemData::SetODE1Coords_t, "set ODE1 system coordinates (displacements) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetAECoordinates", &MainSystemData::GetAECoords, "get algebraic equations (AE) system coordinates for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetAECoordinates", &MainSystemData::SetAECoords, "set algebraic equations (AE) system coordinates for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetDataCoordinates", &MainSystemData::GetDataCoords, "get system data coordinates for given configuration (default: exu.Configuration.Current)", py::arg("configuration") = ConfigurationType::Current, py::arg("copy") = true)
        .def("SetDataCoordinates", &MainSystemData::SetDataCoords, "set system data coordinates for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!", py::arg("coordinates"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetSystemState", &MainSystemData::PyGetSystemState, "get system state for given configuration (default: exu.Configuration.Current); state vectors do not include the non-state derivatives ODE1_t and ODE2_tt and the time; function is copying data - not highly efficient; format of pyList: [ODE2Coords, ODE2Coords_t, ODE1Coords, AEcoords, dataCoords]", py::arg("configuration") = ConfigurationType::Current)
        .def("SetSystemState", &MainSystemData::PySetSystemState, "set system data coordinates for given configuration (default: exu.Configuration.Current); invalid list of vectors / vector size may lead to system crash; write access to state vectors (but not the non-state derivatives ODE1_t and ODE2_tt and the time); function is copying data - not highly efficient; format of pyList: [ODE2Coords, ODE2Coords_t, ODE1Coords, AEcoords, dataCoords]", py::arg("systemStateList"), py::arg("configuration") = ConfigurationType::Current)
        .def("GetSystemStateDict", &MainSystemData::PyGetSystemStateDict, "get dictionary with copies of (or references to) system states for given configuration (default: exu.Configuration.Current), with at least the following quantities: ODE1Coords, ODE1Coords_t, ODE2Coords, ODE2Coords_t, ODE2Coords_tt, AECoords, dataCoords; we can obtain copies OR references to vectors without copying, meaning that these vectors then have read-write properties and have to be treated carefully! The dictionary's contents are subject to changes in the future; if reference=False, data is copied", py::arg("configuration") = ConfigurationType::Current, py::arg("reference") = false)

//        LTG readout functions:
        .def("GetObjectLTGODE2", &MainSystemData::PyGetObjectLocalToGlobalODE2, "get object local-to-global coordinate mapping (list of global coordinate indices) for ODE2 coordinates; only available after Assemble()", py::arg("objectNumber"))
        .def("GetObjectLTGODE1", &MainSystemData::PyGetObjectLocalToGlobalODE1, "get object local-to-global coordinate mapping (list of global coordinate indices) for ODE1 coordinates; only available after Assemble()", py::arg("objectNumber"))
        .def("GetObjectLTGAE", &MainSystemData::PyGetObjectLocalToGlobalAE, "get object local-to-global coordinate mapping (list of global coordinate indices) for algebraic equations (AE) coordinates; only available after Assemble()", py::arg("objectNumber"))
        .def("GetObjectLTGData", &MainSystemData::PyGetObjectLocalToGlobalData, "get object local-to-global coordinate mapping (list of global coordinate indices) for data coordinates; only available after Assemble()", py::arg("objectNumber"))
        .def("GetNodeLTGODE2", &MainSystemData::PyGetNodeLocalToGlobalODE2, "get node local-to-global coordinate mapping (list of global coordinate indices) for ODE2 coordinates; only available after Assemble()", py::arg("nodeNumber"))
        .def("GetNodeLTGODE1", &MainSystemData::PyGetNodeLocalToGlobalODE1, "get node local-to-global coordinate mapping (list of global coordinate indices) for ODE1 coordinates; only available after Assemble()", py::arg("nodeNumber"))
        .def("GetNodeLTGAE", &MainSystemData::PyGetNodeLocalToGlobalAE, "get node local-to-global coordinate mapping (list of global coordinate indices) for AE coordinates; only available after Assemble()", py::arg("nodeNumber"))
        .def("GetNodeLTGData", &MainSystemData::PyGetNodeLocalToGlobalData, "get node local-to-global coordinate mapping (list of global coordinate indices) for Data coordinates; only available after Assemble()", py::arg("nodeNumber"))
        ; // end of SystemData pybind definitions


    py::class_<PyGeneralContact>(m, "GeneralContact")
        .def(py::init(&PyGeneralContact::ForbidConstructor))
        .def("GetPythonObject", &PyGeneralContact::GetPythonObject, "convert member variables of GeneralContact into dictionary; use this for debug only!")
        .def("Reset", &PyGeneralContact::Reset, "remove all contact objects and reset contact parameters", py::arg("freeMemory") = true)
        .def_readwrite("isActive", &PyGeneralContact::isActive, py::return_value_policy::reference)
        .def_readwrite("verboseMode", &PyGeneralContact::verboseMode, py::return_value_policy::reference)
        .def_readwrite("visualization", &PyGeneralContact::visualization, py::return_value_policy::reference)
        .def_property("resetSearchTreeInterval", &PyGeneralContact::GetResetSearchTreeInterval, &PyGeneralContact::SetResetSearchTreeInterval)
        .def_property("sphereSphereContact", &PyGeneralContact::GetSphereSphereContact, &PyGeneralContact::SetSphereSphereContact)
        .def_property("sphereSphereFrictionRecycle", &PyGeneralContact::GetSphereSphereFrictionRecycle, &PyGeneralContact::SetSphereSphereFrictionRecycle)
        .def_property("minRelDistanceSpheresTriangles", &PyGeneralContact::GetMinRelDistanceSpheresTriangles, &PyGeneralContact::SetMinRelDistanceSpheresTriangles)
        .def_property("frictionProportionalZone", &PyGeneralContact::GetFrictionProportionalZone, &PyGeneralContact::SetFrictionProportionalZone)
        .def_property("excludeOverlappingTrigSphereContacts", &PyGeneralContact::GetExcludeOverlappingTrigSphereContacts, &PyGeneralContact::SetExcludeOverlappingTrigSphereContacts)
        .def_property("excludeDuplicatedTrigSphereContactPoints", &PyGeneralContact::GetExcludeDuplicatedTrigSphereContactPoints, &PyGeneralContact::SetExcludeDuplicatedTrigSphereContactPoints)
        .def_property("computeExactStaticTriangleBins", &PyGeneralContact::GetComputeExactStaticTriangleBins, &PyGeneralContact::SetComputeExactStaticTriangleBins)
        .def_property("computeContactForces", &PyGeneralContact::GetComputeContactForces, &PyGeneralContact::SetComputeContactForces)
        .def_property("ancfCableUseExactMethod", &PyGeneralContact::GetAncfCableUseExactMethod, &PyGeneralContact::SetAncfCableUseExactMethod)
        .def_property("ancfCableNumberOfContactSegments", &PyGeneralContact::GetAncfCableNumberOfContactSegments, &PyGeneralContact::SetAncfCableNumberOfContactSegments)
        .def_property("ancfCableMeasuringSegments", &PyGeneralContact::GetAncfCableMeasuringSegments, &PyGeneralContact::SetAncfCableMeasuringSegments)
        .def_property("parallelTaskSplit", &PyGeneralContact::GetParallelTaskSplit, &PyGeneralContact::SetParallelTaskSplit)
        .def_property("parallelTaskSplitBoundingBoxes", &PyGeneralContact::GetParallelTaskSplitBoundingBoxes, &PyGeneralContact::SetParallelTaskSplitBoundingBoxes)
        .def_property("parallelTaskSplitThreshold", &PyGeneralContact::GetParallelTaskSplitThreshold, &PyGeneralContact::SetParallelTaskSplitThreshold)
        .def_property("parallelTaskSplitBoundingBoxesThreshold", &PyGeneralContact::GetParallelTaskSplitBoundingBoxesThreshold, &PyGeneralContact::SetParallelTaskSplitBoundingBoxesThreshold)
        .def("SetFrictionPairings", &PyGeneralContact::SetFrictionPairings, "set Coulomb friction coefficients for pairings of materials (e.g., use material 0,1, then the entries (0,1) and (1,0) define the friction coefficients for this pairing); matrix should be symmetric!", py::arg("frictionPairings"))
        .def("SetFrictionProportionalZone", &PyGeneralContact::SetFrictionProportionalZone, "regularization for friction (m/s); used for all contacts", py::arg("frictionProportionalZone"))
        .def("SetSearchTreeCellSize", &PyGeneralContact::SetSearchTreeCellSize, "set number of cells of search tree (boxed search) in x, y and z direction", py::arg("numberOfCells"))
        .def("SetSearchTreeBox", &PyGeneralContact::SetSearchTreeBox, "set geometric dimensions of searchTreeBox (point with minimum coordinates and point with maximum coordinates); if this box becomes smaller than the effective contact objects, contact computations may slow down significantly", py::arg("pMin"), py::arg("pMax"))
        .def("AddSphereWithMarker", &PyGeneralContact::AddSphereWithMarker, "add contact object using a marker (Position or Rigid), radius and contact/friction parameters and return localIndex of the contact item in GeneralContact; frictionMaterialIndex refers to frictionPairings in GeneralContact; contact is possible between spheres (circles in 2D) (if intraSphereContact = True), spheres and triangles and between sphere (=circle) and ANCFCable2D; contactStiffness is computed as serial spring between contacting objects, while damping is computed as a parallel damper", py::arg("markerIndex"), py::arg("radius"), py::arg("contactStiffness"), py::arg("contactDamping"), py::arg("frictionMaterialIndex"))
        .def("AddANCFCable", &PyGeneralContact::AddANCFCable, "add contact object for an ANCF cable element, using the objectIndex of the cable element and the cable's half height as an additional distance to contacting objects (currently not causing additional torque in case of friction), and return localIndex of the contact item in GeneralContact; currently only contact with spheres (circles in 2D) possible; contact computed using exact geometry of elements, finding max 3 intersecting contact regions", py::arg("objectIndex"), py::arg("halfHeight"), py::arg("contactStiffness"), py::arg("contactDamping"), py::arg("frictionMaterialIndex"))
        .def("AddTrianglesRigidBodyBased", &PyGeneralContact::PyAddTrianglesRigidBodyBased, "add contact object using a rigidBodyMarker (of a body), contact/friction parameters, a list of points (as 3D numpy arrays or lists; coordinates relative to rigidBodyMarker) and a list of triangles (3 indices as numpy array or list) according to a mesh attached to the rigidBodyMarker; the flag staticTriangles=True can be used to inform the contact solver that these triangles are static (fixed in space); note that static triangles have to be added before dynamic triangles; function returns starting local index of trigsRigidBodyBased at which the triangles are stored; mesh can be produced with GraphicsData2TrigsAndPoints(...); contact is possible between sphere (circle) and Triangle but yet not between triangle and triangle; frictionMaterialIndex refers to frictionPairings in GeneralContact; contactStiffness is computed as serial spring between contacting objects, while damping is computed as a parallel damper (otherwise the smaller damper would always dominate); the triangle normal must point outwards, with the normal of a triangle given with local points (p0,p1,p2) defined as n=(p1-p0) x (p2-p0), see function ComputeTriangleNormal(...)", py::arg("rigidBodyMarkerIndex"), py::arg("contactStiffness"), py::arg("contactDamping"), py::arg("frictionMaterialIndex"), py::arg("pointList"), py::arg("triangleList"), py::arg("staticTriangles") = false)
        .def("GetItemsInBox", &PyGeneralContact::PyGetItemsInBox, "Get all items in box defined by minimum coordinates given in pMin and maximum coordinates given by pMax, accepting 3D lists or numpy arrays; in case that no objects are found, False is returned; otherwise, a dictionary is returned, containing numpy arrays with indices of obtained MarkerBasedSpheres, TrigsRigidBodyBased, ANCFCable2D, ...; the indices refer to the local index in GeneralContact which can be evaluated e.g. by GetMarkerBasedSphere(localIndex)", py::arg("pMin"), py::arg("pMax"))
        .def("GetSphereMarkerBased", &PyGeneralContact::PyGetSphereMarkerBased, "Get dictionary with current position, orientation, velocity, angular velocity as computed in last contact iteration; if addData=True, adds stored data of contact element, such as radius, markerIndex and contact parameters; localIndex is the internal index of contact element, as returned e.g. from GetItemsInBox", py::arg("localIndex"), py::arg("addData") = false)
        .def("SetSphereMarkerBased", &PyGeneralContact::PySetSphereMarkerBased, "Set data of marker based sphere with localIndex (as internally stored) with given arguments; arguments that are < 0 (default) imply that current values are not overwritten", py::arg("localIndex"), py::arg("contactStiffness") = -1., py::arg("contactDamping") = -1., py::arg("radius") = -1., py::arg("frictionMaterialIndex") = -1)
        .def("GetTriangleRigidBodyBased", &PyGeneralContact::PyGetTriangleRigidBodyBased, "Get dictionary with rigid body index, local position of triangle vertices (nodes) and triangle normal; NOTE: the mesh added to contact is different from this structure, as it contains nodes and connectivity lists; the triangle index corresponds to the order as triangles are added to GeneralContact", py::arg("localIndex"))
        .def("SetTriangleRigidBodyBased", &PyGeneralContact::PySetTriangleRigidBodyBased, "Set data of marker based sphere with localIndex (triangle index); points are provided as 3x3 numpy array, with point coordinates in rows; contactRigidBodyIndex<0 indicates no change of the current index (and changing this index should be handled with care)", py::arg("localIndex"), py::arg("points"), py::arg("contactRigidBodyIndex") = -1)
        .def("ShortestDistanceAlongLine", &PyGeneralContact::PyShortestDistanceAlongLine, "Find shortest distance to contact objects in GeneralContact along line with pStart (given as 3D list or numpy array) and direction (as 3D list or numpy array with no need to be normalized); the function returns the distance which is >= minDistance and < maxDistance; in case of beam elements, it measures the distance to the beam centerline; the distance is measured from pStart along given direction and can also be negative; if no item is found along line, the maxDistance is returned; if asDictionary=False, the result is a float, while otherwise details are returned as dictionary (including distance, velocityAlongLine (which is the object velocity in given direction and may be different from the time derivative of the distance; works similar to a laser Doppler vibrometer - LDV), itemIndex and itemType in GeneralContact); the cylinderRadius, if not equal to 0, will be used for spheres to find closest sphere along cylinder with given point and direction; the typeIndex can be set to a specific contact type, e.g., which are searched for (otherwise all objects are considered)", py::arg("pStart") = (std::vector<Real>)Vector3D({0,0,0}), py::arg("direction") = (std::vector<Real>)Vector3D({1,0,0}), py::arg("minDistance") = -1e-7, py::arg("maxDistance") = 1e7, py::arg("asDictionary") = false, py::arg("cylinderRadius") = 0, py::arg("typeIndex") = Contact::IndexEndOfEnumList)
        .def("UpdateContacts", &PyGeneralContact::PyUpdateContacts, "Update contact sets, e.g. if no contact is simulated (isActive=False) but user functions need up-to-date contact states for GetItemsInBox(...) or for GetActiveContacts(...)", py::arg("mainSystem"))
        .def("GetActiveContacts", &PyGeneralContact::PyGetActiveContacts, "Get list of global item numbers which are in contact with itemIndex of type typeIndex in case that the global itemIndex is smaller than the abs value of the contact pair index; a negative sign indicates that the contacting (spheres) is in Coloumb friction, a positive sign indicates a regularized friction region; in case of itemIndex==-1, it will return the list of numbers of active contacts per item for the contact type; for interpretation of global contact indices, see gContact.GetPythonObject() and documentation; requires either implicit contact computation or UpdateContacts(...) needs to be called prior to this function", py::arg("typeIndex"), py::arg("itemIndex"))
        .def("GetSystemODE2RhsContactForces", &PyGeneralContact::PyGetSystemODE2RhsContactForces, "Get numpy array of system vector containing contribution of contact forces to system ODE2 Rhs vector; if copy=False, it will give direct (reference) access to the internal vector (note: modifications to this vector do not influence simulation!), however, which may cause problems if the system size changes or simulation is restarted; if copy=True, the vector is copied (time consuming); contributions to single objects may be extracted by checking the according LTG-array of according objects (such as rigid bodies); the contact forces vector is computed in each contact iteration;", py::arg("copy") = false)
        .def("__repr__", [](const PyGeneralContact &item) {
            return EXUstd::ToString(item); }, "return the string representation of the GeneralContact, containing basic information and statistics")
        ; // end of GeneralContact pybind definitions


    py::class_<VisuGeneralContact>(m, "VisuGeneralContact")
        .def(py::init<>())
        .def("Reset", &VisuGeneralContact::Reset, "reset visualization parameters to default values")
        ; // end of GeneralContact pybind definitions


    py::class_<PyMatrixContainer>(m, "MatrixContainer")
        .def(py::init<>())
        .def(py::init<const py::object&>(), py::arg("matrix"))
        .def("Initialize", &PyMatrixContainer::Initialize, "initialize MatrixContainer with number of rows and columns and set dense/sparse mode", py::arg("numberOfRows"), py::arg("numberOfColumns"), py::arg("useDenseMatrix") = true)
        .def("SetWithDenseMatrix", &PyMatrixContainer::SetWithDenseMatrix, "set MatrixContainer with dense numpy array of size (n x m); array (=matrix) contains values and matrix size information; if useDenseMatrix=True, matrix will be stored internally as dense matrix, otherwise it will be converted and stored as sparse matrix (which may speed up computations for larger problems); pyArray is multiplied with given factor", py::arg("pyArray"), py::arg("useDenseMatrix") = false, py::arg("factor") = 1.)
        .def("SetWithSparseMatrix", &PyMatrixContainer::SetWithSparseMatrix, "set with scipy sparse csr_matrix (NOT: csc_matrix!) or with internal sparse triplet format (denoted as CSR): 'sparseMatrix' either contains a scipy matrix create with csr_matrix or a list of lists of sparse triplets (row, col, value) or the list of lists converted into numpy array; numberOfRowsInit and numberOfColumnsInit denote the size of the matrices, which are ignored in case of a scipy sparse matrix; if useDenseMatrix=True, matrix will be converted and stored internally as dense matrix, otherwise it will be stored as sparse matrix triplets; the values of sparseMatrix are multiplied with the given factor before storing", py::arg("sparseMatrix"), py::arg("numberOfRows") = EXUstd::InvalidIndex, py::arg("numberOfColumns") = EXUstd::InvalidIndex, py::arg("useDenseMatrix") = false, py::arg("factor") = 1.)
        .def("AddSparseMatrix", &PyMatrixContainer::AddSparseMatrix, "add scipy sparse csr_matrix with factor to already initilized MatrixContainer; sparseMatrix must contain according scipy csr format, otherwise the behavior is undefined! This function allows to efficiently add submatrices to the MatrixContainer", py::arg("sparseMatrix"), py::arg("factor") = 1.)
        .def("GetPythonObject", &PyMatrixContainer::GetPythonObject, "convert MatrixContainer to numpy array (dense) or dictionary (sparse): containing nr. of rows, nr. of columns, numpy matrix with sparse triplets")
        .def("Convert2DenseMatrix", &PyMatrixContainer::Convert2DenseMatrix, "convert MatrixContainer to dense numpy array (SLOW and may fail for too large sparse matrices)")
        .def("UseDenseMatrix", &PyMatrixContainer::UseDenseMatrix, "returns True if dense matrix is used, otherwise False")
        .def("SetAllZero", &PyMatrixContainer::SetAllZero, "Set all values to zero; dense mode: set all matrix entries to zero (slow); sparse mode: set number of triplets to zero (fast)")
        .def("SetWithSparseMatrixCSR", &PyMatrixContainer::SetWithSparseMatrixCSR, "DEPRECATED: set with sparse CSR matrix format: numpy array 'pyArrayCSR' contains sparse triplet (row, col, value) per row; numberOfRows and numberOfColumns given extra; if useDenseMatrix=True, matrix will be converted and stored internally as dense matrix, otherwise it will be stored as sparse matrix; the values of pyArrayCSR are multiplied by the given factor", py::arg("numberOfRowsInit"), py::arg("numberOfColumnsInit"), py::arg("pyArrayCSR"), py::arg("useDenseMatrix") = false, py::arg("factor") = 1.)
        .def("__repr__", [](const PyMatrixContainer &item) {
            return EXUstd::ToString(item.GetPythonObject()); }, "return the string representation of the MatrixContainer")
        ; // end of MatrixContainer pybind definitions


    py::class_<MainGraphicsMaterialList>(m, "GraphicsMaterialList")
        .def(py::init<>())
        .def("Reset", &MainGraphicsMaterialList::Reset, "reset materials to 10 default materials")
        .def("Append", &MainGraphicsMaterialList::PyAppend, "add single material as dict or VSettingsMaterial to list; returns index of newly added material", py::arg("material"))
        .def("New", &MainGraphicsMaterialList::NewMaterial, "Get new default material, which can be modified or appended to materials list")
        .def("Set", &MainGraphicsMaterialList::PySetMaterial, "set material with index 'materialIndex' as dict or VSettingsMaterial", py::arg("indexOrName"), py::arg("material"))
        .def("Get", &MainGraphicsMaterialList::GetMaterial, "get material with index 'materialIndex' as VSettingsMaterial", py::arg("indexOrName"))
        .def("GetDict", &MainGraphicsMaterialList::PyGetMaterialDict, "get material with index 'materialIndex' as dict", py::arg("indexOrName"))
        .def("__len__", [](const MainGraphicsMaterialList &item) {
            return item.NumberOfItems(); }, "return length of the Vector3DList, using len(data) where data is the Vector3DList")
        .def("__getitem__", [](const MainGraphicsMaterialList &item, py::object index) {
            return py::cast<const VSettingsMaterial&>(item.GetMaterial(index)); }, "get reference access of material with 'index' as VSettingsMaterial")
        .def("__repr__", [](const MainGraphicsMaterialList &item) {
            return EXUstd::ToString(item); }, "return the string representation of the GraphicsMaterialList")
        ; // end of GraphicsMaterialList pybind definitions


    py::class_<PyVector3DList>(m, "Vector3DList")
        .def(py::init<>())
        .def(py::init<const py::object&>(), py::arg("listOfArrays"))
        .def("Append", &PyVector3DList::PyAppend, "add single array or list to Vector3DList; array or list must have appropriate dimension!", py::arg("pyArray"))
        .def("GetPythonObject", &PyVector3DList::GetPythonObject, "convert Vector3DList into (copied) list of numpy arrays")
        .def("__len__", [](const PyVector3DList &item) {
            return item.NumberOfItems(); }, "return length of the Vector3DList, using len(data) where data is the Vector3DList")
        .def("__setitem__", [](PyVector3DList &item, Index index, const py::object& vector) {
            item.PySetItem(index, vector); }, "set list item 'index' with data, write: data[index] = ...")
        .def("__getitem__", [](const PyVector3DList &item, Index index) {
            return py::array_t<Real>(item[index].NumberOfItems(), item[index].GetDataPointer()); }, "get copy of list item with 'index' as vector")
        .def("__copy__", [](const PyVector3DList &item) {
            return PyVector3DList(item); }, "copy method to be used for copy.copy(...); in fact does already deep copy")
        .def("__deepcopy__", [](const PyVector3DList &item, py::dict) {
            return PyVector3DList(item); }, "memo"_a, "deepcopy method to be used for copy.copy(...)")
        .def("__repr__", [](const PyVector3DList &item) {
            return EXUstd::ToString(item.GetPythonObject()); }, "return the string representation of the Vector3DList data, e.g.: print(data)")
        ; // end of PyVector3DList pybind definitions


    py::class_<PyVector2DList>(m, "Vector2DList")
        .def(py::init<>())
        .def(py::init<const py::object&>(), py::arg("listOfArrays"))
        .def("Append", &PyVector2DList::PyAppend, "add single array or list to Vector2DList; array or list must have appropriate dimension!", py::arg("pyArray"))
        .def("GetPythonObject", &PyVector2DList::GetPythonObject, "convert Vector2DList into (copied) list of numpy arrays")
        .def("__len__", [](const PyVector2DList &item) {
            return item.NumberOfItems(); }, "return length of the Vector2DList, using len(data) where data is the Vector2DList")
        .def("__setitem__", [](PyVector2DList &item, Index index, const py::object& vector) {
            item.PySetItem(index, vector); }, "set list item 'index' with data, write: data[index] = ...")
        .def("__getitem__", [](const PyVector2DList &item, Index index) {
            return py::array_t<Real>(item[index].NumberOfItems(), item[index].GetDataPointer()); }, "get copy of list item with 'index' as vector")
        .def("__copy__", [](const PyVector2DList &item) {
            return PyVector2DList(item); }, "copy method to be used for copy.copy(...); in fact does already deep copy")
        .def("__deepcopy__", [](const PyVector2DList &item, py::dict) {
            return PyVector2DList(item); }, "memo"_a, "deepcopy method to be used for copy.copy(...)")
        .def("__repr__", [](const PyVector2DList &item) {
            return EXUstd::ToString(item.GetPythonObject()); }, "return the string representation of the Vector2DList data, e.g.: print(data)")
        ; // end of PyVector2DList pybind definitions


    py::class_<PyVector6DList>(m, "Vector6DList")
        .def(py::init<>())
        .def(py::init<const py::object&>(), py::arg("listOfArrays"))
        .def("Append", &PyVector6DList::PyAppend, "add single array or list to Vector6DList; array or list must have appropriate dimension!", py::arg("pyArray"))
        .def("GetPythonObject", &PyVector6DList::GetPythonObject, "convert Vector6DList into (copied) list of numpy arrays")
        .def("__len__", [](const PyVector6DList &item) {
            return item.NumberOfItems(); }, "return length of the Vector6DList, using len(data) where data is the Vector6DList")
        .def("__setitem__", [](PyVector6DList &item, Index index, const py::object& vector) {
            item.PySetItem(index, vector); }, "set list item 'index' with data, write: data[index] = ...")
        .def("__getitem__", [](const PyVector6DList &item, Index index) {
            return py::array_t<Real>(item[index].NumberOfItems(), item[index].GetDataPointer()); }, "get copy of list item with 'index' as vector")
        .def("__copy__", [](const PyVector6DList &item) {
            return PyVector6DList(item); }, "copy method to be used for copy.copy(...); in fact does already deep copy")
        .def("__deepcopy__", [](const PyVector6DList &item, py::dict) {
            return PyVector6DList(item); }, "memo"_a, "deepcopy method to be used for copy.copy(...)")
        .def("__repr__", [](const PyVector6DList &item) {
            return EXUstd::ToString(item.GetPythonObject()); }, "return the string representation of the Vector6DList data, e.g.: print(data)")
        ; // end of PyVector6DList pybind definitions


    py::class_<PyMatrix3DList>(m, "Matrix3DList")
        .def(py::init<>())
        .def(py::init<const py::object&>(), py::arg("listOfArrays"))
        .def("Append", &PyMatrix3DList::PyAppend, "add single 3D array or list of lists to Matrix3DList; array or lists must have appropriate dimension!", py::arg("pyArray"))
        .def("GetPythonObject", &PyMatrix3DList::GetPythonObject, "convert Matrix3DList into (copied) list of 3x3 numpy arrays")
        .def("__len__", [](const PyMatrix3DList &item) {
            return item.NumberOfItems(); }, "return length of the Matrix3DList, using len(data) where data is the Matrix3DList")
        .def("__setitem__", [](PyMatrix3DList &item, Index index, const py::object& matrix) {
            item.PySetItem(index, matrix); }, "set list item 'index' with matrix, write: data[index] = ...")
        .def("__getitem__", [](const PyMatrix3DList &item, Index index) {
            return item.PyGetItem(index); }, "get copy of list item with 'index' as matrix")
        .def("__repr__", [](const PyMatrix3DList &item) {
            return EXUstd::ToString(item.GetPythonObject()); }, "return the string representation of the Matrix3DList data, e.g.: print(data)")
        ; // end of PyMatrix3DList pybind definitions


    py::class_<PyMatrix6DList>(m, "Matrix6DList")
        .def(py::init<>())
        .def(py::init<const py::object&>(), py::arg("listOfArrays"))
        .def("Append", &PyMatrix6DList::PyAppend, "add single 6D array or list of lists to Matrix6DList; array or lists must have appropriate dimension!", py::arg("pyArray"))
        .def("GetPythonObject", &PyMatrix6DList::GetPythonObject, "convert Matrix6DList into (copied) list of 6x6 numpy arrays")
        .def("__len__", [](const PyMatrix6DList &item) {
            return item.NumberOfItems(); }, "return length of the Matrix6DList, using len(data) where data is the Matrix6DList")
        .def("__setitem__", [](PyMatrix6DList &item, Index index, const py::object& matrix) {
            item.PySetItem(index, matrix); }, "set list item 'index' with matrix, write: data[index] = ...")
        .def("__getitem__", [](const PyMatrix6DList &item, Index index) {
            return item.PyGetItem(index); }, "get copy of list item with 'index' as matrix")
        .def("__repr__", [](const PyMatrix6DList &item) {
            return EXUstd::ToString(item.GetPythonObject()); }, "return the string representation of the Matrix6DList data, e.g.: print(data)")
        ; // end of PyMatrix6DList pybind definitions

