// AUTO:  ++++++++++++++++++++++
// AUTO:  pybind11 module includes; generated by Johannes Gerstmayr
// AUTO:  last modified = 2024-04-01
// AUTO:  ++++++++++++++++++++++

    //++++++++++++++++++++++++++++++++
    py::class_<PyBeamSection>(m, "BeamSection", "BeamSection class") // AUTO: 
        .def(py::init<>())
        .def_property("dampingMatrix", &PyBeamSection::PyGetDampingMatrix, &PyBeamSection::PySetDampingMatrix)
        .def_property("inertia", &PyBeamSection::PyGetInertia, &PyBeamSection::PySetInertia)
        .def_property("massPerLength", &PyBeamSection::PyGetMassPerLength, &PyBeamSection::PySetMassPerLength)
        .def_property("stiffnessMatrix", &PyBeamSection::PyGetStiffnessMatrix, &PyBeamSection::PySetStiffnessMatrix)
        // AUTO: access functions for PyBeamSection
        .def("__repr__", [](const PyBeamSection &item) { return "<PyBeamSection:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const PyBeamSection &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](PyBeamSection &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const PyBeamSection& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "PyBeamSection: loading data with pickle received invalid data structure!");
                PyBeamSection self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<BeamSectionGeometry>(m, "BeamSectionGeometry", "BeamSectionGeometry class") // AUTO: 
        .def(py::init<>())
        .def_property("crossSectionRadiusY", &BeamSectionGeometry::PyGetCrossSectionRadiusY, &BeamSectionGeometry::PySetCrossSectionRadiusY)
        .def_property("crossSectionRadiusZ", &BeamSectionGeometry::PyGetCrossSectionRadiusZ, &BeamSectionGeometry::PySetCrossSectionRadiusZ)
        .def_readwrite("crossSectionType", &BeamSectionGeometry::crossSectionType, "Type of cross section: Polygon, Circular, etc.")
        .def_property("polygonalPoints", &BeamSectionGeometry::PyGetPolygonalPoints, &BeamSectionGeometry::PySetPolygonalPoints)
        // AUTO: access functions for BeamSectionGeometry
        .def("__repr__", [](const BeamSectionGeometry &item) { return "<BeamSectionGeometry:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const BeamSectionGeometry &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](BeamSectionGeometry &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const BeamSectionGeometry& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "BeamSectionGeometry: loading data with pickle received invalid data structure!");
                BeamSectionGeometry self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolutionSettings>(m, "SolutionSettings", "SolutionSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("appendToFile", &SolutionSettings::appendToFile, "flag (true/false); if true, solution and solverInformation is appended to existing file (otherwise created); in BINARY mode, files are always replaced and this parameter is ineffective!")
        .def_readwrite("binarySolutionFile", &SolutionSettings::binarySolutionFile, "if true, the solution file is written in binary format for improved speed and smaller file sizes; setting outputPrecision >= 8 uses double (8 bytes), otherwise float (4 bytes) is used; note that appendToFile is ineffective and files are always replaced without asking! If not provided, file ending will read .sol in case of binary files and .txt in case of text files")
        .def_readwrite("coordinatesSolutionFileName", &SolutionSettings::coordinatesSolutionFileName, "filename and (relative) path of solution file (coordinatesSolutionFile) containing all multibody system coordinates versus time; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '_' only; filename ending will be added automatically if not provided: .txt in case of text mode and .sol in case of binary solution files (binarySolutionFile=True)")
        .def_readwrite("exportAccelerations", &SolutionSettings::exportAccelerations, "add ODE2 accelerations to solution file (coordinatesSolutionFile)")
        .def_readwrite("exportAlgebraicCoordinates", &SolutionSettings::exportAlgebraicCoordinates, "add algebraicCoordinates (=Lagrange multipliers) to solution file (coordinatesSolutionFile)")
        .def_readwrite("exportDataCoordinates", &SolutionSettings::exportDataCoordinates, "add DataCoordinates to solution file (coordinatesSolutionFile)")
        .def_readwrite("exportODE1Velocities", &SolutionSettings::exportODE1Velocities, "add coordinatesODE1_t to solution file (coordinatesSolutionFile)")
        .def_readwrite("exportVelocities", &SolutionSettings::exportVelocities, "add ODE2 velocities to solution file (coordinatesSolutionFile)")
        .def_property("flushFilesDOF", &SolutionSettings::PyGetFlushFilesDOF, &SolutionSettings::PySetFlushFilesDOF)
        .def_readwrite("flushFilesImmediately", &SolutionSettings::flushFilesImmediately, "flush file buffers after every solution period written (coordinatesSolutionFile and sensor files); if set False, the output is written through a buffer, which is highly efficient, but during simulation, files may be always in an incomplete state; if set True, this may add a large amount of CPU time as the process waits until files are really written to hard disc (especially for simulation of small scale systems, writing 10.000s of time steps; at least 5us per step/file, depending on hardware)")
        .def_property("outputPrecision", &SolutionSettings::PyGetOutputPrecision, &SolutionSettings::PySetOutputPrecision)
        .def_readwrite("recordImagesInterval", &SolutionSettings::recordImagesInterval, "record frames (images) during solving: amount of time to wait until next image (frame) is recorded; set recordImages = -1. if no images shall be recorded; set, e.g., recordImages = 0.01 to record an image every 10 milliseconds (requires that the time steps / load steps are sufficiently small!); for file names, etc., see VisualizationSettings.exportImages")
        .def_readwrite("restartFileName", &SolutionSettings::restartFileName, "filename and (relative) path of text file for storing solution after every restartWritePeriod if writeRestartFile=True; backup file is created with ending .bck, which should be used if restart file is crashed; use Python utility function InitializeFromRestartFile(...) to consistently restart")
        .def_property("restartWritePeriod", &SolutionSettings::PyGetRestartWritePeriod, &SolutionSettings::PySetRestartWritePeriod)
        .def_readwrite("sensorsAppendToFile", &SolutionSettings::sensorsAppendToFile, "flag (true/false); if true, sensor output is appended to existing file (otherwise created) or in case of internal storage, it is appended to existing currently stored data; this allows storing sensor values over different simulations")
        .def_readwrite("sensorsStoreAndWriteFiles", &SolutionSettings::sensorsStoreAndWriteFiles, "flag (true/false); if false, no sensor files will be created and no sensor data will be stored; this may be advantageous for benchmarking as well as for special solvers which should not overwrite existing results (e.g. ComputeODE2Eigenvalues); settings this value to False may cause problems if sensors are required to perform operations which are needed e.g. in UserSensors as input of loads, etc.")
        .def_readwrite("sensorsWriteFileFooter", &SolutionSettings::sensorsWriteFileFooter, "flag (true/false); if true, file footer is written for sensor output (turn off, e.g. for multiple runs of time integration)")
        .def_readwrite("sensorsWriteFileHeader", &SolutionSettings::sensorsWriteFileHeader, "flag (true/false); if true, file header is written for sensor output (turn off, e.g. for multiple runs of time integration)")
        .def_property("sensorsWritePeriod", &SolutionSettings::PyGetSensorsWritePeriod, &SolutionSettings::PySetSensorsWritePeriod)
        .def_readwrite("solutionInformation", &SolutionSettings::solutionInformation, "special information added to header of solution file (e.g. parameters and settings, modes, ...); character encoding my be UTF-8, restricted to characters in refSection{sec:utf8}, but for compatibility, it is recommended to use ASCII characters only (95 characters, see wiki)")
        .def_property("solutionWritePeriod", &SolutionSettings::PyGetSolutionWritePeriod, &SolutionSettings::PySetSolutionWritePeriod)
        .def_readwrite("solverInformationFileName", &SolutionSettings::solverInformationFileName, "filename and (relative) path of text file showing detailed information during solving; detail level according to yourSolver.verboseModeFile; if solutionSettings.appendToFile is true, the information is appended in every solution step; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '_' only")
        .def_readwrite("writeFileFooter", &SolutionSettings::writeFileFooter, "flag (true/false); if true, information at end of simulation is written: convergence, total solution time, statistics")
        .def_readwrite("writeFileHeader", &SolutionSettings::writeFileHeader, "flag (true/false); if true, file header is written (turn off, e.g. for multiple runs of time integration)")
        .def_readwrite("writeInitialValues", &SolutionSettings::writeInitialValues, "flag (true/false); if true, initial values are exported for the start time; applies to coordinatesSolution and sensor files; this may not be wanted in the append file mode if the initial values are identical to the final values of a previous computation")
        .def_readwrite("writeRestartFile", &SolutionSettings::writeRestartFile, "flag (true/false), which determines if restart file is written regularly, see restartFileName for details")
        .def_readwrite("writeSolutionToFile", &SolutionSettings::writeSolutionToFile, "flag (true/false), which determines if (global) solution vector is written to the solution file (coordinatesSolutionFile); standard quantities that are written are: solution is written as displacements and coordinatesODE1; for additional coordinates in the solution file, see the options below")
        // AUTO: access functions for SolutionSettings
        .def("__repr__", [](const SolutionSettings &item) { return "<SolutionSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const SolutionSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](SolutionSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const SolutionSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "SolutionSettings: loading data with pickle received invalid data structure!");
                SolutionSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<NumericalDifferentiationSettings>(m, "NumericalDifferentiationSettings", "NumericalDifferentiationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("addReferenceCoordinatesToEpsilon", &NumericalDifferentiationSettings::addReferenceCoordinatesToEpsilon, "True: for the size estimation of the differentiation parameter, the reference coordinate $q^{Ref}_i$ is added to ODE2 coordinates --> see; False: only the current coordinate is used for size estimation of the differentiation parameter")
        .def_readwrite("doSystemWideDifferentiation", &NumericalDifferentiationSettings::doSystemWideDifferentiation, "True: system wide differentiation (e.g. all ODE2 equations w.r.t. all ODE2 coordinates); False: only local (object) differentiation")
        .def_readwrite("forAE", &NumericalDifferentiationSettings::forAE, "flag (true/false); false = perform direct computation of jacobian for algebraic equations (AE), true = use numerical differentiation; as there must always exist an analytical implemented jacobian for AE, 'true' should only be used for verification")
        .def_readwrite("forODE2", &NumericalDifferentiationSettings::forODE2, "flag (true/false); false = perform direct computation (e.g., using autodiff) of jacobian for ODE2 equations, true = use numerical differentiation; numerical differentiation is less efficient and may lead to numerical problems, but may smoothen problems of analytical derivatives; sometimes the analytical derivative may neglect terms")
        .def_readwrite("forODE2connectors", &NumericalDifferentiationSettings::forODE2connectors, "flag (true/false); false: if also forODE2==false, perform direct computation of jacobian for ODE2 terms for connectors; else: use numerical differentiation; NOTE: THIS FLAG IS FOR DEVELOPMENT AND WILL BE ERASED IN FUTURE")
        .def_readwrite("jacobianConnectorDerivative", &NumericalDifferentiationSettings::jacobianConnectorDerivative, "True: for analytic Jacobians of connectors, the Jacobian derivative is computed, causing additional CPU costs and not beeing available for all connectors or markers (thus switching to numerical differentiation); False: Jacobian derivative is neglected in analytic Jacobians (but included in numerical Jacobians), which often has only minor influence on convergence")
        .def_property("minimumCoordinateSize", &NumericalDifferentiationSettings::PyGetMinimumCoordinateSize, &NumericalDifferentiationSettings::PySetMinimumCoordinateSize)
        .def_property("relativeEpsilon", &NumericalDifferentiationSettings::PyGetRelativeEpsilon, &NumericalDifferentiationSettings::PySetRelativeEpsilon)
        // AUTO: access functions for NumericalDifferentiationSettings
        .def("__repr__", [](const NumericalDifferentiationSettings &item) { return "<NumericalDifferentiationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const NumericalDifferentiationSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](NumericalDifferentiationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const NumericalDifferentiationSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "NumericalDifferentiationSettings: loading data with pickle received invalid data structure!");
                NumericalDifferentiationSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<DiscontinuousSettings>(m, "DiscontinuousSettings", "DiscontinuousSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("ignoreMaxIterations", &DiscontinuousSettings::ignoreMaxIterations, "continue solver if maximum number of discontinuous (post Newton) iterations is reached (ignore tolerance)")
        .def_property("iterationTolerance", &DiscontinuousSettings::PyGetIterationTolerance, &DiscontinuousSettings::PySetIterationTolerance)
        .def_property("maxIterations", &DiscontinuousSettings::PyGetMaxIterations, &DiscontinuousSettings::PySetMaxIterations)
        // AUTO: access functions for DiscontinuousSettings
        .def("__repr__", [](const DiscontinuousSettings &item) { return "<DiscontinuousSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const DiscontinuousSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](DiscontinuousSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const DiscontinuousSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "DiscontinuousSettings: loading data with pickle received invalid data structure!");
                DiscontinuousSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<NewtonSettings>(m, "NewtonSettings", "NewtonSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("numericalDifferentiation", &NewtonSettings::numericalDifferentiation, "numerical differentiation parameters for numerical jacobian (e.g. Newton in static solver or implicit time integration)")
        .def_property("absoluteTolerance", &NewtonSettings::PyGetAbsoluteTolerance, &NewtonSettings::PySetAbsoluteTolerance)
        .def_readwrite("adaptInitialResidual", &NewtonSettings::adaptInitialResidual, "flag (true/false); false = standard; True: if initialResidual is very small (or zero), it may increase significantely in the first Newton iteration; to achieve relativeTolerance, the initialResidual will by updated by a higher residual within the first Newton iteration")
        .def_property("maximumSolutionNorm", &NewtonSettings::PyGetMaximumSolutionNorm, &NewtonSettings::PySetMaximumSolutionNorm)
        .def_property("maxIterations", &NewtonSettings::PyGetMaxIterations, &NewtonSettings::PySetMaxIterations)
        .def_property("maxModifiedNewtonIterations", &NewtonSettings::PyGetMaxModifiedNewtonIterations, &NewtonSettings::PySetMaxModifiedNewtonIterations)
        .def_property("maxModifiedNewtonRestartIterations", &NewtonSettings::PyGetMaxModifiedNewtonRestartIterations, &NewtonSettings::PySetMaxModifiedNewtonRestartIterations)
        .def_property("modifiedNewtonContractivity", &NewtonSettings::PyGetModifiedNewtonContractivity, &NewtonSettings::PySetModifiedNewtonContractivity)
        .def_readwrite("modifiedNewtonJacUpdatePerStep", &NewtonSettings::modifiedNewtonJacUpdatePerStep, "True: compute Jacobian at every time step (or static step), but not in every Newton iteration (except for bad convergence ==> switch to full Newton)")
        .def_property("newtonResidualMode", &NewtonSettings::PyGetNewtonResidualMode, &NewtonSettings::PySetNewtonResidualMode)
        .def_property("relativeTolerance", &NewtonSettings::PyGetRelativeTolerance, &NewtonSettings::PySetRelativeTolerance)
        .def_readwrite("useModifiedNewton", &NewtonSettings::useModifiedNewton, "True: compute Jacobian only at first call to solver; the Jacobian (and its factorizations) is not computed in each Newton iteration, even not in every (time integration) step; False: Jacobian (and factorization) is computed in every Newton iteration (default, but may be costly)")
        .def_readwrite("useNewtonSolver", &NewtonSettings::useNewtonSolver, "flag (true/false); false = linear computation, true = use Newton solver for nonlinear solution")
        .def_readwrite("weightTolerancePerCoordinate", &NewtonSettings::weightTolerancePerCoordinate, "flag (true/false); false = compute error as L2-Norm of residual; true = compute error as (L2-Norm of residual) / (sqrt(number of coordinates)), which can help to use common tolerance independent of system size")
        // AUTO: access functions for NewtonSettings
        .def("__repr__", [](const NewtonSettings &item) { return "<NewtonSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const NewtonSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](NewtonSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const NewtonSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "NewtonSettings: loading data with pickle received invalid data structure!");
                NewtonSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<GeneralizedAlphaSettings>(m, "GeneralizedAlphaSettings", "GeneralizedAlphaSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("computeInitialAccelerations", &GeneralizedAlphaSettings::computeInitialAccelerations, "True: compute initial accelerations from system EOM in acceleration form; NOTE that initial accelerations that are following from user functions in constraints are not considered for now! False: use zero accelerations")
        .def_readwrite("lieGroupAddTangentOperator", &GeneralizedAlphaSettings::lieGroupAddTangentOperator, "True: for Lie group nodes, the integrator adds the tangent operator for stiffness and constraint matrices, for improved Newton convergence; not available for sparse matrix mode (EigenSparse)")
        .def_property("newmarkBeta", &GeneralizedAlphaSettings::PyGetNewmarkBeta, &GeneralizedAlphaSettings::PySetNewmarkBeta)
        .def_property("newmarkGamma", &GeneralizedAlphaSettings::PyGetNewmarkGamma, &GeneralizedAlphaSettings::PySetNewmarkGamma)
        .def_readwrite("resetAccelerations", &GeneralizedAlphaSettings::resetAccelerations, "this flag only affects if computeInitialAccelerations=False: if resetAccelerations=True, accelerations are set zero in the solver function InitializeSolverInitialConditions; this may be unwanted in case of repeatedly called SolveSteps() and in cases where solutions shall be prolonged from previous computations")
        .def_property("spectralRadius", &GeneralizedAlphaSettings::PyGetSpectralRadius, &GeneralizedAlphaSettings::PySetSpectralRadius)
        .def_readwrite("useIndex2Constraints", &GeneralizedAlphaSettings::useIndex2Constraints, "set useIndex2Constraints = true in order to use index2 (velocity level constraints) formulation")
        .def_readwrite("useNewmark", &GeneralizedAlphaSettings::useNewmark, "if true, use Newmark method with beta and gamma instead of generalized-Alpha")
        // AUTO: access functions for GeneralizedAlphaSettings
        .def("__repr__", [](const GeneralizedAlphaSettings &item) { return "<GeneralizedAlphaSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const GeneralizedAlphaSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](GeneralizedAlphaSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const GeneralizedAlphaSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "GeneralizedAlphaSettings: loading data with pickle received invalid data structure!");
                GeneralizedAlphaSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<ExplicitIntegrationSettings>(m, "ExplicitIntegrationSettings", "ExplicitIntegrationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("computeEndOfStepAccelerations", &ExplicitIntegrationSettings::computeEndOfStepAccelerations, "accelerations are computed at stages of the explicit integration scheme; if the user needs accelerations at the end of a step, this flag needs to be activated; if True, this causes a second call to the RHS of the equations, which may DOUBLE COMPUTATIONAL COSTS for one-step-methods; if False, the accelerations are re-used from the last stage, being slightly different")
        .def_readwrite("computeMassMatrixInversePerBody", &ExplicitIntegrationSettings::computeMassMatrixInversePerBody, "If true, the solver assumes the bodies to be independent and computes the inverse of the mass matrix for all bodies independently; this may lead to WRONG RESULTS, if bodies share nodes, e.g., two MassPoint objects put on the same node or a beam with a mass point attached at a shared node; however, it may speed up explicit time integration for large systems significantly (multi-threaded)")
        .def_readwrite("dynamicSolverType", &ExplicitIntegrationSettings::dynamicSolverType, "selection of explicit solver type (DOPRI5, ExplicitEuler, ExplicitMidpoint, RK44, RK67, ...), for detailed description see DynamicSolverType, refSection{sec:DynamicSolverType}, but only referring to explicit solvers.")
        .def_readwrite("eliminateConstraints", &ExplicitIntegrationSettings::eliminateConstraints, "True: make explicit solver work for simple CoordinateConstraints, which are eliminated for ground constraints (e.g. fixed nodes in finite element models). False: incompatible constraints are ignored (BE CAREFUL)!")
        .def_readwrite("useLieGroupIntegration", &ExplicitIntegrationSettings::useLieGroupIntegration, "True: use Lie group integration for rigid body nodes; must be turned on for Lie group nodes (without data coordinates) to work properly; does not work for nodes with data coordinates!")
        // AUTO: access functions for ExplicitIntegrationSettings
        .def("__repr__", [](const ExplicitIntegrationSettings &item) { return "<ExplicitIntegrationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const ExplicitIntegrationSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](ExplicitIntegrationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const ExplicitIntegrationSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "ExplicitIntegrationSettings: loading data with pickle received invalid data structure!");
                ExplicitIntegrationSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<TimeIntegrationSettings>(m, "TimeIntegrationSettings", "TimeIntegrationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("discontinuous", &TimeIntegrationSettings::discontinuous, "parameters for treatment of discontinuities")
        .def_readwrite("explicitIntegration", &TimeIntegrationSettings::explicitIntegration, "special parameters for explicit time integration")
        .def_readwrite("generalizedAlpha", &TimeIntegrationSettings::generalizedAlpha, "parameters for generalized-alpha, implicit trapezoidal rule or Newmark (options only apply for these methods)")
        .def_readwrite("newton", &TimeIntegrationSettings::newton, "parameters for Newton method; used for implicit time integration methods only")
        .def_property("absoluteTolerance", &TimeIntegrationSettings::PyGetAbsoluteTolerance, &TimeIntegrationSettings::PySetAbsoluteTolerance)
        .def_readwrite("adaptiveStep", &TimeIntegrationSettings::adaptiveStep, "True: the step size may be reduced if step fails; no automatic stepsize control")
        .def_property("adaptiveStepDecrease", &TimeIntegrationSettings::PyGetAdaptiveStepDecrease, &TimeIntegrationSettings::PySetAdaptiveStepDecrease)
        .def_property("adaptiveStepIncrease", &TimeIntegrationSettings::PyGetAdaptiveStepIncrease, &TimeIntegrationSettings::PySetAdaptiveStepIncrease)
        .def_property("adaptiveStepRecoveryIterations", &TimeIntegrationSettings::PyGetAdaptiveStepRecoveryIterations, &TimeIntegrationSettings::PySetAdaptiveStepRecoveryIterations)
        .def_property("adaptiveStepRecoverySteps", &TimeIntegrationSettings::PyGetAdaptiveStepRecoverySteps, &TimeIntegrationSettings::PySetAdaptiveStepRecoverySteps)
        .def_readwrite("automaticStepSize", &TimeIntegrationSettings::automaticStepSize, "True: for specific integrators with error control (e.g., DOPRI5), compute automatic step size based on error estimation; False: constant step size (step may be reduced if adaptiveStep=True); the maximum stepSize reads $h = h_{max} = frac{t_{end} - t_{start}}{n_{steps}}$")
        .def_property("computeLoadsJacobian", &TimeIntegrationSettings::PyGetComputeLoadsJacobian, &TimeIntegrationSettings::PySetComputeLoadsJacobian)
        .def_property("endTime", &TimeIntegrationSettings::PyGetEndTime, &TimeIntegrationSettings::PySetEndTime)
        .def_property("initialStepSize", &TimeIntegrationSettings::PyGetInitialStepSize, &TimeIntegrationSettings::PySetInitialStepSize)
        .def_property("minimumStepSize", &TimeIntegrationSettings::PyGetMinimumStepSize, &TimeIntegrationSettings::PySetMinimumStepSize)
        .def_property("numberOfSteps", &TimeIntegrationSettings::PyGetNumberOfSteps, &TimeIntegrationSettings::PySetNumberOfSteps)
        .def_property("realtimeFactor", &TimeIntegrationSettings::PyGetRealtimeFactor, &TimeIntegrationSettings::PySetRealtimeFactor)
        .def_property("realtimeWaitMicroseconds", &TimeIntegrationSettings::PyGetRealtimeWaitMicroseconds, &TimeIntegrationSettings::PySetRealtimeWaitMicroseconds)
        .def_property("relativeTolerance", &TimeIntegrationSettings::PyGetRelativeTolerance, &TimeIntegrationSettings::PySetRelativeTolerance)
        .def_readwrite("reuseConstantMassMatrix", &TimeIntegrationSettings::reuseConstantMassMatrix, "True: does not recompute constant mass matrices (e.g. of some finite elements, mass points, etc.); if False, it always recomputes the mass matrix (e.g. needed, if user changes mass parameters via Python)")
        .def_readwrite("simulateInRealtime", &TimeIntegrationSettings::simulateInRealtime, "True: simulate in realtime; the solver waits for computation of the next step until the CPU time reached the simulation time; if the simulation is slower than realtime, it simply continues")
        .def_property("startTime", &TimeIntegrationSettings::PyGetStartTime, &TimeIntegrationSettings::PySetStartTime)
        .def_property("stepInformation", &TimeIntegrationSettings::PyGetStepInformation, &TimeIntegrationSettings::PySetStepInformation)
        .def_property("stepSizeMaxIncrease", &TimeIntegrationSettings::PyGetStepSizeMaxIncrease, &TimeIntegrationSettings::PySetStepSizeMaxIncrease)
        .def_property("stepSizeSafety", &TimeIntegrationSettings::PyGetStepSizeSafety, &TimeIntegrationSettings::PySetStepSizeSafety)
        .def_property("verboseMode", &TimeIntegrationSettings::PyGetVerboseMode, &TimeIntegrationSettings::PySetVerboseMode)
        .def_property("verboseModeFile", &TimeIntegrationSettings::PyGetVerboseModeFile, &TimeIntegrationSettings::PySetVerboseModeFile)
        // AUTO: access functions for TimeIntegrationSettings
        .def("__repr__", [](const TimeIntegrationSettings &item) { return "<TimeIntegrationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const TimeIntegrationSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](TimeIntegrationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const TimeIntegrationSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "TimeIntegrationSettings: loading data with pickle received invalid data structure!");
                TimeIntegrationSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<StaticSolverSettings>(m, "StaticSolverSettings", "StaticSolverSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("discontinuous", &StaticSolverSettings::discontinuous, "parameters for treatment of discontinuities")
        .def_readwrite("newton", &StaticSolverSettings::newton, "parameters for Newton method (e.g. in static solver or time integration)")
        .def_readwrite("adaptiveStep", &StaticSolverSettings::adaptiveStep, "True: use step reduction if step fails; False: fixed step size")
        .def_property("adaptiveStepDecrease", &StaticSolverSettings::PyGetAdaptiveStepDecrease, &StaticSolverSettings::PySetAdaptiveStepDecrease)
        .def_property("adaptiveStepIncrease", &StaticSolverSettings::PyGetAdaptiveStepIncrease, &StaticSolverSettings::PySetAdaptiveStepIncrease)
        .def_property("adaptiveStepRecoveryIterations", &StaticSolverSettings::PyGetAdaptiveStepRecoveryIterations, &StaticSolverSettings::PySetAdaptiveStepRecoveryIterations)
        .def_property("adaptiveStepRecoverySteps", &StaticSolverSettings::PyGetAdaptiveStepRecoverySteps, &StaticSolverSettings::PySetAdaptiveStepRecoverySteps)
        .def_readwrite("computeLoadsJacobian", &StaticSolverSettings::computeLoadsJacobian, "True: compute (currently numerical) Jacobian for loads, causing additional computational costs; this is advantageous in cases where loads are related nonlinearly to coordinates; False: jacobian of loads not considered (may lead to slow convergence or Newton failure); note that computeLoadsJacobian has no effect in case of doSystemWideDifferentiation, as this anyway includes all load dependencies")
        .def_readwrite("constrainODE1coordinates", &StaticSolverSettings::constrainODE1coordinates, "True: ODE1coordinates are constrained to initial values; False: undefined behavior, currently not supported")
        .def_property("loadStepDuration", &StaticSolverSettings::PyGetLoadStepDuration, &StaticSolverSettings::PySetLoadStepDuration)
        .def_readwrite("loadStepGeometric", &StaticSolverSettings::loadStepGeometric, "if loadStepGeometric=false, the load steps are incremental (arithmetic series, e.g. 0.1,0.2,0.3,...); if true, the load steps are increased in a geometric series, e.g. for $n=8$ numberOfLoadSteps and $d = 1000$ loadStepGeometricRange, it follows: $1000^{1/8}/1000=0.00237$, $1000^{2/8}/1000=0.00562$, $1000^{3/8}/1000=0.0133$, ..., $1000^{7/8}/1000=0.422$, $1000^{8/8}/1000=1$")
        .def_property("loadStepGeometricRange", &StaticSolverSettings::PyGetLoadStepGeometricRange, &StaticSolverSettings::PySetLoadStepGeometricRange)
        .def_property("loadStepStart", &StaticSolverSettings::PyGetLoadStepStart, &StaticSolverSettings::PySetLoadStepStart)
        .def_property("minimumStepSize", &StaticSolverSettings::PyGetMinimumStepSize, &StaticSolverSettings::PySetMinimumStepSize)
        .def_property("numberOfLoadSteps", &StaticSolverSettings::PyGetNumberOfLoadSteps, &StaticSolverSettings::PySetNumberOfLoadSteps)
        .def_property("stabilizerODE2term", &StaticSolverSettings::PyGetStabilizerODE2term, &StaticSolverSettings::PySetStabilizerODE2term)
        .def_property("stepInformation", &StaticSolverSettings::PyGetStepInformation, &StaticSolverSettings::PySetStepInformation)
        .def_readwrite("useLoadFactor", &StaticSolverSettings::useLoadFactor, "True: compute a load factor $in [0,1]$ from static step time; all loads are scaled by the load factor; False: loads are always scaled with 1 -- use this option if time dependent loads use a userFunction")
        .def_property("verboseMode", &StaticSolverSettings::PyGetVerboseMode, &StaticSolverSettings::PySetVerboseMode)
        .def_property("verboseModeFile", &StaticSolverSettings::PyGetVerboseModeFile, &StaticSolverSettings::PySetVerboseModeFile)
        // AUTO: access functions for StaticSolverSettings
        .def("__repr__", [](const StaticSolverSettings &item) { return "<StaticSolverSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const StaticSolverSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](StaticSolverSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const StaticSolverSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "StaticSolverSettings: loading data with pickle received invalid data structure!");
                StaticSolverSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<LinearSolverSettings>(m, "LinearSolverSettings", "LinearSolverSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("ignoreSingularJacobian", &LinearSolverSettings::ignoreSingularJacobian, "[ONLY implemented for dense, Eigen matrix mode] False: standard way, fails if jacobian is singular; True: use Eigen's FullPivLU (thus only works with LinearSolverType.EigenDense) which handles over- and underdetermined systems; can often resolve redundant constraints, but MAY ALSO LEAD TO ERRONEOUS RESULTS!")
        .def_property("pivotThreshold", &LinearSolverSettings::PyGetPivotThreshold, &LinearSolverSettings::PySetPivotThreshold)
        .def_readwrite("reuseAnalyzedPattern", &LinearSolverSettings::reuseAnalyzedPattern, "[ONLY available for sparse matrices] True: the Eigen SparseLU solver offers the possibility to reuse an analyzed pattern of a previous factorization; this may reduce total factorization time by a factor of 2 or 3, depending on the matrix type; however, if the matrix patterns heavily change between computations, this may even slow down performance; this flag is set for SparseMatrices in InitializeSolverData(...) and should be handled with care!")
        .def_readwrite("showCausingItems", &LinearSolverSettings::showCausingItems, "False: no output, if solver fails; True: if redundant equations appear, they are resolved such that according solution variables are set to zero; in case of redundant constraints, this may help, but it may lead to erroneous behaviour; for static problems, this may suppress static motion or resolve problems in case of instabilities, but should in general be considered with care!")
        // AUTO: access functions for LinearSolverSettings
        .def("__repr__", [](const LinearSolverSettings &item) { return "<LinearSolverSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const LinearSolverSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](LinearSolverSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const LinearSolverSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "LinearSolverSettings: loading data with pickle received invalid data structure!");
                LinearSolverSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<Parallel>(m, "Parallel", "Parallel class") // AUTO: 
        .def(py::init<>())
        .def_property("multithreadedLLimitJacobians", &Parallel::PyGetMultithreadedLLimitJacobians, &Parallel::PySetMultithreadedLLimitJacobians)
        .def_property("multithreadedLLimitLoads", &Parallel::PyGetMultithreadedLLimitLoads, &Parallel::PySetMultithreadedLLimitLoads)
        .def_property("multithreadedLLimitMassMatrices", &Parallel::PyGetMultithreadedLLimitMassMatrices, &Parallel::PySetMultithreadedLLimitMassMatrices)
        .def_property("multithreadedLLimitResiduals", &Parallel::PyGetMultithreadedLLimitResiduals, &Parallel::PySetMultithreadedLLimitResiduals)
        .def_property("numberOfThreads", &Parallel::PyGetNumberOfThreads, &Parallel::PySetNumberOfThreads)
        .def_property("taskSplitMinItems", &Parallel::PyGetTaskSplitMinItems, &Parallel::PySetTaskSplitMinItems)
        .def_property("taskSplitTasksPerThread", &Parallel::PyGetTaskSplitTasksPerThread, &Parallel::PySetTaskSplitTasksPerThread)
        // AUTO: access functions for Parallel
        .def("__repr__", [](const Parallel &item) { return "<Parallel:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const Parallel &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](Parallel &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const Parallel& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "Parallel: loading data with pickle received invalid data structure!");
                Parallel self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SimulationSettings>(m, "SimulationSettings", "SimulationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("linearSolverSettings", &SimulationSettings::linearSolverSettings, "linear solver parameters (used for dense and sparse solvers)")
        .def_readwrite("parallel", &SimulationSettings::parallel, "parameters for vectorized and parallelized (multi-threaded) computations")
        .def_readwrite("solutionSettings", &SimulationSettings::solutionSettings, "settings for solution files")
        .def_readwrite("staticSolver", &SimulationSettings::staticSolver, "static solver parameters")
        .def_readwrite("timeIntegration", &SimulationSettings::timeIntegration, "time integration parameters")
        .def_readwrite("cleanUpMemory", &SimulationSettings::cleanUpMemory, "True: solvers will free memory at exit (recommended for large systems); False: keep allocated memory for repeated computations to increase performance")
        .def_readwrite("displayComputationTime", &SimulationSettings::displayComputationTime, "display computation time statistics at end of solving")
        .def_readwrite("displayGlobalTimers", &SimulationSettings::displayGlobalTimers, "display global timer statistics at end of solving (e.g., for contact, but also for internal timings during development)")
        .def_readwrite("displayStatistics", &SimulationSettings::displayStatistics, "display general computation information at end of time step (steps, iterations, function calls, step rejections, ...")
        .def_readwrite("linearSolverType", &SimulationSettings::linearSolverType, "selection of numerical linear solver: exu.LinearSolverType.EXUdense (dense matrix inverse), exu.LinearSolverType.EigenSparse (sparse matrix LU-factorization), ... (enumeration type)")
        .def_property("outputPrecision", &SimulationSettings::PyGetOutputPrecision, &SimulationSettings::PySetOutputPrecision)
        .def_readwrite("pauseAfterEachStep", &SimulationSettings::pauseAfterEachStep, "pause after every time step or static load step(user press SPACE)")
        // AUTO: access functions for SimulationSettings
        .def("__repr__", [](const SimulationSettings &item) { return "<SimulationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionaryWithTypeInfo", [](const SimulationSettings &item) { return EPyUtils::GetDictionaryWithTypeInfo(item); }) //!< AUTO: add read as dictionary with type information access
        .def("GetDictionary", [](const SimulationSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](SimulationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const SimulationSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "SimulationSettings: loading data with pickle received invalid data structure!");
                SimulationSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsGeneral>(m, "VSettingsGeneral", "VSettingsGeneral class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("autoFitScene", &VSettingsGeneral::autoFitScene, "automatically fit scene within startup after StartRenderer()")
        .def_property("axesTiling", &VSettingsGeneral::PyGetAxesTiling, &VSettingsGeneral::PySetAxesTiling)
        .def_property("backgroundColor", &VSettingsGeneral::PyGetBackgroundColor, &VSettingsGeneral::PySetBackgroundColor)
        .def_property("backgroundColorBottom", &VSettingsGeneral::PyGetBackgroundColorBottom, &VSettingsGeneral::PySetBackgroundColorBottom)
        .def_property("circleTiling", &VSettingsGeneral::PyGetCircleTiling, &VSettingsGeneral::PySetCircleTiling)
        .def_readwrite("coordinateSystemSize", &VSettingsGeneral::coordinateSystemSize, "size of coordinate system relative to font size")
        .def_property("cylinderTiling", &VSettingsGeneral::PyGetCylinderTiling, &VSettingsGeneral::PySetCylinderTiling)
        .def_readwrite("drawCoordinateSystem", &VSettingsGeneral::drawCoordinateSystem, "false = no coordinate system shown")
        .def_readwrite("drawWorldBasis", &VSettingsGeneral::drawWorldBasis, "true = draw world basis coordinate system at (0,0,0)")
        .def_readwrite("graphicsUpdateInterval", &VSettingsGeneral::graphicsUpdateInterval, "interval of graphics update during simulation in seconds; 0.1 = 10 frames per second; low numbers might slow down computation speed")
        .def_property("linuxDisplayScaleFactor", &VSettingsGeneral::PyGetLinuxDisplayScaleFactor, &VSettingsGeneral::PySetLinuxDisplayScaleFactor)
        .def_readwrite("minSceneSize", &VSettingsGeneral::minSceneSize, "minimum scene size for initial scene size and for autoFitScene, to avoid division by zero; SET GREATER THAN ZERO")
        .def_readwrite("pointSize", &VSettingsGeneral::pointSize, "global point size (absolute)")
        .def_property("rendererPrecision", &VSettingsGeneral::PyGetRendererPrecision, &VSettingsGeneral::PySetRendererPrecision)
        .def_readwrite("renderWindowString", &VSettingsGeneral::renderWindowString, "string shown in render window (use this, e.g., for debugging, etc.; written below EXUDYN, similar to solutionInformation in SimulationSettings.solutionSettings)")
        .def_readwrite("showComputationInfo", &VSettingsGeneral::showComputationInfo, "true = show (hide) all computation information including Exudyn and version")
        .def_property("showHelpOnStartup", &VSettingsGeneral::PyGetShowHelpOnStartup, &VSettingsGeneral::PySetShowHelpOnStartup)
        .def_readwrite("showSolutionInformation", &VSettingsGeneral::showSolutionInformation, "true = show solution information (from simulationSettings.solution)")
        .def_readwrite("showSolverInformation", &VSettingsGeneral::showSolverInformation, "true = solver name and further information shown in render window")
        .def_readwrite("showSolverTime", &VSettingsGeneral::showSolverTime, "true = solver current time shown in render window")
        .def_property("sphereTiling", &VSettingsGeneral::PyGetSphereTiling, &VSettingsGeneral::PySetSphereTiling)
        .def_readwrite("textAlwaysInFront", &VSettingsGeneral::textAlwaysInFront, "if true, text for item numbers and other item-related text is drawn in front; this may be unwanted in case that you only with to see numbers of objects in front; currently does not work with perspective")
        .def_property("textColor", &VSettingsGeneral::PyGetTextColor, &VSettingsGeneral::PySetTextColor)
        .def_readwrite("textHasBackground", &VSettingsGeneral::textHasBackground, "if true, text for item numbers and other item-related text have a background (depending on text color), allowing for better visibility if many numbers are shown; the text itself is black; therefore, dark background colors are ignored and shown as white")
        .def_property("textOffsetFactor", &VSettingsGeneral::PyGetTextOffsetFactor, &VSettingsGeneral::PySetTextOffsetFactor)
        .def_readwrite("textSize", &VSettingsGeneral::textSize, "general text size (font size) in pixels if not overwritten; if useWindowsDisplayScaleFactor=True, the the textSize is multplied with the windows display scaling (monitor scaling; content scaling) factor for larger texts on on high resolution displays; for bitmap fonts, the maximum size of any font (standard/large/huge) is limited to 256 (which is not recommended, especially if you do not have a powerful graphics card)")
        .def_readwrite("threadSafeGraphicsUpdate", &VSettingsGeneral::threadSafeGraphicsUpdate, "true = updating of visualization is threadsafe, but slower for complicated models; deactivate this to speed up computation, but activate for generation of animations; may be improved in future by adding a safe visualizationUpdate state")
        .def_readwrite("useBitmapText", &VSettingsGeneral::useBitmapText, "if true, texts are displayed using pre-defined bitmaps for the text; may increase the complexity of your scene, e.g., if many (>10000) node numbers shown")
        .def_readwrite("useGradientBackground", &VSettingsGeneral::useGradientBackground, "true = use vertical gradient for background; ")
        .def_readwrite("useMultiThreadedRendering", &VSettingsGeneral::useMultiThreadedRendering, "true = rendering is done in separate thread; false = no separate thread, which may be more stable but has lagging interaction for large models (do not interact with models during simulation); set this parameter before call to exudyn.StartRenderer(); MAC OS: uses always false, because MAC OS does not support multi threaded GLFW")
        .def_readwrite("useWindowsDisplayScaleFactor", &VSettingsGeneral::useWindowsDisplayScaleFactor, "the Windows display scaling (monitor scaling; content scaling) factor is used for increased visibility of texts on high resolution displays; based on GLFW glfwGetWindowContentScale; deactivated on linux compilation as it leads to crashes (adjust textSize manually!)")
        .def_readwrite("worldBasisSize", &VSettingsGeneral::worldBasisSize, "size of world basis coordinate system")
        // AUTO: access functions for VSettingsGeneral
        .def("__repr__", [](const VSettingsGeneral &item) { return "<VSettingsGeneral:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsGeneral &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsGeneral &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsGeneral& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsGeneral: loading data with pickle received invalid data structure!");
                VSettingsGeneral self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsContour>(m, "VSettingsContour", "VSettingsContour class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("automaticRange", &VSettingsContour::automaticRange, "if true, the contour plot value range is chosen automatically to the maximum range")
        .def_property("colorBarPrecision", &VSettingsContour::PyGetColorBarPrecision, &VSettingsContour::PySetColorBarPrecision)
        .def_property("colorBarTiling", &VSettingsContour::PyGetColorBarTiling, &VSettingsContour::PySetColorBarTiling)
        .def_readwrite("maxValue", &VSettingsContour::maxValue, "maximum value for contour plot; set manually, if automaticRange == False")
        .def_readwrite("minValue", &VSettingsContour::minValue, "minimum value for contour plot; set manually, if automaticRange == False")
        .def_readwrite("nodesColored", &VSettingsContour::nodesColored, "if true, the contour color is also applied to nodes (except mesh nodes), otherwise node drawing is not influenced by contour settings")
        .def_readwrite("outputVariable", &VSettingsContour::outputVariable, "selected contour plot output variable type; select OutputVariableType._None to deactivate contour plotting.")
        .def_readwrite("outputVariableComponent", &VSettingsContour::outputVariableComponent, "select the component of the chosen output variable; e.g., for displacements, 3 components are available: 0 == x, 1 == y, 2 == z component; for stresses, 6 components are available, see OutputVariableType description; to draw the norm of a outputVariable, set component to -1; if a certain component is not available by certain objects or nodes, no value is drawn (using default color)")
        .def_readwrite("reduceRange", &VSettingsContour::reduceRange, "if true, the contour plot value range is also reduced; better for static computation; in dynamic computation set this option to false, it can reduce visualization artifacts; you should also set minVal to max(float) and maxVal to min(float)")
        .def_readwrite("rigidBodiesColored", &VSettingsContour::rigidBodiesColored, "if true, the contour color is also applied to triangular faces of rigid bodies and mass points, otherwise the rigid body drawing are not influenced by contour settings; for general rigid bodies (except for ObjectGround), Position, Displacement, DisplacementLocal(=0), Velocity, VelocityLocal, AngularVelocity, and AngularVelocityLocal are available; may slow down visualization!")
        .def_readwrite("showColorBar", &VSettingsContour::showColorBar, "show the colour bar with minimum and maximum values for the contour plot")
        // AUTO: access functions for VSettingsContour
        .def("__repr__", [](const VSettingsContour &item) { return "<VSettingsContour:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsContour &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsContour &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsContour& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsContour: loading data with pickle received invalid data structure!");
                VSettingsContour self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsNodes>(m, "VSettingsNodes", "VSettingsNodes class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("basisSize", &VSettingsNodes::basisSize, "size of basis for nodes")
        .def_property("defaultColor", &VSettingsNodes::PyGetDefaultColor, &VSettingsNodes::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsNodes::defaultSize, "global node size; if -1.f, node size is relative to openGL.initialMaxSceneSize")
        .def_readwrite("drawNodesAsPoint", &VSettingsNodes::drawNodesAsPoint, "simplified/faster drawing of nodes; uses general->pointSize as drawing size; if drawNodesAsPoint==True, the basis of the node will be drawn with lines")
        .def_readwrite("show", &VSettingsNodes::show, "flag to decide, whether the nodes are shown")
        .def_readwrite("showBasis", &VSettingsNodes::showBasis, "show basis (three axes) of coordinate system in 3D nodes")
        .def_property("showNodalSlopes", &VSettingsNodes::PyGetShowNodalSlopes, &VSettingsNodes::PySetShowNodalSlopes)
        .def_readwrite("showNumbers", &VSettingsNodes::showNumbers, "flag to decide, whether the node number is shown")
        .def_property("tiling", &VSettingsNodes::PyGetTiling, &VSettingsNodes::PySetTiling)
        // AUTO: access functions for VSettingsNodes
        .def("__repr__", [](const VSettingsNodes &item) { return "<VSettingsNodes:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsNodes &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsNodes &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsNodes& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsNodes: loading data with pickle received invalid data structure!");
                VSettingsNodes self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsBeams>(m, "VSettingsBeams", "VSettingsBeams class") // AUTO: 
        .def(py::init<>())
        .def_property("axialTiling", &VSettingsBeams::PyGetAxialTiling, &VSettingsBeams::PySetAxialTiling)
        .def_readwrite("crossSectionFilled", &VSettingsBeams::crossSectionFilled, "if implemented for element, cross section is drawn as solid (filled) instead of wire-frame; NOTE: some quantities may not be interpolated correctly over cross section in visualization")
        .def_property("crossSectionTiling", &VSettingsBeams::PyGetCrossSectionTiling, &VSettingsBeams::PySetCrossSectionTiling)
        .def_readwrite("drawVertical", &VSettingsBeams::drawVertical, "draw contour plot outputVariables 'vertical' along beam height; contour.outputVariable must be set accordingly")
        .def_property("drawVerticalColor", &VSettingsBeams::PyGetDrawVerticalColor, &VSettingsBeams::PySetDrawVerticalColor)
        .def_readwrite("drawVerticalFactor", &VSettingsBeams::drawVerticalFactor, "factor for outputVariable to be drawn along cross section (vertically)")
        .def_readwrite("drawVerticalLines", &VSettingsBeams::drawVerticalLines, "draw additional vertical lines for better visibility")
        .def_readwrite("drawVerticalOffset", &VSettingsBeams::drawVerticalOffset, "offset for vertical drawn lines; offset is added before multiplication with drawVerticalFactor")
        .def_readwrite("drawVerticalValues", &VSettingsBeams::drawVerticalValues, "show values at vertical lines; note that these numbers are interpolated values and may be different from values evaluated directly at this point!")
        .def_readwrite("reducedAxialInterploation", &VSettingsBeams::reducedAxialInterploation, "if True, the interpolation along the beam axis may be lower than the beam element order; this may be, however, show more consistent values than a full interpolation, e.g. for strains or forces")
        // AUTO: access functions for VSettingsBeams
        .def("__repr__", [](const VSettingsBeams &item) { return "<VSettingsBeams:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsBeams &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsBeams &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsBeams& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsBeams: loading data with pickle received invalid data structure!");
                VSettingsBeams self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsKinematicTree>(m, "VSettingsKinematicTree", "VSettingsKinematicTree class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("frameSize", &VSettingsKinematicTree::frameSize, "size of COM and joint frames")
        .def_readwrite("showCOMframes", &VSettingsKinematicTree::showCOMframes, "if True, a frame is attached to every center of mass")
        .def_readwrite("showFramesNumbers", &VSettingsKinematicTree::showFramesNumbers, "if True, numbers are drawn for joint frames (O[i]J[j]) and COM frames (O[i]COM[j]) for object [i] and local joint [j]")
        .def_readwrite("showJointFrames", &VSettingsKinematicTree::showJointFrames, "if True, a frame is attached to the origin of every joint frame")
        // AUTO: access functions for VSettingsKinematicTree
        .def("__repr__", [](const VSettingsKinematicTree &item) { return "<VSettingsKinematicTree:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsKinematicTree &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsKinematicTree &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsKinematicTree& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsKinematicTree: loading data with pickle received invalid data structure!");
                VSettingsKinematicTree self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsBodies>(m, "VSettingsBodies", "VSettingsBodies class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("beams", &VSettingsBodies::beams, "visualization settings for beams (e.g. ANCFCable or other beam elements)")
        .def_readwrite("kinematicTree", &VSettingsBodies::kinematicTree, "visualization settings for kinematic tree")
        .def_property("defaultColor", &VSettingsBodies::PyGetDefaultColor, &VSettingsBodies::PySetDefaultColor)
        .def_property("defaultSize", &VSettingsBodies::PyGetDefaultSize, &VSettingsBodies::PySetDefaultSize)
        .def_readwrite("deformationScaleFactor", &VSettingsBodies::deformationScaleFactor, "global deformation scale factor; also applies to nodes, if drawn; used for scaled drawing of (linear) finite elements, beams, etc.")
        .def_readwrite("show", &VSettingsBodies::show, "flag to decide, whether the bodies are shown")
        .def_readwrite("showNumbers", &VSettingsBodies::showNumbers, "flag to decide, whether the body(=object) number is shown")
        // AUTO: access functions for VSettingsBodies
        .def("__repr__", [](const VSettingsBodies &item) { return "<VSettingsBodies:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsBodies &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsBodies &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsBodies& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsBodies: loading data with pickle received invalid data structure!");
                VSettingsBodies self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsConnectors>(m, "VSettingsConnectors", "VSettingsConnectors class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("contactPointsDefaultSize", &VSettingsConnectors::contactPointsDefaultSize, "DEPRECATED: do not use! global contact points size; if -1.f, connector size is relative to maxSceneSize")
        .def_property("defaultColor", &VSettingsConnectors::PyGetDefaultColor, &VSettingsConnectors::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsConnectors::defaultSize, "global connector size; if -1.f, connector size is relative to maxSceneSize")
        .def_readwrite("jointAxesLength", &VSettingsConnectors::jointAxesLength, "global joint axes length")
        .def_readwrite("jointAxesRadius", &VSettingsConnectors::jointAxesRadius, "global joint axes radius")
        .def_readwrite("show", &VSettingsConnectors::show, "flag to decide, whether the connectors are shown")
        .def_readwrite("showContact", &VSettingsConnectors::showContact, "flag to decide, whether contact points, lines, etc. are shown")
        .def_readwrite("showJointAxes", &VSettingsConnectors::showJointAxes, "flag to decide, whether contact joint axes of 3D joints are shown")
        .def_readwrite("showNumbers", &VSettingsConnectors::showNumbers, "flag to decide, whether the connector(=object) number is shown")
        .def_property("springNumberOfWindings", &VSettingsConnectors::PyGetSpringNumberOfWindings, &VSettingsConnectors::PySetSpringNumberOfWindings)
        // AUTO: access functions for VSettingsConnectors
        .def("__repr__", [](const VSettingsConnectors &item) { return "<VSettingsConnectors:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsConnectors &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsConnectors &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsConnectors& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsConnectors: loading data with pickle received invalid data structure!");
                VSettingsConnectors self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsMarkers>(m, "VSettingsMarkers", "VSettingsMarkers class") // AUTO: 
        .def(py::init<>())
        .def_property("defaultColor", &VSettingsMarkers::PyGetDefaultColor, &VSettingsMarkers::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsMarkers::defaultSize, "global marker size; if -1.f, marker size is relative to maxSceneSize")
        .def_readwrite("drawSimplified", &VSettingsMarkers::drawSimplified, "draw markers with simplified symbols")
        .def_readwrite("show", &VSettingsMarkers::show, "flag to decide, whether the markers are shown")
        .def_readwrite("showNumbers", &VSettingsMarkers::showNumbers, "flag to decide, whether the marker numbers are shown")
        // AUTO: access functions for VSettingsMarkers
        .def("__repr__", [](const VSettingsMarkers &item) { return "<VSettingsMarkers:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsMarkers &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsMarkers &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsMarkers& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsMarkers: loading data with pickle received invalid data structure!");
                VSettingsMarkers self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsLoads>(m, "VSettingsLoads", "VSettingsLoads class") // AUTO: 
        .def(py::init<>())
        .def_property("defaultColor", &VSettingsLoads::PyGetDefaultColor, &VSettingsLoads::PySetDefaultColor)
        .def_readwrite("defaultRadius", &VSettingsLoads::defaultRadius, "global radius of load axis if drawn in 3D")
        .def_readwrite("defaultSize", &VSettingsLoads::defaultSize, "global load size; if -1.f, load size is relative to maxSceneSize")
        .def_readwrite("drawSimplified", &VSettingsLoads::drawSimplified, "draw markers with simplified symbols")
        .def_readwrite("fixedLoadSize", &VSettingsLoads::fixedLoadSize, "if true, the load is drawn with a fixed vector length in direction of the load vector, independently of the load size")
        .def_readwrite("loadSizeFactor", &VSettingsLoads::loadSizeFactor, "if fixedLoadSize=false, then this scaling factor is used to draw the load vector")
        .def_readwrite("show", &VSettingsLoads::show, "flag to decide, whether the loads are shown")
        .def_readwrite("showNumbers", &VSettingsLoads::showNumbers, "flag to decide, whether the load numbers are shown")
        // AUTO: access functions for VSettingsLoads
        .def("__repr__", [](const VSettingsLoads &item) { return "<VSettingsLoads:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsLoads &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsLoads &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsLoads& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsLoads: loading data with pickle received invalid data structure!");
                VSettingsLoads self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsSensorTraces>(m, "VSettingsSensorTraces", "VSettingsSensorTraces class") // AUTO: 
        .def(py::init<>())
        .def_property("lineWidth", &VSettingsSensorTraces::PyGetLineWidth, &VSettingsSensorTraces::PySetLineWidth)
        .def_property("listOfPositionSensors", &VSettingsSensorTraces::PyGetListOfPositionSensors, &VSettingsSensorTraces::PySetListOfPositionSensors)
        .def_property("listOfTriadSensors", &VSettingsSensorTraces::PyGetListOfTriadSensors, &VSettingsSensorTraces::PySetListOfTriadSensors)
        .def_property("listOfVectorSensors", &VSettingsSensorTraces::PyGetListOfVectorSensors, &VSettingsSensorTraces::PySetListOfVectorSensors)
        .def_property("positionsShowEvery", &VSettingsSensorTraces::PyGetPositionsShowEvery, &VSettingsSensorTraces::PySetPositionsShowEvery)
        .def_readwrite("sensorsMbsNumber", &VSettingsSensorTraces::sensorsMbsNumber, "number of main system which is used to for sensor lists; if only 1 mbs is in the SystemContainer, use 0; if there are several mbs, it needs to specify the number")
        .def_readwrite("showCurrent", &VSettingsSensorTraces::showCurrent, "show current trace position (and especially vector quantity) related to current visualization state; this only works in solution viewer if sensor values are stored at time grid points of the solution file (up to a precision of 1e-10) and may therefore be temporarily unavailable")
        .def_readwrite("showFuture", &VSettingsSensorTraces::showFuture, "show trace future to current visualization state if already computed (e.g. in SolutionViewer)")
        .def_readwrite("showPast", &VSettingsSensorTraces::showPast, "show trace previous to current visualization state")
        .def_readwrite("showPositionTrace", &VSettingsSensorTraces::showPositionTrace, "show position trace of all position sensors if listOfPositionSensors=[] or of specified sensors; sensors need to activate storeInternal=True")
        .def_readwrite("showTriads", &VSettingsSensorTraces::showTriads, "if True, show basis vectors from rotation matrices provided by sensors")
        .def_readwrite("showVectors", &VSettingsSensorTraces::showVectors, "if True, show vector quantities according to description in showPositionTrace")
        .def_property("traceColors", &VSettingsSensorTraces::PyGetTraceColors, &VSettingsSensorTraces::PySetTraceColors)
        .def_readwrite("triadSize", &VSettingsSensorTraces::triadSize, "length of triad axes if shown")
        .def_property("triadsShowEvery", &VSettingsSensorTraces::PyGetTriadsShowEvery, &VSettingsSensorTraces::PySetTriadsShowEvery)
        .def_readwrite("vectorScaling", &VSettingsSensorTraces::vectorScaling, "scaling of vector quantities; if, e.g., loads, this factor has to be adjusted significantly")
        .def_property("vectorsShowEvery", &VSettingsSensorTraces::PyGetVectorsShowEvery, &VSettingsSensorTraces::PySetVectorsShowEvery)
        // AUTO: access functions for VSettingsSensorTraces
        .def("__repr__", [](const VSettingsSensorTraces &item) { return "<VSettingsSensorTraces:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsSensorTraces &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsSensorTraces &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsSensorTraces& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsSensorTraces: loading data with pickle received invalid data structure!");
                VSettingsSensorTraces self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsSensors>(m, "VSettingsSensors", "VSettingsSensors class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("traces", &VSettingsSensors::traces, "settings for showing (position) sensor traces and vector plots in the render window")
        .def_property("defaultColor", &VSettingsSensors::PyGetDefaultColor, &VSettingsSensors::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsSensors::defaultSize, "global sensor size; if -1.f, sensor size is relative to maxSceneSize")
        .def_readwrite("drawSimplified", &VSettingsSensors::drawSimplified, "draw sensors with simplified symbols")
        .def_readwrite("show", &VSettingsSensors::show, "flag to decide, whether the sensors are shown")
        .def_readwrite("showNumbers", &VSettingsSensors::showNumbers, "flag to decide, whether the sensor numbers are shown")
        // AUTO: access functions for VSettingsSensors
        .def("__repr__", [](const VSettingsSensors &item) { return "<VSettingsSensors:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsSensors &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsSensors &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsSensors& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsSensors: loading data with pickle received invalid data structure!");
                VSettingsSensors self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsContact>(m, "VSettingsContact", "VSettingsContact class") // AUTO: 
        .def(py::init<>())
        .def_property("colorBoundingBoxes", &VSettingsContact::PyGetColorBoundingBoxes, &VSettingsContact::PySetColorBoundingBoxes)
        .def_property("colorSearchTree", &VSettingsContact::PyGetColorSearchTree, &VSettingsContact::PySetColorSearchTree)
        .def_property("colorSpheres", &VSettingsContact::PyGetColorSpheres, &VSettingsContact::PySetColorSpheres)
        .def_property("colorTriangles", &VSettingsContact::PyGetColorTriangles, &VSettingsContact::PySetColorTriangles)
        .def_readwrite("contactForcesFactor", &VSettingsContact::contactForcesFactor, "factor used for scaling of contact forces is showContactForces=True")
        .def_readwrite("contactPointsDefaultSize", &VSettingsContact::contactPointsDefaultSize, "global contact points size; if -1.f, connector size is relative to maxSceneSize; used for some contacts, e.g., in ContactFrictionCircle")
        .def_readwrite("showBoundingBoxes", &VSettingsContact::showBoundingBoxes, "show computed bounding boxes of all GeneralContacts; Warning: avoid for large number of contact objects!")
        .def_readwrite("showContactForces", &VSettingsContact::showContactForces, "if True, contact forces are drawn for certain contact models")
        .def_readwrite("showContactForcesValues", &VSettingsContact::showContactForcesValues, "if True and showContactForces=True, numerical values for  contact forces are shown at certain points")
        .def_readwrite("showSearchTree", &VSettingsContact::showSearchTree, "show outer box of search tree for all GeneralContacts")
        .def_readwrite("showSearchTreeCells", &VSettingsContact::showSearchTreeCells, "show all cells of search tree; empty cells have colorSearchTree, cells with contact objects have higher red value; Warning: avoid for large number of search tree cells!")
        .def_readwrite("showSpheres", &VSettingsContact::showSpheres, "show contact spheres (SpheresWithMarker, ...)")
        .def_readwrite("showTriangles", &VSettingsContact::showTriangles, "show contact triangles (TrianglesRigidBodyBased, ...)")
        .def_property("tilingSpheres", &VSettingsContact::PyGetTilingSpheres, &VSettingsContact::PySetTilingSpheres)
        // AUTO: access functions for VSettingsContact
        .def("__repr__", [](const VSettingsContact &item) { return "<VSettingsContact:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsContact &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsContact &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsContact& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsContact: loading data with pickle received invalid data structure!");
                VSettingsContact self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsWindow>(m, "VSettingsWindow", "VSettingsWindow class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("alwaysOnTop", &VSettingsWindow::alwaysOnTop, "True: OpenGL render window will be always on top of all other windows")
        .def_readwrite("ignoreKeys", &VSettingsWindow::ignoreKeys, "True: ignore keyboard input except escape and 'F2' keys; used for interactive mode, e.g., to perform kinematic analysis; This flag can be switched with key 'F2'")
        .def_readwrite("keyPressUserFunction", &VSettingsWindow::keyPressUserFunction, "add a Python function f(key, action, mods) here, which is called every time a key is pressed; function shall return true, if key has been processed; Example: tabnewline def f(key, action, mods):tabnewline phantom{XXX} print('key=',key);tabnewline use chr(key) to convert key codes [32 ...96] to ascii; special key codes (>256) are provided in the exudyn.KeyCode enumeration type; key action needs to be checked (0=released, 1=pressed, 2=repeated); mods provide information (binary) for SHIFT (1), CTRL (2), ALT (4), Super keys (8), CAPSLOCK (16)")
        .def_readwrite("limitWindowToScreenSize", &VSettingsWindow::limitWindowToScreenSize, "True: render window size is limited to screen size; False: larger window sizes (e.g. for rendering) allowed according to renderWindowSize")
        .def_readwrite("maximize", &VSettingsWindow::maximize, "True: OpenGL render window will be maximized at startup")
        .def_property("reallyQuitTimeLimit", &VSettingsWindow::PyGetReallyQuitTimeLimit, &VSettingsWindow::PySetReallyQuitTimeLimit)
        .def_property("renderWindowSize", &VSettingsWindow::PyGetRenderWindowSize, &VSettingsWindow::PySetRenderWindowSize)
        .def_readwrite("showMouseCoordinates", &VSettingsWindow::showMouseCoordinates, "True: show OpenGL coordinates and distance to last left mouse button pressed position; switched on/off with key 'F3'")
        .def_readwrite("showWindow", &VSettingsWindow::showWindow, "True: OpenGL render window is shown on startup; False: window will be iconified at startup (e.g. if you are starting multiple computations automatically)")
        .def_property("startupTimeout", &VSettingsWindow::PyGetStartupTimeout, &VSettingsWindow::PySetStartupTimeout)
        // AUTO: access functions for VSettingsWindow
        .def("ResetKeyPressUserFunction", &VSettingsWindow::ResetKeyPressUserFunction, "set keyPressUserFunction to zero (no function); because this cannot be assign to the variable itself")
        .def("__repr__", [](const VSettingsWindow &item) { return "<VSettingsWindow:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsWindow &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsWindow &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsWindow& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsWindow: loading data with pickle received invalid data structure!");
                VSettingsWindow self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsDialogs>(m, "VSettingsDialogs", "VSettingsDialogs class") // AUTO: 
        .def(py::init<>())
        .def_property("alphaTransparency", &VSettingsDialogs::PyGetAlphaTransparency, &VSettingsDialogs::PySetAlphaTransparency)
        .def_readwrite("alwaysTopmost", &VSettingsDialogs::alwaysTopmost, "True: dialogs are always topmost (otherwise, they are sometimes hidden)")
        .def_property("fontScalingMacOS", &VSettingsDialogs::PyGetFontScalingMacOS, &VSettingsDialogs::PySetFontScalingMacOS)
        .def_readwrite("multiThreadedDialogs", &VSettingsDialogs::multiThreadedDialogs, "True: During dialogs, the OpenGL render window will still get updates of changes in dialogs, etc., which may cause problems on some platforms or for some (complicated) models; False: changes of dialogs will take effect when dialogs are closed")
        .def_readwrite("openTreeView", &VSettingsDialogs::openTreeView, "True: all sub-trees of the visusalization dialog are opened when opening the dialog; False: only some sub-trees are opened")
        // AUTO: access functions for VSettingsDialogs
        .def("__repr__", [](const VSettingsDialogs &item) { return "<VSettingsDialogs:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsDialogs &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsDialogs &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsDialogs& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsDialogs: loading data with pickle received invalid data structure!");
                VSettingsDialogs self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsOpenGL>(m, "VSettingsOpenGL", "VSettingsOpenGL class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("drawFaceNormals", &VSettingsOpenGL::drawFaceNormals, "draws triangle normals, e.g. at center of triangles; used for debugging of faces")
        .def_property("drawNormalsLength", &VSettingsOpenGL::PyGetDrawNormalsLength, &VSettingsOpenGL::PySetDrawNormalsLength)
        .def_readwrite("drawVertexNormals", &VSettingsOpenGL::drawVertexNormals, "draws vertex normals; used for debugging")
        .def_readwrite("enableLight0", &VSettingsOpenGL::enableLight0, "turn on/off light0")
        .def_readwrite("enableLight1", &VSettingsOpenGL::enableLight1, "turn on/off light1")
        .def_readwrite("enableLighting", &VSettingsOpenGL::enableLighting, "generally enable lighting (otherwise, colors of objects are used); OpenGL: glEnable(GL_LIGHTING)")
        .def_property("faceEdgesColor", &VSettingsOpenGL::PyGetFaceEdgesColor, &VSettingsOpenGL::PySetFaceEdgesColor)
        .def_readwrite("facesTransparent", &VSettingsOpenGL::facesTransparent, "True: show faces transparent independent of transparency (A)-value in color of objects; allow to show otherwise hidden node/marker/object numbers")
        .def_property("initialCenterPoint", &VSettingsOpenGL::PyGetInitialCenterPoint, &VSettingsOpenGL::PySetInitialCenterPoint)
        .def_property("initialMaxSceneSize", &VSettingsOpenGL::PyGetInitialMaxSceneSize, &VSettingsOpenGL::PySetInitialMaxSceneSize)
        .def_readwrite("initialModelRotation", &VSettingsOpenGL::initialModelRotation, "initial model rotation matrix for OpenGl; in python use e.g.: initialModelRotation=[[1,0,0],[0,1,0],[0,0,1]]")
        .def_property("initialZoom", &VSettingsOpenGL::PyGetInitialZoom, &VSettingsOpenGL::PySetInitialZoom)
        .def_readwrite("light0ambient", &VSettingsOpenGL::light0ambient, "ambient value of GL_LIGHT0")
        .def_readwrite("light0constantAttenuation", &VSettingsOpenGL::light0constantAttenuation, "constant attenuation coefficient of GL_LIGHT0, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); (kc,kl,kq)=(1,0,0) means no attenuation; only used for lights, where last component of light position is 1")
        .def_readwrite("light0diffuse", &VSettingsOpenGL::light0diffuse, "diffuse value of GL_LIGHT0")
        .def_readwrite("light0linearAttenuation", &VSettingsOpenGL::light0linearAttenuation, "linear attenuation coefficient of GL_LIGHT0, this is a linear factor for attenuation of the light source with distance")
        .def_property("light0position", &VSettingsOpenGL::PyGetLight0position, &VSettingsOpenGL::PySetLight0position)
        .def_readwrite("light0quadraticAttenuation", &VSettingsOpenGL::light0quadraticAttenuation, "quadratic attenuation coefficient of GL_LIGHT0, this is a quadratic factor for attenuation of the light source with distance")
        .def_readwrite("light0specular", &VSettingsOpenGL::light0specular, "specular value of GL_LIGHT0")
        .def_readwrite("light1ambient", &VSettingsOpenGL::light1ambient, "ambient value of GL_LIGHT1")
        .def_readwrite("light1constantAttenuation", &VSettingsOpenGL::light1constantAttenuation, "constant attenuation coefficient of GL_LIGHT1, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); only used for lights, where last component of light position is 1")
        .def_readwrite("light1diffuse", &VSettingsOpenGL::light1diffuse, "diffuse value of GL_LIGHT1")
        .def_readwrite("light1linearAttenuation", &VSettingsOpenGL::light1linearAttenuation, "linear attenuation coefficient of GL_LIGHT1, this is a linear factor for attenuation of the light source with distance")
        .def_property("light1position", &VSettingsOpenGL::PyGetLight1position, &VSettingsOpenGL::PySetLight1position)
        .def_readwrite("light1quadraticAttenuation", &VSettingsOpenGL::light1quadraticAttenuation, "quadratic attenuation coefficient of GL_LIGHT1, this is a quadratic factor for attenuation of the light source with distance")
        .def_readwrite("light1specular", &VSettingsOpenGL::light1specular, "specular value of GL_LIGHT1")
        .def_property("lightModelAmbient", &VSettingsOpenGL::PyGetLightModelAmbient, &VSettingsOpenGL::PySetLightModelAmbient)
        .def_readwrite("lightModelLocalViewer", &VSettingsOpenGL::lightModelLocalViewer, "select local viewer for light; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,...)")
        .def_readwrite("lightModelTwoSide", &VSettingsOpenGL::lightModelTwoSide, "enlighten also backside of object; may cause problems on some graphics cards and lead to slower performance; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,...)")
        .def_readwrite("lineSmooth", &VSettingsOpenGL::lineSmooth, "draw lines smooth")
        .def_property("lineWidth", &VSettingsOpenGL::PyGetLineWidth, &VSettingsOpenGL::PySetLineWidth)
        .def_property("materialAmbientAndDiffuse", &VSettingsOpenGL::PyGetMaterialAmbientAndDiffuse, &VSettingsOpenGL::PySetMaterialAmbientAndDiffuse)
        .def_readwrite("materialShininess", &VSettingsOpenGL::materialShininess, "shininess of material")
        .def_property("materialSpecular", &VSettingsOpenGL::PyGetMaterialSpecular, &VSettingsOpenGL::PySetMaterialSpecular)
        .def_property("multiSampling", &VSettingsOpenGL::PyGetMultiSampling, &VSettingsOpenGL::PySetMultiSampling)
        .def_property("perspective", &VSettingsOpenGL::PyGetPerspective, &VSettingsOpenGL::PySetPerspective)
        .def_readwrite("polygonOffset", &VSettingsOpenGL::polygonOffset, "general polygon offset for polygons, except for shadows; use this parameter to draw polygons behind lines to reduce artifacts for very large or small models")
        .def_readwrite("shadeModelSmooth", &VSettingsOpenGL::shadeModelSmooth, "True: turn on smoothing for shaders, which uses vertex normals to smooth surfaces")
        .def_property("shadow", &VSettingsOpenGL::PyGetShadow, &VSettingsOpenGL::PySetShadow)
        .def_property("shadowPolygonOffset", &VSettingsOpenGL::PyGetShadowPolygonOffset, &VSettingsOpenGL::PySetShadowPolygonOffset)
        .def_readwrite("showFaceEdges", &VSettingsOpenGL::showFaceEdges, "show edges of faces; using the options showFaces=false and showFaceEdges=true gives are wire frame representation")
        .def_readwrite("showFaces", &VSettingsOpenGL::showFaces, "show faces of triangles, etc.; using the options showFaces=false and showFaceEdges=true gives are wire frame representation")
        .def_readwrite("showLines", &VSettingsOpenGL::showLines, "show lines (different from edges of faces)")
        .def_readwrite("showMeshEdges", &VSettingsOpenGL::showMeshEdges, "show edges of finite elements; independent of showFaceEdges")
        .def_readwrite("showMeshFaces", &VSettingsOpenGL::showMeshFaces, "show faces of finite elements; independent of showFaces")
        .def_readwrite("textLineSmooth", &VSettingsOpenGL::textLineSmooth, "draw lines for representation of text smooth")
        .def_property("textLineWidth", &VSettingsOpenGL::PyGetTextLineWidth, &VSettingsOpenGL::PySetTextLineWidth)
        // AUTO: access functions for VSettingsOpenGL
        .def("__repr__", [](const VSettingsOpenGL &item) { return "<VSettingsOpenGL:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsOpenGL &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsOpenGL &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsOpenGL& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsOpenGL: loading data with pickle received invalid data structure!");
                VSettingsOpenGL self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsExportImages>(m, "VSettingsExportImages", "VSettingsExportImages class") // AUTO: 
        .def(py::init<>())
        .def_property("heightAlignment", &VSettingsExportImages::PyGetHeightAlignment, &VSettingsExportImages::PySetHeightAlignment)
        .def_readwrite("saveImageAsTextCircles", &VSettingsExportImages::saveImageAsTextCircles, "export circles in save image (only in TXT format)")
        .def_readwrite("saveImageAsTextLines", &VSettingsExportImages::saveImageAsTextLines, "export lines in save image (only in TXT format)")
        .def_readwrite("saveImageAsTextTexts", &VSettingsExportImages::saveImageAsTextTexts, "export text in save image (only in TXT format)")
        .def_readwrite("saveImageAsTextTriangles", &VSettingsExportImages::saveImageAsTextTriangles, "export triangles in save image (only in TXT format)")
        .def_property("saveImageFileCounter", &VSettingsExportImages::PyGetSaveImageFileCounter, &VSettingsExportImages::PySetSaveImageFileCounter)
        .def_readwrite("saveImageFileName", &VSettingsExportImages::saveImageFileName, "filename (without extension!) and (relative) path for image file(s) with consecutive numbering (e.g., frame0000.png, frame0001.png,...); ; directory will be created if it does not exist")
        .def_readwrite("saveImageFormat", &VSettingsExportImages::saveImageFormat, "format for exporting figures: currently only PNG, TGA and TXT available; while PNG and TGA represent the according image file formats, the TXT format results in a text file containing the 3D graphics data information as lists of lines, triangles, etc; PNG is not available for Ubuntu18.04 (check  use TGA has highest compatibility with all platforms")
        .def_readwrite("saveImageSingleFile", &VSettingsExportImages::saveImageSingleFile, "True: only save single files with given filename, not adding numbering; False: add numbering to files, see saveImageFileName")
        .def_property("saveImageTimeOut", &VSettingsExportImages::PyGetSaveImageTimeOut, &VSettingsExportImages::PySetSaveImageTimeOut)
        .def_property("widthAlignment", &VSettingsExportImages::PyGetWidthAlignment, &VSettingsExportImages::PySetWidthAlignment)
        // AUTO: access functions for VSettingsExportImages
        .def("__repr__", [](const VSettingsExportImages &item) { return "<VSettingsExportImages:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsExportImages &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsExportImages &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsExportImages& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsExportImages: loading data with pickle received invalid data structure!");
                VSettingsExportImages self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsOpenVR>(m, "VSettingsOpenVR", "VSettingsOpenVR class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("actionManifestFileName", &VSettingsOpenVR::actionManifestFileName, "This string must contain a string representing a valid absolute path to a vr_actions.json manifest, which describes all HMD, tracker, etc. devices as given by openVR")
        .def_readwrite("enable", &VSettingsOpenVR::enable, "True: openVR enabled (if compiled with according flag and installed openVR)")
        .def_readwrite("logLevel", &VSettingsOpenVR::logLevel, "integer value setting log level of openVR: -1 (no output), 0 (error), 1 (warning), 2 (info), 3 (debug); increase log level to get more output")
        .def_readwrite("showCompanionWindow", &VSettingsOpenVR::showCompanionWindow, "True: openVR will show companion window containing left and right eye view")
        // AUTO: access functions for VSettingsOpenVR
        .def("__repr__", [](const VSettingsOpenVR &item) { return "<VSettingsOpenVR:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsOpenVR &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsOpenVR &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsOpenVR& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsOpenVR: loading data with pickle received invalid data structure!");
                VSettingsOpenVR self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsInteractive>(m, "VSettingsInteractive", "VSettingsInteractive class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("openVR", &VSettingsInteractive::openVR, "openVR visualization settings")
        .def_property("highlightColor", &VSettingsInteractive::PyGetHighlightColor, &VSettingsInteractive::PySetHighlightColor)
        .def_readwrite("highlightItemIndex", &VSettingsInteractive::highlightItemIndex, "index of item that shall be highlighted (e.g., need to find item due to errors); if set -1, no item is highlighted")
        .def_readwrite("highlightItemType", &VSettingsInteractive::highlightItemType, "item type (Node, Object, ...) that shall be highlighted (e.g., need to find item due to errors)")
        .def_property("highlightMbsNumber", &VSettingsInteractive::PyGetHighlightMbsNumber, &VSettingsInteractive::PySetHighlightMbsNumber)
        .def_property("highlightOtherColor", &VSettingsInteractive::PyGetHighlightOtherColor, &VSettingsInteractive::PySetHighlightOtherColor)
        .def_readwrite("joystickScaleRotation", &VSettingsInteractive::joystickScaleRotation, "rotation scaling factor for joystick input")
        .def_readwrite("joystickScaleTranslation", &VSettingsInteractive::joystickScaleTranslation, "translation scaling factor for joystick input")
        .def_readwrite("keypressRotationStep", &VSettingsInteractive::keypressRotationStep, "rotation increment per keypress in degree (full rotation = 360 degree)")
        .def_readwrite("keypressTranslationStep", &VSettingsInteractive::keypressTranslationStep, "translation increment per keypress relative to window size")
        .def_readwrite("lockModelView", &VSettingsInteractive::lockModelView, "True: all movements (with mouse/keys), rotations, zoom are disabled; initial values are considered ==> initial zoom, rotation and center point need to be adjusted, approx. 0.4*maxSceneSize is a good value")
        .def_readwrite("mouseMoveRotationFactor", &VSettingsInteractive::mouseMoveRotationFactor, "rotation increment per 1 pixel mouse movement in degree")
        .def_readwrite("pauseWithSpacebar", &VSettingsInteractive::pauseWithSpacebar, "True: during simulation, space bar can be pressed to pause simulation")
        .def_readwrite("selectionHighlights", &VSettingsInteractive::selectionHighlights, "True: mouse click highlights item (default: red)")
        .def_readwrite("selectionLeftMouse", &VSettingsInteractive::selectionLeftMouse, "True: left mouse click on items and show basic information")
        .def_readwrite("selectionRightMouse", &VSettingsInteractive::selectionRightMouse, "True: right mouse click on items and show dictionary (read only!)")
        .def_readwrite("selectionRightMouseGraphicsData", &VSettingsInteractive::selectionRightMouseGraphicsData, "True: right mouse click on items also shows GraphicsData information for inspectation (may sometimes be very large and may not fit into dialog for large graphics objects!)")
        .def_readwrite("trackMarker", &VSettingsInteractive::trackMarker, "if valid marker index is provided and marker provides position (and orientation), the centerpoint of the scene follows the marker (and orientation); depends on trackMarkerPosition and trackMarkerOrientation; by default, only position is tracked")
        .def_readwrite("trackMarkerMbsNumber", &VSettingsInteractive::trackMarkerMbsNumber, "number of main system which is used to track marker; if only 1 mbs is in the SystemContainer, use 0; if there are several mbs, it needs to specify the number")
        .def_property("trackMarkerOrientation", &VSettingsInteractive::PyGetTrackMarkerOrientation, &VSettingsInteractive::PySetTrackMarkerOrientation)
        .def_property("trackMarkerPosition", &VSettingsInteractive::PyGetTrackMarkerPosition, &VSettingsInteractive::PySetTrackMarkerPosition)
        .def_readwrite("useJoystickInput", &VSettingsInteractive::useJoystickInput, "True: read joystick input (use 6-axis joystick with lowest ID found when starting renderer window) and interpret as (x,y,z) position and (rotx, roty, rotz) rotation: as available from 3Dconnexion space mouse and maybe others as well; set to False, if external joystick makes problems ...")
        .def_readwrite("zoomStepFactor", &VSettingsInteractive::zoomStepFactor, "change of zoom per keypress (keypad +/-) or mouse wheel increment")
        // AUTO: access functions for VSettingsInteractive
        .def("__repr__", [](const VSettingsInteractive &item) { return "<VSettingsInteractive:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionary", [](const VSettingsInteractive &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VSettingsInteractive &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VSettingsInteractive& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VSettingsInteractive: loading data with pickle received invalid data structure!");
                VSettingsInteractive self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VisualizationSettings>(m, "VisualizationSettings", "VisualizationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("bodies", &VisualizationSettings::bodies, "body visualization settings")
        .def_readwrite("connectors", &VisualizationSettings::connectors, "connector visualization settings")
        .def_readwrite("contact", &VisualizationSettings::contact, "contact visualization settings")
        .def_readwrite("contour", &VisualizationSettings::contour, "contour plot visualization settings")
        .def_readwrite("dialogs", &VisualizationSettings::dialogs, "dialogs settings")
        .def_readwrite("exportImages", &VisualizationSettings::exportImages, "settings for exporting (saving) images to files in order to create animations")
        .def_readwrite("general", &VisualizationSettings::general, "general visualization settings")
        .def_readwrite("interactive", &VisualizationSettings::interactive, "Settings for interaction with renderer")
        .def_readwrite("loads", &VisualizationSettings::loads, "load visualization settings")
        .def_readwrite("markers", &VisualizationSettings::markers, "marker visualization settings")
        .def_readwrite("nodes", &VisualizationSettings::nodes, "node visualization settings")
        .def_readwrite("openGL", &VisualizationSettings::openGL, "OpenGL rendering settings")
        .def_readwrite("sensors", &VisualizationSettings::sensors, "sensor visualization settings")
        .def_readwrite("window", &VisualizationSettings::window, "visualization window and interaction settings")
        // AUTO: access functions for VisualizationSettings
        .def("__repr__", [](const VisualizationSettings &item) { return "<VisualizationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionaryWithTypeInfo", [](const VisualizationSettings &item) { return EPyUtils::GetDictionaryWithTypeInfo(item); }) //!< AUTO: add read as dictionary with type information access
        .def("GetDictionary", [](const VisualizationSettings &item) { return EPyUtils::GetDictionary(item); }) //!< AUTO: add read for dictionary access
        .def("SetDictionary", [](VisualizationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        .def(py::pickle(
            [](const VisualizationSettings& self) {
                return py::make_tuple(EPyUtils::GetDictionary(self));
            },
            [](const py::tuple& t) {
                CHECKandTHROW(t.size() == 1, "VisualizationSettings: loading data with pickle received invalid data structure!");
                VisualizationSettings self;
                EPyUtils::SetDictionary(self,py::cast<py::dict>(t[0]));
                return self;
            }))
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<CSolverTimer>(m, "CSolverTimer", "CSolverTimer class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("AERHS", &CSolverTimer::AERHS, "time for residual evaluation of algebraic equations right-hand-side")
        .def_readwrite("errorEstimator", &CSolverTimer::errorEstimator, "for explicit solvers, additional evaluation")
        .def_readwrite("factorization", &CSolverTimer::factorization, "solve or inverse")
        .def_readwrite("integrationFormula", &CSolverTimer::integrationFormula, "time spent for evaluation of integration formulas")
        .def_readwrite("jacobianAE", &CSolverTimer::jacobianAE, "jacobian of algebraic equations (not counted in sum)")
        .def_readwrite("jacobianODE1", &CSolverTimer::jacobianODE1, "jacobian w.r.t. coordinates of {ODE1} equations (not counted in sum)")
        .def_readwrite("jacobianODE2", &CSolverTimer::jacobianODE2, "jacobian w.r.t. coordinates of ODE2 equations (not counted in sum)")
        .def_readwrite("jacobianODE2_t", &CSolverTimer::jacobianODE2_t, "jacobian w.r.t. coordinates_t of ODE2 equations (not counted in sum)")
        .def_readwrite("massMatrix", &CSolverTimer::massMatrix, "mass matrix computation")
        .def_readwrite("newtonIncrement", &CSolverTimer::newtonIncrement, "Jac$^{-1}$ * RHS; backsubstitution")
        .def_readwrite("ODE1RHS", &CSolverTimer::ODE1RHS, "time for residual evaluation of {ODE1} right-hand-side")
        .def_readwrite("ODE2RHS", &CSolverTimer::ODE2RHS, "time for residual evaluation of ODE2 right-hand-side")
        .def_readwrite("overhead", &CSolverTimer::overhead, "overhead, such as initialization, copying and some matrix-vector multiplication")
        .def_readwrite("postNewton", &CSolverTimer::postNewton, "discontinuous iteration / PostNewtonStep")
        .def_readwrite("python", &CSolverTimer::python, "time spent for Python functions")
        .def_readwrite("reactionForces", &CSolverTimer::reactionForces, "CqT * lambda")
        .def_readwrite("total", &CSolverTimer::total, "total time measured between start and end of computation (static/dynamics)")
        .def_readwrite("totalJacobian", &CSolverTimer::totalJacobian, "time for all jacobian computations")
        .def_readwrite("useTimer", &CSolverTimer::useTimer, "flag to decide, whether the timer is used (true) or not")
        .def_readwrite("visualization", &CSolverTimer::visualization, "time spent for visualization in computation thread")
        .def_readwrite("writeSolution", &CSolverTimer::writeSolution, "time for writing solution")
        // AUTO: access functions for CSolverTimer
        .def("Reset", &CSolverTimer::Reset, "reset solver timings to initial state by assigning default values; useSolverTimer sets the useTimer flag")
        .def("StartTimer", &CSolverTimer::StartTimer, "start timer function for a given variable; subtracts current CPU time from value")
        .def("StopTimer", &CSolverTimer::StopTimer, "stop timer function for a given variable; adds current CPU time to value")
        .def("Sum", &CSolverTimer::Sum, py::return_value_policy::copy, "compute sum of all timers (except for those counted multiple, e.g., jacobians")
        .def("ToString", &CSolverTimer::ToString, py::return_value_policy::copy, "converts the current timings to a string")
        .def("__repr__", [](const CSolverTimer &item) { return "<CSolverTimer:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverLocalData>(m, "SolverLocalData", "SolverLocalData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("aAlgorithmic", &SolverLocalData::aAlgorithmic, "additional term needed for generalized alpha (current state)")
        .def_readwrite("nAE", &SolverLocalData::nAE, "number of algebraic coordinates")
        .def_readwrite("nData", &SolverLocalData::nData, "number of data coordinates")
        .def_readwrite("newtonSolution", &SolverLocalData::newtonSolution, "Newton decrement (computed from residual and jacobian)")
        .def_readwrite("nODE1", &SolverLocalData::nODE1, "number of first order ordinary diff. eq. coordinates")
        .def_readwrite("nODE2", &SolverLocalData::nODE2, "number of second order ordinary diff. eq. coordinates")
        .def_readwrite("nSys", &SolverLocalData::nSys, "number of system (unknown) coordinates = nODE2+nODE1+nAE")
        .def_readwrite("startAE", &SolverLocalData::startAE, "start of algebraic coordinates, but set to zero if nAE==0")
        .def_readwrite("startOfStepStateAAlgorithmic", &SolverLocalData::startOfStepStateAAlgorithmic, "additional term needed for generalized alpha (startOfStep state)")
        .def_readwrite("systemResidual", &SolverLocalData::systemResidual, "system residual vector (vectors will be linked to this vector!)")
        .def_readwrite("temp2ODE2", &SolverLocalData::temp2ODE2, "second temporary vector for ODE2 quantities; use in static computation")
        .def_readwrite("tempODE1F0", &SolverLocalData::tempODE1F0, "temporary vector for {ODE1} Jacobian")
        .def_readwrite("tempODE1F1", &SolverLocalData::tempODE1F1, "temporary vector for {ODE1} Jacobian")
        .def_readwrite("tempODE2", &SolverLocalData::tempODE2, "temporary vector for ODE2 quantities; use in initial accelerations and during Newton")
        .def_readwrite("tempODE2F0", &SolverLocalData::tempODE2F0, "temporary vector for ODE2 Jacobian")
        .def_readwrite("tempODE2F1", &SolverLocalData::tempODE2F1, "temporary vector for ODE2 Jacobian")
        // AUTO: access functions for SolverLocalData
        .def("CleanUpMemory", &SolverLocalData::CleanUpMemory, "if desired, temporary data is cleaned up to safe memory")
        .def("GetLinearSolverType", &SolverLocalData::GetLinearSolverType, py::return_value_policy::copy, "return current linear solver type (dense/sparse)")
        .def("SetLinearSolverType", &SolverLocalData::SetLinearSolverType, "set linear solver type and matrix version: links system matrices to according dense/sparse versions and with option for singular jacobian (redundant constraints)")
        .def("__repr__", [](const SolverLocalData &item) { return "<SolverLocalData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverIterationData>(m, "SolverIterationData", "SolverIterationData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("adaptiveStep", &SolverIterationData::adaptiveStep, "True: the step size may be reduced if step fails; no automatic stepsize control")
        .def_readwrite("automaticStepSize", &SolverIterationData::automaticStepSize, "True: if timeIntegration.automaticStepSize == True AND chosen integrators supports automatic step size control (e.g., DOPRI5); False: constant step size used (step may be reduced if adaptiveStep=True)")
        .def_readwrite("automaticStepSizeError", &SolverIterationData::automaticStepSizeError, "estimated error (relative to atol + rtol*solution) of last step; must be $le 1$  for a step to be accepted")
        .def_readwrite("currentStepIndex", &SolverIterationData::currentStepIndex, "current step index; $i$")
        .def_readwrite("currentStepSize", &SolverIterationData::currentStepSize, "stepSize of current step")
        .def_readwrite("currentTime", &SolverIterationData::currentTime, "holds the current simulation time, copy of state.current.time; interval is [startTime,tEnd]; in static solver, duration is loadStepDuration")
        .def_readwrite("discontinuousIteration", &SolverIterationData::discontinuousIteration, "number of current discontinuous iteration")
        .def_readwrite("discontinuousIterationsCount", &SolverIterationData::discontinuousIterationsCount, "count total number of discontinuous iterations (min. 1 per step)")
        .def_readwrite("endTime", &SolverIterationData::endTime, "end time of static/dynamic solver")
        .def_readwrite("initialStepSize", &SolverIterationData::initialStepSize, "initial stepSize for dynamic solver; only used, if automaticStepSize is activated")
        .def_readwrite("lastStepSize", &SolverIterationData::lastStepSize, "stepSize suggested from last step or by initial step size; only used, if automaticStepSize is activated")
        .def_readwrite("maxStepSize", &SolverIterationData::maxStepSize, "constant or maximum stepSize")
        .def_readwrite("minStepSize", &SolverIterationData::minStepSize, "minimum stepSize for static/dynamic solver; only used, if automaticStepSize is activated")
        .def_readwrite("newtonJacobiCount", &SolverIterationData::newtonJacobiCount, "count total Newton jacobian computations")
        .def_readwrite("newtonSteps", &SolverIterationData::newtonSteps, "number of current newton steps")
        .def_readwrite("newtonStepsCount", &SolverIterationData::newtonStepsCount, "count total Newton steps")
        .def_readwrite("numberOfSteps", &SolverIterationData::numberOfSteps, "number of time steps (if fixed size); $n$")
        .def_readwrite("recommendedStepSize", &SolverIterationData::recommendedStepSize, "recommended step size $h_{recom}$ after PostNewton(...): $h_{recom} < 0$: no recommendation, $h_{recom}==0$: use minimum step size, $h_{recom}>0$: use specific step size, if no smaller size requested by other reason")
        .def_readwrite("rejectedAutomaticStepSizeSteps", &SolverIterationData::rejectedAutomaticStepSizeSteps, "count the number of rejected steps in case of automatic step size control (rejected steps are repeated with smaller step size)")
        .def_readwrite("rejectedModifiedNewtonSteps", &SolverIterationData::rejectedModifiedNewtonSteps, "count the number of rejected modified Newton steps (switch to full Newton)")
        .def_readwrite("startTime", &SolverIterationData::startTime, "time at beginning of time integration")
        // AUTO: access functions for SolverIterationData
        .def("ToString", &SolverIterationData::ToString, py::return_value_policy::copy, "convert iteration statistics to string; used for displayStatistics option")
        .def("__repr__", [](const SolverIterationData &item) { return "<SolverIterationData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverConvergenceData>(m, "SolverConvergenceData", "SolverConvergenceData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("contractivity", &SolverConvergenceData::contractivity, "Newton contractivity = geometric decay of error in every step")
        .def_readwrite("discontinuousIterationError", &SolverConvergenceData::discontinuousIterationError, "error of discontinuous iterations (contact, friction, ...) outside of Newton iteration")
        .def_readwrite("discontinuousIterationSuccessful", &SolverConvergenceData::discontinuousIterationSuccessful, "true, if last discontinuous iteration had success (failure may be recovered by adaptive step)")
        .def_readwrite("errorCoordinateFactor", &SolverConvergenceData::errorCoordinateFactor, "factor may include the number of system coordinates to reduce the residual")
        .def_readwrite("jacobianUpdateRequested", &SolverConvergenceData::jacobianUpdateRequested, "true, if a jacobian update is requested in modified Newton (determined in previous step)")
        .def_readwrite("lastResidual", &SolverConvergenceData::lastResidual, "last Newton residual to determine contractivity")
        .def_readwrite("linearSolverCausingRow", &SolverConvergenceData::linearSolverCausingRow, "-1 if successful, 0 ... n-1, the system equation (=coordinate) index which may have caused the problem, at which the linear solver failed")
        .def_readwrite("linearSolverFailed", &SolverConvergenceData::linearSolverFailed, "true, if linear solver failed to factorize")
        .def_readwrite("massMatrixNotInvertible", &SolverConvergenceData::massMatrixNotInvertible, "true, if mass matrix is not invertable during initialization or solution (explicit solver)")
        .def_readwrite("newtonConverged", &SolverConvergenceData::newtonConverged, "true, if Newton has (finally) converged")
        .def_readwrite("newtonSolutionDiverged", &SolverConvergenceData::newtonSolutionDiverged, "true, if Newton diverged (may be recovered)")
        .def_readwrite("residual", &SolverConvergenceData::residual, "current Newton residual")
        .def_readwrite("stepReductionFailed", &SolverConvergenceData::stepReductionFailed, "true, if iterations over time/static steps failed (finally, cannot be recovered)")
        .def_readwrite("stopNewton", &SolverConvergenceData::stopNewton, "set true by Newton, if Newton was stopped, e.g., because of exceeding iterations or linear solver failed")
        // AUTO: access functions for SolverConvergenceData
        .def("InitializeData", &SolverConvergenceData::InitializeData, "initialize SolverConvergenceData by assigning default values")
        .def("__repr__", [](const SolverConvergenceData &item) { return "<SolverConvergenceData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverOutputData>(m, "SolverOutputData", "SolverOutputData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("cpuLastTimePrinted", &SolverOutputData::cpuLastTimePrinted, "CPU time when output has been printed last time")
        .def_readwrite("cpuStartTime", &SolverOutputData::cpuStartTime, "CPU start time of computation (starts counting at computation of initial conditions)")
        .def_readwrite("finishedSuccessfully", &SolverOutputData::finishedSuccessfully, "flag is false until solver functions SolveSteps)...) or SolveSystem(...) finished successfully (can be used as external trigger)")
        .def_readwrite("initializationSuccessful", &SolverOutputData::initializationSuccessful, "flag is set during call to InitializeSolver(...); reasons for failure are multiple, either inconsistent solver settings are used, files cannot be written (file locked), or initial conditions could not be computed ")
        .def_readwrite("lastDiscontinuousIterationsCount", &SolverOutputData::lastDiscontinuousIterationsCount, "discontinuous iterations count when written to console (or file) last time")
        .def_readwrite("lastImageRecorded", &SolverOutputData::lastImageRecorded, "simulation time when last image has been recorded")
        .def_readwrite("lastNewtonJacobiCount", &SolverOutputData::lastNewtonJacobiCount, "jacobian update count when written to console (or file) last time")
        .def_readwrite("lastNewtonStepsCount", &SolverOutputData::lastNewtonStepsCount, "newton steps count when written to console (or file) last time")
        .def_readwrite("lastSensorsWritten", &SolverOutputData::lastSensorsWritten, "simulation time when last sensors have been written")
        .def_readwrite("lastSolutionWritten", &SolverOutputData::lastSolutionWritten, "simulation time when last solution has been written")
        .def_readwrite("lastVerboseStepIndex", &SolverOutputData::lastVerboseStepIndex, "step index when last time written to console (or file)")
        .def_readwrite("multiThreadingMode", &SolverOutputData::multiThreadingMode, "multithreading mode that has been used: 0=None (serial), 1=NGsolve taskmanager, 2=MicroThreading (Exudyn)")
        .def_readwrite("numberOfThreadsUsed", &SolverOutputData::numberOfThreadsUsed, "number of threads that have been used in simulation")
        .def_readwrite("stepInformation", &SolverOutputData::stepInformation, "this is a copy of the solvers stepInformation used for console output")
        .def_readwrite("verboseMode", &SolverOutputData::verboseMode, "this is a copy of the solvers verboseMode used for console output")
        .def_readwrite("verboseModeFile", &SolverOutputData::verboseModeFile, "this is a copy of the solvers verboseModeFile used for file")
        .def_readwrite("writeToSolutionFile", &SolverOutputData::writeToSolutionFile, "if false, no solution file is generated and no file is written")
        .def_readwrite("writeToSolverFile", &SolverOutputData::writeToSolverFile, "if false, no solver output file is generated and no file is written")
        // AUTO: access functions for SolverOutputData
        .def("InitializeData", &SolverOutputData::InitializeData, "initialize SolverOutputData by assigning default values")
        .def("__repr__", [](const SolverOutputData &item) { return "<SolverOutputData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverFileData>(m, "SolverFileData", "SolverFileData class") // AUTO: 
        .def(py::init<>())
        // AUTO: access functions for SolverFileData
        .def("__repr__", [](const SolverFileData &item) { return "<SolverFileData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverStatic>(m, "MainSolverStatic", "MainSolverStatic class") // AUTO: 
        .def(py::init<>())
        .def_property("conv", &MainSolverStatic::PyGetConv, &MainSolverStatic::PySetConv)
        .def_property("it", &MainSolverStatic::PyGetIt, &MainSolverStatic::PySetIt)
        .def_property("newton", &MainSolverStatic::PyGetNewton, &MainSolverStatic::PySetNewton)
        .def_property("output", &MainSolverStatic::PyGetOutput, &MainSolverStatic::PySetOutput)
        .def_property("timer", &MainSolverStatic::PyGetTimer, &MainSolverStatic::PySetTimer)
        .def_property("loadStepGeometricFactor", &MainSolverStatic::PyGetLoadStepGeometricFactor, &MainSolverStatic::PySetLoadStepGeometricFactor)
        // AUTO: access functions for MainSolverStatic
        .def("CheckInitialized", &MainSolverStatic::CheckInitialized, py::return_value_policy::copy, "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError", py::arg("mainSystem"))
        .def("ComputeAlgebraicEquations", &MainSolverStatic::ComputeAlgebraicEquations, "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)", py::arg("mainSystem"), py::arg("velocityLevel") = false)
        .def("ComputeJacobianAE", &MainSolverStatic::ComputeJacobianAE, "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates, ODE2_t (velocity) coordinates and ODE1 coordinates; if velocityLevel == true, the constraints are evaluated at velocity level; the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 0., py::arg("scalarFactor_ODE1") = 1., py::arg("velocityLevel") = false)
        .def("ComputeJacobianODE1RHS", &MainSolverStatic::ComputeJacobianODE1RHS, "ADD jacobian of ODE1RHS (multiplied with factors for ODE2 and ODE1 coordinates) to the according rows (nODE2:nODE2+nODE1) of the exising systemJacobian in cSolver; it requires a prior call to ComputeJacobianODE2RHS(...); the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 0., py::arg("scalarFactor_ODE1") = 1.)
        .def("ComputeJacobianODE2RHS", &MainSolverStatic::ComputeJacobianODE2RHS, "set systemJacobian to zero, size = (nODE2+nODE1+nAE) x (nODE2+nODE1+nAE), and add jacobian (multiplied with factors for ODE2 and ODE1 coordinates) of ODE2RHS to systemJacobian in cSolver; using (scalarFactor_ODE2=-1,scalarFactor_ODE2=0) gives the stiffness matrix (=derivatives of ODE2 coords) in the nODE2 x nODE2 part, while using (scalarFactor_ODE2=0,scalarFactor_ODE2=-1) gives the damping matrix (= derivatives of ODE2 velocity coordinates) in the same part; a superposition of these two parts makes sense for implicit solvers; if , Index computeLoadsJacobian=0, loads are not considered in the Jacobian computation; for , Index computeLoadsJacobian=1 the ODE2 and ODE1 derivatives of loads are included and for , Index computeLoadsJacobian=2, also the ODE2_t dependencies are added", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 0., py::arg("scalarFactor_ODE1") = 1., py::arg("computeLoadsJacobian") = 0)
        .def("ComputeLoadFactor", &MainSolverStatic::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("ComputeMassMatrix", &MainSolverStatic::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass nODE2 x nODE2 matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeNewtonJacobian", &MainSolverStatic::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverStatic::ComputeNewtonResidual, py::return_value_policy::copy, "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverStatic::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("initial") = true)
        .def("ComputeODE2RHS", &MainSolverStatic::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("DiscontinuousIteration", &MainSolverStatic::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverStatic::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverStatic::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("GetAEsize", &MainSolverStatic::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverStatic::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetErrorString", &MainSolverStatic::GetErrorString, py::return_value_policy::copy, "return error string if solver has not been successful")
        .def("GetNewtonSolution", &MainSolverStatic::GetNewtonSolution, py::return_value_policy::copy, "get locally stored / last computed solution (=increment) of Newton")
        .def("GetODE1size", &MainSolverStatic::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetODE2size", &MainSolverStatic::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetSimulationEndTime", &MainSolverStatic::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverStatic::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("GetSystemJacobian", &MainSolverStatic::GetSystemJacobian, py::return_value_policy::copy, "get locally stored / last computed system jacobian of solver")
        .def("GetSystemMassMatrix", &MainSolverStatic::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverStatic::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("HasAutomaticStepSizeControl", &MainSolverStatic::HasAutomaticStepSizeControl, py::return_value_policy::copy, "return true, if solver supports automatic stepsize control, otherwise false", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IncreaseStepSize", &MainSolverStatic::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverStatic::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverStatic::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverStatic::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverStatic::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverStatic::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverStatic::InitializeStep, "initialize static step / time step; Python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsStaticSolver", &MainSolverStatic::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("IsVerboseCheck", &MainSolverStatic::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("Newton", &MainSolverStatic::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverStatic::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverStatic::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverStatic::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("SetSystemJacobian", &MainSolverStatic::SetSystemJacobian, "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE", py::arg("systemJacobian"))
        .def("SetSystemMassMatrix", &MainSolverStatic::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverStatic::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("SolveSteps", &MainSolverStatic::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverStatic::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverStatic::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("VerboseWrite", &MainSolverStatic::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("WriteCoordinatesToFile", &MainSolverStatic::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverStatic::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("__repr__", [](const MainSolverStatic &item) { return "<MainSolverStatic:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverImplicitSecondOrder>(m, "MainSolverImplicitSecondOrder", "MainSolverImplicitSecondOrder class") // AUTO: 
        .def(py::init<>())
        .def_property("conv", &MainSolverImplicitSecondOrder::PyGetConv, &MainSolverImplicitSecondOrder::PySetConv)
        .def_property("it", &MainSolverImplicitSecondOrder::PyGetIt, &MainSolverImplicitSecondOrder::PySetIt)
        .def_property("newton", &MainSolverImplicitSecondOrder::PyGetNewton, &MainSolverImplicitSecondOrder::PySetNewton)
        .def_property("output", &MainSolverImplicitSecondOrder::PyGetOutput, &MainSolverImplicitSecondOrder::PySetOutput)
        .def_property("timer", &MainSolverImplicitSecondOrder::PyGetTimer, &MainSolverImplicitSecondOrder::PySetTimer)
        .def_property("alphaF", &MainSolverImplicitSecondOrder::PyGetAlphaF, &MainSolverImplicitSecondOrder::PySetAlphaF)
        .def_property("alphaM", &MainSolverImplicitSecondOrder::PyGetAlphaM, &MainSolverImplicitSecondOrder::PySetAlphaM)
        .def_property("factJacAlgorithmic", &MainSolverImplicitSecondOrder::PyGetFactJacAlgorithmic, &MainSolverImplicitSecondOrder::PySetFactJacAlgorithmic)
        .def_property("newmarkBeta", &MainSolverImplicitSecondOrder::PyGetNewmarkBeta, &MainSolverImplicitSecondOrder::PySetNewmarkBeta)
        .def_property("newmarkGamma", &MainSolverImplicitSecondOrder::PyGetNewmarkGamma, &MainSolverImplicitSecondOrder::PySetNewmarkGamma)
        .def_property("spectralRadius", &MainSolverImplicitSecondOrder::PyGetSpectralRadius, &MainSolverImplicitSecondOrder::PySetSpectralRadius)
        // AUTO: access functions for MainSolverImplicitSecondOrder
        .def("CheckInitialized", &MainSolverImplicitSecondOrder::CheckInitialized, py::return_value_policy::copy, "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError", py::arg("mainSystem"))
        .def("ComputeAlgebraicEquations", &MainSolverImplicitSecondOrder::ComputeAlgebraicEquations, "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)", py::arg("mainSystem"), py::arg("velocityLevel") = false)
        .def("ComputeJacobianAE", &MainSolverImplicitSecondOrder::ComputeJacobianAE, "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates, ODE2_t (velocity) coordinates and ODE1 coordinates; if velocityLevel == true, the constraints are evaluated at velocity level; the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 0., py::arg("scalarFactor_ODE1") = 1., py::arg("velocityLevel") = false)
        .def("ComputeJacobianODE1RHS", &MainSolverImplicitSecondOrder::ComputeJacobianODE1RHS, "ADD jacobian of ODE1RHS (multiplied with factors for ODE2 and ODE1 coordinates) to the according rows (nODE2:nODE2+nODE1) of the exising systemJacobian in cSolver; it requires a prior call to ComputeJacobianODE2RHS(...); the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 0., py::arg("scalarFactor_ODE1") = 1.)
        .def("ComputeJacobianODE2RHS", &MainSolverImplicitSecondOrder::ComputeJacobianODE2RHS, "set systemJacobian to zero, size = (nODE2+nODE1+nAE) x (nODE2+nODE1+nAE), and add jacobian (multiplied with factors for ODE2 and ODE1 coordinates) of ODE2RHS to systemJacobian in cSolver; using (scalarFactor_ODE2=-1,scalarFactor_ODE2=0) gives the stiffness matrix (=derivatives of ODE2 coords) in the nODE2 x nODE2 part, while using (scalarFactor_ODE2=0,scalarFactor_ODE2=-1) gives the damping matrix (= derivatives of ODE2 velocity coordinates) in the same part; a superposition of these two parts makes sense for implicit solvers; if , Index computeLoadsJacobian=0, loads are not considered in the Jacobian computation; for , Index computeLoadsJacobian=1 the ODE2 and ODE1 derivatives of loads are included and for , Index computeLoadsJacobian=2, also the ODE2_t dependencies are added", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 0., py::arg("scalarFactor_ODE1") = 1., py::arg("computeLoadsJacobian") = 0)
        .def("ComputeLoadFactor", &MainSolverImplicitSecondOrder::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("ComputeMassMatrix", &MainSolverImplicitSecondOrder::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass nODE2 x nODE2 matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeNewtonJacobian", &MainSolverImplicitSecondOrder::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverImplicitSecondOrder::ComputeNewtonResidual, py::return_value_policy::copy, "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverImplicitSecondOrder::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("initial") = true)
        .def("ComputeODE1RHS", &MainSolverImplicitSecondOrder::ComputeODE1RHS, "compute the RHS of ODE1 equations in systemResidual in range(0,nODE1)", py::arg("mainSystem"))
        .def("ComputeODE2RHS", &MainSolverImplicitSecondOrder::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("DiscontinuousIteration", &MainSolverImplicitSecondOrder::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverImplicitSecondOrder::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverImplicitSecondOrder::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("GetAAlgorithmic", &MainSolverImplicitSecondOrder::GetAAlgorithmic, py::return_value_policy::copy, "get locally stored / last computed algorithmic accelerations")
        .def("GetAEsize", &MainSolverImplicitSecondOrder::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverImplicitSecondOrder::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetErrorString", &MainSolverImplicitSecondOrder::GetErrorString, py::return_value_policy::copy, "return error string if solver has not been successful")
        .def("GetNewtonSolution", &MainSolverImplicitSecondOrder::GetNewtonSolution, py::return_value_policy::copy, "get locally stored / last computed solution (=increment) of Newton")
        .def("GetODE1size", &MainSolverImplicitSecondOrder::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetODE2size", &MainSolverImplicitSecondOrder::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetSimulationEndTime", &MainSolverImplicitSecondOrder::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverImplicitSecondOrder::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("GetStartOfStepStateAAlgorithmic", &MainSolverImplicitSecondOrder::GetStartOfStepStateAAlgorithmic, py::return_value_policy::copy, "get locally stored / last computed algorithmic accelerations at start of step")
        .def("GetSystemJacobian", &MainSolverImplicitSecondOrder::GetSystemJacobian, py::return_value_policy::copy, "get locally stored / last computed system jacobian of solver")
        .def("GetSystemMassMatrix", &MainSolverImplicitSecondOrder::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverImplicitSecondOrder::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("HasAutomaticStepSizeControl", &MainSolverImplicitSecondOrder::HasAutomaticStepSizeControl, py::return_value_policy::copy, "return true, if solver supports automatic stepsize control, otherwise false", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IncreaseStepSize", &MainSolverImplicitSecondOrder::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverImplicitSecondOrder::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverImplicitSecondOrder::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverImplicitSecondOrder::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverImplicitSecondOrder::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverImplicitSecondOrder::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverImplicitSecondOrder::InitializeStep, "initialize static step / time step; Python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsStaticSolver", &MainSolverImplicitSecondOrder::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("IsVerboseCheck", &MainSolverImplicitSecondOrder::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("Newton", &MainSolverImplicitSecondOrder::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverImplicitSecondOrder::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostNewton", &MainSolverImplicitSecondOrder::PostNewton, py::return_value_policy::copy, "call PostNewton for all relevant objects (contact, friction, ... iterations); returns error for discontinuous iteration", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverImplicitSecondOrder::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverImplicitSecondOrder::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("SetSystemJacobian", &MainSolverImplicitSecondOrder::SetSystemJacobian, "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE", py::arg("systemJacobian"))
        .def("SetSystemMassMatrix", &MainSolverImplicitSecondOrder::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverImplicitSecondOrder::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("SetUserFunctionComputeNewtonJacobian", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonJacobian, "set user function")
        .def("SetUserFunctionComputeNewtonResidual", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonResidual, "set user function")
        .def("SetUserFunctionComputeNewtonUpdate", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonUpdate, "set user function")
        .def("SetUserFunctionDiscontinuousIteration", &MainSolverImplicitSecondOrder::SetUserFunctionDiscontinuousIteration, "set user function")
        .def("SetUserFunctionFinishStep", &MainSolverImplicitSecondOrder::SetUserFunctionFinishStep, "set user function")
        .def("SetUserFunctionInitializeStep", &MainSolverImplicitSecondOrder::SetUserFunctionInitializeStep, "set user function")
        .def("SetUserFunctionNewton", &MainSolverImplicitSecondOrder::SetUserFunctionNewton, "set user function")
        .def("SetUserFunctionPostNewton", &MainSolverImplicitSecondOrder::SetUserFunctionPostNewton, "set user function")
        .def("SetUserFunctionUpdateCurrentTime", &MainSolverImplicitSecondOrder::SetUserFunctionUpdateCurrentTime, "set user function")
        .def("SolveSteps", &MainSolverImplicitSecondOrder::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverImplicitSecondOrder::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverImplicitSecondOrder::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("VerboseWrite", &MainSolverImplicitSecondOrder::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("WriteCoordinatesToFile", &MainSolverImplicitSecondOrder::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverImplicitSecondOrder::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("__repr__", [](const MainSolverImplicitSecondOrder &item) { return "<MainSolverImplicitSecondOrder:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverExplicit>(m, "MainSolverExplicit", "MainSolverExplicit class") // AUTO: 
        .def(py::init<>())
        .def_property("conv", &MainSolverExplicit::PyGetConv, &MainSolverExplicit::PySetConv)
        .def_property("it", &MainSolverExplicit::PyGetIt, &MainSolverExplicit::PySetIt)
        .def_property("output", &MainSolverExplicit::PyGetOutput, &MainSolverExplicit::PySetOutput)
        .def_property("timer", &MainSolverExplicit::PyGetTimer, &MainSolverExplicit::PySetTimer)
        // AUTO: access functions for MainSolverExplicit
        .def("ComputeLoadFactor", &MainSolverExplicit::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("ComputeMassMatrix", &MainSolverExplicit::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeNewtonJacobian", &MainSolverExplicit::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverExplicit::ComputeNewtonResidual, py::return_value_policy::copy, "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverExplicit::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("initial") = true)
        .def("ComputeODE1RHS", &MainSolverExplicit::ComputeODE1RHS, "compute the RHS of ODE1 equations in systemResidual in range(0,nODE1)", py::arg("mainSystem"))
        .def("ComputeODE2RHS", &MainSolverExplicit::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("DiscontinuousIteration", &MainSolverExplicit::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverExplicit::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverExplicit::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("GetAEsize", &MainSolverExplicit::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverExplicit::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetErrorString", &MainSolverExplicit::GetErrorString, py::return_value_policy::copy, "return error string if solver has not been successful")
        .def("GetMethodOrder", &MainSolverExplicit::GetMethodOrder, py::return_value_policy::reference, "return order of method (higher value in methods with automatic step size, e.g., DOPRI5=5)")
        .def("GetNumberOfStages", &MainSolverExplicit::GetNumberOfStages, py::return_value_policy::reference, "return number of stages in current method")
        .def("GetODE1size", &MainSolverExplicit::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetODE2size", &MainSolverExplicit::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetSimulationEndTime", &MainSolverExplicit::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverExplicit::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("GetSystemMassMatrix", &MainSolverExplicit::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverExplicit::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("HasAutomaticStepSizeControl", &MainSolverExplicit::HasAutomaticStepSizeControl, py::return_value_policy::copy, "return true, if solver supports automatic stepsize control, otherwise false", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IncreaseStepSize", &MainSolverExplicit::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverExplicit::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverExplicit::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverExplicit::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverExplicit::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverExplicit::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverExplicit::InitializeStep, "initialize static step / time step; Python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsStaticSolver", &MainSolverExplicit::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("IsVerboseCheck", &MainSolverExplicit::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("Newton", &MainSolverExplicit::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverExplicit::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverExplicit::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverExplicit::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("SetSystemMassMatrix", &MainSolverExplicit::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverExplicit::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("SolveSteps", &MainSolverExplicit::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverExplicit::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverExplicit::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("VerboseWrite", &MainSolverExplicit::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("WriteCoordinatesToFile", &MainSolverExplicit::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverExplicit::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("__repr__", [](const MainSolverExplicit &item) { return "<MainSolverExplicit:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
