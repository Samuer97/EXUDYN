// AUTO:  ++++++++++++++++++++++
// AUTO:  pybind11 module includes; generated by Johannes Gerstmayr
// AUTO:  last modified = 2022-04-20
// AUTO:  ++++++++++++++++++++++

    //++++++++++++++++++++++++++++++++
    py::class_<BeamSection>(m, "BeamSection", "BeamSection class") // AUTO: 
        .def(py::init<>())
        .def_property("length", &BeamSection::PyGetLength, &BeamSection::PySetLength)
        .def_property("massPerLength", &BeamSection::PyGetMassPerLength, &BeamSection::PySetMassPerLength)
        .def_readwrite("sectionalDampingMatrix", &BeamSection::sectionalDampingMatrix, "member: sectionalDampingMatrix")
        .def_readwrite("sectionalStiffnessMatrix", &BeamSection::sectionalStiffnessMatrix, "member: sectionalStiffnessMatrix")
        // AUTO: access functions for BeamSection
        .def("__repr__", [](const BeamSection &item) { return "<BeamSection:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<BeamSectionGeometry>(m, "BeamSectionGeometry", "BeamSectionGeometry class") // AUTO: 
        .def(py::init<>())
        .def_property("crossSectionRadiusY", &BeamSectionGeometry::PyGetCrossSectionRadiusY, &BeamSectionGeometry::PySetCrossSectionRadiusY)
        .def_property("crossSectionRadiusZ", &BeamSectionGeometry::PyGetCrossSectionRadiusZ, &BeamSectionGeometry::PySetCrossSectionRadiusZ)
        .def_readwrite("crossSectionType", &BeamSectionGeometry::crossSectionType, "member: crossSectionType")
        .def_property("polygonalPoints", &BeamSectionGeometry::PyGetPolygonalPoints, &BeamSectionGeometry::PySetPolygonalPoints)
        // AUTO: access functions for BeamSectionGeometry
        .def("__repr__", [](const BeamSectionGeometry &item) { return "<BeamSectionGeometry:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolutionSettings>(m, "SolutionSettings", "SolutionSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("appendToFile", &SolutionSettings::appendToFile, "member: appendToFile")
        .def_readwrite("binarySolutionFile", &SolutionSettings::binarySolutionFile, "member: binarySolutionFile")
        .def_readwrite("coordinatesSolutionFileName", &SolutionSettings::coordinatesSolutionFileName, "member: coordinatesSolutionFileName")
        .def_readwrite("exportAccelerations", &SolutionSettings::exportAccelerations, "member: exportAccelerations")
        .def_readwrite("exportAlgebraicCoordinates", &SolutionSettings::exportAlgebraicCoordinates, "member: exportAlgebraicCoordinates")
        .def_readwrite("exportDataCoordinates", &SolutionSettings::exportDataCoordinates, "member: exportDataCoordinates")
        .def_readwrite("exportODE1Velocities", &SolutionSettings::exportODE1Velocities, "member: exportODE1Velocities")
        .def_readwrite("exportVelocities", &SolutionSettings::exportVelocities, "member: exportVelocities")
        .def_property("flushFilesDOF", &SolutionSettings::PyGetFlushFilesDOF, &SolutionSettings::PySetFlushFilesDOF)
        .def_readwrite("flushFilesImmediately", &SolutionSettings::flushFilesImmediately, "member: flushFilesImmediately")
        .def_property("outputPrecision", &SolutionSettings::PyGetOutputPrecision, &SolutionSettings::PySetOutputPrecision)
        .def_readwrite("recordImagesInterval", &SolutionSettings::recordImagesInterval, "member: recordImagesInterval")
        .def_readwrite("restartFileName", &SolutionSettings::restartFileName, "member: restartFileName")
        .def_property("restartWritePeriod", &SolutionSettings::PyGetRestartWritePeriod, &SolutionSettings::PySetRestartWritePeriod)
        .def_readwrite("sensorsAppendToFile", &SolutionSettings::sensorsAppendToFile, "member: sensorsAppendToFile")
        .def_readwrite("sensorsWriteFileHeader", &SolutionSettings::sensorsWriteFileHeader, "member: sensorsWriteFileHeader")
        .def_property("sensorsWritePeriod", &SolutionSettings::PyGetSensorsWritePeriod, &SolutionSettings::PySetSensorsWritePeriod)
        .def_readwrite("solutionInformation", &SolutionSettings::solutionInformation, "member: solutionInformation")
        .def_property("solutionWritePeriod", &SolutionSettings::PyGetSolutionWritePeriod, &SolutionSettings::PySetSolutionWritePeriod)
        .def_readwrite("solverInformationFileName", &SolutionSettings::solverInformationFileName, "member: solverInformationFileName")
        .def_readwrite("writeFileFooter", &SolutionSettings::writeFileFooter, "member: writeFileFooter")
        .def_readwrite("writeFileHeader", &SolutionSettings::writeFileHeader, "member: writeFileHeader")
        .def_readwrite("writeRestartFile", &SolutionSettings::writeRestartFile, "member: writeRestartFile")
        .def_readwrite("writeSolutionToFile", &SolutionSettings::writeSolutionToFile, "member: writeSolutionToFile")
        // AUTO: access functions for SolutionSettings
        .def("__repr__", [](const SolutionSettings &item) { return "<SolutionSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<NumericalDifferentiationSettings>(m, "NumericalDifferentiationSettings", "NumericalDifferentiationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("addReferenceCoordinatesToEpsilon", &NumericalDifferentiationSettings::addReferenceCoordinatesToEpsilon, "member: addReferenceCoordinatesToEpsilon")
        .def_readwrite("doSystemWideDifferentiation", &NumericalDifferentiationSettings::doSystemWideDifferentiation, "member: doSystemWideDifferentiation")
        .def_readwrite("forAE", &NumericalDifferentiationSettings::forAE, "member: forAE")
        .def_readwrite("forODE2", &NumericalDifferentiationSettings::forODE2, "member: forODE2")
        .def_readwrite("forODE2connectors", &NumericalDifferentiationSettings::forODE2connectors, "member: forODE2connectors")
        .def_property("minimumCoordinateSize", &NumericalDifferentiationSettings::PyGetMinimumCoordinateSize, &NumericalDifferentiationSettings::PySetMinimumCoordinateSize)
        .def_property("relativeEpsilon", &NumericalDifferentiationSettings::PyGetRelativeEpsilon, &NumericalDifferentiationSettings::PySetRelativeEpsilon)
        // AUTO: access functions for NumericalDifferentiationSettings
        .def("__repr__", [](const NumericalDifferentiationSettings &item) { return "<NumericalDifferentiationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<DiscontinuousSettings>(m, "DiscontinuousSettings", "DiscontinuousSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("ignoreMaxIterations", &DiscontinuousSettings::ignoreMaxIterations, "member: ignoreMaxIterations")
        .def_property("iterationTolerance", &DiscontinuousSettings::PyGetIterationTolerance, &DiscontinuousSettings::PySetIterationTolerance)
        .def_property("maxIterations", &DiscontinuousSettings::PyGetMaxIterations, &DiscontinuousSettings::PySetMaxIterations)
        // AUTO: access functions for DiscontinuousSettings
        .def("__repr__", [](const DiscontinuousSettings &item) { return "<DiscontinuousSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<NewtonSettings>(m, "NewtonSettings", "NewtonSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("numericalDifferentiation", &NewtonSettings::numericalDifferentiation, "member: numericalDifferentiation")
        .def_property("absoluteTolerance", &NewtonSettings::PyGetAbsoluteTolerance, &NewtonSettings::PySetAbsoluteTolerance)
        .def_readwrite("adaptInitialResidual", &NewtonSettings::adaptInitialResidual, "member: adaptInitialResidual")
        .def_property("maximumSolutionNorm", &NewtonSettings::PyGetMaximumSolutionNorm, &NewtonSettings::PySetMaximumSolutionNorm)
        .def_property("maxIterations", &NewtonSettings::PyGetMaxIterations, &NewtonSettings::PySetMaxIterations)
        .def_property("maxModifiedNewtonIterations", &NewtonSettings::PyGetMaxModifiedNewtonIterations, &NewtonSettings::PySetMaxModifiedNewtonIterations)
        .def_property("maxModifiedNewtonRestartIterations", &NewtonSettings::PyGetMaxModifiedNewtonRestartIterations, &NewtonSettings::PySetMaxModifiedNewtonRestartIterations)
        .def_property("modifiedNewtonContractivity", &NewtonSettings::PyGetModifiedNewtonContractivity, &NewtonSettings::PySetModifiedNewtonContractivity)
        .def_readwrite("modifiedNewtonJacUpdatePerStep", &NewtonSettings::modifiedNewtonJacUpdatePerStep, "member: modifiedNewtonJacUpdatePerStep")
        .def_property("newtonResidualMode", &NewtonSettings::PyGetNewtonResidualMode, &NewtonSettings::PySetNewtonResidualMode)
        .def_property("relativeTolerance", &NewtonSettings::PyGetRelativeTolerance, &NewtonSettings::PySetRelativeTolerance)
        .def_readwrite("useModifiedNewton", &NewtonSettings::useModifiedNewton, "member: useModifiedNewton")
        .def_readwrite("useNewtonSolver", &NewtonSettings::useNewtonSolver, "member: useNewtonSolver")
        .def_readwrite("weightTolerancePerCoordinate", &NewtonSettings::weightTolerancePerCoordinate, "member: weightTolerancePerCoordinate")
        // AUTO: access functions for NewtonSettings
        .def("__repr__", [](const NewtonSettings &item) { return "<NewtonSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<GeneralizedAlphaSettings>(m, "GeneralizedAlphaSettings", "GeneralizedAlphaSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("computeInitialAccelerations", &GeneralizedAlphaSettings::computeInitialAccelerations, "member: computeInitialAccelerations")
        .def_property("newmarkBeta", &GeneralizedAlphaSettings::PyGetNewmarkBeta, &GeneralizedAlphaSettings::PySetNewmarkBeta)
        .def_property("newmarkGamma", &GeneralizedAlphaSettings::PyGetNewmarkGamma, &GeneralizedAlphaSettings::PySetNewmarkGamma)
        .def_property("spectralRadius", &GeneralizedAlphaSettings::PyGetSpectralRadius, &GeneralizedAlphaSettings::PySetSpectralRadius)
        .def_readwrite("useIndex2Constraints", &GeneralizedAlphaSettings::useIndex2Constraints, "member: useIndex2Constraints")
        .def_readwrite("useNewmark", &GeneralizedAlphaSettings::useNewmark, "member: useNewmark")
        // AUTO: access functions for GeneralizedAlphaSettings
        .def("__repr__", [](const GeneralizedAlphaSettings &item) { return "<GeneralizedAlphaSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<ExplicitIntegrationSettings>(m, "ExplicitIntegrationSettings", "ExplicitIntegrationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("computeEndOfStepAccelerations", &ExplicitIntegrationSettings::computeEndOfStepAccelerations, "member: computeEndOfStepAccelerations")
        .def_readwrite("dynamicSolverType", &ExplicitIntegrationSettings::dynamicSolverType, "member: dynamicSolverType")
        .def_readwrite("eliminateConstraints", &ExplicitIntegrationSettings::eliminateConstraints, "member: eliminateConstraints")
        .def_readwrite("useLieGroupIntegration", &ExplicitIntegrationSettings::useLieGroupIntegration, "member: useLieGroupIntegration")
        // AUTO: access functions for ExplicitIntegrationSettings
        .def("__repr__", [](const ExplicitIntegrationSettings &item) { return "<ExplicitIntegrationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<TimeIntegrationSettings>(m, "TimeIntegrationSettings", "TimeIntegrationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("discontinuous", &TimeIntegrationSettings::discontinuous, "member: discontinuous")
        .def_readwrite("explicitIntegration", &TimeIntegrationSettings::explicitIntegration, "member: explicitIntegration")
        .def_readwrite("generalizedAlpha", &TimeIntegrationSettings::generalizedAlpha, "member: generalizedAlpha")
        .def_readwrite("newton", &TimeIntegrationSettings::newton, "member: newton")
        .def_property("absoluteTolerance", &TimeIntegrationSettings::PyGetAbsoluteTolerance, &TimeIntegrationSettings::PySetAbsoluteTolerance)
        .def_readwrite("adaptiveStep", &TimeIntegrationSettings::adaptiveStep, "member: adaptiveStep")
        .def_property("adaptiveStepDecrease", &TimeIntegrationSettings::PyGetAdaptiveStepDecrease, &TimeIntegrationSettings::PySetAdaptiveStepDecrease)
        .def_property("adaptiveStepIncrease", &TimeIntegrationSettings::PyGetAdaptiveStepIncrease, &TimeIntegrationSettings::PySetAdaptiveStepIncrease)
        .def_property("adaptiveStepRecoveryIterations", &TimeIntegrationSettings::PyGetAdaptiveStepRecoveryIterations, &TimeIntegrationSettings::PySetAdaptiveStepRecoveryIterations)
        .def_property("adaptiveStepRecoverySteps", &TimeIntegrationSettings::PyGetAdaptiveStepRecoverySteps, &TimeIntegrationSettings::PySetAdaptiveStepRecoverySteps)
        .def_readwrite("automaticStepSize", &TimeIntegrationSettings::automaticStepSize, "member: automaticStepSize")
        .def_property("endTime", &TimeIntegrationSettings::PyGetEndTime, &TimeIntegrationSettings::PySetEndTime)
        .def_property("initialStepSize", &TimeIntegrationSettings::PyGetInitialStepSize, &TimeIntegrationSettings::PySetInitialStepSize)
        .def_property("minimumStepSize", &TimeIntegrationSettings::PyGetMinimumStepSize, &TimeIntegrationSettings::PySetMinimumStepSize)
        .def_property("numberOfSteps", &TimeIntegrationSettings::PyGetNumberOfSteps, &TimeIntegrationSettings::PySetNumberOfSteps)
        .def_property("realtimeFactor", &TimeIntegrationSettings::PyGetRealtimeFactor, &TimeIntegrationSettings::PySetRealtimeFactor)
        .def_property("relativeTolerance", &TimeIntegrationSettings::PyGetRelativeTolerance, &TimeIntegrationSettings::PySetRelativeTolerance)
        .def_readwrite("reuseConstantMassMatrix", &TimeIntegrationSettings::reuseConstantMassMatrix, "member: reuseConstantMassMatrix")
        .def_readwrite("simulateInRealtime", &TimeIntegrationSettings::simulateInRealtime, "member: simulateInRealtime")
        .def_property("startTime", &TimeIntegrationSettings::PyGetStartTime, &TimeIntegrationSettings::PySetStartTime)
        .def_property("stepInformation", &TimeIntegrationSettings::PyGetStepInformation, &TimeIntegrationSettings::PySetStepInformation)
        .def_property("stepSizeMaxIncrease", &TimeIntegrationSettings::PyGetStepSizeMaxIncrease, &TimeIntegrationSettings::PySetStepSizeMaxIncrease)
        .def_property("stepSizeSafety", &TimeIntegrationSettings::PyGetStepSizeSafety, &TimeIntegrationSettings::PySetStepSizeSafety)
        .def_property("verboseMode", &TimeIntegrationSettings::PyGetVerboseMode, &TimeIntegrationSettings::PySetVerboseMode)
        .def_property("verboseModeFile", &TimeIntegrationSettings::PyGetVerboseModeFile, &TimeIntegrationSettings::PySetVerboseModeFile)
        // AUTO: access functions for TimeIntegrationSettings
        .def("__repr__", [](const TimeIntegrationSettings &item) { return "<TimeIntegrationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<StaticSolverSettings>(m, "StaticSolverSettings", "StaticSolverSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("discontinuous", &StaticSolverSettings::discontinuous, "member: discontinuous")
        .def_readwrite("newton", &StaticSolverSettings::newton, "member: newton")
        .def_readwrite("adaptiveStep", &StaticSolverSettings::adaptiveStep, "member: adaptiveStep")
        .def_property("adaptiveStepDecrease", &StaticSolverSettings::PyGetAdaptiveStepDecrease, &StaticSolverSettings::PySetAdaptiveStepDecrease)
        .def_property("adaptiveStepIncrease", &StaticSolverSettings::PyGetAdaptiveStepIncrease, &StaticSolverSettings::PySetAdaptiveStepIncrease)
        .def_property("adaptiveStepRecoveryIterations", &StaticSolverSettings::PyGetAdaptiveStepRecoveryIterations, &StaticSolverSettings::PySetAdaptiveStepRecoveryIterations)
        .def_property("adaptiveStepRecoverySteps", &StaticSolverSettings::PyGetAdaptiveStepRecoverySteps, &StaticSolverSettings::PySetAdaptiveStepRecoverySteps)
        .def_property("loadStepDuration", &StaticSolverSettings::PyGetLoadStepDuration, &StaticSolverSettings::PySetLoadStepDuration)
        .def_readwrite("loadStepGeometric", &StaticSolverSettings::loadStepGeometric, "member: loadStepGeometric")
        .def_property("loadStepGeometricRange", &StaticSolverSettings::PyGetLoadStepGeometricRange, &StaticSolverSettings::PySetLoadStepGeometricRange)
        .def_property("loadStepStart", &StaticSolverSettings::PyGetLoadStepStart, &StaticSolverSettings::PySetLoadStepStart)
        .def_property("minimumStepSize", &StaticSolverSettings::PyGetMinimumStepSize, &StaticSolverSettings::PySetMinimumStepSize)
        .def_property("numberOfLoadSteps", &StaticSolverSettings::PyGetNumberOfLoadSteps, &StaticSolverSettings::PySetNumberOfLoadSteps)
        .def_property("stabilizerODE2term", &StaticSolverSettings::PyGetStabilizerODE2term, &StaticSolverSettings::PySetStabilizerODE2term)
        .def_property("stepInformation", &StaticSolverSettings::PyGetStepInformation, &StaticSolverSettings::PySetStepInformation)
        .def_readwrite("useLoadFactor", &StaticSolverSettings::useLoadFactor, "member: useLoadFactor")
        .def_property("verboseMode", &StaticSolverSettings::PyGetVerboseMode, &StaticSolverSettings::PySetVerboseMode)
        .def_property("verboseModeFile", &StaticSolverSettings::PyGetVerboseModeFile, &StaticSolverSettings::PySetVerboseModeFile)
        // AUTO: access functions for StaticSolverSettings
        .def("__repr__", [](const StaticSolverSettings &item) { return "<StaticSolverSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<LinearSolverSettings>(m, "LinearSolverSettings", "LinearSolverSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("ignoreRedundantConstraints", &LinearSolverSettings::ignoreRedundantConstraints, "member: ignoreRedundantConstraints")
        .def_readwrite("ignoreSingularJacobian", &LinearSolverSettings::ignoreSingularJacobian, "member: ignoreSingularJacobian")
        .def_property("pivotTreshold", &LinearSolverSettings::PyGetPivotTreshold, &LinearSolverSettings::PySetPivotTreshold)
        .def_readwrite("showCausingItems", &LinearSolverSettings::showCausingItems, "member: showCausingItems")
        // AUTO: access functions for LinearSolverSettings
        .def("__repr__", [](const LinearSolverSettings &item) { return "<LinearSolverSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<Parallel>(m, "Parallel", "Parallel class") // AUTO: 
        .def(py::init<>())
        .def_property("numberOfThreads", &Parallel::PyGetNumberOfThreads, &Parallel::PySetNumberOfThreads)
        .def_readwrite("parallelizeJacobians", &Parallel::parallelizeJacobians, "member: parallelizeJacobians")
        .def_readwrite("parallelizeMassMatrix", &Parallel::parallelizeMassMatrix, "member: parallelizeMassMatrix")
        .def_readwrite("parallelizeResiduals", &Parallel::parallelizeResiduals, "member: parallelizeResiduals")
        .def_readwrite("stopThreadsInSerialSections", &Parallel::stopThreadsInSerialSections, "member: stopThreadsInSerialSections")
        .def_readwrite("useMTforSolver", &Parallel::useMTforSolver, "member: useMTforSolver")
        .def_readwrite("useSIMDforSolver", &Parallel::useSIMDforSolver, "member: useSIMDforSolver")
        // AUTO: access functions for Parallel
        .def("__repr__", [](const Parallel &item) { return "<Parallel:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SimulationSettings>(m, "SimulationSettings", "SimulationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("linearSolverSettings", &SimulationSettings::linearSolverSettings, "member: linearSolverSettings")
        .def_readwrite("parallel", &SimulationSettings::parallel, "member: parallel")
        .def_readwrite("solutionSettings", &SimulationSettings::solutionSettings, "member: solutionSettings")
        .def_readwrite("staticSolver", &SimulationSettings::staticSolver, "member: staticSolver")
        .def_readwrite("timeIntegration", &SimulationSettings::timeIntegration, "member: timeIntegration")
        .def_readwrite("cleanUpMemory", &SimulationSettings::cleanUpMemory, "member: cleanUpMemory")
        .def_readwrite("displayComputationTime", &SimulationSettings::displayComputationTime, "member: displayComputationTime")
        .def_readwrite("displayGlobalTimers", &SimulationSettings::displayGlobalTimers, "member: displayGlobalTimers")
        .def_readwrite("displayStatistics", &SimulationSettings::displayStatistics, "member: displayStatistics")
        .def_readwrite("linearSolverType", &SimulationSettings::linearSolverType, "member: linearSolverType")
        .def_property("outputPrecision", &SimulationSettings::PyGetOutputPrecision, &SimulationSettings::PySetOutputPrecision)
        .def_readwrite("pauseAfterEachStep", &SimulationSettings::pauseAfterEachStep, "member: pauseAfterEachStep")
        // AUTO: access functions for SimulationSettings
        .def("__repr__", [](const SimulationSettings &item) { return "<SimulationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionaryWithTypeInfo", [](const SimulationSettings &item) { return EPyUtils::GetDictionaryWithTypeInfo(item); }) //!< AUTO: add read as dictionary with type information access
        .def("SetDictionary", [](SimulationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsGeneral>(m, "VSettingsGeneral", "VSettingsGeneral class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("autoFitScene", &VSettingsGeneral::autoFitScene, "member: autoFitScene")
        .def_property("axesTiling", &VSettingsGeneral::PyGetAxesTiling, &VSettingsGeneral::PySetAxesTiling)
        .def_property("backgroundColor", &VSettingsGeneral::PyGetBackgroundColor, &VSettingsGeneral::PySetBackgroundColor)
        .def_property("backgroundColorBottom", &VSettingsGeneral::PyGetBackgroundColorBottom, &VSettingsGeneral::PySetBackgroundColorBottom)
        .def_property("circleTiling", &VSettingsGeneral::PyGetCircleTiling, &VSettingsGeneral::PySetCircleTiling)
        .def_readwrite("coordinateSystemSize", &VSettingsGeneral::coordinateSystemSize, "member: coordinateSystemSize")
        .def_property("cylinderTiling", &VSettingsGeneral::PyGetCylinderTiling, &VSettingsGeneral::PySetCylinderTiling)
        .def_readwrite("drawCoordinateSystem", &VSettingsGeneral::drawCoordinateSystem, "member: drawCoordinateSystem")
        .def_readwrite("drawWorldBasis", &VSettingsGeneral::drawWorldBasis, "member: drawWorldBasis")
        .def_readwrite("graphicsUpdateInterval", &VSettingsGeneral::graphicsUpdateInterval, "member: graphicsUpdateInterval")
        .def_readwrite("minSceneSize", &VSettingsGeneral::minSceneSize, "member: minSceneSize")
        .def_readwrite("pointSize", &VSettingsGeneral::pointSize, "member: pointSize")
        .def_property("rendererPrecision", &VSettingsGeneral::PyGetRendererPrecision, &VSettingsGeneral::PySetRendererPrecision)
        .def_readwrite("renderWindowString", &VSettingsGeneral::renderWindowString, "member: renderWindowString")
        .def_readwrite("showComputationInfo", &VSettingsGeneral::showComputationInfo, "member: showComputationInfo")
        .def_property("showHelpOnStartup", &VSettingsGeneral::PyGetShowHelpOnStartup, &VSettingsGeneral::PySetShowHelpOnStartup)
        .def_readwrite("showSolutionInformation", &VSettingsGeneral::showSolutionInformation, "member: showSolutionInformation")
        .def_readwrite("showSolverInformation", &VSettingsGeneral::showSolverInformation, "member: showSolverInformation")
        .def_readwrite("showSolverTime", &VSettingsGeneral::showSolverTime, "member: showSolverTime")
        .def_property("sphereTiling", &VSettingsGeneral::PyGetSphereTiling, &VSettingsGeneral::PySetSphereTiling)
        .def_property("textColor", &VSettingsGeneral::PyGetTextColor, &VSettingsGeneral::PySetTextColor)
        .def_readwrite("textSize", &VSettingsGeneral::textSize, "member: textSize")
        .def_readwrite("threadSafeGraphicsUpdate", &VSettingsGeneral::threadSafeGraphicsUpdate, "member: threadSafeGraphicsUpdate")
        .def_readwrite("useBitmapText", &VSettingsGeneral::useBitmapText, "member: useBitmapText")
        .def_readwrite("useGradientBackground", &VSettingsGeneral::useGradientBackground, "member: useGradientBackground")
        .def_readwrite("useMultiThreadedRendering", &VSettingsGeneral::useMultiThreadedRendering, "member: useMultiThreadedRendering")
        .def_readwrite("useWindowsMonitorScaleFactor", &VSettingsGeneral::useWindowsMonitorScaleFactor, "member: useWindowsMonitorScaleFactor")
        .def_readwrite("worldBasisSize", &VSettingsGeneral::worldBasisSize, "member: worldBasisSize")
        // AUTO: access functions for VSettingsGeneral
        .def("__repr__", [](const VSettingsGeneral &item) { return "<VSettingsGeneral:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsContour>(m, "VSettingsContour", "VSettingsContour class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("automaticRange", &VSettingsContour::automaticRange, "member: automaticRange")
        .def_property("colorBarPrecision", &VSettingsContour::PyGetColorBarPrecision, &VSettingsContour::PySetColorBarPrecision)
        .def_property("colorBarTiling", &VSettingsContour::PyGetColorBarTiling, &VSettingsContour::PySetColorBarTiling)
        .def_readwrite("maxValue", &VSettingsContour::maxValue, "member: maxValue")
        .def_readwrite("minValue", &VSettingsContour::minValue, "member: minValue")
        .def_readwrite("nodesColored", &VSettingsContour::nodesColored, "member: nodesColored")
        .def_readwrite("outputVariable", &VSettingsContour::outputVariable, "member: outputVariable")
        .def_readwrite("outputVariableComponent", &VSettingsContour::outputVariableComponent, "member: outputVariableComponent")
        .def_readwrite("reduceRange", &VSettingsContour::reduceRange, "member: reduceRange")
        .def_readwrite("rigidBodiesColored", &VSettingsContour::rigidBodiesColored, "member: rigidBodiesColored")
        .def_readwrite("showColorBar", &VSettingsContour::showColorBar, "member: showColorBar")
        // AUTO: access functions for VSettingsContour
        .def("__repr__", [](const VSettingsContour &item) { return "<VSettingsContour:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsNodes>(m, "VSettingsNodes", "VSettingsNodes class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("basisSize", &VSettingsNodes::basisSize, "member: basisSize")
        .def_property("defaultColor", &VSettingsNodes::PyGetDefaultColor, &VSettingsNodes::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsNodes::defaultSize, "member: defaultSize")
        .def_readwrite("drawNodesAsPoint", &VSettingsNodes::drawNodesAsPoint, "member: drawNodesAsPoint")
        .def_readwrite("show", &VSettingsNodes::show, "member: show")
        .def_readwrite("showBasis", &VSettingsNodes::showBasis, "member: showBasis")
        .def_property("showNodalSlopes", &VSettingsNodes::PyGetShowNodalSlopes, &VSettingsNodes::PySetShowNodalSlopes)
        .def_readwrite("showNumbers", &VSettingsNodes::showNumbers, "member: showNumbers")
        .def_property("tiling", &VSettingsNodes::PyGetTiling, &VSettingsNodes::PySetTiling)
        // AUTO: access functions for VSettingsNodes
        .def("__repr__", [](const VSettingsNodes &item) { return "<VSettingsNodes:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsBeams>(m, "VSettingsBeams", "VSettingsBeams class") // AUTO: 
        .def(py::init<>())
        .def_property("axialTiling", &VSettingsBeams::PyGetAxialTiling, &VSettingsBeams::PySetAxialTiling)
        .def_property("crossSectionTiling", &VSettingsBeams::PyGetCrossSectionTiling, &VSettingsBeams::PySetCrossSectionTiling)
        .def_readwrite("drawVertical", &VSettingsBeams::drawVertical, "member: drawVertical")
        .def_property("drawVerticalColor", &VSettingsBeams::PyGetDrawVerticalColor, &VSettingsBeams::PySetDrawVerticalColor)
        .def_readwrite("drawVerticalFactor", &VSettingsBeams::drawVerticalFactor, "member: drawVerticalFactor")
        .def_readwrite("drawVerticalLines", &VSettingsBeams::drawVerticalLines, "member: drawVerticalLines")
        .def_readwrite("drawVerticalOffset", &VSettingsBeams::drawVerticalOffset, "member: drawVerticalOffset")
        .def_readwrite("drawVerticalValues", &VSettingsBeams::drawVerticalValues, "member: drawVerticalValues")
        .def_readwrite("reducedAxialInterploation", &VSettingsBeams::reducedAxialInterploation, "member: reducedAxialInterploation")
        // AUTO: access functions for VSettingsBeams
        .def("__repr__", [](const VSettingsBeams &item) { return "<VSettingsBeams:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsBodies>(m, "VSettingsBodies", "VSettingsBodies class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("beams", &VSettingsBodies::beams, "member: beams")
        .def_property("defaultColor", &VSettingsBodies::PyGetDefaultColor, &VSettingsBodies::PySetDefaultColor)
        .def_property("defaultSize", &VSettingsBodies::PyGetDefaultSize, &VSettingsBodies::PySetDefaultSize)
        .def_readwrite("deformationScaleFactor", &VSettingsBodies::deformationScaleFactor, "member: deformationScaleFactor")
        .def_readwrite("show", &VSettingsBodies::show, "member: show")
        .def_readwrite("showNumbers", &VSettingsBodies::showNumbers, "member: showNumbers")
        // AUTO: access functions for VSettingsBodies
        .def("__repr__", [](const VSettingsBodies &item) { return "<VSettingsBodies:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsConnectors>(m, "VSettingsConnectors", "VSettingsConnectors class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("contactPointsDefaultSize", &VSettingsConnectors::contactPointsDefaultSize, "member: contactPointsDefaultSize")
        .def_property("defaultColor", &VSettingsConnectors::PyGetDefaultColor, &VSettingsConnectors::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsConnectors::defaultSize, "member: defaultSize")
        .def_readwrite("jointAxesLength", &VSettingsConnectors::jointAxesLength, "member: jointAxesLength")
        .def_readwrite("jointAxesRadius", &VSettingsConnectors::jointAxesRadius, "member: jointAxesRadius")
        .def_readwrite("show", &VSettingsConnectors::show, "member: show")
        .def_readwrite("showContact", &VSettingsConnectors::showContact, "member: showContact")
        .def_readwrite("showJointAxes", &VSettingsConnectors::showJointAxes, "member: showJointAxes")
        .def_readwrite("showNumbers", &VSettingsConnectors::showNumbers, "member: showNumbers")
        .def_property("springNumberOfWindings", &VSettingsConnectors::PyGetSpringNumberOfWindings, &VSettingsConnectors::PySetSpringNumberOfWindings)
        // AUTO: access functions for VSettingsConnectors
        .def("__repr__", [](const VSettingsConnectors &item) { return "<VSettingsConnectors:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsMarkers>(m, "VSettingsMarkers", "VSettingsMarkers class") // AUTO: 
        .def(py::init<>())
        .def_property("defaultColor", &VSettingsMarkers::PyGetDefaultColor, &VSettingsMarkers::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsMarkers::defaultSize, "member: defaultSize")
        .def_readwrite("drawSimplified", &VSettingsMarkers::drawSimplified, "member: drawSimplified")
        .def_readwrite("show", &VSettingsMarkers::show, "member: show")
        .def_readwrite("showNumbers", &VSettingsMarkers::showNumbers, "member: showNumbers")
        // AUTO: access functions for VSettingsMarkers
        .def("__repr__", [](const VSettingsMarkers &item) { return "<VSettingsMarkers:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsLoads>(m, "VSettingsLoads", "VSettingsLoads class") // AUTO: 
        .def(py::init<>())
        .def_property("defaultColor", &VSettingsLoads::PyGetDefaultColor, &VSettingsLoads::PySetDefaultColor)
        .def_readwrite("defaultRadius", &VSettingsLoads::defaultRadius, "member: defaultRadius")
        .def_readwrite("defaultSize", &VSettingsLoads::defaultSize, "member: defaultSize")
        .def_readwrite("drawSimplified", &VSettingsLoads::drawSimplified, "member: drawSimplified")
        .def_readwrite("fixedLoadSize", &VSettingsLoads::fixedLoadSize, "member: fixedLoadSize")
        .def_readwrite("loadSizeFactor", &VSettingsLoads::loadSizeFactor, "member: loadSizeFactor")
        .def_readwrite("show", &VSettingsLoads::show, "member: show")
        .def_readwrite("showNumbers", &VSettingsLoads::showNumbers, "member: showNumbers")
        // AUTO: access functions for VSettingsLoads
        .def("__repr__", [](const VSettingsLoads &item) { return "<VSettingsLoads:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsSensors>(m, "VSettingsSensors", "VSettingsSensors class") // AUTO: 
        .def(py::init<>())
        .def_property("defaultColor", &VSettingsSensors::PyGetDefaultColor, &VSettingsSensors::PySetDefaultColor)
        .def_readwrite("defaultSize", &VSettingsSensors::defaultSize, "member: defaultSize")
        .def_readwrite("drawSimplified", &VSettingsSensors::drawSimplified, "member: drawSimplified")
        .def_readwrite("show", &VSettingsSensors::show, "member: show")
        .def_readwrite("showNumbers", &VSettingsSensors::showNumbers, "member: showNumbers")
        // AUTO: access functions for VSettingsSensors
        .def("__repr__", [](const VSettingsSensors &item) { return "<VSettingsSensors:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsContact>(m, "VSettingsContact", "VSettingsContact class") // AUTO: 
        .def(py::init<>())
        .def_property("colorBoundingBoxes", &VSettingsContact::PyGetColorBoundingBoxes, &VSettingsContact::PySetColorBoundingBoxes)
        .def_property("colorSearchTree", &VSettingsContact::PyGetColorSearchTree, &VSettingsContact::PySetColorSearchTree)
        .def_readwrite("contactForcesFactor", &VSettingsContact::contactForcesFactor, "member: contactForcesFactor")
        .def_readwrite("contactPointsDefaultSize", &VSettingsContact::contactPointsDefaultSize, "member: contactPointsDefaultSize")
        .def_readwrite("showBoundingBoxes", &VSettingsContact::showBoundingBoxes, "member: showBoundingBoxes")
        .def_readwrite("showContactForces", &VSettingsContact::showContactForces, "member: showContactForces")
        .def_readwrite("showContactForcesValues", &VSettingsContact::showContactForcesValues, "member: showContactForcesValues")
        .def_readwrite("showSearchTree", &VSettingsContact::showSearchTree, "member: showSearchTree")
        .def_readwrite("showSearchTreeCells", &VSettingsContact::showSearchTreeCells, "member: showSearchTreeCells")
        // AUTO: access functions for VSettingsContact
        .def("__repr__", [](const VSettingsContact &item) { return "<VSettingsContact:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsWindow>(m, "VSettingsWindow", "VSettingsWindow class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("alwaysOnTop", &VSettingsWindow::alwaysOnTop, "member: alwaysOnTop")
        .def_readwrite("ignoreKeys", &VSettingsWindow::ignoreKeys, "member: ignoreKeys")
        .def_readwrite("keyPressUserFunction", &VSettingsWindow::keyPressUserFunction, "member: keyPressUserFunction")
        .def_readwrite("maximize", &VSettingsWindow::maximize, "member: maximize")
        .def_property("renderWindowSize", &VSettingsWindow::PyGetRenderWindowSize, &VSettingsWindow::PySetRenderWindowSize)
        .def_readwrite("showMouseCoordinates", &VSettingsWindow::showMouseCoordinates, "member: showMouseCoordinates")
        .def_readwrite("showWindow", &VSettingsWindow::showWindow, "member: showWindow")
        .def_property("startupTimeout", &VSettingsWindow::PyGetStartupTimeout, &VSettingsWindow::PySetStartupTimeout)
        // AUTO: access functions for VSettingsWindow
        .def("ResetKeyPressUserFunction", &VSettingsWindow::ResetKeyPressUserFunction, "set keyPressUserFunction to zero (no function); because this cannot be assign to the variable itself")
        .def("__repr__", [](const VSettingsWindow &item) { return "<VSettingsWindow:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsOpenGL>(m, "VSettingsOpenGL", "VSettingsOpenGL class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("drawFaceNormals", &VSettingsOpenGL::drawFaceNormals, "member: drawFaceNormals")
        .def_readwrite("drawNormalsLength", &VSettingsOpenGL::drawNormalsLength, "member: drawNormalsLength")
        .def_readwrite("drawVertexNormals", &VSettingsOpenGL::drawVertexNormals, "member: drawVertexNormals")
        .def_readwrite("enableLight0", &VSettingsOpenGL::enableLight0, "member: enableLight0")
        .def_readwrite("enableLight1", &VSettingsOpenGL::enableLight1, "member: enableLight1")
        .def_readwrite("enableLighting", &VSettingsOpenGL::enableLighting, "member: enableLighting")
        .def_readwrite("facesTransparent", &VSettingsOpenGL::facesTransparent, "member: facesTransparent")
        .def_property("initialCenterPoint", &VSettingsOpenGL::PyGetInitialCenterPoint, &VSettingsOpenGL::PySetInitialCenterPoint)
        .def_readwrite("initialMaxSceneSize", &VSettingsOpenGL::initialMaxSceneSize, "member: initialMaxSceneSize")
        .def_readwrite("initialModelRotation", &VSettingsOpenGL::initialModelRotation, "member: initialModelRotation")
        .def_readwrite("initialZoom", &VSettingsOpenGL::initialZoom, "member: initialZoom")
        .def_readwrite("light0ambient", &VSettingsOpenGL::light0ambient, "member: light0ambient")
        .def_readwrite("light0constantAttenuation", &VSettingsOpenGL::light0constantAttenuation, "member: light0constantAttenuation")
        .def_readwrite("light0diffuse", &VSettingsOpenGL::light0diffuse, "member: light0diffuse")
        .def_readwrite("light0linearAttenuation", &VSettingsOpenGL::light0linearAttenuation, "member: light0linearAttenuation")
        .def_property("light0position", &VSettingsOpenGL::PyGetLight0position, &VSettingsOpenGL::PySetLight0position)
        .def_readwrite("light0quadraticAttenuation", &VSettingsOpenGL::light0quadraticAttenuation, "member: light0quadraticAttenuation")
        .def_readwrite("light0specular", &VSettingsOpenGL::light0specular, "member: light0specular")
        .def_readwrite("light1ambient", &VSettingsOpenGL::light1ambient, "member: light1ambient")
        .def_readwrite("light1constantAttenuation", &VSettingsOpenGL::light1constantAttenuation, "member: light1constantAttenuation")
        .def_readwrite("light1diffuse", &VSettingsOpenGL::light1diffuse, "member: light1diffuse")
        .def_readwrite("light1linearAttenuation", &VSettingsOpenGL::light1linearAttenuation, "member: light1linearAttenuation")
        .def_property("light1position", &VSettingsOpenGL::PyGetLight1position, &VSettingsOpenGL::PySetLight1position)
        .def_readwrite("light1quadraticAttenuation", &VSettingsOpenGL::light1quadraticAttenuation, "member: light1quadraticAttenuation")
        .def_readwrite("light1specular", &VSettingsOpenGL::light1specular, "member: light1specular")
        .def_property("lightModelAmbient", &VSettingsOpenGL::PyGetLightModelAmbient, &VSettingsOpenGL::PySetLightModelAmbient)
        .def_readwrite("lightModelLocalViewer", &VSettingsOpenGL::lightModelLocalViewer, "member: lightModelLocalViewer")
        .def_readwrite("lightModelTwoSide", &VSettingsOpenGL::lightModelTwoSide, "member: lightModelTwoSide")
        .def_readwrite("lineSmooth", &VSettingsOpenGL::lineSmooth, "member: lineSmooth")
        .def_readwrite("lineWidth", &VSettingsOpenGL::lineWidth, "member: lineWidth")
        .def_property("materialAmbientAndDiffuse", &VSettingsOpenGL::PyGetMaterialAmbientAndDiffuse, &VSettingsOpenGL::PySetMaterialAmbientAndDiffuse)
        .def_readwrite("materialShininess", &VSettingsOpenGL::materialShininess, "member: materialShininess")
        .def_property("materialSpecular", &VSettingsOpenGL::PyGetMaterialSpecular, &VSettingsOpenGL::PySetMaterialSpecular)
        .def_property("multiSampling", &VSettingsOpenGL::PyGetMultiSampling, &VSettingsOpenGL::PySetMultiSampling)
        .def_readwrite("shadeModelSmooth", &VSettingsOpenGL::shadeModelSmooth, "member: shadeModelSmooth")
        .def_readwrite("showFaceEdges", &VSettingsOpenGL::showFaceEdges, "member: showFaceEdges")
        .def_readwrite("showFaces", &VSettingsOpenGL::showFaces, "member: showFaces")
        .def_readwrite("showMeshEdges", &VSettingsOpenGL::showMeshEdges, "member: showMeshEdges")
        .def_readwrite("showMeshFaces", &VSettingsOpenGL::showMeshFaces, "member: showMeshFaces")
        .def_readwrite("textLineSmooth", &VSettingsOpenGL::textLineSmooth, "member: textLineSmooth")
        .def_readwrite("textLineWidth", &VSettingsOpenGL::textLineWidth, "member: textLineWidth")
        // AUTO: access functions for VSettingsOpenGL
        .def("__repr__", [](const VSettingsOpenGL &item) { return "<VSettingsOpenGL:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsExportImages>(m, "VSettingsExportImages", "VSettingsExportImages class") // AUTO: 
        .def(py::init<>())
        .def_property("heightAlignment", &VSettingsExportImages::PyGetHeightAlignment, &VSettingsExportImages::PySetHeightAlignment)
        .def_property("saveImageFileCounter", &VSettingsExportImages::PyGetSaveImageFileCounter, &VSettingsExportImages::PySetSaveImageFileCounter)
        .def_readwrite("saveImageFileName", &VSettingsExportImages::saveImageFileName, "member: saveImageFileName")
        .def_readwrite("saveImageFormat", &VSettingsExportImages::saveImageFormat, "member: saveImageFormat")
        .def_readwrite("saveImageSingleFile", &VSettingsExportImages::saveImageSingleFile, "member: saveImageSingleFile")
        .def_property("saveImageTimeOut", &VSettingsExportImages::PyGetSaveImageTimeOut, &VSettingsExportImages::PySetSaveImageTimeOut)
        .def_property("widthAlignment", &VSettingsExportImages::PyGetWidthAlignment, &VSettingsExportImages::PySetWidthAlignment)
        // AUTO: access functions for VSettingsExportImages
        .def("__repr__", [](const VSettingsExportImages &item) { return "<VSettingsExportImages:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsInteractive>(m, "VSettingsInteractive", "VSettingsInteractive class") // AUTO: 
        .def(py::init<>())
        .def_property("highlightColor", &VSettingsInteractive::PyGetHighlightColor, &VSettingsInteractive::PySetHighlightColor)
        .def_readwrite("highlightItemIndex", &VSettingsInteractive::highlightItemIndex, "member: highlightItemIndex")
        .def_readwrite("highlightItemType", &VSettingsInteractive::highlightItemType, "member: highlightItemType")
        .def_property("highlightMbsNumber", &VSettingsInteractive::PyGetHighlightMbsNumber, &VSettingsInteractive::PySetHighlightMbsNumber)
        .def_property("highlightOtherColor", &VSettingsInteractive::PyGetHighlightOtherColor, &VSettingsInteractive::PySetHighlightOtherColor)
        .def_readwrite("joystickScaleRotation", &VSettingsInteractive::joystickScaleRotation, "member: joystickScaleRotation")
        .def_readwrite("joystickScaleTranslation", &VSettingsInteractive::joystickScaleTranslation, "member: joystickScaleTranslation")
        .def_readwrite("keypressRotationStep", &VSettingsInteractive::keypressRotationStep, "member: keypressRotationStep")
        .def_readwrite("keypressTranslationStep", &VSettingsInteractive::keypressTranslationStep, "member: keypressTranslationStep")
        .def_readwrite("mouseMoveRotationFactor", &VSettingsInteractive::mouseMoveRotationFactor, "member: mouseMoveRotationFactor")
        .def_readwrite("selectionLeftMouse", &VSettingsInteractive::selectionLeftMouse, "member: selectionLeftMouse")
        .def_readwrite("selectionRightMouse", &VSettingsInteractive::selectionRightMouse, "member: selectionRightMouse")
        .def_readwrite("useJoystickInput", &VSettingsInteractive::useJoystickInput, "member: useJoystickInput")
        .def_readwrite("zoomStepFactor", &VSettingsInteractive::zoomStepFactor, "member: zoomStepFactor")
        // AUTO: access functions for VSettingsInteractive
        .def("__repr__", [](const VSettingsInteractive &item) { return "<VSettingsInteractive:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VisualizationSettings>(m, "VisualizationSettings", "VisualizationSettings class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("bodies", &VisualizationSettings::bodies, "member: bodies")
        .def_readwrite("connectors", &VisualizationSettings::connectors, "member: connectors")
        .def_readwrite("contact", &VisualizationSettings::contact, "member: contact")
        .def_readwrite("contour", &VisualizationSettings::contour, "member: contour")
        .def_readwrite("exportImages", &VisualizationSettings::exportImages, "member: exportImages")
        .def_readwrite("general", &VisualizationSettings::general, "member: general")
        .def_readwrite("interactive", &VisualizationSettings::interactive, "member: interactive")
        .def_readwrite("loads", &VisualizationSettings::loads, "member: loads")
        .def_readwrite("markers", &VisualizationSettings::markers, "member: markers")
        .def_readwrite("nodes", &VisualizationSettings::nodes, "member: nodes")
        .def_readwrite("openGL", &VisualizationSettings::openGL, "member: openGL")
        .def_readwrite("sensors", &VisualizationSettings::sensors, "member: sensors")
        .def_readwrite("window", &VisualizationSettings::window, "member: window")
        // AUTO: access functions for VisualizationSettings
        .def("__repr__", [](const VisualizationSettings &item) { return "<VisualizationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionaryWithTypeInfo", [](const VisualizationSettings &item) { return EPyUtils::GetDictionaryWithTypeInfo(item); }) //!< AUTO: add read as dictionary with type information access
        .def("SetDictionary", [](VisualizationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<CSolverTimer>(m, "CSolverTimer", "CSolverTimer class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("AERHS", &CSolverTimer::AERHS, "member: AERHS")
        .def_readwrite("errorEstimator", &CSolverTimer::errorEstimator, "member: errorEstimator")
        .def_readwrite("factorization", &CSolverTimer::factorization, "member: factorization")
        .def_readwrite("integrationFormula", &CSolverTimer::integrationFormula, "member: integrationFormula")
        .def_readwrite("jacobianAE", &CSolverTimer::jacobianAE, "member: jacobianAE")
        .def_readwrite("jacobianODE1", &CSolverTimer::jacobianODE1, "member: jacobianODE1")
        .def_readwrite("jacobianODE2", &CSolverTimer::jacobianODE2, "member: jacobianODE2")
        .def_readwrite("jacobianODE2_t", &CSolverTimer::jacobianODE2_t, "member: jacobianODE2_t")
        .def_readwrite("massMatrix", &CSolverTimer::massMatrix, "member: massMatrix")
        .def_readwrite("newtonIncrement", &CSolverTimer::newtonIncrement, "member: newtonIncrement")
        .def_readwrite("ODE1RHS", &CSolverTimer::ODE1RHS, "member: ODE1RHS")
        .def_readwrite("ODE2RHS", &CSolverTimer::ODE2RHS, "member: ODE2RHS")
        .def_readwrite("overhead", &CSolverTimer::overhead, "member: overhead")
        .def_readwrite("python", &CSolverTimer::python, "member: python")
        .def_readwrite("reactionForces", &CSolverTimer::reactionForces, "member: reactionForces")
        .def_readwrite("total", &CSolverTimer::total, "member: total")
        .def_readwrite("totalJacobian", &CSolverTimer::totalJacobian, "member: totalJacobian")
        .def_readwrite("useTimer", &CSolverTimer::useTimer, "member: useTimer")
        .def_readwrite("visualization", &CSolverTimer::visualization, "member: visualization")
        .def_readwrite("writeSolution", &CSolverTimer::writeSolution, "member: writeSolution")
        // AUTO: access functions for CSolverTimer
        .def("Reset", &CSolverTimer::Reset, "reset solver timings to initial state by assigning default values; useSolverTimer sets the useTimer flag")
        .def("StartTimer", &CSolverTimer::StartTimer, "start timer function for a given variable; subtracts current CPU time from value")
        .def("StopTimer", &CSolverTimer::StopTimer, "stop timer function for a given variable; adds current CPU time to value")
        .def("Sum", &CSolverTimer::Sum, py::return_value_policy::copy, "compute sum of all timers (except for those counted multiple, e.g., jacobians")
        .def("ToString", &CSolverTimer::ToString, py::return_value_policy::copy, "converts the current timings to a string")
        .def("__repr__", [](const CSolverTimer &item) { return "<CSolverTimer:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverLocalData>(m, "SolverLocalData", "SolverLocalData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("aAlgorithmic", &SolverLocalData::aAlgorithmic, "member: aAlgorithmic")
        .def_readwrite("nAE", &SolverLocalData::nAE, "member: nAE")
        .def_readwrite("nData", &SolverLocalData::nData, "member: nData")
        .def_readwrite("newtonSolution", &SolverLocalData::newtonSolution, "member: newtonSolution")
        .def_readwrite("nODE1", &SolverLocalData::nODE1, "member: nODE1")
        .def_readwrite("nODE2", &SolverLocalData::nODE2, "member: nODE2")
        .def_readwrite("nSys", &SolverLocalData::nSys, "member: nSys")
        .def_readwrite("startAE", &SolverLocalData::startAE, "member: startAE")
        .def_readwrite("startOfStepStateAAlgorithmic", &SolverLocalData::startOfStepStateAAlgorithmic, "member: startOfStepStateAAlgorithmic")
        .def_readwrite("systemResidual", &SolverLocalData::systemResidual, "member: systemResidual")
        .def_readwrite("temp2ODE2", &SolverLocalData::temp2ODE2, "member: temp2ODE2")
        .def_readwrite("tempODE1F0", &SolverLocalData::tempODE1F0, "member: tempODE1F0")
        .def_readwrite("tempODE1F1", &SolverLocalData::tempODE1F1, "member: tempODE1F1")
        .def_readwrite("tempODE2", &SolverLocalData::tempODE2, "member: tempODE2")
        .def_readwrite("tempODE2F0", &SolverLocalData::tempODE2F0, "member: tempODE2F0")
        .def_readwrite("tempODE2F1", &SolverLocalData::tempODE2F1, "member: tempODE2F1")
        // AUTO: access functions for SolverLocalData
        .def("CleanUpMemory", &SolverLocalData::CleanUpMemory, "if desired, temporary data is cleaned up to safe memory")
        .def("GetLinearSolverType", &SolverLocalData::GetLinearSolverType, py::return_value_policy::copy, "return current linear solver type (dense/sparse)")
        .def("SetLinearSolverType", &SolverLocalData::SetLinearSolverType, "set linear solver type and matrix version: links system matrices to according dense/sparse versions")
        .def("__repr__", [](const SolverLocalData &item) { return "<SolverLocalData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverIterationData>(m, "SolverIterationData", "SolverIterationData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("adaptiveStep", &SolverIterationData::adaptiveStep, "member: adaptiveStep")
        .def_readwrite("automaticStepSize", &SolverIterationData::automaticStepSize, "member: automaticStepSize")
        .def_readwrite("automaticStepSizeError", &SolverIterationData::automaticStepSizeError, "member: automaticStepSizeError")
        .def_readwrite("currentStepIndex", &SolverIterationData::currentStepIndex, "member: currentStepIndex")
        .def_readwrite("currentStepSize", &SolverIterationData::currentStepSize, "member: currentStepSize")
        .def_readwrite("currentTime", &SolverIterationData::currentTime, "member: currentTime")
        .def_readwrite("discontinuousIteration", &SolverIterationData::discontinuousIteration, "member: discontinuousIteration")
        .def_readwrite("discontinuousIterationsCount", &SolverIterationData::discontinuousIterationsCount, "member: discontinuousIterationsCount")
        .def_readwrite("endTime", &SolverIterationData::endTime, "member: endTime")
        .def_readwrite("initialStepSize", &SolverIterationData::initialStepSize, "member: initialStepSize")
        .def_readwrite("lastStepSize", &SolverIterationData::lastStepSize, "member: lastStepSize")
        .def_readwrite("maxStepSize", &SolverIterationData::maxStepSize, "member: maxStepSize")
        .def_readwrite("minStepSize", &SolverIterationData::minStepSize, "member: minStepSize")
        .def_readwrite("newtonJacobiCount", &SolverIterationData::newtonJacobiCount, "member: newtonJacobiCount")
        .def_readwrite("newtonSteps", &SolverIterationData::newtonSteps, "member: newtonSteps")
        .def_readwrite("newtonStepsCount", &SolverIterationData::newtonStepsCount, "member: newtonStepsCount")
        .def_readwrite("numberOfSteps", &SolverIterationData::numberOfSteps, "member: numberOfSteps")
        .def_readwrite("recommendedStepSize", &SolverIterationData::recommendedStepSize, "member: recommendedStepSize")
        .def_readwrite("rejectedAutomaticStepSizeSteps", &SolverIterationData::rejectedAutomaticStepSizeSteps, "member: rejectedAutomaticStepSizeSteps")
        .def_readwrite("rejectedModifiedNewtonSteps", &SolverIterationData::rejectedModifiedNewtonSteps, "member: rejectedModifiedNewtonSteps")
        .def_readwrite("startTime", &SolverIterationData::startTime, "member: startTime")
        // AUTO: access functions for SolverIterationData
        .def("ToString", &SolverIterationData::ToString, py::return_value_policy::copy, "convert iteration statistics to string; used for displayStatistics option")
        .def("__repr__", [](const SolverIterationData &item) { return "<SolverIterationData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverConvergenceData>(m, "SolverConvergenceData", "SolverConvergenceData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("contractivity", &SolverConvergenceData::contractivity, "member: contractivity")
        .def_readwrite("discontinuousIterationError", &SolverConvergenceData::discontinuousIterationError, "member: discontinuousIterationError")
        .def_readwrite("discontinuousIterationSuccessful", &SolverConvergenceData::discontinuousIterationSuccessful, "member: discontinuousIterationSuccessful")
        .def_readwrite("errorCoordinateFactor", &SolverConvergenceData::errorCoordinateFactor, "member: errorCoordinateFactor")
        .def_readwrite("jacobianUpdateRequested", &SolverConvergenceData::jacobianUpdateRequested, "member: jacobianUpdateRequested")
        .def_readwrite("lastResidual", &SolverConvergenceData::lastResidual, "member: lastResidual")
        .def_readwrite("linearSolverCausingRow", &SolverConvergenceData::linearSolverCausingRow, "member: linearSolverCausingRow")
        .def_readwrite("linearSolverFailed", &SolverConvergenceData::linearSolverFailed, "member: linearSolverFailed")
        .def_readwrite("massMatrixNotInvertible", &SolverConvergenceData::massMatrixNotInvertible, "member: massMatrixNotInvertible")
        .def_readwrite("newtonConverged", &SolverConvergenceData::newtonConverged, "member: newtonConverged")
        .def_readwrite("newtonSolutionDiverged", &SolverConvergenceData::newtonSolutionDiverged, "member: newtonSolutionDiverged")
        .def_readwrite("residual", &SolverConvergenceData::residual, "member: residual")
        .def_readwrite("stepReductionFailed", &SolverConvergenceData::stepReductionFailed, "member: stepReductionFailed")
        .def_readwrite("stopNewton", &SolverConvergenceData::stopNewton, "member: stopNewton")
        // AUTO: access functions for SolverConvergenceData
        .def("InitializeData", &SolverConvergenceData::InitializeData, "initialize SolverConvergenceData by assigning default values")
        .def("__repr__", [](const SolverConvergenceData &item) { return "<SolverConvergenceData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverOutputData>(m, "SolverOutputData", "SolverOutputData class") // AUTO: 
        .def(py::init<>())
        .def_readwrite("cpuLastTimePrinted", &SolverOutputData::cpuLastTimePrinted, "member: cpuLastTimePrinted")
        .def_readwrite("cpuStartTime", &SolverOutputData::cpuStartTime, "member: cpuStartTime")
        .def_readwrite("finishedSuccessfully", &SolverOutputData::finishedSuccessfully, "member: finishedSuccessfully")
        .def_readwrite("lastDiscontinuousIterationsCount", &SolverOutputData::lastDiscontinuousIterationsCount, "member: lastDiscontinuousIterationsCount")
        .def_readwrite("lastImageRecorded", &SolverOutputData::lastImageRecorded, "member: lastImageRecorded")
        .def_readwrite("lastNewtonJacobiCount", &SolverOutputData::lastNewtonJacobiCount, "member: lastNewtonJacobiCount")
        .def_readwrite("lastNewtonStepsCount", &SolverOutputData::lastNewtonStepsCount, "member: lastNewtonStepsCount")
        .def_readwrite("lastSensorsWritten", &SolverOutputData::lastSensorsWritten, "member: lastSensorsWritten")
        .def_readwrite("lastSolutionWritten", &SolverOutputData::lastSolutionWritten, "member: lastSolutionWritten")
        .def_readwrite("lastVerboseStepIndex", &SolverOutputData::lastVerboseStepIndex, "member: lastVerboseStepIndex")
        .def_readwrite("sensorValuesTemp", &SolverOutputData::sensorValuesTemp, "member: sensorValuesTemp")
        .def_readwrite("sensorValuesTemp2", &SolverOutputData::sensorValuesTemp2, "member: sensorValuesTemp2")
        .def_readwrite("stepInformation", &SolverOutputData::stepInformation, "member: stepInformation")
        .def_readwrite("verboseMode", &SolverOutputData::verboseMode, "member: verboseMode")
        .def_readwrite("verboseModeFile", &SolverOutputData::verboseModeFile, "member: verboseModeFile")
        .def_readwrite("writeToSolutionFile", &SolverOutputData::writeToSolutionFile, "member: writeToSolutionFile")
        .def_readwrite("writeToSolverFile", &SolverOutputData::writeToSolverFile, "member: writeToSolverFile")
        // AUTO: access functions for SolverOutputData
        .def("InitializeData", &SolverOutputData::InitializeData, "initialize SolverOutputData by assigning default values")
        .def("__repr__", [](const SolverOutputData &item) { return "<SolverOutputData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverFileData>(m, "SolverFileData", "SolverFileData class") // AUTO: 
        .def(py::init<>())
        // AUTO: access functions for SolverFileData
        .def("__repr__", [](const SolverFileData &item) { return "<SolverFileData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverStatic>(m, "MainSolverStatic", "MainSolverStatic class") // AUTO: 
        .def(py::init<>())
        .def_property("conv", &MainSolverStatic::PyGetConv, &MainSolverStatic::PySetConv, py::return_value_policy::reference)
        .def_property("it", &MainSolverStatic::PyGetIt, &MainSolverStatic::PySetIt, py::return_value_policy::reference)
        .def_property("newton", &MainSolverStatic::PyGetNewton, &MainSolverStatic::PySetNewton, py::return_value_policy::reference)
        .def_property("output", &MainSolverStatic::PyGetOutput, &MainSolverStatic::PySetOutput, py::return_value_policy::reference)
        .def_property("timer", &MainSolverStatic::PyGetTimer, &MainSolverStatic::PySetTimer, py::return_value_policy::reference)
        .def_property("loadStepGeometricFactor", &MainSolverStatic::PyGetLoadStepGeometricFactor, &MainSolverStatic::PySetLoadStepGeometricFactor)
        // AUTO: access functions for MainSolverStatic
        .def("CheckInitialized", &MainSolverStatic::CheckInitialized, py::return_value_policy::copy, "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError", py::arg("mainSystem"))
        .def("ComputeAlgebraicEquations", &MainSolverStatic::ComputeAlgebraicEquations, "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)", py::arg("mainSystem"), py::arg("velocityLevel") = false)
        .def("ComputeJacobianAE", &MainSolverStatic::ComputeJacobianAE, "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 1., py::arg("velocityLevel") = false)
        .def("ComputeJacobianODE2RHS", &MainSolverStatic::ComputeJacobianODE2RHS, "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianODE2RHS_t", &MainSolverStatic::ComputeJacobianODE2RHS_t, "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeLoadFactor", &MainSolverStatic::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("ComputeMassMatrix", &MainSolverStatic::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeNewtonJacobian", &MainSolverStatic::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverStatic::ComputeNewtonResidual, py::return_value_policy::copy, "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverStatic::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("initial") = true)
        .def("ComputeODE2RHS", &MainSolverStatic::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("DiscontinuousIteration", &MainSolverStatic::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverStatic::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverStatic::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("GetAEsize", &MainSolverStatic::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverStatic::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetNewtonSolution", &MainSolverStatic::GetNewtonSolution, py::return_value_policy::copy, "get locally stored / last computed solution (=increment) of Newton")
        .def("GetODE1size", &MainSolverStatic::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetODE2size", &MainSolverStatic::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetSimulationEndTime", &MainSolverStatic::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverStatic::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("GetSystemJacobian", &MainSolverStatic::GetSystemJacobian, py::return_value_policy::copy, "get locally stored / last computed system jacobian of solver")
        .def("GetSystemMassMatrix", &MainSolverStatic::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverStatic::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("HasAutomaticStepSizeControl", &MainSolverStatic::HasAutomaticStepSizeControl, py::return_value_policy::copy, "return true, if solver supports automatic stepsize control, otherwise false", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IncreaseStepSize", &MainSolverStatic::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverStatic::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverStatic::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverStatic::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverStatic::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverStatic::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverStatic::InitializeStep, "initialize static step / time step; Python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsStaticSolver", &MainSolverStatic::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("IsVerboseCheck", &MainSolverStatic::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("Newton", &MainSolverStatic::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverStatic::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverStatic::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverStatic::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("SetSystemJacobian", &MainSolverStatic::SetSystemJacobian, "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE", py::arg("systemJacobian"))
        .def("SetSystemMassMatrix", &MainSolverStatic::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverStatic::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("SolveSteps", &MainSolverStatic::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverStatic::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverStatic::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("VerboseWrite", &MainSolverStatic::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("WriteCoordinatesToFile", &MainSolverStatic::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverStatic::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("__repr__", [](const MainSolverStatic &item) { return "<MainSolverStatic:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverImplicitSecondOrder>(m, "MainSolverImplicitSecondOrder", "MainSolverImplicitSecondOrder class") // AUTO: 
        .def(py::init<>())
        .def_property("conv", &MainSolverImplicitSecondOrder::PyGetConv, &MainSolverImplicitSecondOrder::PySetConv, py::return_value_policy::reference)
        .def_property("it", &MainSolverImplicitSecondOrder::PyGetIt, &MainSolverImplicitSecondOrder::PySetIt, py::return_value_policy::reference)
        .def_property("newton", &MainSolverImplicitSecondOrder::PyGetNewton, &MainSolverImplicitSecondOrder::PySetNewton, py::return_value_policy::reference)
        .def_property("output", &MainSolverImplicitSecondOrder::PyGetOutput, &MainSolverImplicitSecondOrder::PySetOutput, py::return_value_policy::reference)
        .def_property("timer", &MainSolverImplicitSecondOrder::PyGetTimer, &MainSolverImplicitSecondOrder::PySetTimer, py::return_value_policy::reference)
        .def_property("alphaF", &MainSolverImplicitSecondOrder::PyGetAlphaF, &MainSolverImplicitSecondOrder::PySetAlphaF)
        .def_property("alphaM", &MainSolverImplicitSecondOrder::PyGetAlphaM, &MainSolverImplicitSecondOrder::PySetAlphaM)
        .def_property("factJacAlgorithmic", &MainSolverImplicitSecondOrder::PyGetFactJacAlgorithmic, &MainSolverImplicitSecondOrder::PySetFactJacAlgorithmic)
        .def_property("newmarkBeta", &MainSolverImplicitSecondOrder::PyGetNewmarkBeta, &MainSolverImplicitSecondOrder::PySetNewmarkBeta)
        .def_property("newmarkGamma", &MainSolverImplicitSecondOrder::PyGetNewmarkGamma, &MainSolverImplicitSecondOrder::PySetNewmarkGamma)
        .def_property("spectralRadius", &MainSolverImplicitSecondOrder::PyGetSpectralRadius, &MainSolverImplicitSecondOrder::PySetSpectralRadius)
        // AUTO: access functions for MainSolverImplicitSecondOrder
        .def("CheckInitialized", &MainSolverImplicitSecondOrder::CheckInitialized, py::return_value_policy::copy, "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError", py::arg("mainSystem"))
        .def("ComputeAlgebraicEquations", &MainSolverImplicitSecondOrder::ComputeAlgebraicEquations, "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)", py::arg("mainSystem"), py::arg("velocityLevel") = false)
        .def("ComputeJacobianAE", &MainSolverImplicitSecondOrder::ComputeJacobianAE, "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 1., py::arg("velocityLevel") = false)
        .def("ComputeJacobianODE2RHS", &MainSolverImplicitSecondOrder::ComputeJacobianODE2RHS, "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianODE2RHS_t", &MainSolverImplicitSecondOrder::ComputeJacobianODE2RHS_t, "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeLoadFactor", &MainSolverImplicitSecondOrder::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("ComputeMassMatrix", &MainSolverImplicitSecondOrder::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeNewtonJacobian", &MainSolverImplicitSecondOrder::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverImplicitSecondOrder::ComputeNewtonResidual, py::return_value_policy::copy, "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverImplicitSecondOrder::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("initial") = true)
        .def("ComputeODE1RHS", &MainSolverImplicitSecondOrder::ComputeODE1RHS, "compute the RHS of ODE1 equations in systemResidual in range(0,nODE1)", py::arg("mainSystem"))
        .def("ComputeODE2RHS", &MainSolverImplicitSecondOrder::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("DiscontinuousIteration", &MainSolverImplicitSecondOrder::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverImplicitSecondOrder::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverImplicitSecondOrder::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("GetAAlgorithmic", &MainSolverImplicitSecondOrder::GetAAlgorithmic, py::return_value_policy::copy, "get locally stored / last computed algorithmic accelerations")
        .def("GetAEsize", &MainSolverImplicitSecondOrder::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverImplicitSecondOrder::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetNewtonSolution", &MainSolverImplicitSecondOrder::GetNewtonSolution, py::return_value_policy::copy, "get locally stored / last computed solution (=increment) of Newton")
        .def("GetODE1size", &MainSolverImplicitSecondOrder::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetODE2size", &MainSolverImplicitSecondOrder::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetSimulationEndTime", &MainSolverImplicitSecondOrder::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverImplicitSecondOrder::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("GetStartOfStepStateAAlgorithmic", &MainSolverImplicitSecondOrder::GetStartOfStepStateAAlgorithmic, py::return_value_policy::copy, "get locally stored / last computed algorithmic accelerations at start of step")
        .def("GetSystemJacobian", &MainSolverImplicitSecondOrder::GetSystemJacobian, py::return_value_policy::copy, "get locally stored / last computed system jacobian of solver")
        .def("GetSystemMassMatrix", &MainSolverImplicitSecondOrder::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverImplicitSecondOrder::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("HasAutomaticStepSizeControl", &MainSolverImplicitSecondOrder::HasAutomaticStepSizeControl, py::return_value_policy::copy, "return true, if solver supports automatic stepsize control, otherwise false", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IncreaseStepSize", &MainSolverImplicitSecondOrder::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverImplicitSecondOrder::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverImplicitSecondOrder::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverImplicitSecondOrder::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverImplicitSecondOrder::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverImplicitSecondOrder::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverImplicitSecondOrder::InitializeStep, "initialize static step / time step; Python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsStaticSolver", &MainSolverImplicitSecondOrder::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("IsVerboseCheck", &MainSolverImplicitSecondOrder::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("Newton", &MainSolverImplicitSecondOrder::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverImplicitSecondOrder::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostNewton", &MainSolverImplicitSecondOrder::PostNewton, py::return_value_policy::copy, "call PostNewton for all relevant objects (contact, friction, ... iterations); returns error for discontinuous iteration", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverImplicitSecondOrder::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverImplicitSecondOrder::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("SetSystemJacobian", &MainSolverImplicitSecondOrder::SetSystemJacobian, "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE", py::arg("systemJacobian"))
        .def("SetSystemMassMatrix", &MainSolverImplicitSecondOrder::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverImplicitSecondOrder::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("SetUserFunctionComputeNewtonJacobian", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonJacobian, "set user function")
        .def("SetUserFunctionComputeNewtonResidual", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonResidual, "set user function")
        .def("SetUserFunctionComputeNewtonUpdate", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonUpdate, "set user function")
        .def("SetUserFunctionDiscontinuousIteration", &MainSolverImplicitSecondOrder::SetUserFunctionDiscontinuousIteration, "set user function")
        .def("SetUserFunctionFinishStep", &MainSolverImplicitSecondOrder::SetUserFunctionFinishStep, "set user function")
        .def("SetUserFunctionInitializeStep", &MainSolverImplicitSecondOrder::SetUserFunctionInitializeStep, "set user function")
        .def("SetUserFunctionNewton", &MainSolverImplicitSecondOrder::SetUserFunctionNewton, "set user function")
        .def("SetUserFunctionPostNewton", &MainSolverImplicitSecondOrder::SetUserFunctionPostNewton, "set user function")
        .def("SetUserFunctionUpdateCurrentTime", &MainSolverImplicitSecondOrder::SetUserFunctionUpdateCurrentTime, "set user function")
        .def("SolveSteps", &MainSolverImplicitSecondOrder::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverImplicitSecondOrder::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverImplicitSecondOrder::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("VerboseWrite", &MainSolverImplicitSecondOrder::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("WriteCoordinatesToFile", &MainSolverImplicitSecondOrder::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverImplicitSecondOrder::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("__repr__", [](const MainSolverImplicitSecondOrder &item) { return "<MainSolverImplicitSecondOrder:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverExplicit>(m, "MainSolverExplicit", "MainSolverExplicit class") // AUTO: 
        .def(py::init<>())
        .def_property("conv", &MainSolverExplicit::PyGetConv, &MainSolverExplicit::PySetConv, py::return_value_policy::reference)
        .def_property("it", &MainSolverExplicit::PyGetIt, &MainSolverExplicit::PySetIt, py::return_value_policy::reference)
        .def_property("output", &MainSolverExplicit::PyGetOutput, &MainSolverExplicit::PySetOutput, py::return_value_policy::reference)
        .def_property("timer", &MainSolverExplicit::PyGetTimer, &MainSolverExplicit::PySetTimer, py::return_value_policy::reference)
        // AUTO: access functions for MainSolverExplicit
        .def("ComputeLoadFactor", &MainSolverExplicit::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("ComputeMassMatrix", &MainSolverExplicit::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeNewtonJacobian", &MainSolverExplicit::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverExplicit::ComputeNewtonResidual, py::return_value_policy::copy, "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverExplicit::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("initial") = true)
        .def("ComputeODE1RHS", &MainSolverExplicit::ComputeODE1RHS, "compute the RHS of ODE1 equations in systemResidual in range(0,nODE1)", py::arg("mainSystem"))
        .def("ComputeODE2RHS", &MainSolverExplicit::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("DiscontinuousIteration", &MainSolverExplicit::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverExplicit::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverExplicit::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("GetAEsize", &MainSolverExplicit::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverExplicit::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetMethodOrder", &MainSolverExplicit::GetMethodOrder, py::return_value_policy::reference, "return order of method (higher value in methods with automatic step size, e.g., DOPRI5=5)")
        .def("GetNumberOfStages", &MainSolverExplicit::GetNumberOfStages, py::return_value_policy::reference, "return number of stages in current method")
        .def("GetODE1size", &MainSolverExplicit::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetODE2size", &MainSolverExplicit::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetSimulationEndTime", &MainSolverExplicit::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverExplicit::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("GetSystemMassMatrix", &MainSolverExplicit::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverExplicit::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("HasAutomaticStepSizeControl", &MainSolverExplicit::HasAutomaticStepSizeControl, py::return_value_policy::copy, "return true, if solver supports automatic stepsize control, otherwise false", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IncreaseStepSize", &MainSolverExplicit::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverExplicit::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverExplicit::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverExplicit::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverExplicit::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverExplicit::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverExplicit::InitializeStep, "initialize static step / time step; Python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsStaticSolver", &MainSolverExplicit::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("IsVerboseCheck", &MainSolverExplicit::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("Newton", &MainSolverExplicit::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverExplicit::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverExplicit::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverExplicit::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("SetSystemMassMatrix", &MainSolverExplicit::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverExplicit::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("SolveSteps", &MainSolverExplicit::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverExplicit::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverExplicit::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("VerboseWrite", &MainSolverExplicit::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("WriteCoordinatesToFile", &MainSolverExplicit::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverExplicit::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("__repr__", [](const MainSolverExplicit &item) { return "<MainSolverExplicit:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
