/** ***********************************************************************************************
* @class        MainObjectJointRollingDiscParameters
* @brief        Parameter class for MainObjectJointRollingDisc
*
* @author       Gerstmayr Johannes
* @date         2019-07-01 (generated)
* @date         2022-12-07  19:53:51 (last modified)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#ifndef MAINOBJECTJOINTROLLINGDISCPARAMETERS__H
#define MAINOBJECTJOINTROLLINGDISCPARAMETERS__H

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include "Autogenerated/CObjectJointRollingDisc.h"

#include "Autogenerated/VisuObjectJointRollingDisc.h"

//! AUTO: Parameters for class MainObjectJointRollingDiscParameters
class MainObjectJointRollingDiscParameters // AUTO: 
{
public: // AUTO: 
};


/** ***********************************************************************************************
* @class        MainObjectJointRollingDisc
* @brief        A joint representing a rolling rigid disc (marker 1) on a flat surface (marker 0, ground body) in global \f$x\f$-\f$y\f$ plane. The contraint is based on an idealized rolling formulation with no slip. The contraints works for discs as long as the disc axis and the plane normal vector are not parallel. It must be assured that the disc has contact to ground in the initial configuration (adjust z-position of body accordingly). The ground body can be a rigid body which is moving. In this case, the flat surface is assumed to be in the \f$x\f$-\f$y\f$-plane at \f$z=0\f$. Note that the rolling body must have the reference point at the center of the disc. NOTE: the cases of normal other than \f$z\f$-direction, wheel axis other than \f$x\f$-axis and moving ground body needs to be tested further, check your results!
*
* @author       Gerstmayr Johannes
* @date         2019-07-01 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "System/ItemIndices.h"

//! AUTO: MainObjectJointRollingDisc
class MainObjectJointRollingDisc: public MainObjectConnector // AUTO: 
{
protected: // AUTO: 
    CObjectJointRollingDisc* cObjectJointRollingDisc; //pointer to computational object (initialized in object factory) AUTO:
    VisualizationObjectJointRollingDisc* visualizationObjectJointRollingDisc; //pointer to computational object (initialized in object factory) AUTO:

public: // AUTO: 
    //! AUTO: default constructor with parameter initialization
    MainObjectJointRollingDisc()
    {
        name = "";
    };

    // AUTO: access functions
    //! AUTO: Get pointer to computational class
    CObjectJointRollingDisc* GetCObjectJointRollingDisc() { return cObjectJointRollingDisc; }
    //! AUTO: Get const pointer to computational class
    const CObjectJointRollingDisc* GetCObjectJointRollingDisc() const { return cObjectJointRollingDisc; }
    //! AUTO: Set pointer to computational class (do this only in object factory!!!)
    void SetCObjectJointRollingDisc(CObjectJointRollingDisc* pCObjectJointRollingDisc) { cObjectJointRollingDisc = pCObjectJointRollingDisc; }

    //! AUTO: Get pointer to visualization class
    VisualizationObjectJointRollingDisc* GetVisualizationObjectJointRollingDisc() { return visualizationObjectJointRollingDisc; }
    //! AUTO: Get const pointer to visualization class
    const VisualizationObjectJointRollingDisc* GetVisualizationObjectJointRollingDisc() const { return visualizationObjectJointRollingDisc; }
    //! AUTO: Set pointer to visualization class (do this only in object factory!!!)
    void SetVisualizationObjectJointRollingDisc(VisualizationObjectJointRollingDisc* pVisualizationObjectJointRollingDisc) { visualizationObjectJointRollingDisc = pVisualizationObjectJointRollingDisc; }

    //! AUTO: Get const pointer to computational base class object
    virtual CObject* GetCObject() const { return cObjectJointRollingDisc; }
    //! AUTO: Set pointer to computational base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetCObject(CObject* pCObject) { cObjectJointRollingDisc = (CObjectJointRollingDisc*)pCObject; }

    //! AUTO: Get const pointer to visualization base class object
    virtual VisualizationObject* GetVisualizationObject() const { return visualizationObjectJointRollingDisc; }
    //! AUTO: Set pointer to visualization base class object (do this only in object factory; type is NOT CHECKED!!!)
    virtual void SetVisualizationObject(VisualizationObject* pVisualizationObject) { visualizationObjectJointRollingDisc = (VisualizationObjectJointRollingDisc*)pVisualizationObject; }

    //! AUTO:  Check consistency prior to CSystem::Assemble(); needs to find all possible violations such that Assemble() would fail
    virtual bool CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const override;

    //! AUTO:  Get type name of object (without keyword 'Object'...!); could also be realized via a string -> type conversion?
    virtual const char* GetTypeName() const override
    {
        return "JointRollingDisc";
    }


    //! AUTO:  dictionary write access
    virtual void SetWithDictionary(const py::dict& d) override
    {
        cObjectJointRollingDisc->GetParameters().markerNumbers = EPyUtils::GetArrayMarkerIndexSafely(d["markerNumbers"]); /* AUTO:  read out dictionary and cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "constrainedAxes")) { cObjectJointRollingDisc->GetParameters().constrainedAxes = py::cast<std::vector<Index>>(d["constrainedAxes"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "activeConnector")) { cObjectJointRollingDisc->GetParameters().activeConnector = py::cast<bool>(d["activeConnector"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        cObjectJointRollingDisc->GetParameters().discRadius = py::cast<Real>(d["discRadius"]); /* AUTO:  read out dictionary and cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "discAxis")) { EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(d, "discAxis", cObjectJointRollingDisc->GetParameters().discAxis); /*! AUTO:  safely cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "planeNormal")) { EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(d, "planeNormal", cObjectJointRollingDisc->GetParameters().planeNormal); /*! AUTO:  safely cast to C++ type*/} 
        EPyUtils::SetStringSafely(d, "name", name); /*! AUTO:  safely cast to C++ type*/
        if (EPyUtils::DictItemExists(d, "Vshow")) { visualizationObjectJointRollingDisc->GetShow() = py::cast<bool>(d["Vshow"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "VdiscWidth")) { visualizationObjectJointRollingDisc->GetDiscWidth() = py::cast<float>(d["VdiscWidth"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        if (EPyUtils::DictItemExists(d, "Vcolor")) { visualizationObjectJointRollingDisc->GetColor() = py::cast<std::vector<float>>(d["Vcolor"]); /* AUTO:  read out dictionary and cast to C++ type*/} 
        GetCObject()->ParametersHaveChanged();
    }

    //! AUTO:  dictionary read access
    virtual py::dict GetDictionary(bool addGraphicsData=false) const override
    {
        auto d = py::dict();
        d["objectType"] = (std::string)GetTypeName();
        d["markerNumbers"] = EPyUtils::GetArrayMarkerIndex(cObjectJointRollingDisc->GetParameters().markerNumbers); //! AUTO: cast variables into python (not needed for standard types) 
        d["constrainedAxes"] = (std::vector<Index>)cObjectJointRollingDisc->GetParameters().constrainedAxes; //! AUTO: cast variables into python (not needed for standard types) 
        d["activeConnector"] = (bool)cObjectJointRollingDisc->GetParameters().activeConnector; //! AUTO: cast variables into python (not needed for standard types) 
        d["discRadius"] = (Real)cObjectJointRollingDisc->GetParameters().discRadius; //! AUTO: cast variables into python (not needed for standard types) 
        d["discAxis"] = EPyUtils::SlimVector2NumPy(cObjectJointRollingDisc->GetParameters().discAxis); //! AUTO: cast variables into python (not needed for standard types) 
        d["planeNormal"] = EPyUtils::SlimVector2NumPy(cObjectJointRollingDisc->GetParameters().planeNormal); //! AUTO: cast variables into python (not needed for standard types) 
        d["name"] = (std::string)name; //! AUTO: cast variables into python (not needed for standard types) 
        d["Vshow"] = (bool)visualizationObjectJointRollingDisc->GetShow(); //! AUTO: cast variables into python (not needed for standard types) 
        d["VdiscWidth"] = (float)visualizationObjectJointRollingDisc->GetDiscWidth(); //! AUTO: cast variables into python (not needed for standard types) 
        d["Vcolor"] = (std::vector<float>)visualizationObjectJointRollingDisc->GetColor(); //! AUTO: cast variables into python (not needed for standard types) 
        return d; 
    }

    //! AUTO:  parameter read access
    virtual py::object GetParameter(const STDstring& parameterName) const override 
    {
        if (parameterName.compare("name") == 0) { return py::cast((std::string)name);} //! AUTO: get parameter
        else if (parameterName.compare("markerNumbers") == 0) { return py::cast(EPyUtils::GetArrayMarkerIndex(cObjectJointRollingDisc->GetParameters().markerNumbers));} //! AUTO: get parameter
        else if (parameterName.compare("constrainedAxes") == 0) { return py::cast((std::vector<Index>)cObjectJointRollingDisc->GetParameters().constrainedAxes);} //! AUTO: get parameter
        else if (parameterName.compare("activeConnector") == 0) { return py::cast((bool)cObjectJointRollingDisc->GetParameters().activeConnector);} //! AUTO: get parameter
        else if (parameterName.compare("discRadius") == 0) { return py::cast((Real)cObjectJointRollingDisc->GetParameters().discRadius);} //! AUTO: get parameter
        else if (parameterName.compare("discAxis") == 0) { return EPyUtils::SlimVector2NumPy(cObjectJointRollingDisc->GetParameters().discAxis);} //! AUTO: get parameter
        else if (parameterName.compare("planeNormal") == 0) { return EPyUtils::SlimVector2NumPy(cObjectJointRollingDisc->GetParameters().planeNormal);} //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { return py::cast((bool)visualizationObjectJointRollingDisc->GetShow());} //! AUTO: get parameter
        else if (parameterName.compare("VdiscWidth") == 0) { return py::cast((float)visualizationObjectJointRollingDisc->GetDiscWidth());} //! AUTO: get parameter
        else if (parameterName.compare("Vcolor") == 0) { return py::cast((std::vector<float>)visualizationObjectJointRollingDisc->GetColor());} //! AUTO: get parameter
        else  {PyError(STDstring("ObjectJointRollingDisc::GetParameter(...): illegal parameter name ")+parameterName+" cannot be read");} // AUTO: add warning for user
        return py::object();
    }


    //! AUTO:  parameter write access
    virtual void SetParameter(const STDstring& parameterName, const py::object& value) override 
    {
        if (parameterName.compare("name") == 0) { EPyUtils::SetStringSafely(value, name); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("markerNumbers") == 0) { cObjectJointRollingDisc->GetParameters().markerNumbers = EPyUtils::GetArrayMarkerIndexSafely(value); /* AUTO:  read out dictionary, check if correct index used and store (converted) Index to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("constrainedAxes") == 0) { cObjectJointRollingDisc->GetParameters().constrainedAxes = py::cast<std::vector<Index>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("activeConnector") == 0) { cObjectJointRollingDisc->GetParameters().activeConnector = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("discRadius") == 0) { cObjectJointRollingDisc->GetParameters().discRadius = py::cast<Real>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("discAxis") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(value, cObjectJointRollingDisc->GetParameters().discAxis); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("planeNormal") == 0) { EPyUtils::SetSlimVectorTemplateSafely<Real, 3>(value, cObjectJointRollingDisc->GetParameters().planeNormal); /*! AUTO:  safely cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("Vshow") == 0) { visualizationObjectJointRollingDisc->GetShow() = py::cast<bool>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("VdiscWidth") == 0) { visualizationObjectJointRollingDisc->GetDiscWidth() = py::cast<float>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else if (parameterName.compare("Vcolor") == 0) { visualizationObjectJointRollingDisc->GetColor() = py::cast<std::vector<float>>(value); /* AUTO:  read out dictionary and cast to C++ type*/; } //! AUTO: get parameter
        else  {PyError(STDstring("ObjectJointRollingDisc::SetParameter(...): illegal parameter name ")+parameterName+" cannot be modified");} // AUTO: add warning for user
        GetCObject()->ParametersHaveChanged();
    }

};



#endif //#ifdef include once...
