// AUTO:  ++++++++++++++++++++++
// AUTO:  Helper file for dictionaries get/set for system structures; generated by Johannes Gerstmayr
// AUTO:  Generated by Johannes Gerstmayr
// AUTO:  Used for SimulationSettings and VisualizationSettings
// AUTO:  last modified = 2025-07-05
// AUTO:  ++++++++++++++++++++++

  #ifndef DICTIONARIESGETSET__H
  #define DICTIONARIESGETSET__H

  #include "Linalg/BasicLinalg.h"
  #include "Main/CSystem.h"
  #include "Autogenerated/SimulationSettings.h"
  #include "Autogenerated/VisualizationSettings.h"

  #include <pybind11/pybind11.h>
  #include <pybind11/stl.h>
  #include <pybind11/stl_bind.h>
  namespace py = pybind11;

  namespace EPyUtils {
 //add namespace for access to dictionaries//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const PyBeamSection& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const PyBeamSection& data) {
    auto structureDict = py::dict();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(PyBeamSection& data, const py::dict& d) {
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const BeamSectionGeometry& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const BeamSectionGeometry& data) {
    auto structureDict = py::dict();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(BeamSectionGeometry& data, const py::dict& d) {
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const SolutionSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.appendToFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, solution and solverInformation is appended to existing file (otherwise created); in BINARY mode, files are always replaced and this parameter is ineffective!";
    structureDict["appendToFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.binarySolutionFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the solution file is written in binary format for improved speed and smaller file sizes; setting outputPrecision >= 8 uses double (8 bytes), otherwise float (4 bytes) is used; note that appendToFile is ineffective and files are always replaced without asking! If not provided, file ending will read .sol in case of binary files and .txt in case of text files";
    structureDict["binarySolutionFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.coordinatesSolutionFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename and (relative) path of solution file (coordinatesSolutionFile) containing all multibody system coordinates versus time; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '_' only; filename ending will be added automatically if not provided: .txt in case of text mode and .sol in case of binary solution files (binarySolutionFile=True)";
    structureDict["coordinatesSolutionFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportAccelerations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add \\hac{ODE2} accelerations to solution file (coordinatesSolutionFile)";
    structureDict["exportAccelerations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportAlgebraicCoordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add algebraicCoordinates (=Lagrange multipliers) to solution file (coordinatesSolutionFile)";
    structureDict["exportAlgebraicCoordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportDataCoordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add DataCoordinates to solution file (coordinatesSolutionFile)";
    structureDict["exportDataCoordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportODE1Velocities;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add coordinatesODE1_t to solution file (coordinatesSolutionFile)";
    structureDict["exportODE1Velocities"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportVelocities;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add \\hac{ODE2} velocities to solution file (coordinatesSolutionFile)";
    structureDict["exportVelocities"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetFlushFilesDOF();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of DOF, above which solution file (coordinatesSolutionFile) buffers are always flushed, irrespectively of whether flushFilesImmediately is set True or False (see also flushFilesImmediately); for larger files, writing takes so much time that flushing does not add considerable time";
    structureDict["flushFilesDOF"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.flushFilesImmediately;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flush file buffers after every solution period written (coordinatesSolutionFile and sensor files); if set False, the output is written through a buffer, which is highly efficient, but during simulation, files may be always in an incomplete state; if set True, this may add a large amount of CPU time as the process waits until files are really written to hard disc (especially for simulation of small scale systems, writing 10.000s of time steps; at least 5us per step/file, depending on hardware)";
    structureDict["flushFilesImmediately"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetOutputPrecision();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "precision for floating point numbers written to solution and sensor files";
    structureDict["outputPrecision"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.recordImagesInterval;
    d["type"] = "Real";
    d["size"] = std::vector<int>{1};
    d["description"] = "record frames (images) during solving: amount of time to wait until next image (frame) is recorded; set recordImages = -1. if no images shall be recorded; set, e.g., recordImages = 0.01 to record an image every 10 milliseconds (requires that the time steps / load steps are sufficiently small!); for file names, etc., see VisualizationSettings.exportImages";
    structureDict["recordImagesInterval"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.restartFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename and (relative) path of text file for storing solution after every restartWritePeriod if writeRestartFile=True; backup file is created with ending .bck, which should be used if restart file is crashed; use Python utility function InitializeFromRestartFile(...) to consistently restart";
    structureDict["restartFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRestartWritePeriod();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "time span (period), determines how often the restart file is updated; this should be often enough to enable restart without too much loss of data; too low values may influence performance";
    structureDict["restartWritePeriod"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsAppendToFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, sensor output is appended to existing file (otherwise created) or in case of internal storage, it is appended to existing currently stored data; this allows storing sensor values over different simulations";
    structureDict["sensorsAppendToFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsStoreAndWriteFiles;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if false, no sensor files will be created and no sensor data will be stored; this may be advantageous for benchmarking as well as for special solvers which should not overwrite existing results (e.g. ComputeODE2Eigenvalues); settings this value to False may cause problems if sensors are required to perform operations which are needed e.g. in UserSensors as input of loads, etc.";
    structureDict["sensorsStoreAndWriteFiles"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsWriteFileFooter;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, file footer is written for sensor output (turn off, e.g. for multiple runs of time integration)";
    structureDict["sensorsWriteFileFooter"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsWriteFileHeader;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, file header is written for sensor output (turn off, e.g. for multiple runs of time integration)";
    structureDict["sensorsWriteFileHeader"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSensorsWritePeriod();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "time span (period), determines how often the sensor output is written to file or internal storage during a simulation";
    structureDict["sensorsWritePeriod"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.solutionInformation;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "special information added to header of solution file (e.g. parameters and settings, modes, ...); character encoding my be UTF-8, restricted to characters in \\refSection{sec:utf8}, but for compatibility, it is recommended to use ASCII characters only (95 characters, see wiki)";
    structureDict["solutionInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSolutionWritePeriod();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "time span (period), determines how often the solution file (coordinatesSolutionFile) is written during a simulation";
    structureDict["solutionWritePeriod"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.solverInformationFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename and (relative) path of text file showing detailed information during solving; detail level according to yourSolver.verboseModeFile; if solutionSettings.appendToFile is true, the information is appended in every solution step; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '_' only";
    structureDict["solverInformationFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeFileFooter;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, information at end of simulation is written: convergence, total solution time, statistics";
    structureDict["writeFileFooter"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeFileHeader;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, file header is written (turn off, e.g. for multiple runs of time integration)";
    structureDict["writeFileHeader"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeInitialValues;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, initial values are exported for the start time; applies to coordinatesSolution and sensor files; this may not be wanted in the append file mode if the initial values are identical to the final values of a previous computation";
    structureDict["writeInitialValues"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeRestartFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false), which determines if restart file is written regularly, see restartFileName for details";
    structureDict["writeRestartFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeSolutionToFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false), which determines if (global) solution vector is written to the solution file (coordinatesSolutionFile); standard quantities that are written are: solution is written as displacements and coordinatesODE1; for additional coordinates in the solution file, see the options below";
    structureDict["writeSolutionToFile"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const SolutionSettings& data) {
    auto structureDict = py::dict();
    structureDict["appendToFile"] = data.appendToFile;
    structureDict["binarySolutionFile"] = data.binarySolutionFile;
    structureDict["coordinatesSolutionFileName"] = data.coordinatesSolutionFileName;
    structureDict["exportAccelerations"] = data.exportAccelerations;
    structureDict["exportAlgebraicCoordinates"] = data.exportAlgebraicCoordinates;
    structureDict["exportDataCoordinates"] = data.exportDataCoordinates;
    structureDict["exportODE1Velocities"] = data.exportODE1Velocities;
    structureDict["exportVelocities"] = data.exportVelocities;
    structureDict["flushFilesDOF"] = data.PyGetFlushFilesDOF();
    structureDict["flushFilesImmediately"] = data.flushFilesImmediately;
    structureDict["outputPrecision"] = data.PyGetOutputPrecision();
    structureDict["recordImagesInterval"] = data.recordImagesInterval;
    structureDict["restartFileName"] = data.restartFileName;
    structureDict["restartWritePeriod"] = data.PyGetRestartWritePeriod();
    structureDict["sensorsAppendToFile"] = data.sensorsAppendToFile;
    structureDict["sensorsStoreAndWriteFiles"] = data.sensorsStoreAndWriteFiles;
    structureDict["sensorsWriteFileFooter"] = data.sensorsWriteFileFooter;
    structureDict["sensorsWriteFileHeader"] = data.sensorsWriteFileHeader;
    structureDict["sensorsWritePeriod"] = data.PyGetSensorsWritePeriod();
    structureDict["solutionInformation"] = data.solutionInformation;
    structureDict["solutionWritePeriod"] = data.PyGetSolutionWritePeriod();
    structureDict["solverInformationFileName"] = data.solverInformationFileName;
    structureDict["writeFileFooter"] = data.writeFileFooter;
    structureDict["writeFileHeader"] = data.writeFileHeader;
    structureDict["writeInitialValues"] = data.writeInitialValues;
    structureDict["writeRestartFile"] = data.writeRestartFile;
    structureDict["writeSolutionToFile"] = data.writeSolutionToFile;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(SolutionSettings& data, const py::dict& d) {
    data.appendToFile = py::cast<bool>(d["appendToFile"]);
    data.binarySolutionFile = py::cast<bool>(d["binarySolutionFile"]);
    data.coordinatesSolutionFileName = py::cast<std::string>(d["coordinatesSolutionFileName"]);
    data.exportAccelerations = py::cast<bool>(d["exportAccelerations"]);
    data.exportAlgebraicCoordinates = py::cast<bool>(d["exportAlgebraicCoordinates"]);
    data.exportDataCoordinates = py::cast<bool>(d["exportDataCoordinates"]);
    data.exportODE1Velocities = py::cast<bool>(d["exportODE1Velocities"]);
    data.exportVelocities = py::cast<bool>(d["exportVelocities"]);
    data.flushFilesDOF = py::cast<Index>(d["flushFilesDOF"]);
    data.flushFilesImmediately = py::cast<bool>(d["flushFilesImmediately"]);
    data.outputPrecision = py::cast<Index>(d["outputPrecision"]);
    data.recordImagesInterval = py::cast<Real>(d["recordImagesInterval"]);
    data.restartFileName = py::cast<std::string>(d["restartFileName"]);
    data.restartWritePeriod = py::cast<Real>(d["restartWritePeriod"]);
    data.sensorsAppendToFile = py::cast<bool>(d["sensorsAppendToFile"]);
    data.sensorsStoreAndWriteFiles = py::cast<bool>(d["sensorsStoreAndWriteFiles"]);
    data.sensorsWriteFileFooter = py::cast<bool>(d["sensorsWriteFileFooter"]);
    data.sensorsWriteFileHeader = py::cast<bool>(d["sensorsWriteFileHeader"]);
    data.sensorsWritePeriod = py::cast<Real>(d["sensorsWritePeriod"]);
    data.solutionInformation = py::cast<std::string>(d["solutionInformation"]);
    data.solutionWritePeriod = py::cast<Real>(d["solutionWritePeriod"]);
    data.solverInformationFileName = py::cast<std::string>(d["solverInformationFileName"]);
    data.writeFileFooter = py::cast<bool>(d["writeFileFooter"]);
    data.writeFileHeader = py::cast<bool>(d["writeFileHeader"]);
    data.writeInitialValues = py::cast<bool>(d["writeInitialValues"]);
    data.writeRestartFile = py::cast<bool>(d["writeRestartFile"]);
    data.writeSolutionToFile = py::cast<bool>(d["writeSolutionToFile"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const NumericalDifferentiationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.addReferenceCoordinatesToEpsilon;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for the size estimation of the differentiation parameter, the reference coordinate q^{Ref}_i is added to \\hac{ODE2} coordinates --> see; False: only the current coordinate is used for size estimation of the differentiation parameter";
    structureDict["addReferenceCoordinatesToEpsilon"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.doSystemWideDifferentiation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: system wide differentiation (e.g. all \\hac{ODE2} equations w.r.t. all \\hac{ODE2} coordinates); False: only local (object) differentiation";
    structureDict["doSystemWideDifferentiation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.forAE;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = perform direct computation of jacobian for algebraic equations (AE), true = use numerical differentiation; as there must always exist an analytical implemented jacobian for AE, 'true' should only be used for verification";
    structureDict["forAE"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.forODE2;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = perform direct computation (e.g., using autodiff) of jacobian for ODE2 equations, true = use numerical differentiation; numerical differentiation is less efficient and may lead to numerical problems, but may smoothen problems of analytical derivatives; sometimes the analytical derivative may neglect terms";
    structureDict["forODE2"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.forODE2connectors;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false: if also forODE2==false, perform direct computation of jacobian for ODE2 terms for connectors; else: use numerical differentiation; NOTE: THIS FLAG IS FOR DEVELOPMENT AND WILL BE ERASED IN FUTURE";
    structureDict["forODE2connectors"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.jacobianConnectorDerivative;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for analytic Jacobians of connectors, the Jacobian derivative is computed, causing additional CPU costs and not beeing available for all connectors or markers (thus switching to numerical differentiation); False: Jacobian derivative is neglected in analytic Jacobians (but included in numerical Jacobians), which often has only minor influence on convergence";
    structureDict["jacobianConnectorDerivative"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMinimumCoordinateSize();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "minimum size of coordinates in relative differentiation parameter";
    structureDict["minimumCoordinateSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRelativeEpsilon();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "relative differentiation parameter epsilon; the numerical differentiation parameter \\varepsilon follows from the formula (\\varepsilon = \\varepsilon_\\mathrm{relative}*max(q_{min}, |q_i + [q^{Ref}_i]|), with \\varepsilon_\\mathrm{relative}=relativeEpsilon, q_{min} = minimumCoordinateSize, q_i is the current coordinate which is differentiated, and qRef_i is the reference coordinate of the current coordinate";
    structureDict["relativeEpsilon"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const NumericalDifferentiationSettings& data) {
    auto structureDict = py::dict();
    structureDict["addReferenceCoordinatesToEpsilon"] = data.addReferenceCoordinatesToEpsilon;
    structureDict["doSystemWideDifferentiation"] = data.doSystemWideDifferentiation;
    structureDict["forAE"] = data.forAE;
    structureDict["forODE2"] = data.forODE2;
    structureDict["forODE2connectors"] = data.forODE2connectors;
    structureDict["jacobianConnectorDerivative"] = data.jacobianConnectorDerivative;
    structureDict["minimumCoordinateSize"] = data.PyGetMinimumCoordinateSize();
    structureDict["relativeEpsilon"] = data.PyGetRelativeEpsilon();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(NumericalDifferentiationSettings& data, const py::dict& d) {
    data.addReferenceCoordinatesToEpsilon = py::cast<bool>(d["addReferenceCoordinatesToEpsilon"]);
    data.doSystemWideDifferentiation = py::cast<bool>(d["doSystemWideDifferentiation"]);
    data.forAE = py::cast<bool>(d["forAE"]);
    data.forODE2 = py::cast<bool>(d["forODE2"]);
    data.forODE2connectors = py::cast<bool>(d["forODE2connectors"]);
    data.jacobianConnectorDerivative = py::cast<bool>(d["jacobianConnectorDerivative"]);
    data.minimumCoordinateSize = py::cast<Real>(d["minimumCoordinateSize"]);
    data.relativeEpsilon = py::cast<Real>(d["relativeEpsilon"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const DiscontinuousSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreMaxIterations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "continue solver if maximum number of discontinuous (post Newton) iterations is reached (ignore tolerance)";
    structureDict["ignoreMaxIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetIterationTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "absolute tolerance for discontinuous (post Newton) iterations; the errors represent absolute residuals and can be quite high";
    structureDict["iterationTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of discontinuous (post Newton) iterations";
    structureDict["maxIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useRecommendedStepSize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "some objects (contact-related) provide a recommendedStepSize; if True, this recommendation is used, but may lead to very small step sizes and solver could fail if restrictions are too hard; set to False to ignore this recommendation";
    structureDict["useRecommendedStepSize"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const DiscontinuousSettings& data) {
    auto structureDict = py::dict();
    structureDict["ignoreMaxIterations"] = data.ignoreMaxIterations;
    structureDict["iterationTolerance"] = data.PyGetIterationTolerance();
    structureDict["maxIterations"] = data.PyGetMaxIterations();
    structureDict["useRecommendedStepSize"] = data.useRecommendedStepSize;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(DiscontinuousSettings& data, const py::dict& d) {
    data.ignoreMaxIterations = py::cast<bool>(d["ignoreMaxIterations"]);
    data.iterationTolerance = py::cast<Real>(d["iterationTolerance"]);
    data.maxIterations = py::cast<Index>(d["maxIterations"]);
    data.useRecommendedStepSize = py::cast<bool>(d["useRecommendedStepSize"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const NewtonSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["numericalDifferentiation"] = GetDictionaryWithTypeInfo(data.numericalDifferentiation);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAbsoluteTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "absolute tolerance of residual for Newton (needed e.g. if residual is fulfilled right at beginning); condition: sqrt(q*q)/numberOfCoordinates <= absoluteTolerance";
    structureDict["absoluteTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.adaptInitialResidual;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = standard; True: if initialResidual is very small (or zero), it may increase significantely in the first Newton iteration; to achieve relativeTolerance, the initialResidual will by updated by a higher residual within the first Newton iteration";
    structureDict["adaptInitialResidual"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaximumSolutionNorm();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "this is the maximum allowed value for solutionU.L2NormSquared() which is the square of the square norm (i.e., value=u_1^2+u_2^2+...), and solutionV/A...; if the norm of solution vectors is larger, Newton method is stopped; the default value is chosen such that it would still work for single precision numbers (float)";
    structureDict["maximumSolutionNorm"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of iterations (including modified + restart Newton iterations); after that total number of iterations, the static/dynamic solver refines the step size or stops with an error";
    structureDict["maxIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxModifiedNewtonIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of iterations for modified Newton (without Jacobian update); after that number of iterations, the modified Newton method gets a jacobian update and is further iterated";
    structureDict["maxModifiedNewtonIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxModifiedNewtonRestartIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of iterations for modified Newton after a Jacobian update; after that number of iterations, the full Newton method is started for this step";
    structureDict["maxModifiedNewtonRestartIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetModifiedNewtonContractivity();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum contractivity (=reduction of error in every Newton iteration) accepted by modified Newton; if contractivity is greater, a Jacobian update is computed";
    structureDict["modifiedNewtonContractivity"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.modifiedNewtonJacUpdatePerStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute Jacobian at every time step (or static step), but not in every Newton iteration (except for bad convergence ==> switch to full Newton)";
    structureDict["modifiedNewtonJacUpdatePerStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNewtonResidualMode();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... use residual for computation of error (standard); 1 ... use \\hac{ODE2} and \\hac{ODE1} newton increment for error (set relTol and absTol to same values!) ==> may be advantageous if residual is zero, e.g., in kinematic analysis; TAKE CARE with this flag";
    structureDict["newtonResidualMode"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRelativeTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "relative tolerance of residual for Newton (general goal of Newton is to decrease the residual by this factor)";
    structureDict["relativeTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useModifiedNewton;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute Jacobian only at first call to solver; the Jacobian (and its factorizations) is not computed in each Newton iteration, even not in every (time integration) step; False: Jacobian (and factorization) is computed in every Newton iteration (default, but may be costly)";
    structureDict["useModifiedNewton"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useNewtonSolver;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = linear computation, true = use Newton solver for nonlinear solution";
    structureDict["useNewtonSolver"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.weightTolerancePerCoordinate;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = compute error as L2-Norm of residual; true = compute error as (L2-Norm of residual) / (sqrt(number of coordinates)), which can help to use common tolerance independent of system size";
    structureDict["weightTolerancePerCoordinate"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const NewtonSettings& data) {
    auto structureDict = py::dict();
    structureDict["numericalDifferentiation"] = GetDictionary(data.numericalDifferentiation);
    structureDict["absoluteTolerance"] = data.PyGetAbsoluteTolerance();
    structureDict["adaptInitialResidual"] = data.adaptInitialResidual;
    structureDict["maximumSolutionNorm"] = data.PyGetMaximumSolutionNorm();
    structureDict["maxIterations"] = data.PyGetMaxIterations();
    structureDict["maxModifiedNewtonIterations"] = data.PyGetMaxModifiedNewtonIterations();
    structureDict["maxModifiedNewtonRestartIterations"] = data.PyGetMaxModifiedNewtonRestartIterations();
    structureDict["modifiedNewtonContractivity"] = data.PyGetModifiedNewtonContractivity();
    structureDict["modifiedNewtonJacUpdatePerStep"] = data.modifiedNewtonJacUpdatePerStep;
    structureDict["newtonResidualMode"] = data.PyGetNewtonResidualMode();
    structureDict["relativeTolerance"] = data.PyGetRelativeTolerance();
    structureDict["useModifiedNewton"] = data.useModifiedNewton;
    structureDict["useNewtonSolver"] = data.useNewtonSolver;
    structureDict["weightTolerancePerCoordinate"] = data.weightTolerancePerCoordinate;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(NewtonSettings& data, const py::dict& d) {
    SetDictionary(data.numericalDifferentiation, py::cast<py::dict>(d["numericalDifferentiation"]));
    data.absoluteTolerance = py::cast<Real>(d["absoluteTolerance"]);
    data.adaptInitialResidual = py::cast<bool>(d["adaptInitialResidual"]);
    data.maximumSolutionNorm = py::cast<Real>(d["maximumSolutionNorm"]);
    data.maxIterations = py::cast<Index>(d["maxIterations"]);
    data.maxModifiedNewtonIterations = py::cast<Index>(d["maxModifiedNewtonIterations"]);
    data.maxModifiedNewtonRestartIterations = py::cast<Index>(d["maxModifiedNewtonRestartIterations"]);
    data.modifiedNewtonContractivity = py::cast<Real>(d["modifiedNewtonContractivity"]);
    data.modifiedNewtonJacUpdatePerStep = py::cast<bool>(d["modifiedNewtonJacUpdatePerStep"]);
    data.newtonResidualMode = py::cast<Index>(d["newtonResidualMode"]);
    data.relativeTolerance = py::cast<Real>(d["relativeTolerance"]);
    data.useModifiedNewton = py::cast<bool>(d["useModifiedNewton"]);
    data.useNewtonSolver = py::cast<bool>(d["useNewtonSolver"]);
    data.weightTolerancePerCoordinate = py::cast<bool>(d["weightTolerancePerCoordinate"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const GeneralizedAlphaSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.computeInitialAccelerations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute initial accelerations from system EOM in acceleration form; NOTE that initial accelerations that are following from user functions in constraints are not considered for now! False: use zero accelerations";
    structureDict["computeInitialAccelerations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lieGroupAddTangentOperator;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for Lie group nodes, in case that lieGroupSimplifiedKinematicRelations=True, the integrator adds the tangent operator for stiffness and constraint matrices, for improved Newton convergence; not available for sparse matrix mode (EigenSparse)";
    structureDict["lieGroupAddTangentOperator"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lieGroupSimplifiedKinematicRelations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for Lie group nodes, the integrator uses the original kinematic relations of the Bruls and Cardona 2010 paper";
    structureDict["lieGroupSimplifiedKinematicRelations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNewmarkBeta();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "value beta for Newmark method; default value beta = \\frac 1 4 corresponds to (undamped) trapezoidal rule";
    structureDict["newmarkBeta"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNewmarkGamma();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "value gamma for Newmark method; default value gamma = \\frac 1 2 corresponds to (undamped) trapezoidal rule";
    structureDict["newmarkGamma"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.resetAccelerations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "this flag only affects if computeInitialAccelerations=False: if resetAccelerations=True, accelerations are set zero in the solver function InitializeSolverInitialConditions; this may be unwanted in case of repeatedly called SolveSteps() and in cases where solutions shall be prolonged from previous computations";
    structureDict["resetAccelerations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSpectralRadius();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "spectral radius for Generalized-alpha solver; set this value to 1 for no damping or to 0 < spectralRadius < 1 for damping of high-frequency dynamics; for position-level constraints (index 3), spectralRadius must be < 1";
    structureDict["spectralRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useIndex2Constraints;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "set useIndex2Constraints = true in order to use index2 (velocity level constraints) formulation";
    structureDict["useIndex2Constraints"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useNewmark;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, use Newmark method with beta and gamma instead of generalized-Alpha";
    structureDict["useNewmark"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const GeneralizedAlphaSettings& data) {
    auto structureDict = py::dict();
    structureDict["computeInitialAccelerations"] = data.computeInitialAccelerations;
    structureDict["lieGroupAddTangentOperator"] = data.lieGroupAddTangentOperator;
    structureDict["lieGroupSimplifiedKinematicRelations"] = data.lieGroupSimplifiedKinematicRelations;
    structureDict["newmarkBeta"] = data.PyGetNewmarkBeta();
    structureDict["newmarkGamma"] = data.PyGetNewmarkGamma();
    structureDict["resetAccelerations"] = data.resetAccelerations;
    structureDict["spectralRadius"] = data.PyGetSpectralRadius();
    structureDict["useIndex2Constraints"] = data.useIndex2Constraints;
    structureDict["useNewmark"] = data.useNewmark;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(GeneralizedAlphaSettings& data, const py::dict& d) {
    data.computeInitialAccelerations = py::cast<bool>(d["computeInitialAccelerations"]);
    data.lieGroupAddTangentOperator = py::cast<bool>(d["lieGroupAddTangentOperator"]);
    data.lieGroupSimplifiedKinematicRelations = py::cast<bool>(d["lieGroupSimplifiedKinematicRelations"]);
    data.newmarkBeta = py::cast<Real>(d["newmarkBeta"]);
    data.newmarkGamma = py::cast<Real>(d["newmarkGamma"]);
    data.resetAccelerations = py::cast<bool>(d["resetAccelerations"]);
    data.spectralRadius = py::cast<Real>(d["spectralRadius"]);
    data.useIndex2Constraints = py::cast<bool>(d["useIndex2Constraints"]);
    data.useNewmark = py::cast<bool>(d["useNewmark"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const ExplicitIntegrationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.computeEndOfStepAccelerations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "accelerations are computed at stages of the explicit integration scheme; if the user needs accelerations at the end of a step, this flag needs to be activated; if True, this causes a second call to the RHS of the equations, which may DOUBLE COMPUTATIONAL COSTS for one-step-methods; if False, the accelerations are re-used from the last stage, being slightly different";
    structureDict["computeEndOfStepAccelerations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.computeMassMatrixInversePerBody;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "If true, the solver assumes the bodies to be independent and computes the inverse of the mass matrix for all bodies independently; this may lead to WRONG RESULTS, if bodies share nodes, e.g., two MassPoint objects put on the same node or a beam with a mass point attached at a shared node; however, it may speed up explicit time integration for large systems significantly (multi-threaded)";
    structureDict["computeMassMatrixInversePerBody"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.dynamicSolverType;
    d["type"] = "DynamicSolverType";
    d["size"] = std::vector<int>{1};
    d["description"] = "selection of explicit solver type (DOPRI5, ExplicitEuler, ExplicitMidpoint, RK44, RK67, VelocityVerlet, ...), for detailed description see DynamicSolverType, \\refSection{sec:DynamicSolverType}, but only referring to explicit solvers.";
    structureDict["dynamicSolverType"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.eliminateConstraints;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: make explicit solver work for simple CoordinateConstraints, which are eliminated for ground constraints (e.g. fixed nodes in finite element models). False: incompatible constraints are ignored (BE CAREFUL)!";
    structureDict["eliminateConstraints"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useLieGroupIntegration;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: use Lie group integration for rigid body nodes; must be turned on for Lie group nodes (without data coordinates) to work properly; does not work for nodes with data coordinates!";
    structureDict["useLieGroupIntegration"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const ExplicitIntegrationSettings& data) {
    auto structureDict = py::dict();
    structureDict["computeEndOfStepAccelerations"] = data.computeEndOfStepAccelerations;
    structureDict["computeMassMatrixInversePerBody"] = data.computeMassMatrixInversePerBody;
    structureDict["dynamicSolverType"] = data.dynamicSolverType;
    structureDict["eliminateConstraints"] = data.eliminateConstraints;
    structureDict["useLieGroupIntegration"] = data.useLieGroupIntegration;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(ExplicitIntegrationSettings& data, const py::dict& d) {
    data.computeEndOfStepAccelerations = py::cast<bool>(d["computeEndOfStepAccelerations"]);
    data.computeMassMatrixInversePerBody = py::cast<bool>(d["computeMassMatrixInversePerBody"]);
    data.dynamicSolverType = py::cast<DynamicSolverType>(d["dynamicSolverType"]);
    data.eliminateConstraints = py::cast<bool>(d["eliminateConstraints"]);
    data.useLieGroupIntegration = py::cast<bool>(d["useLieGroupIntegration"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const TimeIntegrationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["discontinuous"] = GetDictionaryWithTypeInfo(data.discontinuous);
    structureDict["explicitIntegration"] = GetDictionaryWithTypeInfo(data.explicitIntegration);
    structureDict["generalizedAlpha"] = GetDictionaryWithTypeInfo(data.generalizedAlpha);
    structureDict["newton"] = GetDictionaryWithTypeInfo(data.newton);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAbsoluteTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "a_{tol}: if automaticStepSize=True, absolute tolerance for the error control; must fulfill a_{tol} > 0; see \\refSection{sec:ExplicitSolver}";
    structureDict["absoluteTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.adaptiveStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: the step size may be reduced if step fails; no automatic stepsize control";
    structureDict["adaptiveStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepDecrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE: 0 < factor < 1) for step size to decrese due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepDecrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepIncrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE > 1) for step size to increase after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepIncrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepRecoveryIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of max. (Newton iterations + discontinuous iterations) at which a step increase is considered; in order to immediately increase steps after reduction, chose a high value";
    structureDict["adaptiveStepRecoveryIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepRecoverySteps();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of steps needed after which steps will be increased after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepRecoverySteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.automaticStepSize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for specific integrators with error control (e.g., DOPRI5), compute automatic step size based on error estimation; False: constant step size (step may be reduced if adaptiveStep=True); the maximum stepSize reads h = h_{max} = \\frac{t_{end} - t_{start}}{n_{steps}}";
    structureDict["automaticStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetComputeLoadsJacobian();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0:  jacobian of loads not considered (may lead to slow convergence or Newton failure); 1: in case of implicit integrators, compute (numerical) Jacobian of ODE2 and ODE1 coordinates for loads, causing additional computational costs; this is advantageous in cases where loads are related nonlinearly to coordinates; 2: also compute ODE2_t dependencies for jacobian; note that computeLoadsJacobian has no effect in case of doSystemWideDifferentiation, as this anyway includes all load dependencies";
    structureDict["computeLoadsJacobian"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetEndTime();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "t_{end}: end time of time integration";
    structureDict["endTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetInitialStepSize();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "h_{init}: if automaticStepSize=True, initial step size; if initialStepSize==0, max. stepSize, which is (endTime-startTime)/numberOfSteps, is used as initial guess; a good choice of initialStepSize may help the solver to start up faster.";
    structureDict["initialStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMinimumStepSize();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "h_{min}: if automaticStepSize=True or adaptiveStep=True: lower limit of time step size, before integrator stops with adaptiveStep; lower limit of automaticStepSize control (continues but raises warning)";
    structureDict["minimumStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfSteps();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "n_{steps}: number of steps in time integration; (maximum) stepSize h is computed from h = \\frac{t_{end} - t_{start}}{n_{steps}}; for automatic stepsize control, this stepSize is the maximum steps size, h_{max} = h; numberOfSteps can be a float-point type, but must be close to an integer (relative tolerance 100\\cdot\\varepsilon) as it is silently rounded to int";
    structureDict["numberOfSteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRealtimeFactor();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "if simulateInRealtime=True, this factor is used to make the simulation slower than realtime (factor < 1) or faster than realtime (factor > 1)";
    structureDict["realtimeFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRealtimeWaitMicroseconds();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "if simulateInRealtime=True, a loop runs which waits realtimeWaitMicroseconds until checking again if the realtime is reached; using larger values leads to less CPU usage but less accurate realtime accuracy; smaller values (< 1000) increase CPU usage but improve realtime accuracy";
    structureDict["realtimeWaitMicroseconds"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRelativeTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "r_{tol}: if automaticStepSize=True, relative tolerance for the error control; must fulfill r_{tol} \\ge 0; see \\refSection{sec:ExplicitSolver}";
    structureDict["relativeTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.reuseConstantMassMatrix;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: does not recompute constant mass matrices (e.g. of some finite elements, mass points, etc.); if False, it always recomputes the mass matrix (e.g. needed, if user changes mass parameters via Python)";
    structureDict["reuseConstantMassMatrix"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.simulateInRealtime;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: simulate in realtime; the solver waits for computation of the next step until the CPU time reached the simulation time; if the simulation is slower than realtime, it simply continues";
    structureDict["simulateInRealtime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStartTime();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "t_{start}: start time of time integration (usually set to zero)";
    structureDict["startTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepInformation();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "add up the following binary flags: 0 ... show only step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step or period, 4 ... show Newton jacobians (jac) per step or period, 8 ... show discontinuous iterations (Dit) per step or period, 16 ... show step size (dt), 32 ... show CPU time spent; 64 ... show adaptive step reduction warnings; 128 ... show step increase information; 1024 ... show every time step; time is usually shown in fractions of seconds (s), hours (h), or days";
    structureDict["stepInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepSizeMaxIncrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "f_{maxInc}: if automaticStepSize=True, maximum increase of step size per step, see \\refSection{sec:ExplicitSolver}; make this factor smaller (but > 1) if too many rejected steps";
    structureDict["stepSizeMaxIncrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepSizeSafety();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "r_{sfty}: if automaticStepSize=True, a safety factor added to estimated optimal step size, in order to prevent from many rejected steps, see \\refSection{sec:ExplicitSolver}. Make this factor smaller if many steps are rejected.";
    structureDict["stepSizeSafety"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseMode();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... no output, 1 ... show short step information every 2 seconds (every 30 seconds after 1 hour CPU time), 2 ... show every step information, 3 ... show also solution vector, 4 ... show also mass matrix and jacobian (implicit methods), 5 ... show also Jacobian inverse (implicit methods)";
    structureDict["verboseMode"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseModeFile();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "same behaviour as verboseMode, but outputs all solver information to file";
    structureDict["verboseModeFile"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const TimeIntegrationSettings& data) {
    auto structureDict = py::dict();
    structureDict["discontinuous"] = GetDictionary(data.discontinuous);
    structureDict["explicitIntegration"] = GetDictionary(data.explicitIntegration);
    structureDict["generalizedAlpha"] = GetDictionary(data.generalizedAlpha);
    structureDict["newton"] = GetDictionary(data.newton);
    structureDict["absoluteTolerance"] = data.PyGetAbsoluteTolerance();
    structureDict["adaptiveStep"] = data.adaptiveStep;
    structureDict["adaptiveStepDecrease"] = data.PyGetAdaptiveStepDecrease();
    structureDict["adaptiveStepIncrease"] = data.PyGetAdaptiveStepIncrease();
    structureDict["adaptiveStepRecoveryIterations"] = data.PyGetAdaptiveStepRecoveryIterations();
    structureDict["adaptiveStepRecoverySteps"] = data.PyGetAdaptiveStepRecoverySteps();
    structureDict["automaticStepSize"] = data.automaticStepSize;
    structureDict["computeLoadsJacobian"] = data.PyGetComputeLoadsJacobian();
    structureDict["endTime"] = data.PyGetEndTime();
    structureDict["initialStepSize"] = data.PyGetInitialStepSize();
    structureDict["minimumStepSize"] = data.PyGetMinimumStepSize();
    structureDict["numberOfSteps"] = data.PyGetNumberOfSteps();
    structureDict["realtimeFactor"] = data.PyGetRealtimeFactor();
    structureDict["realtimeWaitMicroseconds"] = data.PyGetRealtimeWaitMicroseconds();
    structureDict["relativeTolerance"] = data.PyGetRelativeTolerance();
    structureDict["reuseConstantMassMatrix"] = data.reuseConstantMassMatrix;
    structureDict["simulateInRealtime"] = data.simulateInRealtime;
    structureDict["startTime"] = data.PyGetStartTime();
    structureDict["stepInformation"] = data.PyGetStepInformation();
    structureDict["stepSizeMaxIncrease"] = data.PyGetStepSizeMaxIncrease();
    structureDict["stepSizeSafety"] = data.PyGetStepSizeSafety();
    structureDict["verboseMode"] = data.PyGetVerboseMode();
    structureDict["verboseModeFile"] = data.PyGetVerboseModeFile();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(TimeIntegrationSettings& data, const py::dict& d) {
    SetDictionary(data.discontinuous, py::cast<py::dict>(d["discontinuous"]));
    SetDictionary(data.explicitIntegration, py::cast<py::dict>(d["explicitIntegration"]));
    SetDictionary(data.generalizedAlpha, py::cast<py::dict>(d["generalizedAlpha"]));
    SetDictionary(data.newton, py::cast<py::dict>(d["newton"]));
    data.absoluteTolerance = py::cast<Real>(d["absoluteTolerance"]);
    data.adaptiveStep = py::cast<bool>(d["adaptiveStep"]);
    data.adaptiveStepDecrease = py::cast<Real>(d["adaptiveStepDecrease"]);
    data.adaptiveStepIncrease = py::cast<Real>(d["adaptiveStepIncrease"]);
    data.adaptiveStepRecoveryIterations = py::cast<Index>(d["adaptiveStepRecoveryIterations"]);
    data.adaptiveStepRecoverySteps = py::cast<Index>(d["adaptiveStepRecoverySteps"]);
    data.automaticStepSize = py::cast<bool>(d["automaticStepSize"]);
    data.computeLoadsJacobian = py::cast<Index>(d["computeLoadsJacobian"]);
    data.endTime = py::cast<Real>(d["endTime"]);
    data.initialStepSize = py::cast<Real>(d["initialStepSize"]);
    data.minimumStepSize = py::cast<Real>(d["minimumStepSize"]);
    data.numberOfSteps = py::cast<Real>(d["numberOfSteps"]);
    data.realtimeFactor = py::cast<Real>(d["realtimeFactor"]);
    data.realtimeWaitMicroseconds = py::cast<Index>(d["realtimeWaitMicroseconds"]);
    data.relativeTolerance = py::cast<Real>(d["relativeTolerance"]);
    data.reuseConstantMassMatrix = py::cast<bool>(d["reuseConstantMassMatrix"]);
    data.simulateInRealtime = py::cast<bool>(d["simulateInRealtime"]);
    data.startTime = py::cast<Real>(d["startTime"]);
    data.stepInformation = py::cast<Index>(d["stepInformation"]);
    data.stepSizeMaxIncrease = py::cast<Real>(d["stepSizeMaxIncrease"]);
    data.stepSizeSafety = py::cast<Real>(d["stepSizeSafety"]);
    data.verboseMode = py::cast<Index>(d["verboseMode"]);
    data.verboseModeFile = py::cast<Index>(d["verboseModeFile"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const StaticSolverSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["discontinuous"] = GetDictionaryWithTypeInfo(data.discontinuous);
    structureDict["newton"] = GetDictionaryWithTypeInfo(data.newton);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.adaptiveStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: use step reduction if step fails; False: fixed step size";
    structureDict["adaptiveStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepDecrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE: 0 < factor < 1) for step size to decrese due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepDecrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepIncrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE > 1) for step size to increase after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepIncrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepRecoveryIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of max. (Newton iterations + discontinuous iterations) at which a step increase is considered; in order to immediately increase steps after reduction, chose a high value";
    structureDict["adaptiveStepRecoveryIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepRecoverySteps();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of steps needed after which steps will be increased after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepRecoverySteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.computeLoadsJacobian;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute (currently numerical) Jacobian for loads, causing additional computational costs; this is advantageous in cases where loads are related nonlinearly to coordinates; False: jacobian of loads not considered (may lead to slow convergence or Newton failure); note that computeLoadsJacobian has no effect in case of doSystemWideDifferentiation, as this anyway includes all load dependencies";
    structureDict["computeLoadsJacobian"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.constrainODE1coordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: ODE1coordinates are constrained to initial values; False: undefined behavior, currently not supported";
    structureDict["constrainODE1coordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLoadStepDuration();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "quasi-time for all load steps (added to current time in load steps)";
    structureDict["loadStepDuration"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.loadStepGeometric;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if loadStepGeometric=false, the load steps are incremental (arithmetic series, e.g. 0.1,0.2,0.3,...); if true, the load steps are increased in a geometric series, e.g. for n=8 numberOfLoadSteps and d = 1000 loadStepGeometricRange, it follows: 1000^{1/8}/1000=0.00237, 1000^{2/8}/1000=0.00562, 1000^{3/8}/1000=0.0133, ..., 1000^{7/8}/1000=0.422, 1000^{8/8}/1000=1";
    structureDict["loadStepGeometric"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLoadStepGeometricRange();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "if loadStepGeometric=true, the load steps are increased in a geometric series, see loadStepGeometric";
    structureDict["loadStepGeometricRange"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLoadStepStart();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "a quasi time, which can be used for the output (first column) as well as for time-dependent forces; quasi-time is increased in every step i by loadStepDuration/numberOfLoadSteps; loadStepTime = loadStepStart + i*loadStepDuration/numberOfLoadSteps, but loadStepStart untouched ==> increment by user";
    structureDict["loadStepStart"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMinimumStepSize();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "lower limit of step size, before nonlinear solver stops";
    structureDict["minimumStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfLoadSteps();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of load steps; if numberOfLoadSteps=1, no load steps are used and full forces are applied at once";
    structureDict["numberOfLoadSteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStabilizerODE2term();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "add mass-proportional stabilizer term in \\hac{ODE2} part of jacobian for stabilization (scaled ), e.g. of badly conditioned problems; the diagnoal terms are scaled with stabilizer = (1-loadStepFactor^2), and go to zero at the end of all load steps: loadStepFactor=1 -> stabilizer = 0";
    structureDict["stabilizerODE2term"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepInformation();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "add up the following binary flags: 0 ... show only step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step or period, 4 ... show Newton jacobians (jac) per step or period, 8 ... show discontinuous iterations (Dit) per step or period, 16 ... show step size (dt), 32 ... show CPU time spent; 64 ... show adaptive step reduction warnings; 128 ... show step increase information; 1024 ... show every time step; time is usually shown in fractions of seconds (s), hours (h), or days";
    structureDict["stepInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useLoadFactor;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute a load factor \\in [0,1] from static step time; all loads are scaled by the load factor; False: loads are always scaled with 1 -- use this option if time dependent loads use a userFunction";
    structureDict["useLoadFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseMode();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... no output, 1 ... show errors and load steps, 2 ... show short Newton step information (error), 3 ... show also solution vector, 4 ... show also jacobian, 5 ... show also Jacobian inverse";
    structureDict["verboseMode"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseModeFile();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "same behaviour as verboseMode, but outputs all solver information to file";
    structureDict["verboseModeFile"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const StaticSolverSettings& data) {
    auto structureDict = py::dict();
    structureDict["discontinuous"] = GetDictionary(data.discontinuous);
    structureDict["newton"] = GetDictionary(data.newton);
    structureDict["adaptiveStep"] = data.adaptiveStep;
    structureDict["adaptiveStepDecrease"] = data.PyGetAdaptiveStepDecrease();
    structureDict["adaptiveStepIncrease"] = data.PyGetAdaptiveStepIncrease();
    structureDict["adaptiveStepRecoveryIterations"] = data.PyGetAdaptiveStepRecoveryIterations();
    structureDict["adaptiveStepRecoverySteps"] = data.PyGetAdaptiveStepRecoverySteps();
    structureDict["computeLoadsJacobian"] = data.computeLoadsJacobian;
    structureDict["constrainODE1coordinates"] = data.constrainODE1coordinates;
    structureDict["loadStepDuration"] = data.PyGetLoadStepDuration();
    structureDict["loadStepGeometric"] = data.loadStepGeometric;
    structureDict["loadStepGeometricRange"] = data.PyGetLoadStepGeometricRange();
    structureDict["loadStepStart"] = data.PyGetLoadStepStart();
    structureDict["minimumStepSize"] = data.PyGetMinimumStepSize();
    structureDict["numberOfLoadSteps"] = data.PyGetNumberOfLoadSteps();
    structureDict["stabilizerODE2term"] = data.PyGetStabilizerODE2term();
    structureDict["stepInformation"] = data.PyGetStepInformation();
    structureDict["useLoadFactor"] = data.useLoadFactor;
    structureDict["verboseMode"] = data.PyGetVerboseMode();
    structureDict["verboseModeFile"] = data.PyGetVerboseModeFile();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(StaticSolverSettings& data, const py::dict& d) {
    SetDictionary(data.discontinuous, py::cast<py::dict>(d["discontinuous"]));
    SetDictionary(data.newton, py::cast<py::dict>(d["newton"]));
    data.adaptiveStep = py::cast<bool>(d["adaptiveStep"]);
    data.adaptiveStepDecrease = py::cast<Real>(d["adaptiveStepDecrease"]);
    data.adaptiveStepIncrease = py::cast<Real>(d["adaptiveStepIncrease"]);
    data.adaptiveStepRecoveryIterations = py::cast<Index>(d["adaptiveStepRecoveryIterations"]);
    data.adaptiveStepRecoverySteps = py::cast<Index>(d["adaptiveStepRecoverySteps"]);
    data.computeLoadsJacobian = py::cast<bool>(d["computeLoadsJacobian"]);
    data.constrainODE1coordinates = py::cast<bool>(d["constrainODE1coordinates"]);
    data.loadStepDuration = py::cast<Real>(d["loadStepDuration"]);
    data.loadStepGeometric = py::cast<bool>(d["loadStepGeometric"]);
    data.loadStepGeometricRange = py::cast<Real>(d["loadStepGeometricRange"]);
    data.loadStepStart = py::cast<Real>(d["loadStepStart"]);
    data.minimumStepSize = py::cast<Real>(d["minimumStepSize"]);
    data.numberOfLoadSteps = py::cast<Index>(d["numberOfLoadSteps"]);
    data.stabilizerODE2term = py::cast<Real>(d["stabilizerODE2term"]);
    data.stepInformation = py::cast<Index>(d["stepInformation"]);
    data.useLoadFactor = py::cast<bool>(d["useLoadFactor"]);
    data.verboseMode = py::cast<Index>(d["verboseMode"]);
    data.verboseModeFile = py::cast<Index>(d["verboseModeFile"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const LinearSolverSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreSingularJacobian;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "[ONLY implemented for dense, Eigen matrix mode] False: standard way, fails if jacobian is singular; True: use Eigen's FullPivLU (thus only works with LinearSolverType.EigenDense) which handles over- and underdetermined systems; can often resolve redundant constraints, but MAY ALSO LEAD TO ERRONEOUS RESULTS!";
    structureDict["ignoreSingularJacobian"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetPivotThreshold();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "[ONLY available for EXUdense and EigenDense (FullPivot) solver] threshold for dense linear solver, can be used to detect close to singular solutions, setting this to, e.g., 1e-12; solver then reports on equations that are causing close to singularity";
    structureDict["pivotThreshold"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.reuseAnalyzedPattern;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "[ONLY available for sparse matrices] True: the Eigen SparseLU solver offers the possibility to reuse an analyzed pattern of a previous factorization; this may reduce total factorization time by a factor of 2 or 3, depending on the matrix type; however, if the matrix patterns heavily change between computations, this may even slow down performance; this flag is set for SparseMatrices in InitializeSolverData(...) and should be handled with care!";
    structureDict["reuseAnalyzedPattern"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showCausingItems;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "False: no output, if solver fails; True: if redundant equations appear, they are resolved such that according solution variables are set to zero; in case of redundant constraints, this may help, but it may lead to erroneous behaviour; for static problems, this may suppress static motion or resolve problems in case of instabilities, but should in general be considered with care!";
    structureDict["showCausingItems"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const LinearSolverSettings& data) {
    auto structureDict = py::dict();
    structureDict["ignoreSingularJacobian"] = data.ignoreSingularJacobian;
    structureDict["pivotThreshold"] = data.PyGetPivotThreshold();
    structureDict["reuseAnalyzedPattern"] = data.reuseAnalyzedPattern;
    structureDict["showCausingItems"] = data.showCausingItems;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(LinearSolverSettings& data, const py::dict& d) {
    data.ignoreSingularJacobian = py::cast<bool>(d["ignoreSingularJacobian"]);
    data.pivotThreshold = py::cast<Real>(d["pivotThreshold"]);
    data.reuseAnalyzedPattern = py::cast<bool>(d["reuseAnalyzedPattern"]);
    data.showCausingItems = py::cast<bool>(d["showCausingItems"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const Parallel& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMultithreadedLLimitJacobians();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "compute jacobians (ODE2, AE, ...) multi-threaded; this is the limit number of according objects from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)";
    structureDict["multithreadedLLimitJacobians"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMultithreadedLLimitLoads();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "compute loads multi-threaded; this is the limit number of loads from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)";
    structureDict["multithreadedLLimitLoads"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMultithreadedLLimitMassMatrices();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "compute bodies mass matrices multi-threaded; this is the limit number of bodies from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)";
    structureDict["multithreadedLLimitMassMatrices"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMultithreadedLLimitResiduals();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "compute RHS vectors, AE, and reaction forces multi-threaded; this is the limit number of objects from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)";
    structureDict["multithreadedLLimitResiduals"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfThreads();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of threads used for parallel computation (1 == scalar processing); do not use more threads than available threads (in most cases it is good to restrict to the number of cores); currently, only one solver can be started with multithreading; if you use several mbs in parallel (co-simulation), you should use serial computing";
    structureDict["numberOfThreads"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTaskSplitMinItems();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of items from which on the tasks are split into subtasks (which slightly increases threading performance; this may be critical for smaller number of objects, should be roughly between 50 and 5000; flag is copied into MainSystem internal flag at InitializeSolverData(...)";
    structureDict["taskSplitMinItems"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTaskSplitTasksPerThread();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "this is the number of subtasks that every thread receives; minimum is 1, the maximum should not be larger than 100; this factor is 1 as long as the taskSplitMinItems is not reached; flag is copied into MainSystem internal flag at InitializeSolverData(...)";
    structureDict["taskSplitTasksPerThread"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useLoadBalancing;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, parallel computation uses load balancing, which may give better performance in case of non-equilibrated loads; (mobile) Intel CPUs may perform better without load balancing; this flag is coupled to exudyn.special.solver.multiThreadingLoadBalancing (overwritten when solver starts with multithreading)";
    structureDict["useLoadBalancing"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const Parallel& data) {
    auto structureDict = py::dict();
    structureDict["multithreadedLLimitJacobians"] = data.PyGetMultithreadedLLimitJacobians();
    structureDict["multithreadedLLimitLoads"] = data.PyGetMultithreadedLLimitLoads();
    structureDict["multithreadedLLimitMassMatrices"] = data.PyGetMultithreadedLLimitMassMatrices();
    structureDict["multithreadedLLimitResiduals"] = data.PyGetMultithreadedLLimitResiduals();
    structureDict["numberOfThreads"] = data.PyGetNumberOfThreads();
    structureDict["taskSplitMinItems"] = data.PyGetTaskSplitMinItems();
    structureDict["taskSplitTasksPerThread"] = data.PyGetTaskSplitTasksPerThread();
    structureDict["useLoadBalancing"] = data.useLoadBalancing;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(Parallel& data, const py::dict& d) {
    data.multithreadedLLimitJacobians = py::cast<Index>(d["multithreadedLLimitJacobians"]);
    data.multithreadedLLimitLoads = py::cast<Index>(d["multithreadedLLimitLoads"]);
    data.multithreadedLLimitMassMatrices = py::cast<Index>(d["multithreadedLLimitMassMatrices"]);
    data.multithreadedLLimitResiduals = py::cast<Index>(d["multithreadedLLimitResiduals"]);
    data.numberOfThreads = py::cast<Index>(d["numberOfThreads"]);
    data.taskSplitMinItems = py::cast<Index>(d["taskSplitMinItems"]);
    data.taskSplitTasksPerThread = py::cast<Index>(d["taskSplitTasksPerThread"]);
    data.useLoadBalancing = py::cast<bool>(d["useLoadBalancing"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const SimulationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["linearSolverSettings"] = GetDictionaryWithTypeInfo(data.linearSolverSettings);
    structureDict["parallel"] = GetDictionaryWithTypeInfo(data.parallel);
    structureDict["solutionSettings"] = GetDictionaryWithTypeInfo(data.solutionSettings);
    structureDict["staticSolver"] = GetDictionaryWithTypeInfo(data.staticSolver);
    structureDict["timeIntegration"] = GetDictionaryWithTypeInfo(data.timeIntegration);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.cleanUpMemory;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: solvers will free memory at exit (recommended for large systems); False: keep allocated memory for repeated computations to increase performance";
    structureDict["cleanUpMemory"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.displayComputationTime;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "display computation time statistics at end of solving";
    structureDict["displayComputationTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.displayGlobalTimers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "display global timer statistics at end of solving (e.g., for contact, but also for internal timings during development)";
    structureDict["displayGlobalTimers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.displayStatistics;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "display general computation information at end of time step (steps, iterations, function calls, step rejections, ...";
    structureDict["displayStatistics"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.linearSolverType;
    d["type"] = "LinearSolverType";
    d["size"] = std::vector<int>{1};
    d["description"] = "selection of numerical linear solver: exu.LinearSolverType.EXUdense (dense matrix inverse), exu.LinearSolverType.EigenSparse (sparse matrix LU-factorization), ... (enumeration type)";
    structureDict["linearSolverType"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetOutputPrecision();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "precision for floating point numbers written to console; e.g. values written by solver";
    structureDict["outputPrecision"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.pauseAfterEachStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "pause after every time step or static load step(user press SPACE)";
    structureDict["pauseAfterEachStep"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const SimulationSettings& data) {
    auto structureDict = py::dict();
    structureDict["linearSolverSettings"] = GetDictionary(data.linearSolverSettings);
    structureDict["parallel"] = GetDictionary(data.parallel);
    structureDict["solutionSettings"] = GetDictionary(data.solutionSettings);
    structureDict["staticSolver"] = GetDictionary(data.staticSolver);
    structureDict["timeIntegration"] = GetDictionary(data.timeIntegration);
    structureDict["cleanUpMemory"] = data.cleanUpMemory;
    structureDict["displayComputationTime"] = data.displayComputationTime;
    structureDict["displayGlobalTimers"] = data.displayGlobalTimers;
    structureDict["displayStatistics"] = data.displayStatistics;
    structureDict["linearSolverType"] = data.linearSolverType;
    structureDict["outputPrecision"] = data.PyGetOutputPrecision();
    structureDict["pauseAfterEachStep"] = data.pauseAfterEachStep;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(SimulationSettings& data, const py::dict& d) {
    SetDictionary(data.linearSolverSettings, py::cast<py::dict>(d["linearSolverSettings"]));
    SetDictionary(data.parallel, py::cast<py::dict>(d["parallel"]));
    SetDictionary(data.solutionSettings, py::cast<py::dict>(d["solutionSettings"]));
    SetDictionary(data.staticSolver, py::cast<py::dict>(d["staticSolver"]));
    SetDictionary(data.timeIntegration, py::cast<py::dict>(d["timeIntegration"]));
    data.cleanUpMemory = py::cast<bool>(d["cleanUpMemory"]);
    data.displayComputationTime = py::cast<bool>(d["displayComputationTime"]);
    data.displayGlobalTimers = py::cast<bool>(d["displayGlobalTimers"]);
    data.displayStatistics = py::cast<bool>(d["displayStatistics"]);
    data.linearSolverType = py::cast<LinearSolverType>(d["linearSolverType"]);
    data.outputPrecision = py::cast<Index>(d["outputPrecision"]);
    data.pauseAfterEachStep = py::cast<bool>(d["pauseAfterEachStep"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsGeneral& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.autoFitScene;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "automatically fit scene within startup after SC.renderer.Start()";
    structureDict["autoFitScene"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAxesTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for drawing cylinders for axes and cones for arrows (reduce this number, e.g. to 4, if many axes are drawn)";
    structureDict["axesTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetBackgroundColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "red, green, blue and alpha values for background color of render window (white=[1,1,1,1]; black = [0,0,0,1])";
    structureDict["backgroundColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetBackgroundColorBottom();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "red, green, blue and alpha values for bottom background color in case that useGradientBackground = True";
    structureDict["backgroundColorBottom"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetCircleTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for circles; if smaller than 2, 2 segments are used (flat)";
    structureDict["circleTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.coordinateSystemSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of coordinate system relative to font size";
    structureDict["coordinateSystemSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetCylinderTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for cylinders; if smaller than 2, 2 segments are used (flat)";
    structureDict["cylinderTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawCoordinateSystem;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "false = no coordinate system shown";
    structureDict["drawCoordinateSystem"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawWorldBasis;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = draw world basis coordinate system at (0,0,0)";
    structureDict["drawWorldBasis"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.graphicsUpdateInterval;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "interval of graphics update during simulation in seconds; 0.1 = 10 frames per second; low numbers might slow down computation speed";
    structureDict["graphicsUpdateInterval"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLinuxDisplayScaleFactor();
    d["type"] = "PFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "Scaling factor for linux, which cannot determined from system by now; adjust this value to scale dialog fonts and renderer fonts";
    structureDict["linuxDisplayScaleFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.minSceneSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "minimum scene size for initial scene size and for autoFitScene, to avoid division by zero; SET GREATER THAN ZERO";
    structureDict["minSceneSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.pointSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global point size (absolute)";
    structureDict["pointSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRendererPrecision();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "precision of general floating point numbers shown in render window: total number of digits used  (max. 16)";
    structureDict["rendererPrecision"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.renderWindowString;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "string shown in render window (use this, e.g., for debugging, etc.; written below EXUDYN, similar to solutionInformation in SimulationSettings.solutionSettings)";
    structureDict["renderWindowString"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showComputationInfo;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = show (hide) all computation information including Exudyn and version";
    structureDict["showComputationInfo"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShowHelpOnStartup();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "seconds to show help message on startup (0=deactivate)";
    structureDict["showHelpOnStartup"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSolutionInformation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = show solution information (from simulationSettings.solution)";
    structureDict["showSolutionInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSolverInformation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = solver name and further information shown in render window";
    structureDict["showSolverInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSolverTime;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = solver current time shown in render window";
    structureDict["showSolverTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSphereTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for spheres; if smaller than 2, 2 segments are used (flat)";
    structureDict["sphereTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textAlwaysInFront;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, text for item numbers and other item-related text is drawn in front; this may be unwanted in case that you only with to see numbers of objects in front; currently does not work with perspective";
    structureDict["textAlwaysInFront"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTextColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "general text color (default); used for system texts in render window";
    structureDict["textColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textHasBackground;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, text for item numbers and other item-related text have a background (depending on text color), allowing for better visibility if many numbers are shown; the text itself is black; therefore, dark background colors are ignored and shown as white";
    structureDict["textHasBackground"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTextOffsetFactor();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "This is an additional out of plane offset for item texts (node number, etc.); the factor is relative to the maximum scene size and is only used, if textAlwaysInFront=False; this factor allows to draw text, e.g., in front of nodes";
    structureDict["textOffsetFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "general text size (font size) in pixels if not overwritten; if useWindowsDisplayScaleFactor=True, the the textSize is multplied with the windows display scaling (monitor scaling; content scaling) factor for larger texts on on high resolution displays; for bitmap fonts, the maximum size of any font (standard/large/huge) is limited to 256 (which is not recommended, especially if you do not have a powerful graphics card)";
    structureDict["textSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.threadSafeGraphicsUpdate;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = updating of visualization is threadsafe, but slower for complicated models; deactivate this to speed up computation, but activate for generation of animations; may be improved in future by adding a safe visualizationUpdate state";
    structureDict["threadSafeGraphicsUpdate"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useBitmapText;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, texts are displayed using pre-defined bitmaps for the text; may increase the complexity of your scene, e.g., if many (>10000) node numbers shown";
    structureDict["useBitmapText"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useGradientBackground;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = use vertical gradient for background; ";
    structureDict["useGradientBackground"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useMultiThreadedRendering;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = rendering is done in separate thread; false = no separate thread, which may be more stable but has lagging interaction for large models (do not interact with models during simulation); set this parameter before call to SC.renderer.Start(); MAC OS: uses always false, because MAC OS does not support multi threaded GLFW";
    structureDict["useMultiThreadedRendering"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useWindowsDisplayScaleFactor;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "the Windows display scaling (monitor scaling; content scaling) factor is used for increased visibility of texts on high resolution displays; based on GLFW glfwGetWindowContentScale; deactivated on linux compilation as it leads to crashes (adjust textSize manually!)";
    structureDict["useWindowsDisplayScaleFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.worldBasisSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of world basis coordinate system";
    structureDict["worldBasisSize"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsGeneral& data) {
    auto structureDict = py::dict();
    structureDict["autoFitScene"] = data.autoFitScene;
    structureDict["axesTiling"] = data.PyGetAxesTiling();
    structureDict["backgroundColor"] = data.PyGetBackgroundColor();
    structureDict["backgroundColorBottom"] = data.PyGetBackgroundColorBottom();
    structureDict["circleTiling"] = data.PyGetCircleTiling();
    structureDict["coordinateSystemSize"] = data.coordinateSystemSize;
    structureDict["cylinderTiling"] = data.PyGetCylinderTiling();
    structureDict["drawCoordinateSystem"] = data.drawCoordinateSystem;
    structureDict["drawWorldBasis"] = data.drawWorldBasis;
    structureDict["graphicsUpdateInterval"] = data.graphicsUpdateInterval;
    structureDict["linuxDisplayScaleFactor"] = data.PyGetLinuxDisplayScaleFactor();
    structureDict["minSceneSize"] = data.minSceneSize;
    structureDict["pointSize"] = data.pointSize;
    structureDict["rendererPrecision"] = data.PyGetRendererPrecision();
    structureDict["renderWindowString"] = data.renderWindowString;
    structureDict["showComputationInfo"] = data.showComputationInfo;
    structureDict["showHelpOnStartup"] = data.PyGetShowHelpOnStartup();
    structureDict["showSolutionInformation"] = data.showSolutionInformation;
    structureDict["showSolverInformation"] = data.showSolverInformation;
    structureDict["showSolverTime"] = data.showSolverTime;
    structureDict["sphereTiling"] = data.PyGetSphereTiling();
    structureDict["textAlwaysInFront"] = data.textAlwaysInFront;
    structureDict["textColor"] = data.PyGetTextColor();
    structureDict["textHasBackground"] = data.textHasBackground;
    structureDict["textOffsetFactor"] = data.PyGetTextOffsetFactor();
    structureDict["textSize"] = data.textSize;
    structureDict["threadSafeGraphicsUpdate"] = data.threadSafeGraphicsUpdate;
    structureDict["useBitmapText"] = data.useBitmapText;
    structureDict["useGradientBackground"] = data.useGradientBackground;
    structureDict["useMultiThreadedRendering"] = data.useMultiThreadedRendering;
    structureDict["useWindowsDisplayScaleFactor"] = data.useWindowsDisplayScaleFactor;
    structureDict["worldBasisSize"] = data.worldBasisSize;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsGeneral& data, const py::dict& d) {
    data.autoFitScene = py::cast<bool>(d["autoFitScene"]);
    data.axesTiling = py::cast<Index>(d["axesTiling"]);
    data.backgroundColor = py::cast<std::array<float,4>>(d["backgroundColor"]);
    data.backgroundColorBottom = py::cast<std::array<float,4>>(d["backgroundColorBottom"]);
    data.circleTiling = py::cast<Index>(d["circleTiling"]);
    data.coordinateSystemSize = py::cast<float>(d["coordinateSystemSize"]);
    data.cylinderTiling = py::cast<Index>(d["cylinderTiling"]);
    data.drawCoordinateSystem = py::cast<bool>(d["drawCoordinateSystem"]);
    data.drawWorldBasis = py::cast<bool>(d["drawWorldBasis"]);
    data.graphicsUpdateInterval = py::cast<float>(d["graphicsUpdateInterval"]);
    data.linuxDisplayScaleFactor = py::cast<float>(d["linuxDisplayScaleFactor"]);
    data.minSceneSize = py::cast<float>(d["minSceneSize"]);
    data.pointSize = py::cast<float>(d["pointSize"]);
    data.rendererPrecision = py::cast<Index>(d["rendererPrecision"]);
    data.renderWindowString = py::cast<std::string>(d["renderWindowString"]);
    data.showComputationInfo = py::cast<bool>(d["showComputationInfo"]);
    data.showHelpOnStartup = py::cast<Index>(d["showHelpOnStartup"]);
    data.showSolutionInformation = py::cast<bool>(d["showSolutionInformation"]);
    data.showSolverInformation = py::cast<bool>(d["showSolverInformation"]);
    data.showSolverTime = py::cast<bool>(d["showSolverTime"]);
    data.sphereTiling = py::cast<Index>(d["sphereTiling"]);
    data.textAlwaysInFront = py::cast<bool>(d["textAlwaysInFront"]);
    data.textColor = py::cast<std::array<float,4>>(d["textColor"]);
    data.textHasBackground = py::cast<bool>(d["textHasBackground"]);
    data.textOffsetFactor = py::cast<float>(d["textOffsetFactor"]);
    data.textSize = py::cast<float>(d["textSize"]);
    data.threadSafeGraphicsUpdate = py::cast<bool>(d["threadSafeGraphicsUpdate"]);
    data.useBitmapText = py::cast<bool>(d["useBitmapText"]);
    data.useGradientBackground = py::cast<bool>(d["useGradientBackground"]);
    data.useMultiThreadedRendering = py::cast<bool>(d["useMultiThreadedRendering"]);
    data.useWindowsDisplayScaleFactor = py::cast<bool>(d["useWindowsDisplayScaleFactor"]);
    data.worldBasisSize = py::cast<float>(d["worldBasisSize"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsContour& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.alphaTransparency;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "default value for contour alpha transparency (RGB color computed from contour value)";
    structureDict["alphaTransparency"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.automaticRange;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the contour plot value range is chosen automatically to the maximum range";
    structureDict["automaticRange"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorBarPrecision();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "precision of floating point values shown in color bar; total number of digits used (max. 16)";
    structureDict["colorBarPrecision"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorBarTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of tiles (segements) shown in the colorbar for the contour plot";
    structureDict["colorBarTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.maxValue;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum value for contour plot; set manually, if automaticRange == False";
    structureDict["maxValue"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.minValue;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "minimum value for contour plot; set manually, if automaticRange == False";
    structureDict["minValue"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.nodesColored;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the contour color is also applied to nodes (except mesh nodes), otherwise node drawing is not influenced by contour settings";
    structureDict["nodesColored"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.outputVariable;
    d["type"] = "OutputVariableType";
    d["size"] = std::vector<int>{1};
    d["description"] = "selected contour plot output variable type; select OutputVariableType._None to deactivate contour plotting.";
    structureDict["outputVariable"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.outputVariableComponent;
    d["type"] = "Int";
    d["size"] = std::vector<int>{1};
    d["description"] = "select the component of the chosen output variable; e.g., for displacements, 3 components are available: 0 == x, 1 == y, 2 == z component; for stresses, 6 components are available, see OutputVariableType description; to draw the norm of a outputVariable, set component to -1; if a certain component is not available by certain objects or nodes, no value is drawn (using default color)";
    structureDict["outputVariableComponent"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.reduceRange;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the contour plot value range is also reduced; better for static computation; in dynamic computation set this option to false, it can reduce visualization artifacts; you should also set minVal to max(float) and maxVal to min(float)";
    structureDict["reduceRange"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.rigidBodiesColored;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the contour color is also applied to triangular faces of rigid bodies and mass points, otherwise the rigid body drawing are not influenced by contour settings; for general rigid bodies (except for ObjectGround), Position, Displacement, DisplacementLocal(=0), Velocity, VelocityLocal, AngularVelocity, and AngularVelocityLocal are available; may slow down visualization!";
    structureDict["rigidBodiesColored"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showColorBar;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show the colour bar with minimum and maximum values for the contour plot";
    structureDict["showColorBar"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsContour& data) {
    auto structureDict = py::dict();
    structureDict["alphaTransparency"] = data.alphaTransparency;
    structureDict["automaticRange"] = data.automaticRange;
    structureDict["colorBarPrecision"] = data.PyGetColorBarPrecision();
    structureDict["colorBarTiling"] = data.PyGetColorBarTiling();
    structureDict["maxValue"] = data.maxValue;
    structureDict["minValue"] = data.minValue;
    structureDict["nodesColored"] = data.nodesColored;
    structureDict["outputVariable"] = data.outputVariable;
    structureDict["outputVariableComponent"] = data.outputVariableComponent;
    structureDict["reduceRange"] = data.reduceRange;
    structureDict["rigidBodiesColored"] = data.rigidBodiesColored;
    structureDict["showColorBar"] = data.showColorBar;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsContour& data, const py::dict& d) {
    data.alphaTransparency = py::cast<float>(d["alphaTransparency"]);
    data.automaticRange = py::cast<bool>(d["automaticRange"]);
    data.colorBarPrecision = py::cast<Index>(d["colorBarPrecision"]);
    data.colorBarTiling = py::cast<Index>(d["colorBarTiling"]);
    data.maxValue = py::cast<float>(d["maxValue"]);
    data.minValue = py::cast<float>(d["minValue"]);
    data.nodesColored = py::cast<bool>(d["nodesColored"]);
    data.outputVariable = py::cast<OutputVariableType>(d["outputVariable"]);
    data.outputVariableComponent = py::cast<Index>(d["outputVariableComponent"]);
    data.reduceRange = py::cast<bool>(d["reduceRange"]);
    data.rigidBodiesColored = py::cast<bool>(d["rigidBodiesColored"]);
    data.showColorBar = py::cast<bool>(d["showColorBar"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsNodes& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.basisSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of basis for nodes";
    structureDict["basisSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "default RGBA color for nodes; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global node size; if -1.f, node size is relative to openGL.initialMaxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawNodesAsPoint;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "simplified/faster drawing of nodes; uses general->pointSize as drawing size; if drawNodesAsPoint==True, the basis of the node will be drawn with lines";
    structureDict["drawNodesAsPoint"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the nodes are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showBasis;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show basis (three axes) of coordinate system in 3D nodes";
    structureDict["showBasis"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShowNodalSlopes();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw nodal slope vectors, e.g. in ANCF beam finite elements";
    structureDict["showNodalSlopes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the node number is shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "tiling for node if drawn as sphere; used to lower the amount of triangles to draw each node; if drawn as circle, this value is multiplied with 4";
    structureDict["tiling"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsNodes& data) {
    auto structureDict = py::dict();
    structureDict["basisSize"] = data.basisSize;
    structureDict["defaultColor"] = data.PyGetDefaultColor();
    structureDict["defaultSize"] = data.defaultSize;
    structureDict["drawNodesAsPoint"] = data.drawNodesAsPoint;
    structureDict["show"] = data.show;
    structureDict["showBasis"] = data.showBasis;
    structureDict["showNodalSlopes"] = data.PyGetShowNodalSlopes();
    structureDict["showNumbers"] = data.showNumbers;
    structureDict["tiling"] = data.PyGetTiling();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsNodes& data, const py::dict& d) {
    data.basisSize = py::cast<float>(d["basisSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.drawNodesAsPoint = py::cast<bool>(d["drawNodesAsPoint"]);
    data.show = py::cast<bool>(d["show"]);
    data.showBasis = py::cast<bool>(d["showBasis"]);
    data.showNodalSlopes = py::cast<Index>(d["showNodalSlopes"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.tiling = py::cast<Index>(d["tiling"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsBeams& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAxialTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of segments to discretise the beams axis";
    structureDict["axialTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.crossSectionFilled;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if implemented for element, cross section is drawn as solid (filled) instead of wire-frame; NOTE: some quantities may not be interpolated correctly over cross section in visualization";
    structureDict["crossSectionFilled"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetCrossSectionTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of quads drawn over height of beam, if drawn as flat objects; leads to higher accuracy of components drawn over beam height or with, but also to larger CPU costs for drawing";
    structureDict["crossSectionTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVertical;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw contour plot outputVariables 'vertical' along beam height; contour.outputVariable must be set accordingly";
    structureDict["drawVertical"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDrawVerticalColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "color for outputVariable to be drawn along cross section (vertically)";
    structureDict["drawVerticalColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVerticalFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "factor for outputVariable to be drawn along cross section (vertically)";
    structureDict["drawVerticalFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVerticalLines;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw additional vertical lines for better visibility";
    structureDict["drawVerticalLines"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVerticalOffset;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "offset for vertical drawn lines; offset is added before multiplication with drawVerticalFactor";
    structureDict["drawVerticalOffset"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVerticalValues;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show values at vertical lines; note that these numbers are interpolated values and may be different from values evaluated directly at this point!";
    structureDict["drawVerticalValues"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.reducedAxialInterploation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, the interpolation along the beam axis may be lower than the beam element order; this may be, however, show more consistent values than a full interpolation, e.g. for strains or forces";
    structureDict["reducedAxialInterploation"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsBeams& data) {
    auto structureDict = py::dict();
    structureDict["axialTiling"] = data.PyGetAxialTiling();
    structureDict["crossSectionFilled"] = data.crossSectionFilled;
    structureDict["crossSectionTiling"] = data.PyGetCrossSectionTiling();
    structureDict["drawVertical"] = data.drawVertical;
    structureDict["drawVerticalColor"] = data.PyGetDrawVerticalColor();
    structureDict["drawVerticalFactor"] = data.drawVerticalFactor;
    structureDict["drawVerticalLines"] = data.drawVerticalLines;
    structureDict["drawVerticalOffset"] = data.drawVerticalOffset;
    structureDict["drawVerticalValues"] = data.drawVerticalValues;
    structureDict["reducedAxialInterploation"] = data.reducedAxialInterploation;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsBeams& data, const py::dict& d) {
    data.axialTiling = py::cast<Index>(d["axialTiling"]);
    data.crossSectionFilled = py::cast<bool>(d["crossSectionFilled"]);
    data.crossSectionTiling = py::cast<Index>(d["crossSectionTiling"]);
    data.drawVertical = py::cast<bool>(d["drawVertical"]);
    data.drawVerticalColor = py::cast<std::array<float,4>>(d["drawVerticalColor"]);
    data.drawVerticalFactor = py::cast<float>(d["drawVerticalFactor"]);
    data.drawVerticalLines = py::cast<bool>(d["drawVerticalLines"]);
    data.drawVerticalOffset = py::cast<float>(d["drawVerticalOffset"]);
    data.drawVerticalValues = py::cast<bool>(d["drawVerticalValues"]);
    data.reducedAxialInterploation = py::cast<bool>(d["reducedAxialInterploation"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsKinematicTree& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.frameSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of COM and joint frames";
    structureDict["frameSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showCOMframes;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, a frame is attached to every center of mass";
    structureDict["showCOMframes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showFramesNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, numbers are drawn for joint frames (O[i]J[j]) and COM frames (O[i]COM[j]) for object [i] and local joint [j]";
    structureDict["showFramesNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showJointFrames;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, a frame is attached to the origin of every joint frame";
    structureDict["showJointFrames"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsKinematicTree& data) {
    auto structureDict = py::dict();
    structureDict["frameSize"] = data.frameSize;
    structureDict["showCOMframes"] = data.showCOMframes;
    structureDict["showFramesNumbers"] = data.showFramesNumbers;
    structureDict["showJointFrames"] = data.showJointFrames;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsKinematicTree& data, const py::dict& d) {
    data.frameSize = py::cast<float>(d["frameSize"]);
    data.showCOMframes = py::cast<bool>(d["showCOMframes"]);
    data.showFramesNumbers = py::cast<bool>(d["showFramesNumbers"]);
    data.showJointFrames = py::cast<bool>(d["showJointFrames"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsBodies& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["beams"] = GetDictionaryWithTypeInfo(data.beams);
    structureDict["kinematicTree"] = GetDictionaryWithTypeInfo(data.kinematicTree);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "default RGBA color for bodies; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultSize();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "global body size of xyz-cube";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.deformationScaleFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global deformation scale factor; also applies to nodes, if drawn; currently only used for scaled drawing of (linear) finite elements in FFRF and FFRFreducedOrder objects";
    structureDict["deformationScaleFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the bodies are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the body(=object) number is shown";
    structureDict["showNumbers"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsBodies& data) {
    auto structureDict = py::dict();
    structureDict["beams"] = GetDictionary(data.beams);
    structureDict["kinematicTree"] = GetDictionary(data.kinematicTree);
    structureDict["defaultColor"] = data.PyGetDefaultColor();
    structureDict["defaultSize"] = data.PyGetDefaultSize();
    structureDict["deformationScaleFactor"] = data.deformationScaleFactor;
    structureDict["show"] = data.show;
    structureDict["showNumbers"] = data.showNumbers;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsBodies& data, const py::dict& d) {
    SetDictionary(data.beams, py::cast<py::dict>(d["beams"]));
    SetDictionary(data.kinematicTree, py::cast<py::dict>(d["kinematicTree"]));
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.defaultSize = py::cast<std::array<float,3>>(d["defaultSize"]);
    data.deformationScaleFactor = py::cast<float>(d["deformationScaleFactor"]);
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsConnectors& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.contactPointsDefaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "DEPRECATED: do not use! global contact points size; if -1.f, connector size is relative to maxSceneSize";
    structureDict["contactPointsDefaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "default RGBA color for connectors; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global connector size; if -1.f, connector size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.jointAxesLength;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global joint axes length";
    structureDict["jointAxesLength"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.jointAxesRadius;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global joint axes radius";
    structureDict["jointAxesRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the connectors are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showContact;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether contact points, lines, etc. are shown for special cable-circle contacts; for spheres, triangles, tori, see visualizationSettings.contact";
    structureDict["showContact"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showJointAxes;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether contact joint axes of 3D joints are shown";
    structureDict["showJointAxes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the connector(=object) number is shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSpringNumberOfWindings();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of windings for springs drawn as helical spring";
    structureDict["springNumberOfWindings"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsConnectors& data) {
    auto structureDict = py::dict();
    structureDict["contactPointsDefaultSize"] = data.contactPointsDefaultSize;
    structureDict["defaultColor"] = data.PyGetDefaultColor();
    structureDict["defaultSize"] = data.defaultSize;
    structureDict["jointAxesLength"] = data.jointAxesLength;
    structureDict["jointAxesRadius"] = data.jointAxesRadius;
    structureDict["show"] = data.show;
    structureDict["showContact"] = data.showContact;
    structureDict["showJointAxes"] = data.showJointAxes;
    structureDict["showNumbers"] = data.showNumbers;
    structureDict["springNumberOfWindings"] = data.PyGetSpringNumberOfWindings();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsConnectors& data, const py::dict& d) {
    data.contactPointsDefaultSize = py::cast<float>(d["contactPointsDefaultSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.jointAxesLength = py::cast<float>(d["jointAxesLength"]);
    data.jointAxesRadius = py::cast<float>(d["jointAxesRadius"]);
    data.show = py::cast<bool>(d["show"]);
    data.showContact = py::cast<bool>(d["showContact"]);
    data.showJointAxes = py::cast<bool>(d["showJointAxes"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.springNumberOfWindings = py::cast<Index>(d["springNumberOfWindings"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsMarkers& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "default RGBA color for markers; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global marker size; if -1.f, marker size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawSimplified;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw markers with simplified symbols";
    structureDict["drawSimplified"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the markers are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the marker numbers are shown";
    structureDict["showNumbers"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsMarkers& data) {
    auto structureDict = py::dict();
    structureDict["defaultColor"] = data.PyGetDefaultColor();
    structureDict["defaultSize"] = data.defaultSize;
    structureDict["drawSimplified"] = data.drawSimplified;
    structureDict["show"] = data.show;
    structureDict["showNumbers"] = data.showNumbers;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsMarkers& data, const py::dict& d) {
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.drawSimplified = py::cast<bool>(d["drawSimplified"]);
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsLoads& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "default RGBA color for loads; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultRadius;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global radius of load axis if drawn in 3D";
    structureDict["defaultRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global load size; if -1.f, load size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawSimplified;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw markers with simplified symbols";
    structureDict["drawSimplified"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawWithUserFunction;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw loads like force vectors time dependent; make sure that fixedLoadSize=false, while otherwise only the direction will change; user functions can only be drawn, if they are either symbolic or for Python user functions if useMultiThreadedRendering=False";
    structureDict["drawWithUserFunction"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.fixedLoadSize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the load is drawn with a fixed vector length in direction of the load vector, independently of the load size";
    structureDict["fixedLoadSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.loadSizeFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "if fixedLoadSize=false, then this scaling factor is used to draw the load vector";
    structureDict["loadSizeFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the loads are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the load numbers are shown";
    structureDict["showNumbers"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsLoads& data) {
    auto structureDict = py::dict();
    structureDict["defaultColor"] = data.PyGetDefaultColor();
    structureDict["defaultRadius"] = data.defaultRadius;
    structureDict["defaultSize"] = data.defaultSize;
    structureDict["drawSimplified"] = data.drawSimplified;
    structureDict["drawWithUserFunction"] = data.drawWithUserFunction;
    structureDict["fixedLoadSize"] = data.fixedLoadSize;
    structureDict["loadSizeFactor"] = data.loadSizeFactor;
    structureDict["show"] = data.show;
    structureDict["showNumbers"] = data.showNumbers;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsLoads& data, const py::dict& d) {
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.defaultRadius = py::cast<float>(d["defaultRadius"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.drawSimplified = py::cast<bool>(d["drawSimplified"]);
    data.drawWithUserFunction = py::cast<bool>(d["drawWithUserFunction"]);
    data.fixedLoadSize = py::cast<bool>(d["fixedLoadSize"]);
    data.loadSizeFactor = py::cast<float>(d["loadSizeFactor"]);
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsTraces& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLineWidth();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "line width for traces";
    structureDict["lineWidth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetListOfPositionSensors();
    d["type"] = "IndexArray";
    d["size"] = std::vector<int>{-1};
    d["description"] = "list of position sensors which can be shown as trace inside render window if sensors have storeInternal=True; if this list is empty and showPositionTrace=True, then all available sensors are shown";
    structureDict["listOfPositionSensors"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetListOfTriadSensors();
    d["type"] = "IndexArray";
    d["size"] = std::vector<int>{-1};
    d["description"] = "list of sensors of with OutputVariableType RotationMatrix; this non-empty list needs to coincide in length with the listOfPositionSensors to be shown if showTriads=True; the triad is drawn at the related position";
    structureDict["listOfTriadSensors"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetListOfVectorSensors();
    d["type"] = "IndexArray";
    d["size"] = std::vector<int>{-1};
    d["description"] = "list of sensors with 3D vector quantities; this non-empty list needs to coincide in length with the listOfPositionSensors to be shown if showVectors=True; the vector quantity is drawn relative to the related position";
    structureDict["listOfVectorSensors"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetPositionsShowEvery();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "integer value i; out of available sensor data, show every i-th position";
    structureDict["positionsShowEvery"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsMbsNumber;
    d["type"] = "Index";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of main system which is used to for sensor lists; if only 1 mbs is in the SystemContainer, use 0; if there are several mbs, it needs to specify the number";
    structureDict["sensorsMbsNumber"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showCurrent;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show current trace position (and especially vector quantity) related to current visualization state; this only works in solution viewer if sensor values are stored at time grid points of the solution file (up to a precision of 1e-10) and may therefore be temporarily unavailable";
    structureDict["showCurrent"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showFuture;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show trace future to current visualization state if already computed (e.g. in SolutionViewer)";
    structureDict["showFuture"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showPast;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show trace previous to current visualization state";
    structureDict["showPast"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showPositionTrace;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show position trace of all position sensors if listOfPositionSensors=[] or of specified sensors; sensors need to activate storeInternal=True";
    structureDict["showPositionTrace"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showTriads;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, show basis vectors from rotation matrices provided by sensors";
    structureDict["showTriads"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showVectors;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, show vector quantities according to description in showPositionTrace";
    structureDict["showVectors"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTimeSpan();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum trace time span of past or future trace; given in seconds of simulation time; if zero, it is unused";
    structureDict["timeSpan"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTraceColors();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{-1};
    d["description"] = "RGBA float values for traces in one array; using 6x4 values gives different colors for 6 traces; in case of triads, the 0/1/2-axes are drawn in red, green, and blue";
    structureDict["traceColors"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.triadSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "length of triad axes if shown";
    structureDict["triadSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTriadsShowEvery();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "integer value i; out of available sensor data, show every i-th triad";
    structureDict["triadsShowEvery"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.vectorScaling;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "scaling of vector quantities; if, e.g., loads, this factor has to be adjusted significantly";
    structureDict["vectorScaling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVectorsShowEvery();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "integer value i; out of available sensor data, show every i-th vector";
    structureDict["vectorsShowEvery"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsTraces& data) {
    auto structureDict = py::dict();
    structureDict["lineWidth"] = data.PyGetLineWidth();
    structureDict["listOfPositionSensors"] = data.PyGetListOfPositionSensors();
    structureDict["listOfTriadSensors"] = data.PyGetListOfTriadSensors();
    structureDict["listOfVectorSensors"] = data.PyGetListOfVectorSensors();
    structureDict["positionsShowEvery"] = data.PyGetPositionsShowEvery();
    structureDict["sensorsMbsNumber"] = data.sensorsMbsNumber;
    structureDict["showCurrent"] = data.showCurrent;
    structureDict["showFuture"] = data.showFuture;
    structureDict["showPast"] = data.showPast;
    structureDict["showPositionTrace"] = data.showPositionTrace;
    structureDict["showTriads"] = data.showTriads;
    structureDict["showVectors"] = data.showVectors;
    structureDict["timeSpan"] = data.PyGetTimeSpan();
    structureDict["traceColors"] = data.PyGetTraceColors();
    structureDict["triadSize"] = data.triadSize;
    structureDict["triadsShowEvery"] = data.PyGetTriadsShowEvery();
    structureDict["vectorScaling"] = data.vectorScaling;
    structureDict["vectorsShowEvery"] = data.PyGetVectorsShowEvery();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsTraces& data, const py::dict& d) {
    data.lineWidth = py::cast<float>(d["lineWidth"]);
    data.listOfPositionSensors = py::cast<std::vector<Index>>(d["listOfPositionSensors"]);
    data.listOfTriadSensors = py::cast<std::vector<Index>>(d["listOfTriadSensors"]);
    data.listOfVectorSensors = py::cast<std::vector<Index>>(d["listOfVectorSensors"]);
    data.positionsShowEvery = py::cast<Index>(d["positionsShowEvery"]);
    data.sensorsMbsNumber = py::cast<Index>(d["sensorsMbsNumber"]);
    data.showCurrent = py::cast<bool>(d["showCurrent"]);
    data.showFuture = py::cast<bool>(d["showFuture"]);
    data.showPast = py::cast<bool>(d["showPast"]);
    data.showPositionTrace = py::cast<bool>(d["showPositionTrace"]);
    data.showTriads = py::cast<bool>(d["showTriads"]);
    data.showVectors = py::cast<bool>(d["showVectors"]);
    data.timeSpan = py::cast<Real>(d["timeSpan"]);
    data.traceColors = py::cast<std::vector<float>>(d["traceColors"]);
    data.triadSize = py::cast<float>(d["triadSize"]);
    data.triadsShowEvery = py::cast<Index>(d["triadsShowEvery"]);
    data.vectorScaling = py::cast<float>(d["vectorScaling"]);
    data.vectorsShowEvery = py::cast<Index>(d["vectorsShowEvery"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsSensors& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["traces"] = GetDictionaryWithTypeInfo(data.traces);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "default RGBA color for sensors; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global sensor size; if -1.f, sensor size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawSimplified;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw sensors with simplified symbols";
    structureDict["drawSimplified"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the sensors are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the sensor numbers are shown";
    structureDict["showNumbers"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsSensors& data) {
    auto structureDict = py::dict();
    structureDict["traces"] = GetDictionary(data.traces);
    structureDict["defaultColor"] = data.PyGetDefaultColor();
    structureDict["defaultSize"] = data.defaultSize;
    structureDict["drawSimplified"] = data.drawSimplified;
    structureDict["show"] = data.show;
    structureDict["showNumbers"] = data.showNumbers;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsSensors& data, const py::dict& d) {
    SetDictionary(data.traces, py::cast<py::dict>(d["traces"]));
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.drawSimplified = py::cast<bool>(d["drawSimplified"]);
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsContact& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorBoundingBoxes();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for boudnding boxes, see showBoundingBoxes";
    structureDict["colorBoundingBoxes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorSearchTree();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for search tree, see showSearchTree";
    structureDict["colorSearchTree"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorSpheres();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for contact spheres, see showSpheres";
    structureDict["colorSpheres"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorTori();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for contact tori, see showTori";
    structureDict["colorTori"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorTriangles();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for contact triangles, see showTriangles";
    structureDict["colorTriangles"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.contactForcesFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "factor used for scaling of contact forces is showContactForces=True";
    structureDict["contactForcesFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.contactPointsDefaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global contact points size; if -1.f, connector size is relative to maxSceneSize; used for some contacts, e.g., in ContactFrictionCircle";
    structureDict["contactPointsDefaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showBoundingBoxes;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show computed bounding boxes of all GeneralContacts; Warning: avoid for large number of contact objects!";
    structureDict["showBoundingBoxes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showContactForces;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True, contact forces are drawn for certain contact models";
    structureDict["showContactForces"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showContactForcesValues;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if True and showContactForces=True, numerical values for  contact forces are shown at certain points";
    structureDict["showContactForcesValues"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSearchTree;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show outer box of search tree for all GeneralContacts";
    structureDict["showSearchTree"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSearchTreeCells;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show all cells of search tree; empty cells have colorSearchTree, cells with contact objects have higher red value; Warning: avoid for large number of search tree cells!";
    structureDict["showSearchTreeCells"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSpheres;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show contact spheres (SpheresWithMarker, ...)";
    structureDict["showSpheres"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showTori;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show each contact torus";
    structureDict["showTori"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showTriangles;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show contact triangles (TrianglesRigidBodyBased, ...)";
    structureDict["showTriangles"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTilingCurves();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "tiling for nonlinear/polynomial curves; higher values give smoother curves";
    structureDict["tilingCurves"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTilingSpheres();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "tiling for spheres; higher values give smoother spheres, but may lead to lower frame rates";
    structureDict["tilingSpheres"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsContact& data) {
    auto structureDict = py::dict();
    structureDict["colorBoundingBoxes"] = data.PyGetColorBoundingBoxes();
    structureDict["colorSearchTree"] = data.PyGetColorSearchTree();
    structureDict["colorSpheres"] = data.PyGetColorSpheres();
    structureDict["colorTori"] = data.PyGetColorTori();
    structureDict["colorTriangles"] = data.PyGetColorTriangles();
    structureDict["contactForcesFactor"] = data.contactForcesFactor;
    structureDict["contactPointsDefaultSize"] = data.contactPointsDefaultSize;
    structureDict["showBoundingBoxes"] = data.showBoundingBoxes;
    structureDict["showContactForces"] = data.showContactForces;
    structureDict["showContactForcesValues"] = data.showContactForcesValues;
    structureDict["showSearchTree"] = data.showSearchTree;
    structureDict["showSearchTreeCells"] = data.showSearchTreeCells;
    structureDict["showSpheres"] = data.showSpheres;
    structureDict["showTori"] = data.showTori;
    structureDict["showTriangles"] = data.showTriangles;
    structureDict["tilingCurves"] = data.PyGetTilingCurves();
    structureDict["tilingSpheres"] = data.PyGetTilingSpheres();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsContact& data, const py::dict& d) {
    data.colorBoundingBoxes = py::cast<std::array<float,4>>(d["colorBoundingBoxes"]);
    data.colorSearchTree = py::cast<std::array<float,4>>(d["colorSearchTree"]);
    data.colorSpheres = py::cast<std::array<float,4>>(d["colorSpheres"]);
    data.colorTori = py::cast<std::array<float,4>>(d["colorTori"]);
    data.colorTriangles = py::cast<std::array<float,4>>(d["colorTriangles"]);
    data.contactForcesFactor = py::cast<float>(d["contactForcesFactor"]);
    data.contactPointsDefaultSize = py::cast<float>(d["contactPointsDefaultSize"]);
    data.showBoundingBoxes = py::cast<bool>(d["showBoundingBoxes"]);
    data.showContactForces = py::cast<bool>(d["showContactForces"]);
    data.showContactForcesValues = py::cast<bool>(d["showContactForcesValues"]);
    data.showSearchTree = py::cast<bool>(d["showSearchTree"]);
    data.showSearchTreeCells = py::cast<bool>(d["showSearchTreeCells"]);
    data.showSpheres = py::cast<bool>(d["showSpheres"]);
    data.showTori = py::cast<bool>(d["showTori"]);
    data.showTriangles = py::cast<bool>(d["showTriangles"]);
    data.tilingCurves = py::cast<Index>(d["tilingCurves"]);
    data.tilingSpheres = py::cast<Index>(d["tilingSpheres"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsWindow& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.alwaysOnTop;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: OpenGL render window will be always on top of all other windows";
    structureDict["alwaysOnTop"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreKeys;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: ignore keyboard input except escape and 'F2' keys; used for interactive mode, e.g., to perform kinematic analysis; This flag can be switched with key 'F2'";
    structureDict["ignoreKeys"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.limitWindowToScreenSize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: render window size is limited to screen size; False: larger window sizes (e.g. for rendering) allowed according to renderWindowSize";
    structureDict["limitWindowToScreenSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.maximize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: OpenGL render window will be maximized at startup";
    structureDict["maximize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetReallyQuitTimeLimit();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of seconds after which user is asked a security question before stopping simulation and closing renderer; set to 0 in order to always get asked; set to 1e10 to (nearly) never get asked";
    structureDict["reallyQuitTimeLimit"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRenderWindowSize();
    d["type"] = "IndexArray";
    d["size"] = std::vector<int>{2};
    d["description"] = "initial size of OpenGL render window in pixel";
    structureDict["renderWindowSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showMouseCoordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: show OpenGL coordinates and distance to last left mouse button pressed position; switched on/off with key 'F3'";
    structureDict["showMouseCoordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showWindow;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: OpenGL render window is shown on startup; False: window will be iconified at startup (e.g. if you are starting multiple computations automatically)";
    structureDict["showWindow"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStartupTimeout();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "OpenGL render window startup timeout in ms (change might be necessary if CPU is very slow)";
    structureDict["startupTimeout"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsWindow& data) {
    auto structureDict = py::dict();
    structureDict["alwaysOnTop"] = data.alwaysOnTop;
    structureDict["ignoreKeys"] = data.ignoreKeys;
    structureDict["limitWindowToScreenSize"] = data.limitWindowToScreenSize;
    structureDict["maximize"] = data.maximize;
    structureDict["reallyQuitTimeLimit"] = data.PyGetReallyQuitTimeLimit();
    structureDict["renderWindowSize"] = data.PyGetRenderWindowSize();
    structureDict["showMouseCoordinates"] = data.showMouseCoordinates;
    structureDict["showWindow"] = data.showWindow;
    structureDict["startupTimeout"] = data.PyGetStartupTimeout();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsWindow& data, const py::dict& d) {
    data.alwaysOnTop = py::cast<bool>(d["alwaysOnTop"]);
    data.ignoreKeys = py::cast<bool>(d["ignoreKeys"]);
    data.limitWindowToScreenSize = py::cast<bool>(d["limitWindowToScreenSize"]);
    data.maximize = py::cast<bool>(d["maximize"]);
    data.reallyQuitTimeLimit = py::cast<Real>(d["reallyQuitTimeLimit"]);
    data.renderWindowSize = py::cast<std::array<Index,2>>(d["renderWindowSize"]);
    data.showMouseCoordinates = py::cast<bool>(d["showMouseCoordinates"]);
    data.showWindow = py::cast<bool>(d["showWindow"]);
    data.startupTimeout = py::cast<Index>(d["startupTimeout"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsDialogs& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAlphaTransparency();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "alpha-transparency of dialogs; recommended range 0.7 (very transparent) - 1 (not transparent at all)";
    structureDict["alphaTransparency"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.alwaysTopmost;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: dialogs are always topmost (otherwise, they are sometimes hidden)";
    structureDict["alwaysTopmost"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetFontScalingMacOS();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "font scaling value for MacOS systems (on Windows, system display scaling is used)";
    structureDict["fontScalingMacOS"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.multiThreadedDialogs;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: During dialogs, the OpenGL render window will still get updates of changes in dialogs, etc., which may cause problems on some platforms or for some (complicated) models; False: changes of dialogs will take effect when dialogs are closed";
    structureDict["multiThreadedDialogs"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.openTreeView;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: all sub-trees of the visusalization dialog are opened when opening the dialog; False: only some sub-trees are opened";
    structureDict["openTreeView"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsDialogs& data) {
    auto structureDict = py::dict();
    structureDict["alphaTransparency"] = data.PyGetAlphaTransparency();
    structureDict["alwaysTopmost"] = data.alwaysTopmost;
    structureDict["fontScalingMacOS"] = data.PyGetFontScalingMacOS();
    structureDict["multiThreadedDialogs"] = data.multiThreadedDialogs;
    structureDict["openTreeView"] = data.openTreeView;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsDialogs& data, const py::dict& d) {
    data.alphaTransparency = py::cast<float>(d["alphaTransparency"]);
    data.alwaysTopmost = py::cast<bool>(d["alwaysTopmost"]);
    data.fontScalingMacOS = py::cast<float>(d["fontScalingMacOS"]);
    data.multiThreadedDialogs = py::cast<bool>(d["multiThreadedDialogs"]);
    data.openTreeView = py::cast<bool>(d["openTreeView"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsMaterial& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAlpha();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "alpha-transparency, same as in alpha channel in RGBA colors; 1=opaque, 0=fully transparent; leads to extra rendering costs per transparent pixel";
    structureDict["alpha"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetBaseColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "RGB default material color if face color has R-color channel -1";
    structureDict["baseColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetEmission();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "RGB emissive material color (enlightened material)";
    structureDict["emission"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetIor();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "index of refraction for transparent materials (1=no refraction), >1 represents refraction";
    structureDict["ior"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.name;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "material name for easier handling";
    structureDict["name"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetReflectivity();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "controls reflectivity of material; 0=no reflections (rough, e.g. rubber), 1=fully reflective (mirror); this leads to large extra rendering costs per visible reflective pixel";
    structureDict["reflectivity"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShininess();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "controls shininess of specular component of lights; values < 5 is not very shiny, while > 50 is very shiny";
    structureDict["shininess"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSpecular();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "RGB specular material color";
    structureDict["specular"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsMaterial& data) {
    auto structureDict = py::dict();
    structureDict["alpha"] = data.PyGetAlpha();
    structureDict["baseColor"] = data.PyGetBaseColor();
    structureDict["emission"] = data.PyGetEmission();
    structureDict["ior"] = data.PyGetIor();
    structureDict["name"] = data.name;
    structureDict["reflectivity"] = data.PyGetReflectivity();
    structureDict["shininess"] = data.PyGetShininess();
    structureDict["specular"] = data.PyGetSpecular();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsMaterial& data, const py::dict& d) {
    data.alpha = py::cast<float>(d["alpha"]);
    data.baseColor = py::cast<std::array<float,3>>(d["baseColor"]);
    data.emission = py::cast<std::array<float,3>>(d["emission"]);
    data.ior = py::cast<float>(d["ior"]);
    data.name = py::cast<std::string>(d["name"]);
    data.reflectivity = py::cast<float>(d["reflectivity"]);
    data.shininess = py::cast<float>(d["shininess"]);
    data.specular = py::cast<std::array<float,3>>(d["specular"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsRaytracer& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["material0"] = GetDictionaryWithTypeInfo(data.material0);
    structureDict["material1"] = GetDictionaryWithTypeInfo(data.material1);
    structureDict["material2"] = GetDictionaryWithTypeInfo(data.material2);
    structureDict["material3"] = GetDictionaryWithTypeInfo(data.material3);
    structureDict["material4"] = GetDictionaryWithTypeInfo(data.material4);
    structureDict["material5"] = GetDictionaryWithTypeInfo(data.material5);
    structureDict["material6"] = GetDictionaryWithTypeInfo(data.material6);
    structureDict["material7"] = GetDictionaryWithTypeInfo(data.material7);
    structureDict["material8"] = GetDictionaryWithTypeInfo(data.material8);
    structureDict["material9"] = GetDictionaryWithTypeInfo(data.material9);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAmbientLightColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "scene RGBA color for ambient light effect (min. light for regions in shadow); same as openGL.materialAmbientAndDiffuse in OpenGL renderer";
    structureDict["ambientLightColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetBackgroundColorReflections();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "scene RGBA color for background that is hit by reflection; while openGL.backgroundColor is used for rays that do not hit an object, this background may - if black or white - not be a suitable color for computing reflections; important, if scene is not inside a room.";
    structureDict["backgroundColorReflections"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enable;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: use (software) raytracer; False: use standard OpenGL renderer";
    structureDict["enable"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetGlobalFogColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "scene RGBA fog color";
    structureDict["globalFogColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.globalFogDensity;
    d["type"] = "Real";
    d["size"] = std::vector<int>{1};
    d["description"] = "global fog density; fog is deactivated if fogDensity=0, otherwise it is a density relative to scene max size; as it is relative, the factor has to be relatively high to be visible (usually >1)";
    structureDict["globalFogDensity"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetImageSizeFactor();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Special size factor (1-16) to allow drawing with smaller resolution (faster); use this for long rendering times for adjustments, etc.";
    structureDict["imageSizeFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.keepWindowActive;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "Special flag, handle with care; True: sends some glfw functions to keep window reactive for long render times (>2 seconds); otherwise, the rendering may not finish due to timeout";
    structureDict["keepWindowActive"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lightRadius;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "if lightRadiusVariations>1, it uses the given radius for all lights, to convert point lights into distributed lights (slower)";
    structureDict["lightRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLightRadiusVariations();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "if lightRadiusVariations>1, this defines the number of positions that are used to compute the effect of distributed lights (larger is slower but better quality); range=1..64";
    structureDict["lightRadiusVariations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxReflectionDepth();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Maximum number of reflections computed for one ray (note that for each transparent face passed, the reflection depth is reduced by 1); maximum is 32 (but should not be more than 2-4 usually!)";
    structureDict["maxReflectionDepth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxTransparencyDepth();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Maximum number of transparent faces that can be passed (note that for each reflection, the transparency depth is reduced by 1); maximum is 32 (but should not be more than 2-4 usually!)";
    structureDict["maxTransparencyDepth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfThreads();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of CPU-threads (max: 256) used for software rendering (should be approx. the number of available threads)";
    structureDict["numberOfThreads"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSearchTreeFactor();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "This factor can be used to increase the number of search tree bins, which can improve performance in case of inequilibrated scense; range=1..128";
    structureDict["searchTreeFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTilesPerThread();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Total number of sub-tiles per thread, used to evenly distribute rendering load to threads";
    structureDict["tilesPerThread"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.verbose;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: print out some debug information on rendering, in particular rendering timings and counter";
    structureDict["verbose"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.zBiasLines;
    d["type"] = "Real";
    d["size"] = std::vector<int>{1};
    d["description"] = "offset for lines to draw in front of faces; relative to scene radius";
    structureDict["zBiasLines"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.zOffsetCamera;
    d["type"] = "Real";
    d["size"] = std::vector<int>{1};
    d["description"] = "offset for for camera towards the scene; use positive factor put camera inside, e.g. of brick (like a room) or sphere; use (slightly) negative value to make whole scene visible";
    structureDict["zOffsetCamera"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsRaytracer& data) {
    auto structureDict = py::dict();
    structureDict["material0"] = GetDictionary(data.material0);
    structureDict["material1"] = GetDictionary(data.material1);
    structureDict["material2"] = GetDictionary(data.material2);
    structureDict["material3"] = GetDictionary(data.material3);
    structureDict["material4"] = GetDictionary(data.material4);
    structureDict["material5"] = GetDictionary(data.material5);
    structureDict["material6"] = GetDictionary(data.material6);
    structureDict["material7"] = GetDictionary(data.material7);
    structureDict["material8"] = GetDictionary(data.material8);
    structureDict["material9"] = GetDictionary(data.material9);
    structureDict["ambientLightColor"] = data.PyGetAmbientLightColor();
    structureDict["backgroundColorReflections"] = data.PyGetBackgroundColorReflections();
    structureDict["enable"] = data.enable;
    structureDict["globalFogColor"] = data.PyGetGlobalFogColor();
    structureDict["globalFogDensity"] = data.globalFogDensity;
    structureDict["imageSizeFactor"] = data.PyGetImageSizeFactor();
    structureDict["keepWindowActive"] = data.keepWindowActive;
    structureDict["lightRadius"] = data.lightRadius;
    structureDict["lightRadiusVariations"] = data.PyGetLightRadiusVariations();
    structureDict["maxReflectionDepth"] = data.PyGetMaxReflectionDepth();
    structureDict["maxTransparencyDepth"] = data.PyGetMaxTransparencyDepth();
    structureDict["numberOfThreads"] = data.PyGetNumberOfThreads();
    structureDict["searchTreeFactor"] = data.PyGetSearchTreeFactor();
    structureDict["tilesPerThread"] = data.PyGetTilesPerThread();
    structureDict["verbose"] = data.verbose;
    structureDict["zBiasLines"] = data.zBiasLines;
    structureDict["zOffsetCamera"] = data.zOffsetCamera;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsRaytracer& data, const py::dict& d) {
    SetDictionary(data.material0, py::cast<py::dict>(d["material0"]));
    SetDictionary(data.material1, py::cast<py::dict>(d["material1"]));
    SetDictionary(data.material2, py::cast<py::dict>(d["material2"]));
    SetDictionary(data.material3, py::cast<py::dict>(d["material3"]));
    SetDictionary(data.material4, py::cast<py::dict>(d["material4"]));
    SetDictionary(data.material5, py::cast<py::dict>(d["material5"]));
    SetDictionary(data.material6, py::cast<py::dict>(d["material6"]));
    SetDictionary(data.material7, py::cast<py::dict>(d["material7"]));
    SetDictionary(data.material8, py::cast<py::dict>(d["material8"]));
    SetDictionary(data.material9, py::cast<py::dict>(d["material9"]));
    data.ambientLightColor = py::cast<std::array<float,4>>(d["ambientLightColor"]);
    data.backgroundColorReflections = py::cast<std::array<float,4>>(d["backgroundColorReflections"]);
    data.enable = py::cast<bool>(d["enable"]);
    data.globalFogColor = py::cast<std::array<float,4>>(d["globalFogColor"]);
    data.globalFogDensity = py::cast<Real>(d["globalFogDensity"]);
    data.imageSizeFactor = py::cast<Index>(d["imageSizeFactor"]);
    data.keepWindowActive = py::cast<bool>(d["keepWindowActive"]);
    data.lightRadius = py::cast<float>(d["lightRadius"]);
    data.lightRadiusVariations = py::cast<Index>(d["lightRadiusVariations"]);
    data.maxReflectionDepth = py::cast<Index>(d["maxReflectionDepth"]);
    data.maxTransparencyDepth = py::cast<Index>(d["maxTransparencyDepth"]);
    data.numberOfThreads = py::cast<Index>(d["numberOfThreads"]);
    data.searchTreeFactor = py::cast<Index>(d["searchTreeFactor"]);
    data.tilesPerThread = py::cast<Index>(d["tilesPerThread"]);
    data.verbose = py::cast<bool>(d["verbose"]);
    data.zBiasLines = py::cast<Real>(d["zBiasLines"]);
    data.zOffsetCamera = py::cast<Real>(d["zOffsetCamera"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsOpenGL& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetClippingPlaneColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for clipping plane; if alpha-channel is 0, the cutting plane is not drawn; if alpha-channel is 1, the clippingPlaneColor is used; if alpha-channel is 2, the color of the object interior is used as clipping plane color (which may look strange in case of object-in-object)";
    structureDict["clippingPlaneColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.clippingPlaneDistance;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "distance of clipping plane on normal vector; see also clippingPlaneNormal";
    structureDict["clippingPlaneDistance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetClippingPlaneNormal();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "normal vector of clipping plane, e.g. [0,0,1] to set a xy-clipping plane; the clipped half-space is in direction of the normal; use [0,0,0] to deactivate clipping plane; Note that clipping is mainly made for triangles in order to visualize hidden objects and currently it only fully clips triangles, but does not exactly cut them; see also clippingPlaneDistance";
    structureDict["clippingPlaneNormal"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.depthSorting;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True (slower): sort triangles by Z-depth to remove transparency artifacts: only works if triangles do not intersect or come close (you may like to refine triangle meshes); False: no depth-sort (faster)";
    structureDict["depthSorting"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawFaceNormals;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draws triangle normals, e.g. at center of triangles; used for debugging of faces";
    structureDict["drawFaceNormals"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDrawNormalsLength();
    d["type"] = "PFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "length of normals; used for debugging";
    structureDict["drawNormalsLength"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVertexNormals;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draws vertex normals; used for debugging";
    structureDict["drawVertexNormals"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enableLight0;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "turn on/off light0";
    structureDict["enableLight0"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enableLight1;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "turn on/off light1";
    structureDict["enableLight1"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enableLighting;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "generally enable lighting (otherwise, colors of objects are used); OpenGL: glEnable(GL_LIGHTING)";
    structureDict["enableLighting"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetFaceEdgesColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "global RGBA color for face edges";
    structureDict["faceEdgesColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.facesTransparent;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: show faces transparent independent of transparency (A)-value in color of objects; allow to show otherwise hidden node/marker/object numbers";
    structureDict["facesTransparent"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetFaceTransparencyGlobal();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "in case that facesTransparent=True this represents the max alpha-transparency";
    structureDict["faceTransparencyGlobal"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetInitialCenterPoint();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "centerpoint of scene (3D) at renderer startup; overwritten if autoFitScene = True";
    structureDict["initialCenterPoint"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetInitialMaxSceneSize();
    d["type"] = "PFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "initial maximum scene size (auto: diagonal of cube with maximum scene coordinates); used for 'zoom all' functionality and for visibility of objects; overwritten if autoFitScene = True";
    structureDict["initialMaxSceneSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.initialModelRotation;
    d["type"] = "MatrixFloat";
    d["size"] = std::vector<int>{3,3};
    d["description"] = "initial model rotation matrix for OpenGl; in python use e.g.: initialModelRotation=[[1,0,0],[0,1,0],[0,0,1]]";
    structureDict["initialModelRotation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetInitialZoom();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "initial zoom of scene; overwritten/ignored if autoFitScene = True";
    structureDict["initialZoom"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0ambient;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "ambient value of GL_LIGHT0";
    structureDict["light0ambient"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0constantAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "constant attenuation coefficient of GL_LIGHT0, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); (kc,kl,kq)=(1,0,0) means no attenuation; only used for lights, where last component of light position is 1";
    structureDict["light0constantAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0diffuse;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "diffuse value of GL_LIGHT0";
    structureDict["light0diffuse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0linearAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "linear attenuation coefficient of GL_LIGHT0, this is a linear factor for attenuation of the light source with distance";
    structureDict["light0linearAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLight0position();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "4D position vector of GL_LIGHT0; 4th value should be 0 for lights like sun, but 1 for directional lights (and for attenuation factor being calculated); light0 is also used for shadows, so you need to adjust this position; see opengl manuals";
    structureDict["light0position"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0quadraticAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "quadratic attenuation coefficient of GL_LIGHT0, this is a quadratic factor for attenuation of the light source with distance";
    structureDict["light0quadraticAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0specular;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "specular value of GL_LIGHT0";
    structureDict["light0specular"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1ambient;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "ambient value of GL_LIGHT1";
    structureDict["light1ambient"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1constantAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "constant attenuation coefficient of GL_LIGHT1, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); only used for lights, where last component of light position is 1";
    structureDict["light1constantAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1diffuse;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "diffuse value of GL_LIGHT1";
    structureDict["light1diffuse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1linearAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "linear attenuation coefficient of GL_LIGHT1, this is a linear factor for attenuation of the light source with distance";
    structureDict["light1linearAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLight1position();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "4D position vector of GL_LIGHT0; 4th value should be 0 for lights like sun, but 1 for directional lights (and for attenuation factor being calculated); see opengl manuals";
    structureDict["light1position"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1quadraticAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "quadratic attenuation coefficient of GL_LIGHT1, this is a quadratic factor for attenuation of the light source with distance";
    structureDict["light1quadraticAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1specular;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "specular value of GL_LIGHT1";
    structureDict["light1specular"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLightModelAmbient();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "global ambient light; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_AMBIENT,[r,g,b,a])";
    structureDict["lightModelAmbient"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lightModelLocalViewer;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "select local viewer for light; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,...)";
    structureDict["lightModelLocalViewer"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lightModelTwoSide;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "enlighten also backside of object; may cause problems on some graphics cards and lead to slower performance; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,...)";
    structureDict["lightModelTwoSide"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lightPositionsInCameraFrame;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "set False to set light positions and directions relative to model frame; True: lights are in global (camera) frame; this is always False for raytracer; this was True up to Exudyn 1.9.174";
    structureDict["lightPositionsInCameraFrame"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lineSmooth;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw lines smooth";
    structureDict["lineSmooth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLineWidth();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "width of lines used for representation of lines, circles, points, etc.";
    structureDict["lineWidth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaterialAmbientAndDiffuse();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA ambient color of material";
    structureDict["materialAmbientAndDiffuse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.materialShininess;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "shininess of material";
    structureDict["materialShininess"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaterialSpecular();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA specular color of material";
    structureDict["materialSpecular"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMultiSampling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "NOTE: this parameter must be set before starting renderer; later changes are not affecting visualization; multi sampling turned off (<=1) or turned on to given values (2, 4, 8 or 16); increases the graphics buffers and might crash due to graphics card memory limitations; only works if supported by hardware; if it does not work, try to change 3D graphics hardware settings!";
    structureDict["multiSampling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetPerspective();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "parameter prescribes amount of perspective (0=no perspective=orthographic projection; positive values increase perspective; feasible values are 0.001 (little perspective) ... 0.5 (large amount of perspective); mouse coordinates will not work with perspective";
    structureDict["perspective"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.polygonOffset;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "general polygon offset for polygons, except for shadows; use this parameter to draw polygons behind lines to reduce artifacts for very large or small models";
    structureDict["polygonOffset"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.shadeModelSmooth;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: turn on smoothing for shaders, which uses vertex normals to smooth surfaces";
    structureDict["shadeModelSmooth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShadow();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "parameter \\in [0 ... 1] prescribes amount of shadow for light0 (using light0position, etc.) in OpenGL renderer; if this parameter is different from 1, rendering of triangles becomes approx.\\ 5 times more expensive, so take care in case of complex scenes; for complex object, such as spheres with fine resolution or for particle systems, the present approach has limitations and leads to artifacts and unrealistic shadows; for raytracer, shadow is included by a physics-based model for all lights if shadow>0";
    structureDict["shadow"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShadowPolygonOffset();
    d["type"] = "PFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "some special drawing parameter for shadows which should be handled with care; defines some offset needed by openGL to avoid aritfacts for shadows and depends on maxSceneSize; this value may need to be reduced for larger models in order to achieve more accurate shadows, it may be needed to be increased for thin bodies";
    structureDict["shadowPolygonOffset"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showFaceEdges;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show edges of faces; using the options showFaces=false and showFaceEdges=true gives are wire frame representation";
    structureDict["showFaceEdges"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showFaces;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show faces of triangles, etc.; using the options showFaces=false and showFaceEdges=true gives are wire frame representation";
    structureDict["showFaces"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showLines;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show lines (different from edges of faces)";
    structureDict["showLines"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showMeshEdges;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show edges of finite elements; independent of showFaceEdges";
    structureDict["showMeshEdges"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showMeshFaces;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show faces of finite elements; independent of showFaces";
    structureDict["showMeshFaces"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textLineSmooth;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw lines for representation of text smooth";
    structureDict["textLineSmooth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTextLineWidth();
    d["type"] = "UFloat";
    d["size"] = std::vector<int>{1};
    d["description"] = "width of lines used for representation of text";
    structureDict["textLineWidth"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsOpenGL& data) {
    auto structureDict = py::dict();
    structureDict["clippingPlaneColor"] = data.PyGetClippingPlaneColor();
    structureDict["clippingPlaneDistance"] = data.clippingPlaneDistance;
    structureDict["clippingPlaneNormal"] = data.PyGetClippingPlaneNormal();
    structureDict["depthSorting"] = data.depthSorting;
    structureDict["drawFaceNormals"] = data.drawFaceNormals;
    structureDict["drawNormalsLength"] = data.PyGetDrawNormalsLength();
    structureDict["drawVertexNormals"] = data.drawVertexNormals;
    structureDict["enableLight0"] = data.enableLight0;
    structureDict["enableLight1"] = data.enableLight1;
    structureDict["enableLighting"] = data.enableLighting;
    structureDict["faceEdgesColor"] = data.PyGetFaceEdgesColor();
    structureDict["facesTransparent"] = data.facesTransparent;
    structureDict["faceTransparencyGlobal"] = data.PyGetFaceTransparencyGlobal();
    structureDict["initialCenterPoint"] = data.PyGetInitialCenterPoint();
    structureDict["initialMaxSceneSize"] = data.PyGetInitialMaxSceneSize();
    structureDict["initialModelRotation"] = data.initialModelRotation;
    structureDict["initialZoom"] = data.PyGetInitialZoom();
    structureDict["light0ambient"] = data.light0ambient;
    structureDict["light0constantAttenuation"] = data.light0constantAttenuation;
    structureDict["light0diffuse"] = data.light0diffuse;
    structureDict["light0linearAttenuation"] = data.light0linearAttenuation;
    structureDict["light0position"] = data.PyGetLight0position();
    structureDict["light0quadraticAttenuation"] = data.light0quadraticAttenuation;
    structureDict["light0specular"] = data.light0specular;
    structureDict["light1ambient"] = data.light1ambient;
    structureDict["light1constantAttenuation"] = data.light1constantAttenuation;
    structureDict["light1diffuse"] = data.light1diffuse;
    structureDict["light1linearAttenuation"] = data.light1linearAttenuation;
    structureDict["light1position"] = data.PyGetLight1position();
    structureDict["light1quadraticAttenuation"] = data.light1quadraticAttenuation;
    structureDict["light1specular"] = data.light1specular;
    structureDict["lightModelAmbient"] = data.PyGetLightModelAmbient();
    structureDict["lightModelLocalViewer"] = data.lightModelLocalViewer;
    structureDict["lightModelTwoSide"] = data.lightModelTwoSide;
    structureDict["lightPositionsInCameraFrame"] = data.lightPositionsInCameraFrame;
    structureDict["lineSmooth"] = data.lineSmooth;
    structureDict["lineWidth"] = data.PyGetLineWidth();
    structureDict["materialAmbientAndDiffuse"] = data.PyGetMaterialAmbientAndDiffuse();
    structureDict["materialShininess"] = data.materialShininess;
    structureDict["materialSpecular"] = data.PyGetMaterialSpecular();
    structureDict["multiSampling"] = data.PyGetMultiSampling();
    structureDict["perspective"] = data.PyGetPerspective();
    structureDict["polygonOffset"] = data.polygonOffset;
    structureDict["shadeModelSmooth"] = data.shadeModelSmooth;
    structureDict["shadow"] = data.PyGetShadow();
    structureDict["shadowPolygonOffset"] = data.PyGetShadowPolygonOffset();
    structureDict["showFaceEdges"] = data.showFaceEdges;
    structureDict["showFaces"] = data.showFaces;
    structureDict["showLines"] = data.showLines;
    structureDict["showMeshEdges"] = data.showMeshEdges;
    structureDict["showMeshFaces"] = data.showMeshFaces;
    structureDict["textLineSmooth"] = data.textLineSmooth;
    structureDict["textLineWidth"] = data.PyGetTextLineWidth();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsOpenGL& data, const py::dict& d) {
    data.clippingPlaneColor = py::cast<std::array<float,4>>(d["clippingPlaneColor"]);
    data.clippingPlaneDistance = py::cast<float>(d["clippingPlaneDistance"]);
    data.clippingPlaneNormal = py::cast<std::array<float,3>>(d["clippingPlaneNormal"]);
    data.depthSorting = py::cast<bool>(d["depthSorting"]);
    data.drawFaceNormals = py::cast<bool>(d["drawFaceNormals"]);
    data.drawNormalsLength = py::cast<float>(d["drawNormalsLength"]);
    data.drawVertexNormals = py::cast<bool>(d["drawVertexNormals"]);
    data.enableLight0 = py::cast<bool>(d["enableLight0"]);
    data.enableLight1 = py::cast<bool>(d["enableLight1"]);
    data.enableLighting = py::cast<bool>(d["enableLighting"]);
    data.faceEdgesColor = py::cast<std::array<float,4>>(d["faceEdgesColor"]);
    data.facesTransparent = py::cast<bool>(d["facesTransparent"]);
    data.faceTransparencyGlobal = py::cast<float>(d["faceTransparencyGlobal"]);
    data.initialCenterPoint = py::cast<std::array<float,3>>(d["initialCenterPoint"]);
    data.initialMaxSceneSize = py::cast<float>(d["initialMaxSceneSize"]);
    data.initialModelRotation = py::cast<StdArray33F>(d["initialModelRotation"]);
    data.initialZoom = py::cast<float>(d["initialZoom"]);
    data.light0ambient = py::cast<float>(d["light0ambient"]);
    data.light0constantAttenuation = py::cast<float>(d["light0constantAttenuation"]);
    data.light0diffuse = py::cast<float>(d["light0diffuse"]);
    data.light0linearAttenuation = py::cast<float>(d["light0linearAttenuation"]);
    data.light0position = py::cast<std::array<float,4>>(d["light0position"]);
    data.light0quadraticAttenuation = py::cast<float>(d["light0quadraticAttenuation"]);
    data.light0specular = py::cast<float>(d["light0specular"]);
    data.light1ambient = py::cast<float>(d["light1ambient"]);
    data.light1constantAttenuation = py::cast<float>(d["light1constantAttenuation"]);
    data.light1diffuse = py::cast<float>(d["light1diffuse"]);
    data.light1linearAttenuation = py::cast<float>(d["light1linearAttenuation"]);
    data.light1position = py::cast<std::array<float,4>>(d["light1position"]);
    data.light1quadraticAttenuation = py::cast<float>(d["light1quadraticAttenuation"]);
    data.light1specular = py::cast<float>(d["light1specular"]);
    data.lightModelAmbient = py::cast<std::array<float,4>>(d["lightModelAmbient"]);
    data.lightModelLocalViewer = py::cast<bool>(d["lightModelLocalViewer"]);
    data.lightModelTwoSide = py::cast<bool>(d["lightModelTwoSide"]);
    data.lightPositionsInCameraFrame = py::cast<bool>(d["lightPositionsInCameraFrame"]);
    data.lineSmooth = py::cast<bool>(d["lineSmooth"]);
    data.lineWidth = py::cast<float>(d["lineWidth"]);
    data.materialAmbientAndDiffuse = py::cast<std::array<float,4>>(d["materialAmbientAndDiffuse"]);
    data.materialShininess = py::cast<float>(d["materialShininess"]);
    data.materialSpecular = py::cast<std::array<float,4>>(d["materialSpecular"]);
    data.multiSampling = py::cast<Index>(d["multiSampling"]);
    data.perspective = py::cast<float>(d["perspective"]);
    data.polygonOffset = py::cast<float>(d["polygonOffset"]);
    data.shadeModelSmooth = py::cast<bool>(d["shadeModelSmooth"]);
    data.shadow = py::cast<float>(d["shadow"]);
    data.shadowPolygonOffset = py::cast<float>(d["shadowPolygonOffset"]);
    data.showFaceEdges = py::cast<bool>(d["showFaceEdges"]);
    data.showFaces = py::cast<bool>(d["showFaces"]);
    data.showLines = py::cast<bool>(d["showLines"]);
    data.showMeshEdges = py::cast<bool>(d["showMeshEdges"]);
    data.showMeshFaces = py::cast<bool>(d["showMeshFaces"]);
    data.textLineSmooth = py::cast<bool>(d["textLineSmooth"]);
    data.textLineWidth = py::cast<float>(d["textLineWidth"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsExportImages& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHeightAlignment();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "alignment of exported image height; using a value of 2 helps to reduce problems with video conversion (additional horizontal lines are lost)";
    structureDict["heightAlignment"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageAsTextCircles;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "export circles in save image (only in TXT format)";
    structureDict["saveImageAsTextCircles"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageAsTextLines;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "export lines in save image (only in TXT format)";
    structureDict["saveImageAsTextLines"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageAsTextTexts;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "export text in save image (only in TXT format)";
    structureDict["saveImageAsTextTexts"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageAsTextTriangles;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "export triangles in save image (only in TXT format)";
    structureDict["saveImageAsTextTriangles"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSaveImageFileCounter();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "current value of the counter which is used to consecutively save frames (images) with consecutive numbers";
    structureDict["saveImageFileCounter"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename (without extension!) and (relative) path for image file(s) with consecutive numbering (e.g., frame0000.png, frame0001.png,...); ; directory will be created if it does not exist";
    structureDict["saveImageFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageFormat;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "format for exporting figures: currently only PNG, TGA and TXT available; while PNG and TGA represent the according image file formats, the TXT format results in a text file containing the 3D graphics data information as lists of lines, triangles, etc; PNG is not available for Ubuntu18.04 (check  use TGA has highest compatibility with all platforms";
    structureDict["saveImageFormat"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageSingleFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: only save single files with given filename, not adding numbering; False: add numbering to files, see saveImageFileName";
    structureDict["saveImageSingleFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSaveImageTimeOut();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "timeout in milliseconds for saving a frame as image to disk; this is the amount of time waited for redrawing; increase for very complex scenes";
    structureDict["saveImageTimeOut"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetWidthAlignment();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "alignment of exported image width; using a value of 4 helps to reduce problems with video conversion (additional vertical lines are lost)";
    structureDict["widthAlignment"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsExportImages& data) {
    auto structureDict = py::dict();
    structureDict["heightAlignment"] = data.PyGetHeightAlignment();
    structureDict["saveImageAsTextCircles"] = data.saveImageAsTextCircles;
    structureDict["saveImageAsTextLines"] = data.saveImageAsTextLines;
    structureDict["saveImageAsTextTexts"] = data.saveImageAsTextTexts;
    structureDict["saveImageAsTextTriangles"] = data.saveImageAsTextTriangles;
    structureDict["saveImageFileCounter"] = data.PyGetSaveImageFileCounter();
    structureDict["saveImageFileName"] = data.saveImageFileName;
    structureDict["saveImageFormat"] = data.saveImageFormat;
    structureDict["saveImageSingleFile"] = data.saveImageSingleFile;
    structureDict["saveImageTimeOut"] = data.PyGetSaveImageTimeOut();
    structureDict["widthAlignment"] = data.PyGetWidthAlignment();
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsExportImages& data, const py::dict& d) {
    data.heightAlignment = py::cast<Index>(d["heightAlignment"]);
    data.saveImageAsTextCircles = py::cast<bool>(d["saveImageAsTextCircles"]);
    data.saveImageAsTextLines = py::cast<bool>(d["saveImageAsTextLines"]);
    data.saveImageAsTextTexts = py::cast<bool>(d["saveImageAsTextTexts"]);
    data.saveImageAsTextTriangles = py::cast<bool>(d["saveImageAsTextTriangles"]);
    data.saveImageFileCounter = py::cast<Index>(d["saveImageFileCounter"]);
    data.saveImageFileName = py::cast<std::string>(d["saveImageFileName"]);
    data.saveImageFormat = py::cast<std::string>(d["saveImageFormat"]);
    data.saveImageSingleFile = py::cast<bool>(d["saveImageSingleFile"]);
    data.saveImageTimeOut = py::cast<Index>(d["saveImageTimeOut"]);
    data.widthAlignment = py::cast<Index>(d["widthAlignment"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsOpenVR& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.actionManifestFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "This string must contain a string representing a valid absolute path to a vr_actions.json manifest, which describes all HMD, tracker, etc. devices as given by openVR";
    structureDict["actionManifestFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enable;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: openVR enabled (if compiled with according flag and installed openVR)";
    structureDict["enable"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.logLevel;
    d["type"] = "Int";
    d["size"] = std::vector<int>{1};
    d["description"] = "integer value setting log level of openVR: -1 (no output), 0 (error), 1 (warning), 2 (info), 3 (debug); increase log level to get more output";
    structureDict["logLevel"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showCompanionWindow;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: openVR will show companion window containing left and right eye view";
    structureDict["showCompanionWindow"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsOpenVR& data) {
    auto structureDict = py::dict();
    structureDict["actionManifestFileName"] = data.actionManifestFileName;
    structureDict["enable"] = data.enable;
    structureDict["logLevel"] = data.logLevel;
    structureDict["showCompanionWindow"] = data.showCompanionWindow;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsOpenVR& data, const py::dict& d) {
    data.actionManifestFileName = py::cast<std::string>(d["actionManifestFileName"]);
    data.enable = py::cast<bool>(d["enable"]);
    data.logLevel = py::cast<Index>(d["logLevel"]);
    data.showCompanionWindow = py::cast<bool>(d["showCompanionWindow"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VSettingsInteractive& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["openVR"] = GetDictionaryWithTypeInfo(data.openVR);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHighlightColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for highlighted item; 4th value is alpha-transparency";
    structureDict["highlightColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.highlightItemIndex;
    d["type"] = "Int";
    d["size"] = std::vector<int>{1};
    d["description"] = "index of item that shall be highlighted (e.g., need to find item due to errors); if set -1, no item is highlighted";
    structureDict["highlightItemIndex"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.highlightItemType;
    d["type"] = "ItemType";
    d["size"] = std::vector<int>{1};
    d["description"] = "item type (Node, Object, ...) that shall be highlighted (e.g., need to find item due to errors)";
    structureDict["highlightItemType"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHighlightMbsNumber();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "index of main system (mbs) for which the item shall be highlighted; number is related to the ID in SystemContainer (first mbs = 0, second = 1, ...)";
    structureDict["highlightMbsNumber"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHighlightOtherColor();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{4};
    d["description"] = "RGBA color for other items (which are not highlighted); 4th value is alpha-transparency";
    structureDict["highlightOtherColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.joystickScaleRotation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "rotation scaling factor for joystick input";
    structureDict["joystickScaleRotation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.joystickScaleTranslation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "translation scaling factor for joystick input";
    structureDict["joystickScaleTranslation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.keypressRotationStep;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "rotation increment per keypress in degree (full rotation = 360 degree)";
    structureDict["keypressRotationStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.keypressTranslationStep;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "translation increment per keypress relative to window size";
    structureDict["keypressTranslationStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lockModelView;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: all movements (with mouse/keys), rotations, zoom are disabled; initial values are considered ==> initial zoom, rotation and center point need to be adjusted, approx. 0.4*maxSceneSize is a good value";
    structureDict["lockModelView"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.mouseMoveRotationFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "rotation increment per 1 pixel mouse movement in degree";
    structureDict["mouseMoveRotationFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.pauseWithSpacebar;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: during simulation, space bar can be pressed to pause simulation";
    structureDict["pauseWithSpacebar"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionHighlights;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: mouse click highlights item (default: red)";
    structureDict["selectionHighlights"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionLeftMouse;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: left mouse click on items and show basic information";
    structureDict["selectionLeftMouse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionLeftMouseItemTypes;
    d["type"] = "Index";
    d["size"] = std::vector<int>{1};
    d["description"] = "binary flags (1,2,4,8,16) for (Node,Object,Marker,Load,Sensor) that are identified with left mouse click selection";
    structureDict["selectionLeftMouseItemTypes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionRightMouse;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: right mouse click on items and show dictionary (read only!)";
    structureDict["selectionRightMouse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionRightMouseGraphicsData;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: right mouse click on items also shows GraphicsData information for inspectation (may sometimes be very large and may not fit into dialog for large graphics objects!)";
    structureDict["selectionRightMouseGraphicsData"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.trackMarker;
    d["type"] = "Int";
    d["size"] = std::vector<int>{1};
    d["description"] = "if valid marker index is provided and marker provides position (and orientation), the centerpoint of the scene follows the marker (and orientation); depends on trackMarkerPosition and trackMarkerOrientation; by default, only position is tracked";
    structureDict["trackMarker"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.trackMarkerMbsNumber;
    d["type"] = "Index";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of main system which is used to track marker; if only 1 mbs is in the SystemContainer, use 0; if there are several mbs, it needs to specify the number";
    structureDict["trackMarkerMbsNumber"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTrackMarkerOrientation();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "choose which orientation axes (x,y,z) are tracked; currently can only be all zero or all one";
    structureDict["trackMarkerOrientation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTrackMarkerPosition();
    d["type"] = "VectorFloat";
    d["size"] = std::vector<int>{3};
    d["description"] = "choose which coordinates or marker are tracked (x,y,z)";
    structureDict["trackMarkerPosition"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useJoystickInput;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: read joystick input (use 6-axis joystick with lowest ID found when starting renderer window) and interpret as (x,y,z) position and (rotx, roty, rotz) rotation: as available from 3Dconnexion space mouse and maybe others as well; set to False, if external joystick makes problems ...";
    structureDict["useJoystickInput"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.zoomStepFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "change of zoom per keypress (keypad +/-) or mouse wheel increment";
    structureDict["zoomStepFactor"] = d;

    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VSettingsInteractive& data) {
    auto structureDict = py::dict();
    structureDict["openVR"] = GetDictionary(data.openVR);
    structureDict["highlightColor"] = data.PyGetHighlightColor();
    structureDict["highlightItemIndex"] = data.highlightItemIndex;
    structureDict["highlightItemType"] = data.highlightItemType;
    structureDict["highlightMbsNumber"] = data.PyGetHighlightMbsNumber();
    structureDict["highlightOtherColor"] = data.PyGetHighlightOtherColor();
    structureDict["joystickScaleRotation"] = data.joystickScaleRotation;
    structureDict["joystickScaleTranslation"] = data.joystickScaleTranslation;
    structureDict["keypressRotationStep"] = data.keypressRotationStep;
    structureDict["keypressTranslationStep"] = data.keypressTranslationStep;
    structureDict["lockModelView"] = data.lockModelView;
    structureDict["mouseMoveRotationFactor"] = data.mouseMoveRotationFactor;
    structureDict["pauseWithSpacebar"] = data.pauseWithSpacebar;
    structureDict["selectionHighlights"] = data.selectionHighlights;
    structureDict["selectionLeftMouse"] = data.selectionLeftMouse;
    structureDict["selectionLeftMouseItemTypes"] = data.selectionLeftMouseItemTypes;
    structureDict["selectionRightMouse"] = data.selectionRightMouse;
    structureDict["selectionRightMouseGraphicsData"] = data.selectionRightMouseGraphicsData;
    structureDict["trackMarker"] = data.trackMarker;
    structureDict["trackMarkerMbsNumber"] = data.trackMarkerMbsNumber;
    structureDict["trackMarkerOrientation"] = data.PyGetTrackMarkerOrientation();
    structureDict["trackMarkerPosition"] = data.PyGetTrackMarkerPosition();
    structureDict["useJoystickInput"] = data.useJoystickInput;
    structureDict["zoomStepFactor"] = data.zoomStepFactor;
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VSettingsInteractive& data, const py::dict& d) {
    SetDictionary(data.openVR, py::cast<py::dict>(d["openVR"]));
    data.highlightColor = py::cast<std::array<float,4>>(d["highlightColor"]);
    data.highlightItemIndex = py::cast<Index>(d["highlightItemIndex"]);
    data.highlightItemType = py::cast<ItemType>(d["highlightItemType"]);
    data.highlightMbsNumber = py::cast<Index>(d["highlightMbsNumber"]);
    data.highlightOtherColor = py::cast<std::array<float,4>>(d["highlightOtherColor"]);
    data.joystickScaleRotation = py::cast<float>(d["joystickScaleRotation"]);
    data.joystickScaleTranslation = py::cast<float>(d["joystickScaleTranslation"]);
    data.keypressRotationStep = py::cast<float>(d["keypressRotationStep"]);
    data.keypressTranslationStep = py::cast<float>(d["keypressTranslationStep"]);
    data.lockModelView = py::cast<bool>(d["lockModelView"]);
    data.mouseMoveRotationFactor = py::cast<float>(d["mouseMoveRotationFactor"]);
    data.pauseWithSpacebar = py::cast<bool>(d["pauseWithSpacebar"]);
    data.selectionHighlights = py::cast<bool>(d["selectionHighlights"]);
    data.selectionLeftMouse = py::cast<bool>(d["selectionLeftMouse"]);
    data.selectionLeftMouseItemTypes = py::cast<Index>(d["selectionLeftMouseItemTypes"]);
    data.selectionRightMouse = py::cast<bool>(d["selectionRightMouse"]);
    data.selectionRightMouseGraphicsData = py::cast<bool>(d["selectionRightMouseGraphicsData"]);
    data.trackMarker = py::cast<Index>(d["trackMarker"]);
    data.trackMarkerMbsNumber = py::cast<Index>(d["trackMarkerMbsNumber"]);
    data.trackMarkerOrientation = py::cast<std::array<float,3>>(d["trackMarkerOrientation"]);
    data.trackMarkerPosition = py::cast<std::array<float,3>>(d["trackMarkerPosition"]);
    data.useJoystickInput = py::cast<bool>(d["useJoystickInput"]);
    data.zoomStepFactor = py::cast<float>(d["zoomStepFactor"]);
}

//! AUTO: read access to structure; converting into dictionary
inline py::dict GetDictionaryWithTypeInfo(const VisualizationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["nodes"] = GetDictionaryWithTypeInfo(data.nodes);
    structureDict["bodies"] = GetDictionaryWithTypeInfo(data.bodies);
    structureDict["connectors"] = GetDictionaryWithTypeInfo(data.connectors);
    structureDict["markers"] = GetDictionaryWithTypeInfo(data.markers);
    structureDict["loads"] = GetDictionaryWithTypeInfo(data.loads);
    structureDict["sensors"] = GetDictionaryWithTypeInfo(data.sensors);
    structureDict["contour"] = GetDictionaryWithTypeInfo(data.contour);
    structureDict["contact"] = GetDictionaryWithTypeInfo(data.contact);
    structureDict["interactive"] = GetDictionaryWithTypeInfo(data.interactive);
    structureDict["dialogs"] = GetDictionaryWithTypeInfo(data.dialogs);
    structureDict["exportImages"] = GetDictionaryWithTypeInfo(data.exportImages);
    structureDict["window"] = GetDictionaryWithTypeInfo(data.window);
    structureDict["openGL"] = GetDictionaryWithTypeInfo(data.openGL);
    structureDict["raytracer"] = GetDictionaryWithTypeInfo(data.raytracer);
    structureDict["general"] = GetDictionaryWithTypeInfo(data.general);
    return structureDict;
}

//! AUTO: read access to structure; converting into dictionary without type info
inline py::dict GetDictionary(const VisualizationSettings& data) {
    auto structureDict = py::dict();
    structureDict["nodes"] = GetDictionary(data.nodes);
    structureDict["bodies"] = GetDictionary(data.bodies);
    structureDict["connectors"] = GetDictionary(data.connectors);
    structureDict["markers"] = GetDictionary(data.markers);
    structureDict["loads"] = GetDictionary(data.loads);
    structureDict["sensors"] = GetDictionary(data.sensors);
    structureDict["contour"] = GetDictionary(data.contour);
    structureDict["contact"] = GetDictionary(data.contact);
    structureDict["interactive"] = GetDictionary(data.interactive);
    structureDict["dialogs"] = GetDictionary(data.dialogs);
    structureDict["exportImages"] = GetDictionary(data.exportImages);
    structureDict["window"] = GetDictionary(data.window);
    structureDict["openGL"] = GetDictionary(data.openGL);
    structureDict["raytracer"] = GetDictionary(data.raytracer);
    structureDict["general"] = GetDictionary(data.general);
    return structureDict;
}

//! AUTO: write access to data structure; converting dictionary d into structure
inline void SetDictionary(VisualizationSettings& data, const py::dict& d) {
    SetDictionary(data.nodes, py::cast<py::dict>(d["nodes"]));
    SetDictionary(data.bodies, py::cast<py::dict>(d["bodies"]));
    SetDictionary(data.connectors, py::cast<py::dict>(d["connectors"]));
    SetDictionary(data.markers, py::cast<py::dict>(d["markers"]));
    SetDictionary(data.loads, py::cast<py::dict>(d["loads"]));
    SetDictionary(data.sensors, py::cast<py::dict>(d["sensors"]));
    SetDictionary(data.contour, py::cast<py::dict>(d["contour"]));
    SetDictionary(data.contact, py::cast<py::dict>(d["contact"]));
    SetDictionary(data.interactive, py::cast<py::dict>(d["interactive"]));
    SetDictionary(data.dialogs, py::cast<py::dict>(d["dialogs"]));
    SetDictionary(data.exportImages, py::cast<py::dict>(d["exportImages"]));
    SetDictionary(data.window, py::cast<py::dict>(d["window"]));
    SetDictionary(data.openGL, py::cast<py::dict>(d["openGL"]));
    SetDictionary(data.raytracer, py::cast<py::dict>(d["raytracer"]));
    SetDictionary(data.general, py::cast<py::dict>(d["general"]));
}

} //namespace EPyUtils 


#endif //#ifdef include once...
