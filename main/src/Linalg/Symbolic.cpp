/** ***********************************************************************************************
* @brief		implementation of tools for high-performant symbolic computation and expression trees
* @details		Details:
				- self-recording expression trees
				- record C++ code, imitating Real in the regular mode
				- fast evaluation of trees, potential for parallel computation
				- recording of Python math expressions and code for fast user functions
*
* @author		Gerstmayr Johannes
* @date			2023-11-22
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Utilities/BasicDefinitions.h"
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>      //interface to numpy
#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
#include <pybind11/embed.h>      //scoped interpreter
#include <pybind11/cast.h>		 //for arguments
#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)
namespace py = pybind11;

#include "Linalg/BasicLinalg.h"
#include "Pymodules/PybindUtilities.h"

#include <typeinfo>  //for typeid

//temporarily, for user function:
#include "Main/MainSystem.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamperExt.h"
#include "Autogenerated/CObjectConnectorCoordinate.h"
#include "Autogenerated/CObjectConnectorLinearSpringDamper.h"
#include "Autogenerated/CObjectConnectorSpringDamper.h"
#include "Autogenerated/CObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/CObjectConnectorTorsionalSpringDamper.h"

#include "Autogenerated/CObjectANCFCable2D.h"
#include "Autogenerated/CObjectGenericODE2.h"
#include "Autogenerated/CObjectGenericODE1.h"
#include "Autogenerated/CObjectFFRF.h"
#include "Autogenerated/CObjectFFRFreducedOrder.h"
#include "Autogenerated/CObjectKinematicTree.h"
#include "Autogenerated/CObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/CObjectConnectorCoordinateVector.h"
#include "Autogenerated/CObjectJointGeneric.h"
					   
#include "Autogenerated/CLoadCoordinate.h"
#include "Autogenerated/CLoadForceVector.h"
#include "Autogenerated/CLoadTorqueVector.h"
#include "Autogenerated/CLoadMassProportional.h"
//#include "Autogenerated/CSensorUserFunction.h" //no performance issue; would require StdArrayIndex and ConfigurationType ...

#include "Linalg/Symbolic.h"
#include "Linalg/SymbolicVector.h"
#include "Linalg/SymbolicMatrix.h"
#include "Linalg/SymbolicUtilities.h"

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Initialize the static flag
bool Symbolic::SReal::recordExpressions = true; //advantageous, if on by default; otherwise, users may forget ...
bool Symbolic::SReal::flagDebug = false;

int Symbolic::ExpressionBase::newCount = 0;
int Symbolic::ExpressionBase::deleteCount = 0;
int Symbolic::VectorExpressionBase::newCount = 0;
int Symbolic::VectorExpressionBase::deleteCount = 0;
int Symbolic::MatrixExpressionBase::newCount = 0;
int Symbolic::MatrixExpressionBase::deleteCount = 0;

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//plan:
// DONE: add PySpecial and exudyn.special to be used for special flags or functions, not intended to be used broadly 
// DONE: add Symbol submodule
// DONE: put SReal into separate header file
// DONE: Test simple Python SReal, manually implemented similar to NodeIndex
// DONE: ExpressionLinkedReal to link data to existing C++ data
// DONE: SymbolicIfThenElse
// DONE: add comparison operators < <= == != > >=

// DONE: Make all functions templated like Symbolic::sin
// DONE: add all Real:SReal combinations 
// DONE: add missing functions: sinh, cosh, tanh, 
// DONE: add missing functions: ... check some function table ...
// 
// DONE: Sign function
// DONE: analyze function in Python: create args, return values and symbolic trees
// DONE: add variable carrying SymbolicLinkedReal or SReal, having additional name
// DONE: design function: args are SymbolicLinkedReal that are passed on to expressions which compute a number
// DONE: SymbolicFunction with list of args (variable as hiearchical class with [Bool/Int]/Real/RealVector/RealMatrix?)
//   ==> return value (Real, Vector, ...) again as list of variables that are filled
//   ==> args are local variables (Real, int, Vector, ...), SymbolicLinkedReal are linked to these variables
//   ==> during function call, the local args are set; return values are evaluated as real
// 
// DONE: Not necessary: IncreaseReferenceCounter => do this when used in operators or functions, but not outside ... => check increase/decrease
// DONE: add "_" to allowed variable chars
// DONE: add SymbolicFunction and add to Python interface
// DONE: SymbolicFunction: consider a way of storing a function globally, but such that calling is thread-safe, 
//       without copying tree; means that each time, the SymbolicLinkedReal args are set and return values are copied back
//       test with modified / adapted user function for SpringDamper
// 
// DONE: generalized SymbolicFunction: put most parts of ConnectorSpringDamperUFspringForce(py::object pyObject) into base function
// DONE: generalized SymbolicFunction: EvaluateScalar: use variadic args to generalize
// 
// add utilities function to build prototype user-functions
// build one Python function (taking function, prototype function, destination object), 
//   => converts a given function; 
//   => checks for correct interface
//   => checks for correct destination object type
// 
// DONE: bind Python function to symbolic module
// DONE: Create automated user function classes and interfaces for most user functions
//   create all Python user function interfaces (with types)
//   create C++ class to carry user function (only one per std::function type); similar to ConnectorSpringDamperUFspringForce
//   automatically create Python bindings (symbolic) for these user functions (must be included into Symbolic.cpp file)
// DONE: put ConvertFunctionToSymbolic, CreateSymbolicUserFunction to exudyn.advancedUtilities
// 
// DONE: add missing functions: not(SReal)
// DONE: returnList => returnValue, also as SymbolicGeneric
// DONE: add VariableSet to symbolic (and later on to mbs)
// DONE: create SymbolicGeneric (holds SReal, SVector, with type switch; may also hold other types in future);
// DONE: argList becomes list of SymbolicGeneric
// DONE: extend userFunctionArgs for StdVector, etc.
// DONE: put userFunctionArgs types into userFunction dict
// DONE: adapt Python functions for SVector
// DONE: Create documentation for symbolic module (with autoGeneratePyBindings.py)
//		DONE: add SReal to docu; create SReal, create NamedReal
//		DONE: evaluate, recording, ...
//		DONE: add docu for all operators and functions
//		Create documentation for symbolic user functions
// DONE: Add 3D vector (and possibly other vectors) to symbolic
// DONE: SymbolicVector: add ResizableConstVector with const size of 7
// DONE: SymbolicVector: add operators *, -, +(), -(), ==, !=
// DONE: SymbolicVector: add operators +=, -=, *=, [i] (read/write?), 
// DONE: SymbolicVector: add functions NormL2(...), Skew(...), ...
// DONE: SymbolicVector: initializer list SReal: check how to do this in Python?
// Fix new/delete counts for SReal / SVector
// DONE: SymbolicVector: add NumberOfItems() to VectorExpressionBase and perform size checks in operators, if possible?
// 
// Add 3D matrix to symbolic
// SymbolicMatrix: add ResizableConstMatrix with const size of 12? 
//                 check if 6x6 matrices could be handled just by its components and M*v still works without new; 
//                 M*M should only happen for rotation matrices?
// SymbolicMatrix: add operators *, +, -, +(), -(), ==, +=, -=, *=, !=, [i] (read/write?), Set(i,j, SReal), Get(i,j)
// SymbolicMatrix: add functions NormL2(...), Skew(...), Inv(...), Transpose(...), ...
// 
// DONE: make symbolic variable space, available globally in exudyn.symbolic as well as in mbs.symbolic; 
//		this allows to store/transfer data into user functions without the need for Python; 
//		use integer handles which are returned by creation function: 
//		a=symbolic.NamedReal(value, name)
//		handle=symbolic.variables.AddReal(a)
//		symbolic.variables.clear()
// 
// **NEXT**
// Add ANCF Cable user function
// Create "MainSystem.symbolic" with functions compatible to MainSystem, but without Python
//		access via mbs.symbolic.GetObjectOutput(...)
//		define functions, which shall be mapped: GetSensorValues, GetNodeOutput, Get...Output, 
//												systemData: first introduce reference to system coordinate vectors
// 
// 
// DONE: put class interface into exudyn.symbolic abbrv. as esym
// add EXUDYN_MINIMAL_COMPILATION flag for exudyn (only few objects, no graphics, ...)
// test compile EXUDYN_MINIMAL_COMPILATION and replacing Real with SReal in general (which problems could appear?)
// consider access to MainSystem and SystemData functions, using special calls (templated?); 
// DONE: add (dense) vector, matrix SReal objects for Python side
// consider AssignEvaluate method, which builds intermediate objects (expressions), which do not add up in the tree
//     OR:
//   sf = SymbolicFunction([arg1, arg2, ...])
//   sf.AddVar(var1)
//	 sf.AddAssign(var1, 1+arg1)
//   sf.AddAssign(var2, arg2*arg1)
//   sf.AddReturn([var1, var2])
//     AND:
//   sf1 = Statement()
//   sf1.AddAssign(var1, 1+var)
//   sf1.AddAssign(var1, var1*2)
//   x = NamedReal(0,'x')
//   sf.AddForLoop(x, [0,10], sf1)
// 
// add ExprCode, allowing statements and loops for user functions


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void Init_Pybind_Symbolic(py::module& m) {

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	py::class_<Symbolic::SReal>(m, "Real", "symbolic.Real: a hybrid Real-symbolic type used for recording of expression trees")
		.def(py::init<>())
		.def(py::init<Real>())
		.def(py::init<STDstring, Real>()) //named real, gives separate expression ...
		.def(py::init<int>())
		
		.def_readwrite_static("__newCount", &Symbolic::ExpressionBase::newCount)
		.def_readwrite_static("__deleteCount", &Symbolic::ExpressionBase::deleteCount)

		//+++++++++++++++++++++++++++++++++++++++++++
		.def("SetValue", &Symbolic::SReal::SetSymbolicValue,
			"set value of symbolic Real quantity")

		.def("Evaluate", &Symbolic::SReal::Evaluate,
			"return evaluated expression (prioritized) or stored Real value")

		//.def("Diff", py::overload_cast<const Symbolic::SReal&>(&Symbolic::SReal::Diff),
		//	"return derivative of stored expression w.r.t. given variable")
		.def("Diff", &Symbolic::SReal::DiffSReal,
			//static_cast<Real (Symbolic::SReal::Diff::*)(const Symbolic::SReal&)>(&Symbolic::SReal::Diff),
			"return derivative of stored expression w.r.t. given variable")

		//.def("ToString", &Symbolic::SReal::ToString,
		//	"return string representation")

		.def_property("value", &Symbolic::SReal::GetValue, &Symbolic::SReal::SetValue)

		.def("__float__", [](const Symbolic::SReal& item) {
		return (Real)item;
			}, "same as Evaluate()")

		//+++++++++++++++++++++++++++++++++++++++++++
		//add operators: (right now, we do not have implicit conversion from Real to Symbolic::SReal)
		.def(py::self + py::self)
		.def(py::self + Real()) //brace needed to define the special case
		.def(Real() + py::self) //brace needed to define the special case

		.def(py::self - py::self)
		.def(py::self - Real())
		.def(Real() - py::self)

		.def(py::self * py::self)
		.def(py::self * Real())
		.def(Real() * py::self)

		.def(py::self / py::self)
		.def(py::self / Real())
		.def(Real() / py::self)

		.def(py::self += py::self)
		.def(py::self += Real())
		.def(py::self -= py::self)
		.def(py::self -= Real())
		.def(py::self *= py::self)
		.def(py::self *= Real())
		.def(py::self /= py::self)
		.def(py::self /= Real())

		.def(-py::self) //-Real not needed => converts to number!
		.def(+py::self) //+Real not needed => converts to number!

		.def(py::self == py::self)
		.def(Real() == py::self)
		.def(py::self == Real())
		.def(py::self != py::self)
		.def(Real() != py::self)
		.def(py::self != Real())

		.def(py::self > py::self)
		.def(Real() > py::self)
		.def(py::self > Real())
		.def(py::self >= py::self)
		.def(Real() >= py::self)
		.def(py::self >= Real())
		
		.def(py::self <= py::self)
		.def(Real() <= py::self)
		.def(py::self <= Real())
		.def(py::self < py::self)
		.def(Real() < py::self)
		.def(py::self < Real())

				
		//pow as ** needs special treatment:
		.def("__pow__", [](const Symbolic::SReal& base, const Symbolic::SReal& exponent) { return Symbolic::SReal::pow(base, exponent); }, py::is_operator())
		.def("__pow__", [](const Symbolic::SReal& base, const Real& exponent) { return Symbolic::SReal::pow(base, exponent); }, py::is_operator())
		.def("__pow__", [](const Real& base, const Symbolic::SReal& exponent) { return Symbolic::SReal::pow(base, exponent); }, py::is_operator())

		//+++++++++++++++++++++++++++++++++++++++++++
		//representation:
		.def("__str__", [](const Symbolic::SReal& item) {
		return item.ToString();
			}, "return evaluated expression (prioritized) or stored Real value")
		.def("__repr__", [](const Symbolic::SReal& item) {
		return item.ToString();
			}, "return evaluated expression (prioritized) or stored Real value")
		;

	//+++++++++++++++++++++++++++++++++++++++++++
	//functions defined in module!:
	m.def("isfinite", &Symbolic::SReal::isfinite<Symbolic::SReal>);
	m.def("isfinite", &Symbolic::SReal::isfinite<Real>);
	m.def("abs", &Symbolic::SReal::abs<Symbolic::SReal>);
	m.def("abs", &Symbolic::SReal::abs<Real>);
	m.def("sign", &Symbolic::SReal::sign<Symbolic::SReal>);
	m.def("sign", &Symbolic::SReal::sign<Real>);
	m.def("Not", &Symbolic::SReal::Not<Symbolic::SReal>);
	m.def("Not", &Symbolic::SReal::Not<Real>);

	m.def("round", &Symbolic::SReal::round<Symbolic::SReal>);
	m.def("round", &Symbolic::SReal::round<Real>);
	m.def("ceil", &Symbolic::SReal::ceil<Symbolic::SReal>);
	m.def("ceil", &Symbolic::SReal::ceil<Real>);
	m.def("floor", &Symbolic::SReal::floor<Symbolic::SReal>);
	m.def("floor", &Symbolic::SReal::floor<Real>);

	m.def("sqrt", &Symbolic::SReal::sqrt<Symbolic::SReal>);
	m.def("sqrt", &Symbolic::SReal::sqrt<Real>);
	m.def("exp", &Symbolic::SReal::exp<Symbolic::SReal>);
	m.def("exp", &Symbolic::SReal::exp<Real>);
	m.def("log", &Symbolic::SReal::log<Symbolic::SReal>);
	m.def("log", &Symbolic::SReal::log<Real>);

	m.def("sin", &Symbolic::SReal::sin<Symbolic::SReal>);
	m.def("sin", &Symbolic::SReal::sin<Real>);
	m.def("cos", &Symbolic::SReal::cos<Symbolic::SReal>);
	m.def("cos", &Symbolic::SReal::cos<Real>);
	m.def("tan", &Symbolic::SReal::tan<Symbolic::SReal>);
	m.def("tan", &Symbolic::SReal::tan<Real>);

	m.def("asin", &Symbolic::SReal::asin<Symbolic::SReal>);
	m.def("asin", &Symbolic::SReal::asin<Real>);
	m.def("acos", &Symbolic::SReal::acos<Symbolic::SReal>);
	m.def("acos", &Symbolic::SReal::acos<Real>);
	m.def("atan", &Symbolic::SReal::atan<Symbolic::SReal>);
	m.def("atan", &Symbolic::SReal::atan<Real>);

	m.def("sinh", &Symbolic::SReal::sinh<Symbolic::SReal>);
	m.def("sinh", &Symbolic::SReal::sinh<Real>);
	m.def("cosh", &Symbolic::SReal::cosh<Symbolic::SReal>);
	m.def("cosh", &Symbolic::SReal::cosh<Real>);
	m.def("tanh", &Symbolic::SReal::tanh<Symbolic::SReal>);
	m.def("tanh", &Symbolic::SReal::tanh<Real>);

	m.def("asinh", &Symbolic::SReal::asinh<Symbolic::SReal>);
	m.def("asinh", &Symbolic::SReal::asinh<Real>);
	m.def("acosh", &Symbolic::SReal::acosh<Symbolic::SReal>);
	m.def("acosh", &Symbolic::SReal::acosh<Real>);
	m.def("atanh", &Symbolic::SReal::atanh<Symbolic::SReal>);
	m.def("atanh", &Symbolic::SReal::atanh<Real>);

	//++++++++++ with 2 args
	
	m.def("pow", &Symbolic::SReal::pow<Symbolic::SReal, Symbolic::SReal>);
	m.def("pow", &Symbolic::SReal::pow<Symbolic::SReal, Real>);
	m.def("pow", &Symbolic::SReal::pow<Real, Symbolic::SReal>);
	m.def("pow", &Symbolic::SReal::pow<Real, Real>);
	m.def("atan2", &Symbolic::SReal::atan2<Symbolic::SReal, Symbolic::SReal>);
	m.def("atan2", &Symbolic::SReal::atan2<Symbolic::SReal, Real>);
	m.def("atan2", &Symbolic::SReal::atan2<Real, Symbolic::SReal>);
	m.def("atan2", &Symbolic::SReal::atan2<Real, Real>);
	m.def("mod", &Symbolic::SReal::mod<Symbolic::SReal, Symbolic::SReal>);
	m.def("mod", &Symbolic::SReal::mod<Symbolic::SReal, Real>);
	m.def("mod", &Symbolic::SReal::mod<Real, Symbolic::SReal>);
	m.def("mod", &Symbolic::SReal::mod<Real, Real>);

	m.def("min", &Symbolic::SReal::min<Symbolic::SReal, Symbolic::SReal>);
	m.def("min", &Symbolic::SReal::min<Symbolic::SReal, Real>);
	m.def("min", &Symbolic::SReal::min<Real, Symbolic::SReal>);
	m.def("min", &Symbolic::SReal::min<Real, Real>);
	m.def("max", &Symbolic::SReal::max<Symbolic::SReal, Symbolic::SReal>);
	m.def("max", &Symbolic::SReal::max<Symbolic::SReal, Real>);
	m.def("max", &Symbolic::SReal::max<Real, Symbolic::SReal>);
	m.def("max", &Symbolic::SReal::max<Real, Real>);

	//++++++++++ with 3 args
	m.def("IfThenElse", &Symbolic::SReal::IfThenElse<Symbolic::SReal, Symbolic::SReal, Symbolic::SReal>);

	//+++++++++++++++++++++++++++++++++++++++++++
	m.def("GetRecording", &Symbolic::SReal::GetRecording,
		"get current (global / module-wide) status of recording");
	m.def("SetRecording", &Symbolic::SReal::SetRecording,
		"set current (global / module-wide) status of recording");






	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	py::class_<Symbolic::SymbolicRealVector>(m, "Vector", "symbolic.Vector: a hybrid Vector-symbolic type used for recording of expression trees")
		.def(py::init<>())
		.def(py::init<py::list>()) //cast from mixed list of Real and SReal
		.def(py::init<std::vector<Real> >()) //cast from list and numpy array
		.def(py::init<STDstring, std::vector<Real> >())

		.def_readwrite_static("__newCount", &Symbolic::VectorExpressionBase::newCount)
		.def_readwrite_static("__deleteCount", &Symbolic::VectorExpressionBase::deleteCount)

		//would work if initializer_list implemented in SymbolicRealVector, but is dangerous:
		//.def(py::init<Symbolic::SReal, Symbolic::SReal, Symbolic::SReal >()) //cast from list of SReal

		//+++++++++++++++++++++++++++++++++++++++++++
		.def("Evaluate", &Symbolic::SymbolicRealVector::PyEvaluate,
			"return evaluated expression (prioritized) or stored Real value")

		.def("SetVector", &Symbolic::SymbolicRealVector::SetSymbolicVector,
			"set symbolic Vector quantity")

		//.def("ToString", &Symbolic::SymbolicRealVector::ToString,
		//	"return string representation")

		.def("NumberOfItems", &Symbolic::SymbolicRealVector::NumberOfItems)

		//this could be allowed in certain cases, such as if we carry a VectorExpressionSReal or VectorExpressionReal
		//but it would be not possible then to record operations in the tree ...
		.def("__setitem__", [](Symbolic::SymbolicRealVector& self, Index index, Real value)
			{ self.SetSymbolicVectorComponent(index, value); })

		.def("__len__", [](const Symbolic::SymbolicRealVector& item) {
		return item.NumberOfItems();
			}, "return number of items")

		//+++++++++++++++++++++++++++++++++++++++++++
		//representation:
		.def("__str__", [](const Symbolic::SymbolicRealVector& item) {
		return item.ToString();
			}, "return evaluated expression (prioritized) or stored vector")
		.def("__repr__", [](const Symbolic::SymbolicRealVector& item) {
				return item.ToString();
			}, "return evaluated expression (prioritized) or stored vector")
				

		//+++++++++++++++++++++++++++++++++++++++++++
		//recorded functions and operators:
		.def("NormL2", &Symbolic::SymbolicRealVector::NormL2)
		.def("MultComponents", &Symbolic::SymbolicRealVector::MultComponents)

		.def("__getitem__", [](const Symbolic::SymbolicRealVector& self, Index index)
			{ return self[index]; })

		//operators: (right now, we do not have implicit conversion from Real to Symbolic::SReal)
		.def(py::self + py::self)
		.def(py::self - py::self)
		.def(py::self * py::self)

		.def(py::self * Real())
		.def(Real() * py::self)
		.def(py::self * Symbolic::SReal())
		.def(Symbolic::SReal() * py::self)

		.def(py::self += py::self)
		.def(py::self -= py::self)
		.def(py::self *= Real())
		.def(py::self *= Symbolic::SReal())

		.def(-py::self)

		.def(py::self == py::self)
		.def(py::self != py::self)
		;


	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	py::class_<Symbolic::SymbolicRealMatrix>(m, "Matrix", "symbolic.Matrix: a hybrid Matrix-symbolic type used for recording of expression trees")
		.def(py::init<>())
		.def(py::init<py::list>()) //cast from mixed list of Real and SReal
		.def(py::init<py::array_t<Real> >()) //cast from list and numpy array
		.def(py::init<STDstring, py::array_t<Real> >())

		//would work if initializer_list implemented in SymbolicRealMatrix, but is dangerous:
		//.def(py::init<Symbolic::SReal, Symbolic::SReal, Symbolic::SReal >()) //cast from list of SReal

		.def_readwrite_static("__newCount", &Symbolic::MatrixExpressionBase::newCount)
		.def_readwrite_static("__deleteCount", &Symbolic::MatrixExpressionBase::deleteCount)

		//+++++++++++++++++++++++++++++++++++++++++++
		.def("Evaluate", &Symbolic::SymbolicRealMatrix::PyEvaluate,
			"return evaluated expression (prioritized) or stored Real value")

		.def("SetMatrix", &Symbolic::SymbolicRealMatrix::SetSymbolicMatrix,
			"set symbolic Matrix quantity")

		.def("NumberOfRows", &Symbolic::SymbolicRealMatrix::NumberOfRows)
		.def("NumberOfColumns", &Symbolic::SymbolicRealMatrix::NumberOfColumns)

		//this could be allowed in certain cases, such as if we carry a MatrixExpressionSReal or MatrixExpressionReal
		//but it would be not possible then to record operations in the tree ...
		.def("__setitem__", [](Symbolic::SymbolicRealMatrix& self, std::pair<Index, Index> index, Real value)
			{ self.SetSymbolicMatrixComponent(index.first, index.second, value); })

		//+++++++++++++++++++++++++++++++++++++++++++
		//representation:
		.def("__str__", [](const Symbolic::SymbolicRealMatrix& item) {
		return item.ToString();
			}, "return evaluated expression (prioritized) or stored matrix")
		.def("__repr__", [](const Symbolic::SymbolicRealMatrix& item) {
				return item.ToString();
			}, "return evaluated expression (prioritized) or stored matrix")


		//+++++++++++++++++++++++++++++++++++++++++++
		//recorded functions and operators:
		//.def("NormL2", &Symbolic::SymbolicRealMatrix::NormL2)
		//.def("MultComponents", &Symbolic::SymbolicRealMatrix::MultComponents)

		.def("__getitem__", [](const Symbolic::SymbolicRealMatrix& self, std::pair<Index, Index> index)
			{ return self.GetComponent(index.first, index.second); })

		.def("Get", [](const Symbolic::SymbolicRealMatrix& self, Index row, Index column)
			{ return self.GetComponent(row, column); })

		//operators: (right now, we do not have implicit conversion from Real to Symbolic::SReal)
		.def(py::self + py::self)
		.def(py::self - py::self)
		.def(py::self * py::self)

		.def(py::self * Real())
		.def(Real() * py::self)

		.def(py::self * Symbolic::SReal())
		.def(Symbolic::SReal() * py::self)
		.def(py::self * Symbolic::SymbolicRealVector())
		.def(Symbolic::SymbolicRealVector() * py::self)

		.def(py::self += py::self)
		.def(py::self -= py::self)
		.def(py::self *= Real())
		.def(py::self *= Symbolic::SReal())

		.def(-py::self)

		//.def(py::self == py::self)
		//.def(py::self != py::self)
		;



	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	py::class_<Symbolic::VariableSet>(m, "VariableSet", "symbolic.VariableSet: set of variables which can be accessed from Python and C++")
		.def(py::init<>())

		//+++++++++++++++++++++++++++++++++++++++++++
		.def("Add", 
			(void (Symbolic::VariableSet::*)(const STDstring&, Real))& Symbolic::VariableSet::AddVariable,
			//&Symbolic::VariableSet::AddVariable,
			"add a new variable to the set, which may not exist")

		.def("Add",
			(void (Symbolic::VariableSet::*)(const Symbolic::SReal&))& Symbolic::VariableSet::AddVariable,
			"add a new variable to the set, which may not exist")

		.def("Get",
			&Symbolic::VariableSet::GetVariable,
			"return variable with given name")

		.def("Set",
			(void (Symbolic::VariableSet::*)(const STDstring&, Real))& Symbolic::VariableSet::SetVariable,
			"set given variable to new value or add new variable, if none exists")

		.def("Exists",
			&Symbolic::VariableSet::HasVariable,
			"return true, if variable exists")

		.def("NumberOfItems",
			&Symbolic::VariableSet::NumberOfItems,
			"return number of variables")
		
		.def("GetNames",
			&Symbolic::VariableSet::GetNames,
			"return list of variable names")

		.def("Reset",
			&Symbolic::VariableSet::Reset,
			"clear variable space")

		//this could be allowed in certain cases, such as if we carry a VectorExpressionSReal or VectorExpressionReal
		//but it would be not possible then to record operations in the tree ...
		.def("__getitem__", [](Symbolic::VariableSet& self, std::string name)
			{ return self.GetVariable(name); })

		.def("__setitem__", [](Symbolic::VariableSet& self, std::string name, Real value)
			{ return self.SetVariable(name, value); })


		//representation:
		.def("__str__", [](const Symbolic::VariableSet& item) {
		return item.ToString();
			}, "return set of variables with current values as string")
		.def("__repr__", [](const Symbolic::VariableSet& item) {
				return item.ToString();
			}, "return set of variables as representation")

		;

	//py::dict variables;
	Symbolic::VariableSet variables; //!< module-wide set of variables; used to exchange information in particular at C++ level
	m.attr("variables") = variables;


	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	py::class_<Symbolic::PySymbolicUserFunction>(m, "UserFunction", "used to create symbolic user functions, evaluated purly on C++ side")
		.def(py::init<>())

		.def("SetUserFunctionFromDict", &Symbolic::PySymbolicUserFunction::SetUserFunctionFromDict<ObjectIndex>,
			"set user function given by according dictionary, item index and user function name")
		.def("SetUserFunctionFromDict", &Symbolic::PySymbolicUserFunction::SetUserFunctionFromDict<LoadIndex>,
			"set user function given by according dictionary, item index and user function name")

		.def("TransferUserFunction2Item", &Symbolic::PySymbolicUserFunction::TransferUserFunction2Item<ObjectIndex>,
			"transfer stored user function to given MainSystem with item index and user function name")
		.def("TransferUserFunction2Item", &Symbolic::PySymbolicUserFunction::TransferUserFunction2Item<LoadIndex>,
			"transfer stored user function to given MainSystem with item index and user function name")

		.def("Evaluate", &Symbolic::PySymbolicUserFunction::PyEvaluateUF,
			"for testing: evaluate user function; note: this version is much slower than the C++ version because of the overhead in the interface")

		.def("__str__", [](const Symbolic::PySymbolicUserFunction& item) {
		return item.ToString();
			}, "return function as string")

		.def("__repr__", [](const Symbolic::PySymbolicUserFunction& item) {
			return STDstring("Symbolic<")+item.GetFunctionName() + STDstring(">");
			}, "return function information")
		;

}









//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void PyTest()
{
	typedef Symbolic::SReal SR;
	typedef Symbolic::SymbolicRealVector SRV;
	if (false)
	{
		Symbolic::SReal a = 5;
		Symbolic::SReal b(3);
		Symbolic::SReal c = 2 + (a + b) * 7.;
		std::cout << "regular Real:" << (Real)c << std::endl;
		std::cout << "regular Expression:" << c.ToString() << std::endl;
	}

	if (false)
	{
		Symbolic::SReal::SetRecording(true); // Turn on expression recording
		Symbolic::ExpressionNamedReal n("x13", 42.);
		Symbolic::SReal a(&n);
		Symbolic::SReal b(3);
		Symbolic::SReal c = 2 + (a + b) * 7.;
		std::cout << "regular Real:" << (Real)c << std::endl;
		std::cout << "regular Expression:" << c.ToString() << std::endl;
	}

	//Vector
	if (true)
	{
		Symbolic::SReal::SetRecording(true); // Turn on expression recording
		Symbolic::ExpressionNamedReal n("a", 42.);
		Symbolic::SReal a(&n);
		Symbolic::SReal bb(3);
		SRV c = Vector({ 3.3,2.2,1.1 });
		std::cout << "Vector c: " << c << "=" << c.Evaluate() << std::endl;
		SRV d = bb * c;
		std::cout << "Vector d: " << d << "=" << d.Evaluate() << std::endl;
		Symbolic::SReal e = c * c;
		std::cout << "Real e: " << e << "=" << e.Evaluate() << std::endl;

		Symbolic::ExpressionNamedReal nb("b", 2.5);
		Symbolic::SReal b(&nb);

		SRV v1;
		v1.SetSRealVector({ a, b, SR(3.1) });
		SRV v2;
		v2.SetSRealVector({ a / 2, b + 1, SR(3) });

		SRV v3 = -v1 + 2. * v2;
		Vector vv1({ 0.5 * EXUstd::pi / 42,0.,0. });
		SRV v4 = -v1 + 2. * v2 + SR::sin(v1 * SRV(vv1) ) * v1;
		Vector vv2({ 0.5 * EXUstd::pi / 42,0.,0. });
		std::cout << "sin term = " << (Real)(SR::sin(v1 * SRV(vv2) )) << std::endl;

		std::cout << "Vector v1: " << v1 << "=" << v1.Evaluate() << std::endl;
		std::cout << "Vector v2: " << v2 << "=" << v2.Evaluate() << std::endl;
		std::cout << "Vector v3: " << v3 << "=" << v3.Evaluate() << std::endl;
		std::cout << "Vector v4: " << v4 << "=" << v4.Evaluate() << std::endl;

	}

	if (false) //test diff
	{
		Symbolic::ExpressionNamedReal xVar("x",3.);
		Symbolic::SReal x(&xVar);
		Symbolic::SReal a(1.);

		//Symbolic::SReal f = Symbolic::SReal::sin(5. * x) * x + x * (x + 2);
		Symbolic::SReal f = a * (5. - x) * SR::tan(x) + SR::atan2(x, 1) + SR::abs(x) + SR::sin(x) * SR::cos(x) * (x + 2);
		std::cout << "f: " << f << "=" << f.Evaluate() << ", diff(f,x)=" << f.Diff(&xVar) << std::endl;
	}

	if (false)
	{
		Symbolic::SReal::SetRecording(true); // Turn on expression recording
		typedef Symbolic::SReal SR;

		Symbolic::ExpressionNamedReal na("a", 5);
		Symbolic::ExpressionNamedReal nb("b", EXUstd::pi);
		Symbolic::ExpressionNamedReal nc("c", 7.42);
		Symbolic::SReal a(&na);
		Symbolic::SReal b(&nb);
		Symbolic::SReal c(&nc);
		//SR a(5);
		//SR b(EXUstd::pi);
		//SR c(7.42);
		SR f;
		f = a + b - a * c / c;
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::sin(b);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::cos(b);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::tan(b);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";

		f = SR::sign(a);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::sign(-a);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::min(a, b);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::max(a, b);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::round(c);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::round(-c);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::round(c + 0.3);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::round(-c - 0.3);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::atan2(1, c - c);
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::sqrt(SR::pow(a - a + 4.33, 2.));
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::isfinite(1. / (a - a));
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = SR::isfinite(1. * (a - a));
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";
		f = 1;
		std::cout << "f:" << f.ToString() << "=" << (Real)f << "\n";

	}

	if (false)
	{
		Symbolic::SReal::SetRecording(true); // Turn on expression recording
		Symbolic::SReal w;
		w = 5;
		Symbolic::SReal a(5);
		Symbolic::SReal b(3);
		Symbolic::SReal d(7);
		//std::cout << "a:" << a.ReferenceCounter() << ", b:" << b.ReferenceCounter() << "\n";
		Symbolic::SReal x = a + 2. * b;
		//std::cout << "a:" << a.ReferenceCounter() << ", b:" << b.ReferenceCounter() << ", x:" << x.ReferenceCounter() << "\n";
		Symbolic::SReal c = a + b + x; //= d * (a + Symbolic::SReal::sin(x)) + b * 2;// +Symbolic::SReal::pow(8, 2);
		//std::cout << "a:" << a.ReferenceCounter() << ", b:" << b.ReferenceCounter() << ", x:" << x.ReferenceCounter() << ", c:" << c.ReferenceCounter() << "\n";
		//c = b;// d* Symbolic::SReal::cos(Symbolic::SReal::sin(x));
		//std::cout << "a:" << a.ReferenceCounter() << ", b:" << b.ReferenceCounter() << ", x:" << x.ReferenceCounter() << ", c:" << c.ReferenceCounter() << "\n";
		//c = d * Symbolic::SReal::cos(Symbolic::SReal::sin(x));
		//std::cout << "a:" << a.ReferenceCounter() << ", b:" << b.ReferenceCounter() << ", x:" << x.ReferenceCounter() << ", c:" << c.ReferenceCounter() << "\n";
		Symbolic::SReal e = d * (a + 8) + 3. * b * 2;// +Symbolic::SReal::pow(8, 2);

		//for (int j = 0; j < 100; j++)
		//{
		//	e += (a * b);
		//}

		Symbolic::SReal::SetRecording(false); // Turn off expression recording
		if (true)
		{
			int n = 10000000;
			Real tstart = -EXUstd::GetTimeInSeconds();
			Real z = 0;
			for (int i = 0; i < n; i++)
			{
				z += e.Evaluate(); //2-4ns/op for evaluation or recorded expression
				z += e.Evaluate();
			}
			tstart += EXUstd::GetTimeInSeconds();
			std::cout << "result1=" << z << ", time per op=" << tstart / (2 * 5 * n) * 1e9 << "ns\n";

			tstart = -EXUstd::GetTimeInSeconds();
			z = 0;
			for (int i = 0; i < n; i++)
			{
				Symbolic::SReal e = d * (a + 8) + 3. * b * 2;// i9: 3ns/op in evaluation mode; 126ns/op in recording mode
				Symbolic::SReal f = d * (a + 8) + 3. * b * 2;// 
				z += (Real)e + (Real)f;
			}
			tstart += EXUstd::GetTimeInSeconds();
			std::cout << "result2=" << z << ", time per op=" << tstart / (2 * 6 * n) * 1e9 << "ns\n";
		}

		//w = 3 * x;

		std::cout << (Real)e << std::endl;
		std::cout << "Expression:" << e.ToString() << std::endl;


		//SlimVectorBase<Symbolic::SReal, 3> v({ 1+a,3*x,42 });
		//v[0] = a + b;
		//std::cout << "\nv=" << v << std::endl;
		//std::cout << "\nv[0] = " << v[0].ToString() << std::endl;
		Symbolic::SReal::SetRecording(false); // Turn off expression recording

	}
	std::cout << "newCount:" << Symbolic::ExpressionBase::newCount << std::endl;
	std::cout << "deleteCount:" << Symbolic::ExpressionBase::deleteCount << std::endl;
}



