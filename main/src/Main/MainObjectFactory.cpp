/** ***********************************************************************************************
* @brief		ObjectFactory implementation
* @details		Details:
				- creation of objects in Exudyn
*
* @author		Gerstmayr Johannes
* @date			2019-04-19 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/MainSystem.h"
#include "Linalg/KinematicsBasics.h"

#include "Pymodules/PybindUtilities.h"
#include "Pymodules/PyMatrixVector.h"


//files for minimal compilation:
#include "Autogenerated/MainObjectMassPoint.h"
#include "Autogenerated/MainObjectGround.h"
#include "Autogenerated/MainObjectConnectorSpringDamper.h"
#include "Autogenerated/MainObjectANCFCable2D.h"
#include "Autogenerated/MainNodePoint.h"
#include "Autogenerated/MainMarkerBodyPosition.h"
#include "Autogenerated/MainLoadForceVector.h"
#include "Autogenerated/MainSensorNode.h"

#ifndef EXUDYN_MINIMAL_COMPILATION
#include "Autogenerated/MainObjectMassPoint.h"
#include "Autogenerated/MainObjectMassPoint2D.h"
#include "Autogenerated/MainObjectMass1D.h"
#include "Autogenerated/MainObjectRotationalMass1D.h"
#include "Autogenerated/MainObjectRigidBody.h"
#include "Autogenerated/MainObjectRigidBody2D.h"
#include "Autogenerated/MainObjectGenericODE2.h"
#include "Autogenerated/MainObjectGenericODE1.h"
#include "Autogenerated/MainObjectKinematicTree.h"
#include "Autogenerated/MainObjectFFRF.h"
#include "Autogenerated/MainObjectFFRFreducedOrder.h"
//#include "Autogenerated/MainObjectGround.h"

#include "Autogenerated/MainObjectANCFCable.h"
//#include "Autogenerated/MainObjectANCFCable2D.h"
#include "Autogenerated/MainObjectALEANCFCable2D.h"
#include "Autogenerated/MainObjectANCFBeam.h"
#include "Autogenerated/MainObjectBeamGeometricallyExact2D.h"
#include "Autogenerated/MainObjectBeamGeometricallyExact.h"

//#include "Autogenerated/MainObjectConnectorSpringDamper.h"
#include "Autogenerated/MainObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/MainObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/MainObjectConnectorLinearSpringDamper.h"
#include "Autogenerated/MainObjectConnectorTorsionalSpringDamper.h"
#include "Autogenerated/MainObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/MainObjectConnectorCoordinateSpringDamperExt.h"
#include "Autogenerated/MainObjectConnectorGravity.h"
#include "Autogenerated/MainObjectConnectorHydraulicActuatorSimple.h"
#include "Autogenerated/MainObjectConnectorReevingSystemSprings.h"
#include "Autogenerated/MainObjectConnectorDistance.h"
#include "Autogenerated/MainObjectConnectorCoordinate.h"
#include "Autogenerated/MainObjectConnectorCoordinateVector.h"
#include "Autogenerated/MainObjectConnectorRollingDiscPenalty.h"
#include "Autogenerated/MainObjectContactConvexRoll.h"
#include "Autogenerated/MainObjectContactCoordinate.h"
#include "Autogenerated/MainObjectContactCircleCable2D.h"
#include "Autogenerated/MainObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/MainObjectContactFrictionCircleCable2DOld.h"
#include "Autogenerated/MainObjectContactSphereSphere.h"
#include "Autogenerated/MainObjectContactCurveCircles.h"
#include "Autogenerated/MainObjectJointGeneric.h"
#include "Autogenerated/MainObjectJointRevoluteZ.h"
#include "Autogenerated/MainObjectJointPrismaticX.h"
#include "Autogenerated/MainObjectJointSpherical.h"
#include "Autogenerated/MainObjectJointRollingDisc.h"
#include "Autogenerated/MainObjectJointRevolute2D.h"
#include "Autogenerated/MainObjectJointPrismatic2D.h"
#include "Autogenerated/MainObjectJointSliding2D.h"
#include "Autogenerated/MainObjectJointALEMoving2D.h"

//#include "Autogenerated/MainNodePoint.h"
#include "Autogenerated/MainNodePointGround.h"
#include "Autogenerated/MainNodePoint2D.h"
#include "Autogenerated/MainNodeRigidBodyEP.h"
#include "Autogenerated/MainNodeRigidBodyRxyz.h"
#include "Autogenerated/MainNodeRigidBodyRotVecLG.h"
#include "Autogenerated/MainNodeRigidBody2D.h"
#include "Autogenerated/MainNode1D.h"
#include "Autogenerated/MainNodePoint2DSlope1.h"
#include "Autogenerated/MainNodePointSlope1.h"
#include "Autogenerated/MainNodePointSlope12.h"
#include "Autogenerated/MainNodePointSlope23.h"
#include "Autogenerated/MainNodeGenericODE2.h"
#include "Autogenerated/MainNodeGenericODE1.h"
#include "Autogenerated/MainNodeGenericAE.h"
#include "Autogenerated/MainNodeGenericData.h"

//#include "Autogenerated/MainMarkerBodyPosition.h"
#include "Autogenerated/MainMarkerBodyRigid.h"
#include "Autogenerated/MainMarkerBodyMass.h"
#include "Autogenerated/MainMarkerNodePosition.h"
#include "Autogenerated/MainMarkerNodeRigid.h"
#include "Autogenerated/MainMarkerNodeCoordinate.h"
#include "Autogenerated/MainMarkerNodeCoordinates.h"
#include "Autogenerated/MainMarkerNodeODE1Coordinate.h"
#include "Autogenerated/MainMarkerNodeRotationCoordinate.h"
#include "Autogenerated/MainMarkerObjectODE2Coordinates.h"
#include "Autogenerated/MainMarkerSuperElementPosition.h"
#include "Autogenerated/MainMarkerSuperElementRigid.h"
#include "Autogenerated/MainMarkerKinematicTreeRigid.h"
#include "Autogenerated/MainMarkerBodyCable2DShape.h"
#include "Autogenerated/MainMarkerBodyCable2DCoordinates.h"

//#include "Autogenerated/MainLoadForceVector.h"
#include "Autogenerated/MainLoadMassProportional.h"
#include "Autogenerated/MainLoadTorqueVector.h"
#include "Autogenerated/MainLoadCoordinate.h"

//#include "Autogenerated/MainSensorNode.h"
#include "Autogenerated/MainSensorObject.h"
#include "Autogenerated/MainSensorBody.h"
#include "Autogenerated/MainSensorSuperElement.h"
#include "Autogenerated/MainSensorKinematicTree.h"
#include "Autogenerated/MainSensorMarker.h"
#include "Autogenerated/MainSensorLoad.h"
#include "Autogenerated/MainSensorUserFunction.h"

#endif //EXUDYN_MINIMAL_COMPILATION

#include "Autogenerated/objectFactoryAutoReg.h"

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  NODE
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Get available items in object factory
py::dict MainObjectFactory::GetAvailableFactoryItems()
{
	auto d = py::dict();
	auto  lNode   = py::list();
	auto  lObject = py::list();
	auto  lMarker = py::list();
	auto  lLoad   = py::list();
	auto  lSensor = py::list();
	for (const auto& creator : ClassFactoryItemsSystemData<MainNode>::GetCreators())
	{
		lNode.append(STDstring("Node") + creator.first);
	}
	for (const auto& creator : ClassFactoryItemsSystemData<MainObject>::GetCreators())
	{
		lObject.append(STDstring("Object") + creator.first);
	}
	for (const auto& creator : ClassFactoryItem<MainMarker>::GetCreators())
	{
		lMarker.append(STDstring("Marker") + creator.first);
	}
	for (const auto& creator : ClassFactoryItem<MainLoad>::GetCreators())
	{
		lLoad.append(STDstring("Load") + creator.first);
	}
	for (const auto& creator : ClassFactoryItem<MainSensor>::GetCreators())
	{
		lSensor.append(STDstring("Sensor") + creator.first);
	}
	d["Node"]   = lNode;
	d["Object"] = lObject;
	d["Marker"] = lMarker;
	d["Load"]   = lLoad;
	d["Sensor"] = lSensor;
	return d;
}



//! Create a specific node with nodeType; returns node=Null if no success
MainNode* MainObjectFactory::CreateMainNode(MainSystem& mainSystem, STDstring nodeType)
{
	return ClassFactoryItemsSystemData<MainNode>::Get().CreateInstance(nodeType, &(mainSystem.GetCSystem().GetSystemData()));
}

Index MainObjectFactory::AddMainNode(MainSystem& mainSystem, const py::dict& d)
{
	bool errorFound = false;

	STDstring baseItem = "node";
	Index currentNumber = mainSystem.GetMainSystemData().GetMainNodes().NumberOfItems();

	if (!DictHasValidName(mainSystem, d, currentNumber, baseItem, errorFound))
	{
		if (!errorFound) {d["name"] = baseItem + EXUstd::ToString(currentNumber); }
	}

	if (!errorFound)
	{
		if (d.contains("nodeType"))
		{
			py::object nameItem = d["nodeType"]; //this is necessary to make isinstance work
			if (py::isinstance<py::str>(nameItem))
			{
				STDstring nameString = py::cast<std::string>(nameItem); //!  read out dictionary and cast to C++ type

				MainNode* mainNode = CreateMainNode(mainSystem, nameString);

				if (mainNode != NULL)
				{
					mainNode->SetWithDictionary(d);
					mainSystem.GetCSystem().GetSystemData().GetCNodes().Append(mainNode->GetCNode());
					mainSystem.GetVisualizationSystem().GetVisualizationSystemData().GetVisualizationNodes().Append(mainNode->GetVisualizationNode());
					return mainSystem.GetMainSystemData().GetMainNodes().Append(mainNode);
				}
				else
				{
					PyError(STDstring("AddNode, arg:dict['nodeType'] contains invalid node type '") + nameString + "'");
				}

			}
			else
			{
				PyError("AddNode, arg:dict['nodeType'] must be of string type");
			}
		}
		else
		{
			PyError("AddNode, arg:dict must contain item 'nodeType'");
		}
	}
	return EXUstd::InvalidIndex;


}





//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  OBJECT
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Create a specific object with objectType; returns object=Null if no success
MainObject* MainObjectFactory::CreateMainObject(MainSystem& mainSystem, STDstring objectType)
{
	return ClassFactoryItemsSystemData<MainObject>::Get().CreateInstance(objectType, &(mainSystem.GetCSystem().GetSystemData()));
}

Index MainObjectFactory::AddMainObject(MainSystem& mainSystem, const py::dict& d)
{
	bool errorFound = false;

	//add default name, if it does not exist ...
	STDstring baseItem = "object";
	Index currentNumber = mainSystem.GetMainSystemData().GetMainObjects().NumberOfItems();

	if (!DictHasValidName(mainSystem, d, currentNumber, baseItem, errorFound))
	{
		if (!errorFound) { d["name"] = baseItem + EXUstd::ToString(currentNumber); }
	}

	if (!errorFound)
	{
		if (d.contains("objectType"))
		{
			py::object nameItem = d["objectType"]; //this is necessary to make isinstance work
			if (py::isinstance<py::str>(nameItem))
			{
				STDstring nameString = py::cast<std::string>(nameItem); //!  read out dictionary and cast to C++ type

				MainObject* mainObject = CreateMainObject(mainSystem, nameString);

				if (mainObject != NULL)
				{
					mainObject->SetWithDictionary(d);
					mainSystem.GetCSystem().GetSystemData().GetCObjects().Append(mainObject->GetCObject());
					mainSystem.GetVisualizationSystem().GetVisualizationSystemData().GetVisualizationObjects().Append(mainObject->GetVisualizationObject());
					return mainSystem.GetMainSystemData().GetMainObjects().Append(mainObject);
				}
				else
				{
					PyError(STDstring("AddObject, arg:dict['objectType'] contains invalid object type '") + nameString + "'");
				}

			}
			else
			{
				PyError("AddObject, arg:dict['objectType'] must be of string type");
			}
		}
		else
		{
			PyError("AddObject, arg:dict must contain item 'objectType'");
		}
	}
	return EXUstd::InvalidIndex;

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  MARKER
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Create a specific marker with markerType; returns marker=Null if no success
MainMarker* MainObjectFactory::CreateMainMarker(MainSystem& mainSystem, STDstring markerType)
{
	return ClassFactoryItem<MainMarker>::Get().CreateInstance(markerType);
}

Index MainObjectFactory::AddMainMarker(MainSystem& mainSystem, const py::dict& d)
{
	bool errorFound = false;

	//add default name, if it does not exist ...
	STDstring baseItem = "marker";
	Index currentNumber = mainSystem.GetMainSystemData().GetMainMarkers().NumberOfItems();

	if (!DictHasValidName(mainSystem, d, currentNumber, baseItem, errorFound))
	{
		if (!errorFound) { d["name"] = baseItem + EXUstd::ToString(currentNumber); }
	}

	if (!errorFound)
	{
		if (d.contains("markerType"))
		{
			py::object nameItem = d["markerType"]; //this is necessary to make isinstance work
			if (py::isinstance<py::str>(nameItem))
			{
				STDstring nameString = py::cast<std::string>(nameItem); //!  read out dictionary and cast to C++ type

				MainMarker* mainMarker = CreateMainMarker(mainSystem, nameString);

				if (mainMarker != NULL)
				{
					mainMarker->SetWithDictionary(d);
					mainSystem.GetCSystem().GetSystemData().GetCMarkers().Append(mainMarker->GetCMarker());
					mainSystem.GetVisualizationSystem().GetVisualizationSystemData().GetVisualizationMarkers().Append(mainMarker->GetVisualizationMarker());
					return mainSystem.GetMainSystemData().GetMainMarkers().Append(mainMarker);
				}
				else
				{
					PyError(STDstring("AddMarker, arg:dict['markerType'] contains invalid marker type '") + nameString + "'");
				}

			}
			else
			{
				PyError("AddMarker, arg:dict['markerType'] must be of string type");
			}
		}
		else
		{
			PyError("AddMarker, arg:dict must contain item 'markerType'");
		}
	}
	return EXUstd::InvalidIndex;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  LOAD
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Create a specific load with loadType; returns load=Null if no success
MainLoad* MainObjectFactory::CreateMainLoad(MainSystem& mainSystem, STDstring loadType)
{
	return ClassFactoryItem<MainLoad>::Get().CreateInstance(loadType);
}


Index MainObjectFactory::AddMainLoad(MainSystem& mainSystem, const py::dict& d)
{
	bool errorFound = false;

	//add default name, if it does not exist ...
	STDstring baseItem = "load";
	Index currentNumber = mainSystem.GetMainSystemData().GetMainLoads().NumberOfItems();

	if (!DictHasValidName(mainSystem, d, currentNumber, baseItem, errorFound))
	{
		if (!errorFound) { d["name"] = baseItem + EXUstd::ToString(currentNumber); }
	}

	if (!errorFound)
	{
		if (d.contains("loadType"))
		{
			py::object nameItem = d["loadType"]; //this is necessary to make isinstance work
			if (py::isinstance<py::str>(nameItem))
			{
				STDstring nameString = py::cast<std::string>(nameItem); //!  read out dictionary and cast to C++ type

				MainLoad* mainLoad = CreateMainLoad(mainSystem, nameString);

				if (mainLoad != NULL)
				{
					mainLoad->SetWithDictionary(d);
					mainSystem.GetCSystem().GetSystemData().GetCLoads().Append(mainLoad->GetCLoad());
					mainSystem.GetVisualizationSystem().GetVisualizationSystemData().GetVisualizationLoads().Append(mainLoad->GetVisualizationLoad());
					return mainSystem.GetMainSystemData().GetMainLoads().Append(mainLoad);
				}
				else
				{
					PyError(STDstring("AddLoad, arg:dict['loadType'] contains invalid load type '") + nameString + "'");
				}

			}
			else
			{
				PyError("AddLoad, arg:dict['loadType'] must be of string type");
			}
		}
		else
		{
			PyError("AddLoad, arg:dict must contain item 'loadType'");
		}
	}
	return EXUstd::InvalidIndex;

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  SENSOR
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Create a specific sensor with sensorType; returns sensor=Null if no success
MainSensor* MainObjectFactory::CreateMainSensor(MainSystem& mainSystem, STDstring sensorType)
{
	return ClassFactoryItem<MainSensor>::Get().CreateInstance(sensorType);
}


Index MainObjectFactory::AddMainSensor(MainSystem& mainSystem, const py::dict& d)
{
	bool errorFound = false;

	//add default name, if it does not exist ...
	STDstring baseItem = "sensor";
	Index currentNumber = mainSystem.GetMainSystemData().GetMainSensors().NumberOfItems();

	if (!DictHasValidName(mainSystem, d, currentNumber, baseItem, errorFound))
	{
		if (!errorFound) { d["name"] = baseItem + EXUstd::ToString(currentNumber); }
	}

	if (!errorFound)
	{
		if (d.contains("sensorType"))
		{
			py::object nameItem = d["sensorType"]; //this is necessary to make isinstance work
			if (py::isinstance<py::str>(nameItem))
			{
				STDstring nameString = py::cast<std::string>(nameItem); //!  read out dictionary and cast to C++ type

				MainSensor* mainSensor = CreateMainSensor(mainSystem, nameString);

				if (mainSensor != NULL)
				{
					mainSensor->SetWithDictionary(d);
					mainSystem.GetCSystem().GetSystemData().GetCSensors().Append(mainSensor->GetCSensor());
					mainSystem.GetVisualizationSystem().GetVisualizationSystemData().GetVisualizationSensors().Append(mainSensor->GetVisualizationSensor());
					return mainSystem.GetMainSystemData().GetMainSensors().Append(mainSensor);
				}
				else
				{
					PyError(STDstring("AddSensor, arg:dict['sensorType'] contains invalid sensor type '") + nameString + "'");
				}

			}
			else
			{
				PyError("AddSensor, arg:dict['sensorType'] must be of string type");
			}
		}
		else
		{
			PyError("AddSensor, arg:dict must contain item 'sensorType'");
		}
	}
	return EXUstd::InvalidIndex;

}

//! check whether dictionary has valid name (return true), or generate a name for certain item (node, object, marker, ...);
//! the generated name is baseItem+string(currentNumber); in case of inconsistencies, errorFound is set to true
bool MainObjectFactory::DictHasValidName(const MainSystem& mainSystem, const py::dict& d, Index currentNumber, const STDstring& baseItem, bool& errorFound)
{
	Index baseItemLength = (Index)baseItem.size();
	bool hasName = false; //set to true, if name is already o.k.

	if (d.contains("name"))
	{
		if (EPyUtils::DictItemIsValidString(d, "name"))
		{
			STDstring nameString = py::cast<std::string>(d["name"]); //! read out dictionary and cast to C++ type

			//allow baseItem + EXUstd::ToString(currentNumber) for loading from dict!
			if (nameString != baseItem + EXUstd::ToString(currentNumber) && nameString.size() != 0) //empty string '' shall not raise error, but generate name==>this is the default value for python interface classes
			{
				hasName = true;

				//check if name conflicts with item enumeration (having the according name + a digit)
				if ((Index)nameString.size() > baseItemLength && nameString.substr(0, baseItemLength) == baseItem && isdigit(nameString[baseItemLength]))
				{
					STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
					PyError(s + ", arg:dict['name'] may not have the format '" + baseItem + "[0-9][...]'");
					errorFound = true;
				}

				//check if name exists (this may be slow for > 50000 items with individual names):
				if (baseItem == "node")
				{
					for (auto item : mainSystem.GetMainSystemData().GetMainNodes())
					{
						if (item->GetName() == nameString)
						{
							STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
							PyError(s + ", arg:dict['name'] '" + nameString + "' already exists; item not added");
							errorFound = true;
							break;
						}
					}
				}
				else if (baseItem == "object")
				{
					for (auto item : mainSystem.GetMainSystemData().GetMainObjects())
					{
						if (item->GetName() == nameString)
						{
							STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
							PyError(s + ", arg:dict['name'] '" + nameString + "' already exists; item not added");
							errorFound = true;
							break;
						}
					}
				}
				else if (baseItem == "marker")
				{
					for (auto item : mainSystem.GetMainSystemData().GetMainMarkers())
					{
						if (item->GetName() == nameString)
						{
							STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
							PyError(s + ", arg:dict['name'] '" + nameString + "' already exists; item not added");
							errorFound = true;
							break;
						}
					}
				}
				else if (baseItem == "load")
				{
					for (auto item : mainSystem.GetMainSystemData().GetMainLoads())
					{
						if (item->GetName() == nameString)
						{
							STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
							PyError(s + ", arg:dict['name'] '" + nameString + "' already exists; item not added");
							errorFound = true;
							break;
						}
					}
				}
				else if (baseItem == "sensor")
				{
					for (auto item : mainSystem.GetMainSystemData().GetMainSensors())
					{
						if (item->GetName() == nameString)
						{
							STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
							PyError(s + ", arg:dict['name'] '" + nameString + "' already exists; item not added");
							errorFound = true;
							break;
						}
					}
				}
				else { CHECKandTHROWstring("MainObjectFactory::DictHasValidName called for invalid case"); }
			}
		}
		else
		{
			STDstring s = baseItem; s[0] = toupper(s[0]);	s = "Add" + s; //generate string for error messages, e.g. "AddNode"
			PyError(s + ", arg:dict['name'] must be a valid string");
			errorFound = true;
		}
	}

	return hasName && !errorFound;
}



