/** ***********************************************************************************************
* @brief		Implementation of CSystem
*
* @author		Gerstmayr Johannes
* @date			2019-04-18 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

//++++++++++++++++ 
#include <iostream>
#include <chrono>
#include <thread>
//++++++++++++++++

#include <functional>					//for std::invoke
#include "Main/CSystemData.h"			//Basics, Vector/Array, OutputVariable, CData, Material, Body, Node, Marker, Load
#include "Main/CSystem.h"	

#include "Main/MainSystem.h"
#include "Linalg/LinearSolver.h" //for GeneralMatrixEXUdense
#include "Linalg/MatrixContainer.h" //for GeneralMatrixEXUdense
#include "Main/OutputVariable.h" //for GeneralMatrixEXUdense
#include "Autogenerated/CSensorSuperElement.h" //for sensor integrity checks
#include "Autogenerated/CSensorUserFunction.h" //for sensor integrity checks
//#include "Autogenerated/CSensorMarker.h" //for sensor integrity checks

#include "Utilities/TimerStructure.h" //for local CPU time measurement
#include "Main/rendererPythonInterface.h" //for regular call to PyExecuteQueue(...)

//delete: //#define USE_AUTODIFF


#include "Utilities/Parallel.h" //include after 

//not needed, as these structures moved to TemporaryComputationDataArray
//#if defined(USE_NGSOLVE_TASKMANAGER)
//TemporaryComputationData tempParallel[MAX_NUMBER_OF_THREADS];
//GeneralMatrixEigenSparse matSparse[MAX_NUMBER_OF_THREADS];
//#endif

//! Prepare a newly created System of nodes, objects, loads, ... for computation
void CSystem::Assemble(const MainSystem& mainSystem)
{
	for (CObject* object : cSystemData.GetCObjects())
	{
		object->PreAssemble();
	}
	//pout << "++++++++++++++++\nCheckSystemIntegrity ...\n";
	if (CheckSystemIntegrity(mainSystem)) //checks prior to Assemble() ==> after Assemble(), everything shall be ok.
	{
		//pout << "                        ... ok\n";
		AssembleCoordinates(mainSystem);
		AssembleLTGLists(mainSystem);
		AssembleInitializeSystemCoordinates(mainSystem); //mainSystem needed for initial displacements
		AssembleSystemInitialize(mainSystem);

		//now system is consistent and can safely be drawn
		SetSystemIsConsistent(true);
		postProcessData.postProcessDataReady = true;
		//cSystemData.isODE2RHSjacobianComputation = false; //hack
	}
	else
	{
		SetSystemIsConsistent(false);
	}
	for (CObject* object : cSystemData.GetCObjects())
	{
		object->PostAssemble();
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! Check if all references are valid (body->node number, marker->body/nodenumber, load->marker, etc.);
//  Function is called before 
bool CSystem::CheckSystemIntegrity(const MainSystem& mainSystem)
{
	//check that MarkerNodeCoordinate has a valid coordinate
	//check that initial values for generic nodes are consistent (e.g. NodeGenericData)
	//general check for length of initial coordinate (and time derivatives) is correct is checked in AssembleInitializeSystemCoordinates()
	//add CheckSystemIntegrity function to all MainItems?

	STDstring errorString;
	Index itemIndex;
	bool systemIsInteger = true;

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Index numberOfNodes = mainSystem.GetMainSystemData().GetMainNodes().NumberOfItems();
	Index numberOfObjects = mainSystem.GetMainSystemData().GetMainObjects().NumberOfItems();
	Index numberOfMarkers = mainSystem.GetMainSystemData().GetMainMarkers().NumberOfItems();
	Index numberOfLoads = mainSystem.GetMainSystemData().GetMainLoads().NumberOfItems();
	Index numberOfSensors = mainSystem.GetMainSystemData().GetMainSensors().NumberOfItems();

	itemIndex = 0;
	for (MainNode* mainNode : mainSystem.GetMainSystemData().GetMainNodes())
	{
		CNode* node = mainNode->GetCNode();
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			Index numberOfCoordinates = node->GetNumberOfODE2Coordinates();
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial displacement coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialVector().NumberOfItems()) + ") != number of nodal ODE2 coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}

				if (numberOfCoordinates != mainNode->GetInitialVector_t().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial velocity coordinate vector (" +
						EXUstd::ToString(mainNode->GetInitialVector_t().NumberOfItems()) + ") != number of nodal ODE2 coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE1variables)
		{
			Index numberOfCoordinates = node->GetNumberOfODE1Coordinates();
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialVector().NumberOfItems()) + ") != number of nodal ODE1 coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables)
		{
			Index numberOfCoordinates = node->GetNumberOfDataCoordinates();
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialVector().NumberOfItems()) + ") != number of nodal Data coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		else // mixed ODE1, ODE2 and/or AE variables
		{
			Index numberOfCoordinates = node->GetNumberOfAccessibleCoordinates(); //ODE2+ODE1+AE
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialVector().NumberOfItems()) + ") != number of nodal coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		itemIndex++;
	}
	if (!systemIsInteger) { return false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid node numbers (objects)
	//check for valid marker numbers in connectors
	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainObjects())
	{
		//GetRequestedNodeType() must be implemented for all objects with nodes
		for (Index i = 0; i < item->GetCObject()->GetNumberOfNodes(); i++)
		{
			Index nodeItemIndex = item->GetCObject()->GetNodeNumber(i);
			if (!EXUstd::IndexIsInRange(nodeItemIndex, 0, numberOfNodes))
			{
				PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local node " +
					EXUstd::ToString(i) + " contains invalid (global) node number " + EXUstd::ToString(nodeItemIndex));
				systemIsInteger = false;
			}
			else //check if right nodeTypes are used
			{
				CNode* cNode = mainSystem.GetMainSystemData().GetMainNodes()[nodeItemIndex]->GetCNode();
				//if ((item->GetRequestedNodeType() & cNode->GetType()) != item->GetRequestedNodeType())
				if (!EXUstd::IsOfType(cNode->GetType(), item->GetRequestedNodeType()))
				{
					PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local node " +
						EXUstd::ToString(i) + " (global index = " + EXUstd::ToString(nodeItemIndex) + ")" +
						" contains invalid node type " + Node::GetTypeString(cNode->GetType()) +
						" while the requested node type was '" + Node::GetTypeString(item->GetRequestedNodeType()) + "'");
					systemIsInteger = false;
				}
			}
		}

		if ((Index)item->GetCObject()->GetType() & (Index)CObjectType::Connector)
		{
			CObjectConnector* connector = (CObjectConnector*)item->GetCObject();
			if (connector->GetMarkerNumbers().NumberOfItems() != 2)
			{
				PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + 
					" must have two markers, but got " + EXUstd::ToString(connector->GetMarkerNumbers().NumberOfItems()) + " markers");
				systemIsInteger = false;
			}
			else
			{
				if (connector->GetMarkerNumbers().NumberOfItems() == 2) //for future cases
				{
					if (connector->GetMarkerNumbers()[0] == connector->GetMarkerNumbers()[1])
					{
						PyWarning(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + ", contains two identical markers");
					}
				}
				for (Index i = 0; i < connector->GetMarkerNumbers().NumberOfItems(); i++)
				{
					Index markerItemIndex = connector->GetMarkerNumbers()[i];
					if (!EXUstd::IndexIsInRange(markerItemIndex, 0, numberOfMarkers))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local marker " +
							EXUstd::ToString(i) + " contains invalid (global) marker number " + EXUstd::ToString(markerItemIndex));
						systemIsInteger = false;
					}
					else
					{
						//now check Marker::Type flags
						CMarker* marker = mainSystem.GetMainSystemData().GetMainMarkers()[markerItemIndex]->GetCMarker();
						if ((connector->GetRequestedMarkerType() & marker->GetType()) != connector->GetRequestedMarkerType()) //marker must contain all requested flags
						{
							PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local marker " +
								EXUstd::ToString(i) + " contains marker with invalid type '" + Marker::GetTypeString(marker->GetType()) +
								"', but expected marker type '" + Marker::GetTypeString(connector->GetRequestedMarkerType()) + "'");
							systemIsInteger = false;
						}
					}
				}
				if ((Index)item->GetCObject()->GetType() & (Index)CObjectType::Constraint)
				{
					if (((connector->GetAvailableJacobians() & JacobianType::AE_ODE2) != 0) != ((connector->GetAvailableJacobians() & JacobianType::AE_ODE2_function) != 0))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							": Internal error: connector JacobianType::AE_ODE2 must be consistent with JacobianType::AE_ODE2_function");
						systemIsInteger = false;
					}
					if (((connector->GetAvailableJacobians() & JacobianType::AE_AE) != 0) != ((connector->GetAvailableJacobians() & JacobianType::AE_AE_function) != 0))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							": Internal error: connector JacobianType::AE_AE must be consistent with JacobianType::AE_AE_function");
						systemIsInteger = false;
					}
				}
			}

		}


		itemIndex++;
	}


	if (!systemIsInteger) { return false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid node/object numbers in markers; special markers can contain node+body!
	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainMarkers())
	{
		if (item->GetCMarker()->GetType() & Marker::Node)
		{
			Index nodeIndex = item->GetCMarker()->GetNodeNumber();
			if (!EXUstd::IndexIsInRange(nodeIndex, 0, numberOfNodes))
			{
				PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + 
					", contains invalid (global) node number " + EXUstd::ToString(nodeIndex));
				systemIsInteger = false;
			}
			if (systemIsInteger)
			{
				const CNode* node = mainSystem.GetMainSystemData().GetMainNode(nodeIndex).GetCNode();
				Node::Type nodeType = node->GetType();
				Marker::Type markerType = item->GetCMarker()->GetType();
				if (EXUstd::IsOfType(markerType, Marker::Position))
				{
					if (!EXUstd::IsOfType(nodeType, Node::Position) && !EXUstd::IsOfType(nodeType, Node::Position2D))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires a node with type Position or Position2D, but node number " + EXUstd::ToString(nodeIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
				if (EXUstd::IsOfType(markerType, Marker::Orientation))
				{
					if (!EXUstd::IsOfType(nodeType, Node::Orientation) && !EXUstd::IsOfType(nodeType, Node::Orientation2D))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires a node with type Orientation or Orientation2D, but node number " + EXUstd::ToString(nodeIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
			}
		}
		//else //must be object (usually body, but could also be connector)
		if (item->GetCMarker()->GetType() & Marker::Object) //might also be Marker::Body
		{
			Index objectIndex = item->GetCMarker()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(objectIndex, 0, numberOfObjects))
			{
				PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
					", contains invalid (global) object number " + EXUstd::ToString(objectIndex));
				systemIsInteger = false;
			}
			if (systemIsConsistent)
			{
				if (((Index)mainSystem.GetMainSystemData().GetMainObjects()[objectIndex]->GetCObject()->GetType() & (Index)CObjectType::Body) == 0)
				{
					PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
						": expected ObjectType::Body, but received object (object number=" + EXUstd::ToString(objectIndex) + ")");
					systemIsInteger = false;
				}
			}
			if (systemIsInteger)
			{
				const CObject* object = mainSystem.GetMainSystemData().GetMainObjects()[objectIndex]->GetCObject();
				AccessFunctionType afType = object->GetAccessFunctionTypes();
				Marker::Type markerType = item->GetCMarker()->GetType();
				if (EXUstd::IsOfType(markerType, Marker::Position))
				{
					if (!EXUstd::IsOfType(afType, AccessFunctionType::TranslationalVelocity_qt))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires an object with position information, but object number " + EXUstd::ToString(objectIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
				if (EXUstd::IsOfType(markerType, Marker::Orientation))
				{
					if (!EXUstd::IsOfType(afType, AccessFunctionType::AngularVelocity_qt))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires an object with orienation (rotation) information, but object number " + EXUstd::ToString(itemIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
			}
		}
		itemIndex++;
	}


	if (!systemIsInteger) { return false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid marker numbers in loads; check requested MarkerType; 
	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainLoads())
	{
		Index markerIndex = item->GetCLoad()->GetMarkerNumber();

		if (!EXUstd::IndexIsInRange(markerIndex, 0, numberOfMarkers))
		{
			PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + 
				", contains invalid marker number " + EXUstd::ToString(markerIndex));
			systemIsInteger = false;
		}
		
		if (systemIsInteger) //only if markerNumber is valid
		{
			Marker::Type requestedType = item->GetCLoad()->GetRequestedMarkerType();
			Marker::Type markerType = mainSystem.GetMainSystemData().GetMainMarkers()[markerIndex]->GetCMarker()->GetType();
			if ((requestedType & markerType) != requestedType)
			{
				PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
					", contains marker with invalid type '" + Marker::GetTypeString(markerType) +
					"', but expected marker type '" + Marker::GetTypeString(requestedType) + "'");
				systemIsInteger = false;
			}
		}
		if (systemIsInteger) //only if markerNumber is valid
		{
			CLoad* cLoad = item->GetCLoad();

			if (cLoad->IsBodyFixed() && ((mainSystem.GetCSystem()->GetSystemData().GetCMarker(cLoad->GetMarkerNumber()).GetType() & Marker::Orientation) == 0))
			{
				PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
					": marker (marker number = " + EXUstd::ToString(cLoad->GetMarkerNumber()) + 
					") must provide orientation (e.g. RigidBody marker) in case that bodyFixed == True");
				systemIsInteger = false;
			}
		}

		itemIndex++;
	}

	if (!systemIsInteger) { return false; } //avoid crashes due to further checks!

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid sensors: valid node/object/... numbers and valid OutputVariableTypes

	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainSensors())
	{
		if (item->GetCSensor()->GetType() == SensorType::Node)
		{
			Index n = item->GetCSensor()->GetNodeNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfNodes))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Node, contains invalid node number " + EXUstd::ToString(n));
			}
			else if (!EXUstd::IsOfTypeAndNotNone(mainSystem.GetMainSystemData().GetMainNode(n).GetCNode()->GetOutputVariableTypes(), 
				item->GetCSensor()->GetOutputVariableType()))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + 
					"', type = SensorType::Node: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) + "' is not available in node with node number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Object)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + 
					"', type = SensorType::Object, contains invalid object number " + EXUstd::ToString(n));
			}
			else if (EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::Body))
			{
				PyError(STDstring("SensorObject ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
					"', type = SensorType::Object: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) +
					"' cannot be attached to a body. Use SensorBody instead");
			}
			else if (!EXUstd::IsOfTypeAndNotNone(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetOutputVariableTypes(), 
				item->GetCSensor()->GetOutputVariableType()))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
					"', type = SensorType::Object: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) +
					"' is not available in object with object number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Body)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Body, contains invalid object number " + EXUstd::ToString(n));
			}
			else if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::Body))
			//2020-09-04: wrong use of &: else if (((Index)mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType() & (Index)CObjectType::Body) == 0)
			{
				PyError(STDstring("SensorBody ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + 
					"', type = SensorType::Body, contains invalid object (ID=" + EXUstd::ToString(n) + ") which is not of ObjectType::Body. Use SensorObject instead");
			}
			else if (!EXUstd::IsOfTypeAndNotNone(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetOutputVariableTypes(), 
				item->GetCSensor()->GetOutputVariableType()))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
					"', type = SensorType::Body: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) + "' is not available in object with object number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::SuperElement)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::SuperElement, contains invalid object number " + EXUstd::ToString(n));
			}
			else if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::SuperElement))
			//else if (((Index)mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType() & (Index)CObjectType::SuperElement) == 0)
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::SuperElement, contains invalid object (ID=" + EXUstd::ToString(n) + ") which is not of ObjectType::Body");
			}
			else
			{
				const CObjectSuperElement* cObjectSuperElement = (const CObjectSuperElement*)(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject());
				const CSensorSuperElement* cSensorSuperElement = (const CSensorSuperElement*)(item->GetCSensor());
				
				if (!EXUstd::IsOfTypeAndNotNone(cObjectSuperElement->GetOutputVariableTypesSuperElement(cSensorSuperElement->GetMeshNodeNumber()), 
					cSensorSuperElement->GetOutputVariableType()))
				{
					PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
						"', type = SensorType::Body: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) + "' is not available in object with object number " + EXUstd::ToString(n));
				}
				if (!EXUstd::IndexIsInRange(cSensorSuperElement->GetMeshNodeNumber(), 0, cObjectSuperElement->GetNumberOfMeshNodes()))
				{
					PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
						"', meshNodeNumber '" + EXUstd::ToString(cSensorSuperElement->GetMeshNodeNumber()) + "' is out of valid range [0, " + EXUstd::ToString(cObjectSuperElement->GetNumberOfMeshNodes()-1) + "]");
				}
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Marker)
		{
			Index n = item->GetCSensor()->GetMarkerNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfMarkers))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Marker, contains invalid marker number " + EXUstd::ToString(n));
			}
			else
			{
				const CMarker& cMarker = *mainSystem.GetMainSystemData().GetMainMarkers()[n]->GetCMarker();
				if (!( (EXUstd::IsOfType(cMarker.GetType(), Marker::Position) && (item->GetCSensor()->GetOutputVariableType() == OutputVariableType::Position || item->GetCSensor()->GetOutputVariableType() == OutputVariableType::Velocity)) ||
					(EXUstd::IsOfType(cMarker.GetType(), Marker::Orientation) && (item->GetCSensor()->GetOutputVariableType() == OutputVariableType::Rotation || item->GetCSensor()->GetOutputVariableType() == OutputVariableType::AngularVelocityLocal)) ||
					(EXUstd::IsOfType(cMarker.GetType(), Marker::Coordinate) && (item->GetCSensor()->GetOutputVariableType() == OutputVariableType::Coordinates || item->GetCSensor()->GetOutputVariableType() == OutputVariableType::Coordinates_t)) ) )
				{
					PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
						"', type = SensorType::Marker: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) + "' is not available in marker with marker number " + EXUstd::ToString(n));
				}
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Load)
		{
			Index n = item->GetCSensor()->GetLoadNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfLoads))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Load, contains invalid load number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::UserFunction)
		{
			const CSensorUserFunction& sensorUserFunction = (const CSensorUserFunction&)(*item->GetCSensor());
			if (sensorUserFunction.GetParameters().sensorUserFunction == 0)
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::UserFunction, contains empty user function");
			}
			for (Index m : sensorUserFunction.GetParameters().sensorNumbers)
			{
				if (!EXUstd::IndexIsInRange(m, 0, numberOfSensors))
				{
					PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
						"', type = SensorType::UserFunction: local sensor number " + EXUstd::ToString(m) + " is invalid");
				}
			}
			//else if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainMarkers()[n]->GetCMarker()->GetOutputVariableTypes(), item->GetCSensor()->GetOutputVariableType()))
			//{
			//	PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
			//		"', type = SensorType::Marker: OutputVariableType '" + GetOutputVariableTypeString(item->GetCSensor()->GetOutputVariableType()) + "' is not available in marker with marker number " + EXUstd::ToString(n));
			//}
		}
		else
		{
			PyWarning("CheckSystemIntegrity: sensor type not implemented");
		}

		itemIndex++;
	}
	if (!systemIsInteger) { return false; } //avoid crashes due to further checks!

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//now do object-specific checks!
	itemIndex = 0;
	for (MainNode* item : mainSystem.GetMainSystemData().GetMainNodes())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}

	itemIndex = 0;
	for (MainObject* item : mainSystem.GetMainSystemData().GetMainObjects())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}

	itemIndex = 0;
	for (MainMarker* item : mainSystem.GetMainSystemData().GetMainMarkers())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}

	itemIndex = 0;
	for (MainLoad* item : mainSystem.GetMainSystemData().GetMainLoads())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}


	return systemIsInteger;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! assign coordinate numbers to nodes; LATER: prepare LinkedDataVectors (of coordinates) for nodes
void CSystem::AssembleCoordinates(const MainSystem& mainSystem)
{
	//pout << "Assemble nodes:\n";

	//make global node_DOF lists
	Index globalODE2Index = 0;
	Index globalODE1Index = 0;
	Index globalAEIndex = 0;
	Index globalDataIndex = 0;

	//+++++++++++++++++++++++++++
	//process nodes:
	Index node_ind = 0;
	for (CNode* node : cSystemData.GetCNodes())
	{
		//pout << "Assembling node " << node_ind << "\n";
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			//pout << "  NodeODE2 found\n";
			node->SetGlobalODE2CoordinateIndex(globalODE2Index); //use current index
			globalODE2Index += node->GetNumberOfODE2Coordinates(); //add counter in order to track number of ODE2-coordinates
			//pout << "  number of coordinates = " << node->GetNumberOfODE2Coordinates() << "\n";

			if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::AEvariables) //nodes might contain algebraic variables in addition to ODE-coordinates, e.g. Euler parameters
			{
				node->SetGlobalAECoordinateIndex(globalAEIndex); //use current index
				globalAEIndex += node->GetNumberOfAECoordinates(); //add counter in order to track number of AE-coordinates
			}

		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE1variables)
		{
			node->SetGlobalODE1CoordinateIndex(globalODE1Index); //use current index
			globalODE1Index += node->GetNumberOfODE1Coordinates(); //add counter in order to track number of ODE1-coordinates
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::AEvariables) //nodes might contain algebraic variables
		{
			node->SetGlobalAECoordinateIndex(globalAEIndex); //use current index
			globalAEIndex += node->GetNumberOfAECoordinates(); //add counter in order to track number of AE-coordinates
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables) //
		{
			node->SetGlobalDataCoordinateIndex(globalDataIndex); //use current index
			globalDataIndex += node->GetNumberOfDataCoordinates(); //add counter in order to track number of Data-coordinates
		}
		else { CHECKandTHROWstring("CSystem::Assemble(): invalid node type!"); }
		node_ind++;
	}

	//+++++++++++++++++++++++++++
	//process constraints:
	for (CObject* object : cSystemData.GetCObjects())
	{
		if ((Index)object->GetType() & (Index)CObjectType::Constraint) //only constraints have algebraic variables not linked to nodes
		{
			CObjectConstraint* constraint = (CObjectConstraint*)object;

			constraint->SetGlobalAECoordinateIndex(globalAEIndex);
			//add counter in order to track number of AE-coordinates
			globalAEIndex += constraint->GetAlgebraicEquationsSize(); //number of Lagrange multipliers equals number of algebraic equations
		}
	}

	cSystemData.GetNumberOfCoordinatesODE2() = globalODE2Index;
	cSystemData.GetNumberOfCoordinatesODE1() = globalODE1Index;
	cSystemData.GetNumberOfCoordinatesAE() = globalAEIndex;
	cSystemData.GetNumberOfCoordinatesData() = globalDataIndex;
	//pout << "global ODE2 coordinates = " << globalODE2Index << "\n";
	//pout << "global ODE1 coordinates = " << globalODE1Index << "\n";
	//pout << "global AE coordinates = " << globalAEIndex << "\n";
	//pout << "global Data coordinates = " << globalDataIndex << "\n";
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! build ltg-coordinate lists for objects (used to build system ODE2RHS, MassMatrix, etc. vectors and matrices) 
//! and store special object lists (body, connector, constraint, ...)
void CSystem::AssembleLTGLists(const MainSystem& mainSystem)
{
	//pout << "Assemble LTG Lists\n";

	//build system-wide local to global lists for objects:
	ObjectContainer<ArrayIndex>& listODE2 = cSystemData.GetLocalToGlobalODE2();
	ObjectContainer<ArrayIndex>& listODE1 = cSystemData.GetLocalToGlobalODE1();
	ObjectContainer<ArrayIndex>& listAE = cSystemData.GetLocalToGlobalAE();
	ObjectContainer<ArrayIndex>& listData = cSystemData.GetLocalToGlobalData();
	listODE2.Flush();
	listODE1.Flush();
	listAE.Flush();
	listData.Flush();

	//temporary lists per object:
	ArrayIndex ltgListODE2;
	ArrayIndex ltgListODE1;
	ArrayIndex ltgListAE;
	ArrayIndex ltgListData;

	//compute localToGlobalODE2 coordinate indices
	for (Index i = 0; i < cSystemData.GetCObjects().NumberOfItems(); i++)
	{
		AssembleObjectLTGLists(i, ltgListODE2, ltgListODE1, ltgListAE, ltgListData);

		listODE2.Append(ltgListODE2);
		listODE1.Append(ltgListODE1);
		listAE.Append(ltgListAE);
		listData.Append(ltgListData);
	}
	//pout << "local to global ODE2 Indices:\n" << listODE2 << "\n\n";
	//pout << "local to global ODE1 Indices:\n" << listODE1 << "\n\n";
	//pout << "local to global AE Indices:\n" << listAE << "\n\n";
	//pout << "local to global Data Indices:\n" << listData << "\n\n";

	PreComputeItemLists();
}


//! build ltg-coordinate lists for object with 'objectIndex' and set indices in ltg lists
void CSystem::AssembleObjectLTGLists(Index objectIndex, ArrayIndex& ltgListODE2, ArrayIndex& ltgListODE1,
	ArrayIndex& ltgListAE, ArrayIndex& ltgListData)
{
	ltgListODE2.SetNumberOfItems(0);
	ltgListODE1.SetNumberOfItems(0);
	ltgListAE.SetNumberOfItems(0);
	ltgListData.SetNumberOfItems(0);

	CObject* object = cSystemData.GetCObjects()[objectIndex];

	//body not necessary here, works for all objects: if ((Index)object->GetType() & (Index)CObjectType::Body) //single and multinoded objects
	if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
	{
		//CObjectBody* objectBody = (CObjectBody*)object;

		//bool algebraicEquationsInNodes = false;
		//node-based elements (bodies, finite elements, ...)
		//for (Index nodeNumber : objectBody->GetCNode())
		for (Index j = 0; j < object->GetNumberOfNodes(); j++)
		{
			CNode* node = object->GetCNode(j);
			if (node->GetNumberOfODE2Coordinates())
			{
				Index gIndex = node->GetGlobalODE2CoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfODE2Coordinates(); i++)
				{
					ltgListODE2.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfODE1Coordinates())
			{
				Index gIndex = node->GetGlobalODE1CoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfODE1Coordinates(); i++)
				{
					ltgListODE1.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfAECoordinates()) //this is for algebraic nodes (e.g. Euler Parameters); but constraint equation handled by node!
			{
				Index gIndex = node->GetGlobalAECoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfAECoordinates(); i++)
				{
					ltgListAE.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfDataCoordinates()) //data/history variables - contact, friction, plasticity
			{
				Index gIndex = node->GetGlobalDataCoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfDataCoordinates(); i++)
				{
					ltgListData.Append(gIndex + i);
				}
			}
		}
	}
	else
	{
		CObjectConnector* connector = (CObjectConnector*)object;

		//connector may also contain Data nodes
		for (Index j = 0; j < connector->GetNumberOfNodes(); j++)
		{
			CNode* node = connector->GetCNode(j);
			if (node->GetNumberOfDataCoordinates()) //data/history variables - contact, friction, plasticity
			{
				Index gIndex = node->GetGlobalDataCoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfDataCoordinates(); i++)
				{
					ltgListData.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfODE1Coordinates()) //controller: integrator; generic object with ODE1 coordinates
			{
				Index gIndex = node->GetGlobalODE1CoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfODE1Coordinates(); i++)
				{
					ltgListODE1.Append(gIndex + i);
				}
			}
		}

		//+++++++++++++++++++++++++++++++++++++++
		//process markers --> they have associated coordinates
		for (Index markerNumber : connector->GetMarkerNumbers())
		{
			cSystemData.ComputeMarkerODE2LTGarray(markerNumber, ltgListODE2, false);

			cSystemData.ComputeMarkerODE1DataLTGarray(markerNumber, ltgListODE1, ltgListData, false);
		}

		//+++++++++++++++++++++++++++++++++++++++
		//now process algebraic equations of connector (algebraic variables are treated earlier!)
		//this is because LAGRANGE MULTIPLIERS DO NOT REQUIRE NODES
		if ((Index)object->GetType() & (Index)CObjectType::Constraint)
		{
			CObjectConstraint* constraint = (CObjectConstraint*)object;
			//build ltg-list directly from connector

			Index gIndex = constraint->GetGlobalAECoordinateIndex();
			for (Index i = 0; i < constraint->GetAlgebraicEquationsSize(); i++)
			{
				ltgListAE.Append(gIndex + i);
			}
		}
	}
	//else
	//{
	//	pout << "ERROR: ObjectType Nr. " << (Index)object->GetType() << " not implemented in CSystem::AssembleLTGLists!\n";
	//}

	//pout << "ltgODE1=" << ltgListODE1 << "\n";
	//pout << "ltgAE=" << ltgListAE << "\n";
}

//! precompute item lists (special lists for constraints, connectors, etc.)
void CSystem::PreComputeItemLists()
{
	cSystemData.objectsBodyWithODE2Coords.Flush();
	cSystemData.listComputeObjectODE2Lhs.Flush();
	cSystemData.listComputeObjectODE2LhsUF.Flush();
	cSystemData.listComputeObjectODE2LhsNoUF.Flush();
	cSystemData.listComputeObjectODE1Rhs.Flush();
	cSystemData.listDiscontinuousIteration.Flush();
	cSystemData.listOfLoads.Flush();
	cSystemData.listOfLoadsUF.Flush();

	cSystemData.objectsBodyWithAE.Flush();
	cSystemData.nodesODE2WithAE.Flush();
	cSystemData.objectsConstraintWithAE.Flush();
	cSystemData.objectsWithAlgebraicEquations.Flush();
	cSystemData.listObjectProjectedReactionForcesODE2.Flush();


	//compute localToGlobalODE2 coordinate indices
	for (Index i = 0; i < cSystemData.GetCObjects().NumberOfItems(); i++)
	{
		//unused
		CObject* object = cSystemData.GetCObjects()[i];

		//if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		//{
		//	cSystemData.objectsConnectors.Append(i);
		//}
		////unused
		//if (EXUstd::IsOfType(object->GetType(), CObjectType::Constraint))
		//{
		//	cSystemData.objectsConstraints.Append(i);
		//}

		
		//for ComputeObjectODE2Lhs
		if (cSystemData.GetLocalToGlobalODE2()[i].NumberOfItems() != 0 &&  //ground
			!EXUstd::IsOfType(object->GetType(), CObjectType::Constraint)) //only if ODE2 exists and if not constraint (Constraint force action added in solver)
		{
			//if object is a body, it must have ODE2RHS
			if (EXUstd::IsOfType(object->GetType(), CObjectType::Body) ||
				EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
			{
				cSystemData.listComputeObjectODE2Lhs.Append(i); 
				if (object->HasUserFunction()) { cSystemData.listComputeObjectODE2LhsUF.Append(i); }
				else { cSystemData.listComputeObjectODE2LhsNoUF.Append(i); }
			}
			else 
			{ 
				SysError("CSystem::PreComputeItemLists(...): object "+EXUstd::ToString(i) + ": ODE2 type not implemented"); 
			}
		}


		//for ComputeObjectODE1Rhs
		if (cSystemData.GetLocalToGlobalODE1()[i].NumberOfItems() != 0)
		{
			if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector)) //connector for ODE1 not implemented
			{
				cSystemData.listComputeObjectODE1Rhs.Append(i);
			}
			else
			{
				SysError("CSystem::PreComputeItemLists(...): object " + EXUstd::ToString(i) + ": ODE1 type not implemented");
			}
		}

		//for ComputeMassMatrix
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Body))
		{
			if (cSystemData.GetLocalToGlobalODE2()[i].NumberOfItems() != 0)
			{
				cSystemData.objectsBodyWithODE2Coords.Append(i);
				//pout << "body+ODE2=" << i << "\n";
			}
		}
		//ComputeAlgebraicEquations:
		if (cSystemData.GetLocalToGlobalAE()[i].NumberOfItems() != 0)
		{
			bool AEavailable = false;
			if (EXUstd::IsOfType(object->GetType(), CObjectType::Body) &&
				object->GetAlgebraicEquationsSize() != 0)
			{
				AEavailable = true;
				cSystemData.objectsBodyWithAE.Append(i);
				cSystemData.objectsWithAlgebraicEquations.Append(i);
			}
			else if (EXUstd::IsOfType(object->GetType(), CObjectType::Constraint))
			{
				AEavailable = true;
				cSystemData.objectsConstraintWithAE.Append(i);
				cSystemData.objectsWithAlgebraicEquations.Append(i);
			}
			//NOT AVAILABLE NOW: connectors or pure objects
			else if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
			{
				CHECKandTHROW(object->GetAlgebraicEquationsSize() == 0, "CSystem::PreComputeItemLists: not implemented for Connectors with AE");
			}
			else
			{
				CHECKandTHROW(object->GetAlgebraicEquationsSize() == 0, "CSystem::PreComputeItemLists: not implemented for pure objects with AE");
			}

			//add projected equations only if algebraic equation is available (i.e., do not add for rigid bodies, because this term is handled by nodes)
			if (AEavailable && cSystemData.GetLocalToGlobalODE2()[i].NumberOfItems() != 0)
			{
				cSystemData.listObjectProjectedReactionForcesODE2.Append(i); //for constraints, reaction forces on ODE2 coordinates
			}

		}

		//PostNewtonStep, PostDiscontinuousIteration:
		//for constraint, algebraic equations depend on Markers
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		{
			//CObjectConnector* connector = (CObjectConnector*)object;

			if (((CObjectConnector*)object)->HasDiscontinuousIteration())
			{
				cSystemData.listDiscontinuousIteration.Append(i);
			}
		}
	}

	//compute list of nodes with constraint equations
	for (Index i = 0; i < cSystemData.GetCNodes().NumberOfItems(); i++)
	{
		CNode* node = cSystemData.GetCNodes()[i];
		if (EXUstd::IsOfType(node->GetNodeGroup(), CNodeGroup::ODE2variables) &&  node->GetAlgebraicEquationsSize() != 0)
			//&& EXUstd::IsOfType(((CNodeODE2*)node)->GetType(), Node::RotationEulerParameters
		{
			cSystemData.nodesODE2WithAE.Append(i);
		}
	}

	//compute list of loads with/without user functions
	for (Index i = 0; i < cSystemData.GetCLoads().NumberOfItems(); i++)
	{
		CLoad* load = cSystemData.GetCLoads()[i];
		if (load->HasUserFunction())
		{
			cSystemData.listOfLoadsUF.Append(i);
		}
		else
		{
			cSystemData.listOfLoads.Append(i);
		}
	}

	//std::cout << "cSystemData.objectsBodyWithODE2Coords = " << cSystemData.objectsBodyWithODE2Coords << "\n";
	//std::cout << "cSystemData.listComputeObjectODE2Lhs = " << cSystemData.listComputeObjectODE2Lhs << "\n";
	//std::cout << "cSystemData.listComputeObjectODE1Rhs = " << cSystemData.listComputeObjectODE1Rhs << "\n";
	//std::cout << "cSystemData.objectsBodyWithAE = " << cSystemData.objectsBodyWithAE << "\n";
	//std::cout << "cSystemData.nodesODE2WithAE = " << cSystemData.nodesODE2WithAE << "\n";
	//std::cout << "cSystemData.listObjectProjectedReactionForcesODE2 = " << cSystemData.listObjectProjectedReactionForcesODE2 << "\n";

}

//! Use initial values of nodes to compute system-wide initial coordinate vectors
void CSystem::AssembleInitializeSystemCoordinates(const MainSystem& mainSystem)
{
	//pout << "Set initial system coordinates (for ODE2, ODE1 and Data coordinates) ...\n";

	//initial system vectors
	Vector ODE2u =  Vector(cSystemData.GetNumberOfCoordinatesODE2());
	Vector ODE2v =  Vector(cSystemData.GetNumberOfCoordinatesODE2());
	Vector ODE1x =  Vector(cSystemData.GetNumberOfCoordinatesODE1());
	Vector data =	Vector(cSystemData.GetNumberOfCoordinatesData());
	Vector AE =		Vector(cSystemData.GetNumberOfCoordinatesAE(), 0.); //algebraic variables initialized with zero!

	Vector ODE2uRef = Vector(cSystemData.GetNumberOfCoordinatesODE2()); 
	Vector ODE1xRef = Vector(cSystemData.GetNumberOfCoordinatesODE1());  
	//Vector ODE2vRef = Vector(cSystemData.GetNumberOfCoordinatesODE2(), 0.);
	//Vector dataRef =  Vector(cSystemData.GetNumberOfCoordinatesData(), 0.);
	//Vector AERef =    Vector(cSystemData.GetNumberOfCoordinatesAE(), 0.);

	const MainSystemData& mainSystemData = mainSystem.mainSystemData;

	//now extract initial coordinate information from nodes:
	Index nodeIndex = 0;
	for (auto mainNode : mainSystemData.GetMainNodes())
	{
		CNode* node = mainNode->GetCNode();
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			Index coordIndex = node->GetGlobalODE2CoordinateIndex();

			if (node->GetNumberOfODE2Coordinates())
			{
				Index numberOfCoordinates = node->GetNumberOfODE2Coordinates();

				//link to sublist of global coordinate vector:
				LinkedDataVector u(ODE2u, coordIndex, numberOfCoordinates);
				LinkedDataVector v(ODE2v, coordIndex, numberOfCoordinates);

				u = mainNode->GetInitialVector();	//size must be compatible and is not checked!
				v = mainNode->GetInitialVector_t();	//size must be compatible and is not checked!

				//also initialize global reference coordinate vector (used for differentiation and in finite elements)
				LinkedDataVector uRef(ODE2uRef, coordIndex, numberOfCoordinates);
				uRef = node->GetReferenceCoordinateVector();
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE1variables)
		{
			Index coordIndex = node->GetGlobalODE1CoordinateIndex();

			if (node->GetNumberOfODE1Coordinates())
			{
				Index numberOfCoordinates = node->GetNumberOfODE1Coordinates();
				LinkedDataVector x(ODE1x, coordIndex, numberOfCoordinates);

				x = mainNode->GetInitialVector(); //size must be compatible and is not checked!

				//also initialize global reference coordinate vector (used for differentiation and in finite elements)
				LinkedDataVector uRef(ODE1xRef, coordIndex, numberOfCoordinates);
				uRef = node->GetReferenceCoordinateVector();
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables)
		{
			Index coordIndex = node->GetGlobalDataCoordinateIndex();

			if (node->GetNumberOfDataCoordinates())
			{
				Index numberOfCoordinates = node->GetNumberOfDataCoordinates();
				LinkedDataVector x(data, coordIndex, numberOfCoordinates);

				x = mainNode->GetInitialVector(); //size must be compatible and is not checked!
			}
		}
		else { CHECKandTHROWstring("CSystem::AssembleInitializeSystemCoordinates: invalid Node type, not implemented"); }
		nodeIndex++;
	}

	cSystemData.GetCData().initialState.ODE2Coords = ODE2u;
	cSystemData.GetCData().initialState.ODE2Coords_t = ODE2v;
	cSystemData.GetCData().initialState.ODE2Coords_tt = 0*ODE2v; //use same size as in velocities for accelerations, but initialize with zeros
	cSystemData.GetCData().initialState.ODE1Coords = ODE1x;
	cSystemData.GetCData().initialState.ODE1Coords_t = 0*ODE1x; //use same size as at position level, but with zeros; could be necessary for some evaluations at initial state
	cSystemData.GetCData().initialState.dataCoords = data;
	cSystemData.GetCData().initialState.AECoords = AE;

	cSystemData.GetCData().referenceState.ODE2Coords = ODE2uRef;
	cSystemData.GetCData().referenceState.ODE1Coords = ODE1xRef;
	//cSystemData.GetCData().referenceState.ODE2Coords_t = ODE2vRef; //access to these coordinates will lead to crash
	//cSystemData.GetCData().referenceState.dataCoords = dataRef;
	//cSystemData.GetCData().referenceState.AECoords = AERef; 



	//initial values are also used for current step ==> from here on, the system can be visualized!
	cSystemData.GetCData().currentState = cSystemData.GetCData().initialState;
	cSystemData.GetCData().visualizationState = cSystemData.GetCData().initialState; //from this point on, drawing should be possible
	postProcessData.SetVisualizationStateUpdateAvailable(false);
	//done at beginning of solver/time integration: cSystemData.GetCData().startOfStepState = cSystemData.GetCData().initialState;
}


void CSystem::AssembleSystemInitialize(const MainSystem& mainSystem)
{
	//initialize all contacts (searchtree, etc)
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		gc->FinalizeContact(*this);
	}
}

//#define USE_NGSOLVE_TASKMANAGER_MASS //not implemented generally!
#ifdef USE_NGSOLVE_TASKMANAGER_MASS
////timer structures for PajeTracer:
//ngstd::Timer t0(STDstring("CSystem::ComputeMassMatrix0")); //timer name and importance
//ngstd::Timer t1(STDstring("CSystem::ComputeMassMatrix1"), 2); //timer name and importance
//ngstd::Timer t2(STDstring("CSystem::ComputeMassMatrix2"), 2); //timer name and importance
//Index TScomputeMM0;
//TimerStructureRegistrator TSRcomputeMM0("computeMassMatrix0", TScomputeMM0, globalTimers);
//Index TScomputeMM1;
//TimerStructureRegistrator TSRcomputeMM1("computeMassMatrix1", TScomputeMM1, globalTimers);
//Index TScomputeMM2;
//TimerStructureRegistrator TSRcomputeMM2("computeMassMatrix2", TScomputeMM2, globalTimers);


void CSystem::ComputeMassMatrix(TemporaryComputationData& temp, GeneralMatrix& massMatrix)
{

	//size needs to be set accordingly in the caller function; components are addd to massMatrix!
	Index nThreadsTaskmanager = ngstd::task_manager->GetNumThreads();

	for (Index i = 0; i < nThreadsTaskmanager; i++)
	{
		matSparse[i].SetAllZero();
	}

	//#pragma omp parallel num_threads(maxThreads)
	//#pragma omp for

	//for improved parallel version: split into listComputeObjectODE2LhsNoUF and listComputeObjectODE2LhsUF !!!
	int nItems = (int)(cSystemData.GetCObjects().NumberOfItems());
	outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation
	
	STARTGLOBALTIMER(TScomputeMM0);

	ngstd::ParallelFor(nItems, [this, &nItems](NGSsizeType j) //&temp,&systemODE2Rhs,&cSystemData
	{
		//ngstd::RegionTracer regtr(ngstd::TaskManager::GetThreadId(), t1);

		Index threadID = ngstd::TaskManager::GetThreadId();
		TemporaryComputationData& myTemp = tempParallel[threadID];
		//work over bodies, connectors, etc.
		CObject& object = *(cSystemData.GetCObjects()[j]);

		//if object is a body, it must have a mass matrix
		if ((Index)object.GetType() & (Index)CObjectType::Body)
		{
			ArrayIndex& ltg = cSystemData.GetLocalToGlobalODE2()[j];
			if (ltg.NumberOfItems() != 0) //to exclude bodies attached to ground nodes
			{
				((CObjectBody&)object).ComputeMassMatrix(myTemp.localMass);

				//ngstd::RegionTracer regtr(ngstd::TaskManager::GetThreadId(), t2);
				matSparse[threadID].AddSubmatrix(myTemp.localMass, 1., ltg, ltg);
			}
		}
	}, nThreadsTaskmanager*3);
	STOPGLOBALTIMER(TScomputeMM0);

	CHECKandTHROW(massMatrix.GetSystemMatrixType() == LinearSolverType::EigenSparse,
		"CSystem::ComputeMassMatrix in USE_NGSOLVE_TASKMANAGER only sparse mode allowed");

	GeneralMatrixEigenSparse& massMatrixSparse = (GeneralMatrixEigenSparse&)massMatrix;
	EigenTripletVector& triplets = massMatrixSparse.GetEigenTriplets();

	Index totalTriplets = 0;
	SlimArray<Index, MAX_NUMBER_OF_THREADS> tripletIndex;
	for (Index i = 0; i < nThreadsTaskmanager; i++)
	{
		tripletIndex[i] = totalTriplets;
		totalTriplets += (Index)matSparse[i].GetEigenTriplets().size();
	}

	//STARTGLOBALTIMER(TScomputeMM1);
	////triplets.reserve(totalTriplets+ triplets.size()); //this guarantees that vector size is large enough
	//triplets.resize(totalTriplets);
	//STOPGLOBALTIMER(TScomputeMM1);
	
	STARTGLOBALTIMER(TScomputeMM2);
	//Index iTriplet = 0;
	for (Index i = 0; i < nThreadsTaskmanager; i++)
	{
		//for (Index j = 0; j < (Index)matSparse[i].GetEigenTriplets().size(); i++)
		for (auto& item : matSparse[i].GetEigenTriplets())
		{
			triplets.push_back(item);
			//triplets[iTriplet++] = item;
		}
	}
	//for (Index i = 0; i < nThreadsTaskmanager; i++)
	//{
	//	copy(matSparse[i].GetEigenTriplets().begin(), matSparse[i].GetEigenTriplets().end(),
	//		triplets[tripletIndex[i]]);
	//}

	//ngstd::ParallelFor(nThreadsTaskmanager, [&triplets, &tripletIndex](NGSsizeType j) //&temp,&systemODE2Rhs,&cSystemData
	//{
	//	Index matSparseSize = (Index)matSparse[j].GetEigenTriplets().size();
	//	for (Index k = 0; k < matSparseSize; ++k)
	//	{
	//		triplets[tripletIndex[j] + k] = matSparse[j].GetEigenTriplets()[k];
	//	}
	//});
	STOPGLOBALTIMER(TScomputeMM2);
	outputBuffer.SetSuspendWriting(false); //may not write to python during parallel computation

}
#else
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CSystem computation functions
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! compute system massmatrix; massmatrix must have according size
void CSystem::ComputeMassMatrix(TemporaryComputationData& temp, GeneralMatrix& massMatrix)
{
	//size needs to be set accordingly in the caller function; components are addd to massMatrix!
	//only call bodies with ODE2
	temp.massMatrix.SetAllMatricesZero(); //this resets both matrices (no new)
	if (massMatrix.GetSystemMatrixType() == LinearSolverType::EXUdense)
	{

		for (Index j : cSystemData.objectsBodyWithODE2Coords)
		{
			temp.massMatrix.SetUseDenseMatrix(true); //this is default, mass matrix must either switch to sparse or 

			ArrayIndex& ltg = cSystemData.GetLocalToGlobalODE2()[j];
			((CObjectBody*)(cSystemData.GetCObjects()[j]))->ComputeMassMatrix(temp.massMatrix, ltg, j); //ltg only used in sparse mode

			if (temp.massMatrix.UseDenseMatrix()) //dense matrix filled in and this is now transferred to dense system matrix
			{
				massMatrix.AddSubmatrix(temp.massMatrix.GetInternalDenseMatrix(), 1., ltg, ltg);
			}
			//else //object switched to sparse matrix and added sparse matrix to sparseTriplets ==> action only needed at the end
			//{
			//}
		}
		//add sparse triplets to the dense matrix
		temp.massMatrix.SetUseDenseMatrix(false); //for next operation needed
		//pout << "sys triplet mass=" << temp.massMatrix.GetInternalSparseTripletsAsMatrix() << "\n";

		const ResizableArray<EXUmath::Triplet>& triplets = temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets();
		ResizableMatrix& matrix = ((GeneralMatrixEXUdense&)massMatrix).GetMatrixEXUdense();
		for (const EXUmath::Triplet& triplet : triplets)
		{
			matrix(triplet.row(), triplet.col()) += triplet.value();
		}
	}
	else //GeneralMatrix is sparse matrix
	{
		//exchange GeneralMatrix and MatrixContainer triplets ==> mass matrix directly filled by objects!
		SparseTripletVector& generalMatrixTriplets = ((GeneralMatrixEigenSparse&)massMatrix).GetSparseTriplets();

		temp.massMatrix.SetUseDenseMatrix(false); //for next 2 operations needed
		generalMatrixTriplets.Swap(temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets());
		SparseTripletVector& sparseTriplets = temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets(); //link to current triplets in temp.massMatrix:

		temp.massMatrix.SetUseDenseMatrix(true); //for next operation needed
		Matrix& denseMatrix = temp.massMatrix.GetInternalDenseMatrix();

		for (Index j : cSystemData.objectsBodyWithODE2Coords)
		{
			temp.massMatrix.SetUseDenseMatrix(true); //this is default, mass matrix must either switch to sparse or 

			ArrayIndex& ltg = cSystemData.GetLocalToGlobalODE2()[j];
			((CObjectBody*)(cSystemData.GetCObjects()[j]))->ComputeMassMatrix(temp.massMatrix, ltg, j); //ltg only used in sparse mode

			if (temp.massMatrix.UseDenseMatrix()) //dense matrix filled in and this is now transferred to dense system matrix
			{
				for (Index i = 0; i < denseMatrix.NumberOfRows(); i++)
				{
					for (Index j = 0; j < denseMatrix.NumberOfColumns(); j++)
					{
						Real value = denseMatrix(i, j);
						if (value != 0.)
						{
							sparseTriplets.AppendPure(SparseTriplet(ltg[i], ltg[j], value));
						}
					}
				}
			}
			//else: already added to sparse triplets!
		}

		//exchange back GeneralMatrix and MatrixContainer triplets
		temp.massMatrix.SetUseDenseMatrix(false); //for next operation needed
		generalMatrixTriplets.Swap(temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets());
	}

}
#endif

//! run through all bodies and check if has constant mass matrix; used for solver
bool CSystem::HasConstantMassMatrix()
{
	bool isConstant = true;
	for (Index j: cSystemData.objectsBodyWithODE2Coords)
	{
		//if object is a body, it must have a mass matrix
		if (!(((CObjectBody*)cSystemData.GetCObjects()[j])->HasConstantMassMatrix()) )
		{
			isConstant = false;
		}
	}
	return isConstant;
}

//Index TScomputeODE2LHSobject;
//TimerStructureRegistrator TSRcomputeODE2LHSobject("computeODE2LHSobject", TScomputeODE2LHSobject, globalTimers);
//Index TScomputeODE2LHSconnector;
//TimerStructureRegistrator TSRcomputeODE2LHSconnector("computeODE2LHSconnector", TScomputeODE2LHSconnector, globalTimers);
//Index TScomputeODE2LHSmarkerData;
//TimerStructureRegistrator TSRcomputeODE2LHSmarkerData("computeODE2LHSmarkerData", TScomputeODE2LHSmarkerData, globalTimers);
//Index TScomputeLoads;
//TimerStructureRegistrator TSRcomputeLoads("computeLoads", TScomputeLoads, globalTimers);
//Index TScomputeObjectODE2;
//TimerStructureRegistrator TSRcomputeObjectODE2("computeObjectODE2", TScomputeObjectODE2, globalTimers);
//Index TScomputeLoadsMarkerData;
//TimerStructureRegistrator TSRcomputeLoadsMarkerData("computeLoadsMarkerData", TScomputeLoadsMarkerData, globalTimers);
Index TScomputeConnectorsMarkerData;
TimerStructureRegistrator TSRcomputeConnectorsMarkerData("connectorsMarkerData", TScomputeConnectorsMarkerData, globalTimers);

Index TScomputeAlgebraicEquations;
TimerStructureRegistrator TSRcomputeAlgebraicEquations("computeAlgebraicEquations", TScomputeAlgebraicEquations, globalTimers);

Index TScomputeGeneralContact;
TimerStructureRegistrator TSRcomputeGeneralContact("Contact:overall", TScomputeGeneralContact, globalTimers);
//Index TScomputeMarkerDataODE2;
//TimerStructureRegistrator TSRcomputeMarkerDataODE2("computeMarkerDataODE2", TScomputeMarkerDataODE2, globalTimers);


//! compute left-hand-side (LHS) of second order ordinary differential equations (ODE) for every object (used in numerical differentiation and in RHS computation)
//! return true, if object has localODE2Lhs, false otherwise
inline bool CSystem::ComputeObjectODE2LHS(TemporaryComputationData& temp, CObject* object, Vector& localODE2Lhs, Index objectNumber)
{
	if (object->IsActive()) //usually is active ...
	{
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Body))
		{
			object->ComputeODE2LHS(localODE2Lhs, objectNumber);
		}
		else if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		{
			CObjectConnector* connector = (CObjectConnector*)object;

			//compute MarkerData for connector:
			const bool computeJacobian = true; //jacobian needed for connectors, to add correct projection of forces!
			cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);

			connector->ComputeODE2LHS(localODE2Lhs, temp.markerDataStructure, objectNumber);
		}
		return true;
	}
	return false;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
void CSystem::ComputeSystemODE2RHS(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
{
	//STARTGLOBALTIMER(TScomputeObjectODE2);
	systemODE2Rhs.SetAll(0.);

#ifdef USE_NGSOLVE_TASKMANAGER
	Index nThreads = ngstd::TaskManager::GetNumThreads();
	if (nThreads > 1)
	{
		//std::mutex mtx;           // mutex for critical section
		outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation

		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}

		int nItems = cSystemData.listComputeObjectODE2LhsNoUF.NumberOfItems();
		Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
		if (nItems >= 500 * nThreads) { taskSplit = 100 * nThreads; }
		ngstd::ParallelFor(nItems, [this, &systemODE2Rhs, &tempArray, &nItems](NGSsizeType j) //&temp,&systemODE2Rhs,&cSystemData
		{
			Index i = cSystemData.listComputeObjectODE2Lhs[(Index)j];
			Index threadID = ngstd::TaskManager::GetThreadId();

			TemporaryComputationData& temp = tempArray[threadID];
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[i];

			if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[i], temp.localODE2LHS, i))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
				{
					tempArray[threadID].sparseVector.AddIndexAndValue(ltgODE2[k], temp.localODE2LHS[k]);
					//systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
				}
			}

		}, taskSplit);
		//serial section for writing into system vector
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				systemODE2Rhs[item.GetIndex()] -= item.GetValue(); //minus: LHS->RHS
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++
		//now work over objects with user functions:
		TemporaryComputationData& temp = tempArray[0]; //always exists

		for (Index j : cSystemData.listComputeObjectODE2LhsUF)
		{
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];

			if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[j], temp.localODE2LHS, j))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
				{
					systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
				}
			}
		}

	}
	else
#endif
	{	//conventional SERIAL version:
		TemporaryComputationData& temp = tempArray[0]; //always exists
		//STARTGLOBALTIMER(TScomputeObjectODE2);
		//systemODE2Rhs.SetAll(0.);

		for (Index j : cSystemData.listComputeObjectODE2Lhs)
		{
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];

			if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[j], temp.localODE2LHS, j))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
				{
					systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
				}
			}
		}
		//STOPGLOBALTIMER(TScomputeObjectODE2);

	}
	//pout << "systemODE2Rhs=" << systemODE2Rhs << "\n";
	//STOPGLOBALTIMER(TScomputeObjectODE2);

	//this part is anyway done in parallel:
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		STARTGLOBALTIMER(TScomputeGeneralContact);
		//gc->ComputeContactDataAndBoundingBoxes(*this, tempArray); //done in compute ODE2RHS ...
		gc->ComputeODE2RHS(*this, tempArray, systemODE2Rhs);
		STOPGLOBALTIMER(TScomputeGeneralContact);
	}

	//STARTGLOBALTIMER(TScomputeLoads);
	ComputeODE2Loads(tempArray, systemODE2Rhs);
	//STOPGLOBALTIMER(TScomputeLoads);

	outputBuffer.SetSuspendWriting(false);
}

////+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
////! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
//void CSystem::ComputeSystemODE2RHS(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
//{
//	TemporaryComputationData& temp = tempArray[0]; //always exists
//	//STARTGLOBALTIMER(TScomputeObjectODE2);
//	systemODE2Rhs.SetAll(0.);
//
//	for (Index j : cSystemData.listComputeObjectODE2Lhs)
//	{
//		ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
//
//		if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[j], temp.localODE2LHS, j))
//		{
//			//now add RHS to system vector
//			for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
//			{
//				systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
//			}
//		}
//	}
//	//STOPGLOBALTIMER(TScomputeObjectODE2);
//
//	for (GeneralContact* gc : generalContacts) //usually only 1
//	{
//		STARTGLOBALTIMER(TScomputeGeneralContact);
//		gc->ComputeContactDataAndBoundingBoxes(*this, temp);
//		gc->ComputeODE2RHS(*this, temp, systemODE2Rhs);
//		STOPGLOBALTIMER(TScomputeGeneralContact);
//	}
//	//STARTGLOBALTIMER(TScomputeLoads);
//	ComputeODE2Loads(temp, systemODE2Rhs);
//	//STOPGLOBALTIMER(TScomputeLoads);
//}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//evaluate RHS of ODE1 objects (always right-hand-side as first order ODEs always read q_t=f(q, t) )
inline bool CSystem::ComputeObjectODE1RHS(TemporaryComputationData& temp, CObject* object, Vector& localODE1Rhs, Index objectNumber)
{
	if (object->IsActive())
	{
		//must be body or similar object (in all cases, evaluate ComputeODE1LHS)
		object->ComputeODE1RHS(localODE1Rhs,  objectNumber);
		return true;
	}
	return false;
}

void CSystem::ComputeSystemODE1RHS(TemporaryComputationData& temp, Vector& systemODE1Rhs)
{
	if (systemODE1Rhs.NumberOfItems() != 0) //usually not called
	{
		systemODE1Rhs.SetAll(0.);
		//std::cout << "ComputeSystemODE1RHS start\n";

		for (Index j : cSystemData.listComputeObjectODE1Rhs)
		{
			ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];

			if (ComputeObjectODE1RHS(temp, cSystemData.GetCObjects()[j], temp.localODE1RHS, j))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE1RHS.NumberOfItems(); k++)
				{
					systemODE1Rhs[ltgODE1[k]] += temp.localODE1RHS[k]; //positive sign as compared to ComputeSystemODE2RHS: in ODE1, everything is on RHS
				}
			}
		}
		ComputeODE1Loads(temp, systemODE1Rhs);
	}
	//std::cout << "ComputeSystemODE1RHS end\n";
}


//! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
void CSystem::ComputeODE2Loads(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
{
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	//compute loads ==> not needed in jacobian, except for follower loads, 
	//  using e.g. local body coordinate system

	//Index nLoads = cSystemData.GetCLoads().NumberOfItems();
	Real currentTime = cSystemData.GetCData().currentState.time;

//#define USE_NGSOLVE_TASKMANAGER_LOADS
	Index nThreads = ngstd::TaskManager::GetNumThreads();

	if (nThreads > 1)
	{
		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}

		int nItems = cSystemData.listOfLoads.NumberOfItems();
		Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
		if (nItems >= 500 * nThreads) { taskSplit = 100 * nThreads; }
		ngstd::ParallelFor(nItems, [this, &systemODE2Rhs, &tempArray, &currentTime, &nItems](NGSsizeType i) //&temp,&systemODE2Rhs,&cSystemData
		{
			Index threadID = ngstd::TaskManager::GetThreadId();
			const bool fillSparseVector = true;

			ComputeODE2SingleLoad(cSystemData.listOfLoads[(Index)i], tempArray[threadID], currentTime, systemODE2Rhs, fillSparseVector);
		}, taskSplit);
		//serial section for writing sparseVectors into system vector
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				systemODE2Rhs[item.GetIndex()] += item.GetValue(); //minus: LHS->RHS
			}
		}
		const bool fillSparseVector = false;
		TemporaryComputationData& temp = tempArray[0];
		for (Index j: cSystemData.listOfLoadsUF)
		{
			ComputeODE2SingleLoad(j, temp, currentTime, systemODE2Rhs, fillSparseVector);
		}
	}
	else
	{
		//serial version, directly writes into systemODE2Rhs
		const bool fillSparseVector = false;
		int nLoads = cSystemData.GetCLoads().NumberOfItems();
		TemporaryComputationData& temp = tempArray[0];
		for (Index j = 0; j < nLoads; j++)
		{
			ComputeODE2SingleLoad(j, temp, currentTime, systemODE2Rhs, fillSparseVector);
		}
	}
}


//! compute part of load for 'ode2rhs' or to sparsevector; if fillSparseVector, values are added to temp.sparseVector; otherwise, filled directly into systemODE2Rhs
void CSystem::ComputeODE2SingleLoad(Index loadIndex, TemporaryComputationData& temp, Real currentTime, Vector& systemODE2Rhs, bool fillSparseVector)
{
	Vector3D loadVector3D(0); //initialization in order to avoid gcc warnings
	Vector1D loadVector1D(0); //scalar loads...//initialization in order to avoid gcc warnings
	bool loadVector1Ddefined = false; //add checks such that wrong formats would fail
	bool loadVector3Ddefined = false; //add checks such that wrong formats would fail

	CLoad* cLoad = cSystemData.GetCLoads()[(Index)loadIndex];
	if (cLoad->IsVector())
	{
		loadVector3D = cLoad->GetLoadVector(cSystemData.GetMainSystemBacklink(), currentTime);
		loadVector3Ddefined = true;
	}
	else
	{
		loadVector1D = Vector1D(cLoad->GetLoadValue(cSystemData.GetMainSystemBacklink(), currentTime));
		loadVector1Ddefined = true;
	}

	Index markerNumber = cLoad->GetMarkerNumber();
	CMarker* marker = cSystemData.GetCMarkers()[markerNumber];
	LoadType loadType = cLoad->GetType();

	ArrayIndex* ltg = nullptr;	//for objects
	Index nodeCoordinate = 99999;//initialize with arbitrary value for gcc; starting index for nodes (consecutively numbered)
	bool applyLoad = false;		//loads are not applied to ground objects/nodes

	//loads only applied to Marker::Body or Marker::Node
	if (marker->GetType() & Marker::Body) //code for body markers
	{
		Index markerBodyNumber = marker->GetObjectNumber();
		if (!((Index)cSystemData.GetCObjectBody(markerBodyNumber).GetType() & (Index)CObjectType::Ground)) //no action on ground objects!
		{
			ltg = &cSystemData.GetLocalToGlobalODE2()[markerBodyNumber];
			if (ltg->NumberOfItems() != 0) { applyLoad = true; } //only apply load, if object is not attached to ground node!
		}
	}
	else if (marker->GetType() & Marker::Node) //code for body markers
	{
		Index markerNodeNumber = marker->GetNodeNumber();
		if (!cSystemData.GetCNodes()[markerNodeNumber]->IsGroundNode()) //if node has zero coordinates ==> ground node; no action on ground nodes!
		{
			if (((marker->GetType() & Marker::Position) || (marker->GetType() & Marker::Coordinate)) && !(marker->GetType() & Marker::ODE1))
			{
				nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE2CoordinateIndex();
				applyLoad = true;
			}
			else if (EXUstd::IsOfType((Index)marker->GetType(), Marker::Coordinate + Marker::ODE1))
			{
				applyLoad = false; //belongs to ODE1 coordinates, but valid load
			}
			else
			{
				CHECKandTHROWstring("ERROR: CSystem::ComputeODE2SingleLoad, marker type not implemented!");
			}
		}
	}
	else { pout << "ERROR: CSystem::ComputeODE2SingleLoad: marker must be Body or Node type\n"; }

	if (applyLoad)
	{
		//AccessFunctionType aft = GetAccessFunctionType(loadType, marker->GetType());
		//==> lateron: depending on AccessFunctionType compute jacobians, put into markerDataStructure as in connectors
		//    and call according jacobian function
		//    marker->GetAccessFunctionJacobian(AccessFunctionType, ...) ==> handles automatically the jacobian
		Real loadFactor = solverData.loadFactor; //copy
		if (cLoad->HasUserFunction())
		{
			loadFactor = 1.; //loadFactor not used for case of user functions, see issue #603
		}

		//bodyFixed (local) follower loads:
		bool bodyFixed = false;
		if (cLoad->IsBodyFixed())
		{
			bodyFixed = true;
		}

		if (loadType == LoadType::Force || loadType == LoadType::ForcePerMass)
		{
			const bool computeJacobian = true;
			CHECKandTHROW(loadVector3Ddefined, "ComputeODE2SingleLoad(...): illegal force vector format (expected 3D load)");
			//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
			marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
			//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
			if (bodyFixed) { loadVector3D = temp.markerDataStructure.GetMarkerData(0).orientation * loadVector3D; }
			EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).positionJacobian, loadVector3D, temp.generalizedLoad); //generalized load: Q = (dPos/dq)^T * Force

			//marker->GetPositionJacobian(cSystemData, temp.loadJacobian);
			//EXUmath::MultMatrixVector(temp.loadJacobian, loadVector3D, temp.generalizedLoad);
		}
		else if (loadType == LoadType::Torque)
		{
			const bool computeJacobian = true;
			CHECKandTHROW(loadVector3Ddefined, "ComputeODE2SingleLoad(...): illegal force vector format (expected 3D torque)");
			//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
			marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
			//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
			if (bodyFixed) { loadVector3D = temp.markerDataStructure.GetMarkerData(0).orientation * loadVector3D; }
			EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).rotationJacobian, loadVector3D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
			//pout << "rotationJacobian=" << temp.markerDataStructure.GetMarkerData(0).rotationJacobian << "\n";
			//pout << "loadVector3D=" << loadVector3D << "\n";
		}
		else if (loadType == LoadType::Coordinate)
		{
			const bool computeJacobian = true;
			CHECKandTHROW(loadVector1Ddefined, "ComputeODE2SingleLoad(...): illegal force vector format (expected 1D load)");
			//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
			marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
			//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
			EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).jacobian, loadVector1D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
			//pout << "jacobian=" << temp.markerDataStructure.GetMarkerData(0).jacobian << "\n";
			//pout << "generalizedLoad=" << temp.generalizedLoad << "\n";
			//pout << "loadVector1D=" << loadVector1D << "\n";
		}
		else { CHECKandTHROWstring("ERROR: CSystem::ComputeODE2SingleLoad, LoadType not implemented!"); }

		//ResizableArray<CObject*>& objectList = cSystemData.GetCObjects();
		//pout << "genLoad=" << temp.generalizedLoad << "\n";

		if (fillSparseVector)
		{
			if (ltg != nullptr) //must be object
			{
				for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
				{
					temp.sparseVector.AddIndexAndValue((*ltg)[k], loadFactor * temp.generalizedLoad[k]);
					//systemODE2Rhs[(*ltg)[k]] += loadFactor * temp.generalizedLoad[k];
				}
			}
			else //must be node
			{
				for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
				{
					temp.sparseVector.AddIndexAndValue(nodeCoordinate + k, loadFactor * temp.generalizedLoad[k]);
					//systemODE2Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
				}
			}
		}
		else
		{
			if (ltg != nullptr) //must be object
			{
				for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
				{
					systemODE2Rhs[(*ltg)[k]] += loadFactor * temp.generalizedLoad[k];
				}
			}
			else //must be node
			{
				for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
				{
					systemODE2Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
				}
			}
		}
	}

}



//! compute system right-hand-side (RHS) of first order ordinary differential equations (ODE) to 'ode1rhs' for ODE1 part
void CSystem::ComputeODE1Loads(TemporaryComputationData& temp, Vector& systemODE1Rhs)
{
	//STARTGLOBALTIMER(TScomputeLoads);

	Index nLoads = cSystemData.GetCLoads().NumberOfItems();
	//Vector3D loadVector3D(0); //initialization in order to avoid gcc warnings
	Vector1D loadVector1D(0); //scalar loads...//initialization in order to avoid gcc warnings
	bool loadVector1Ddefined = false; //add checks such that wrong formats would fail
	//bool loadVector3Ddefined = false; //add checks such that wrong formats would fail

	Real currentTime = cSystemData.GetCData().currentState.time;
	for (Index j = 0; j < nLoads; j++)
	{
		CLoad* cLoad = cSystemData.GetCLoads()[j];
		Index markerNumber = cLoad->GetMarkerNumber();
		CMarker* marker = cSystemData.GetCMarkers()[markerNumber];

		Index nodeCoordinate = 99999;//initialize with arbitrary value for gcc; starting index for nodes (consecutively numbered)
		bool applyLoad = false;		//loads are not applied to ground objects/nodes

		if (marker->GetType() & Marker::Node) //code for body markers
		{
			Index markerNodeNumber = marker->GetNodeNumber();
			if (!cSystemData.GetCNodes()[markerNodeNumber]->IsGroundNode()) //if node has zero coordinates ==> ground node; no action on ground nodes!
			{
				if (EXUstd::IsOfType((Index)marker->GetType(), Marker::Coordinate + Marker::ODE1))
				{
					nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE1CoordinateIndex();
					applyLoad = true;
				}
			}
		}

		if (applyLoad)
		{
			if (cLoad->IsVector())
			{
				//loadVector3D = cLoad->GetLoadVector(cSystemData.GetMainSystemBacklink(), currentTime);
				//loadVector3Ddefined = true;
				CHECKandTHROW(true, "ComputeODE1Loads(...): illegal 3D force vector ");
			}
			else
			{
				loadVector1D = Vector1D(cLoad->GetLoadValue(cSystemData.GetMainSystemBacklink(), currentTime));
				loadVector1Ddefined = true;
			}

			//AccessFunctionType aft = GetAccessFunctionType(loadType, marker->GetType());
			//==> lateron: depending on AccessFunctionType compute jacobians, put into markerDataStructure as in connectors
			//    and call according jacobian function
			//    marker->GetAccessFunctionJacobian(AccessFunctionType, ...) ==> handles automatically the jacobian
			Real loadFactor = solverData.loadFactor; //copy
			if (cLoad->HasUserFunction())
			{
				loadFactor = 1.; //loadFactor not used for case of user functions, see issue #603
			}

			LoadType loadType = cLoad->GetType();
			if (loadType == LoadType::Coordinate)
			{
				const bool computeJacobian = true;
				CHECKandTHROW(loadVector1Ddefined, "ComputeODE1Loads(...): illegal force vector format (expected 1D load)");
				marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
				EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).jacobian, loadVector1D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
			}
			else { CHECKandTHROWstring("ERROR: CSystem::ComputeSystemODE1RHS, LoadType not implemented!"); }

			//ResizableArray<CObject*>& objectList = cSystemData.GetCObjects();
			//pout << "genLoad=" << temp.generalizedLoad << "\n";

			//pout << "  nodeCoordinate=" << nodeCoordinate << "\n";
			for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
			{
				systemODE1Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
			}
		}

	}
	//STOPGLOBALTIMER(TScomputeLoads);
}

//! compute system right-hand-side (RHS) of algebraic equations (AE) to vector 'AERhs'
void CSystem::ComputeAlgebraicEquations(TemporaryComputationData& temp, Vector& algebraicEquations, bool velocityLevel)
{
	//Still needed? algebraicEquations.SetNumberOfItems(cSystemData.GetNumberOfCoordinatesAE()); //needed for numerical differentiation
	algebraicEquations.SetAll(0.);

	//algebraic equations only origin from objects (e.g. Euler parameters) and constraints

	//for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
	for (Index j : cSystemData.objectsBodyWithAE)
	{
		//work over bodies, connectors, etc.
		ArrayIndex& ltg = cSystemData.GetLocalToGlobalAE()[j];

		cSystemData.GetCObjects()[j]->ComputeAlgebraicEquations(temp.localAE, velocityLevel); //no time given for objects for now (only Euler parameters...)

		CHECKandTHROW(ltg.NumberOfItems() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: objectsBodyWithAE: ltg size mismatch");
		//now add RHS to system vector
		for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
		{
			algebraicEquations[ltg[k]] += temp.localAE[k]; 
		}
	}
	for (Index j : cSystemData.nodesODE2WithAE)
	{
		//pout << "add algebraic equations for nodes\n";
		//work over bodies, connectors, etc.
		Index aeIndex = cSystemData.GetCNode(j).GetGlobalAECoordinateIndex();

		((CNodeODE2&)(cSystemData.GetCNode(j))).ComputeAlgebraicEquations(temp.localAE, velocityLevel); 

		CHECKandTHROW(cSystemData.GetCNode(j).GetNumberOfAECoordinates() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: nodesODE2WithAE: size mismatch");
		//now add RHS to system vector
		for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
		{
			algebraicEquations[k+aeIndex] += temp.localAE[k]; 
		}
	}
	for (Index j : cSystemData.objectsConstraintWithAE)
	{
		CObjectConstraint* constraint = (CObjectConstraint*)(cSystemData.GetCObjects()[j]);
		ArrayIndex& ltg = cSystemData.GetLocalToGlobalAE()[j];

		const bool computeJacobian = false;
		//STARTGLOBALTIMER(TScomputeConnectorsMarkerData);
		cSystemData.ComputeMarkerDataStructure(constraint, computeJacobian, temp.markerDataStructure);
		//STOPGLOBALTIMER(TScomputeConnectorsMarkerData);

		//STARTGLOBALTIMER(TScomputeAlgebraicEquations);
		constraint->ComputeAlgebraicEquations(temp.localAE, temp.markerDataStructure, cSystemData.GetCData().currentState.time, j, velocityLevel);
		//STOPGLOBALTIMER(TScomputeAlgebraicEquations);

		CHECKandTHROW(ltg.NumberOfItems() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: ltg size mismatch");
		//now add RHS to system vector
		for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
		{
			algebraicEquations[ltg[k]] += temp.localAE[k]; //negative sign ==> check sign of Lagrange multipliers
		}
	}

}

//void CSystem::ComputeMarkerDataStructure(const CObjectConnector* connector, bool computeJacobian, MarkerDataStructure& markerDataStructure) const
//{
//	const ArrayIndex& markerNumbers = connector->GetMarkerNumbers();
//	Index nMarkers = connector->GetMarkerNumbers().NumberOfItems();
//	if (nMarkers != 2) { CHECKandTHROWstring("CSystem::ComputeMarkerDataStructure(...): Number of connector markers != 2 not implemented"); }
//	markerDataStructure.SetTime(cSystemData.GetCData().currentState.GetTime());
//
//	if ((Index)connector->GetType() & (Index)CObjectType::Constraint)
//	{
//		const CObjectConstraint* constraint = (CObjectConstraint*)connector;
//		Index AEindex = constraint->GetGlobalAECoordinateIndex();
//		Index nAEcoords = constraint->GetAlgebraicEquationsSize();
//		markerDataStructure.GetLagrangeMultipliers().LinkDataTo(cSystemData.GetCData().currentState.AECoords, AEindex, nAEcoords);
//	}
//	for (Index k = 0; k < 2; k++)
//	{
//		cSystemData.GetCMarkers()[markerNumbers[k]]->ComputeMarkerData(cSystemData, computeJacobian, markerDataStructure.GetMarkerData(k));
//	}
//}

//! PostNewtonStep: do this for every object (connector), which has a PostNewtonStep ->discontinuous iteration e.g. to resolve contact, friction or plasticity
//! recommendedStepSize must be initialized with -1 or previous recommendation: [< 0: no recommendation, 0: use minimum step size, >0: use specific step size, if no smaller size requested by other reason]
Real CSystem::PostNewtonStep(TemporaryComputationDataArray& tempArray, Real& recommendedStepSize)
{
	//recommendedStepSize (must be initialized with -1 or appropriately)
	Real PNerror = 0;
	PostNewtonFlags::Type postNewtonFlags;
	//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
	TemporaryComputationData& temp = tempArray[0]; //always exists

	//for (Index objectIndex = 0; objectIndex < cSystemData.GetCObjects().NumberOfItems(); objectIndex++)
	for (Index j : cSystemData.listDiscontinuousIteration)
	{
		CObjectConnector* connector = (CObjectConnector*)(cSystemData.GetCObjects()[j]);

		if (connector->IsActive()) //usually is active ...
		{
			const bool computeJacobian = true; //why needed for PostNewtonStep?==> check Issue #241
			cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);

			Real objectRecomStepSize = -1;
			PNerror = EXUstd::Maximum(connector->PostNewtonStep(temp.markerDataStructure, j, postNewtonFlags, objectRecomStepSize), PNerror);
			if (objectRecomStepSize >= 0 && (objectRecomStepSize < recommendedStepSize || recommendedStepSize==-1))
			{
				recommendedStepSize = objectRecomStepSize;
			}

			if (postNewtonFlags&PostNewtonFlags::UpdateLTGLists)
			{
				//now update specific ltg lists, if e.g. due to contact or switching the connectivity has changed
				AssembleObjectLTGLists(j, cSystemData.GetLocalToGlobalODE2()[j], cSystemData.GetLocalToGlobalODE1()[j],
					cSystemData.GetLocalToGlobalAE()[j], cSystemData.GetLocalToGlobalData()[j]);

				//pout << "Connector" << objectIndex << ", new LTGlist=" << cSystemData.GetLocalToGlobalODE2()[objectIndex] << "\n";
			}
		}
	}

	//this part is anyway done in parallel:
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		STARTGLOBALTIMER(TScomputeGeneralContact);
		PNerror = EXUstd::Maximum(gc->PostNewtonStep(*this, tempArray, recommendedStepSize),  PNerror);
		STOPGLOBALTIMER(TScomputeGeneralContact);
	}


	return PNerror;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CSystem::PostDiscontinuousIterationStep()
{
	//for (CObject* object : cSystemData.GetCObjects())
	for (Index j : cSystemData.listDiscontinuousIteration)
	{
		CObjectConnector* connector = (CObjectConnector*)(cSystemData.GetCObjects()[j]);

		if (connector->IsActive()) //usually is active ...
		{
			connector->PostDiscontinuousIterationStep();
		}
	}
}







//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                          JACOBIANS
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! compute numerical differentiation of ODE2RHS w.r.t. ODE2 and ODE2_t quantities; 
//! multiply (before added to jacobianGM) ODE2 with factorODE2 and ODE2_t with factorODE2_t
//! the jacobian is ADDed to jacobianGM, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
void CSystem::JacobianODE2RHS(TemporaryComputationDataArray& tempArray, const NumericalDifferentiationSettings& numDiff,
	GeneralMatrix& jacobianGM, Real factorODE2, Real factorODE2_t)
{
	TemporaryComputationData& temp = tempArray[0]; //always exists
	temp.jacobianODE2Container.SetAllMatricesZero();

	ResizableVector& f0 = temp.numericalJacobianf0;
	ResizableVector& f1 = temp.numericalJacobianf1;

	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;			//current coordinates ==> this is what is differentiated for
	Vector& xRef = cSystemData.GetCData().referenceState.ODE2Coords;	//reference coordinates; might be important for numerical differentiation
	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation
	Vector& x_t = cSystemData.GetCData().currentState.ODE2Coords_t;		//for diff w.r.t. velocities

	bool diffODE2 = (factorODE2 != 0.);
	bool diffODE2_t = (factorODE2_t != 0.);

	if (!numDiff.doSystemWideDifferentiation)
	{
		ResizableMatrix& localJacobian = temp.localJacobian;

		//++++++++++++++++++++++++++++++++++++++++++++++++
		//for parallelized version add list to distinguish between parallelizable jacs and serial
		for (Index j : cSystemData.listComputeObjectODE2Lhs)
		{
			CObject* object = cSystemData.GetCObjects()[j];
			if (object->IsActive())
			{
				ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
				Index nLocalODE2 = ltgODE2.NumberOfItems();
				f0.SetNumberOfItems(nLocalODE2);
				f1.SetNumberOfItems(nLocalODE2);

				JacobianType::Type jacType = object->GetAvailableJacobians();

				bool jacobianComputed = false;
				if (jacType & (JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t)) //any ODE2 dependency
				{
					if (!numDiff.forODE2 && ((jacType & (JacobianType::ODE2_ODE2_function + JacobianType::ODE2_ODE2_t_function)) != 0))
					{
						if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
						{   //*** compute object jacobian, e.g., finite element or rigid body
							jacobianComputed = true;

							//matrix size set inside object
							object->ComputeJacobianODE2_ODE2(temp.jacobianODE2Container, temp.jacobianTemp,
								-factorODE2, -factorODE2_t, j, ltgODE2); //minus (-) because in numerical mode, f0-f1 leads to negative sign (RHS ==> LHS)
							if (temp.jacobianODE2Container.UseDenseMatrix())
							{
								jacobianGM.AddSubmatrix(temp.jacobianODE2Container.GetInternalDenseMatrix(), 1., ltgODE2, ltgODE2);
							}
							else
							{
								jacobianGM.AddSparseTriplets(temp.jacobianODE2Container.GetInternalSparseTripletMatrix().GetTriplets());
								//sparse matrix container cannot be reset in jacobian function for future implementations
								//==>replace this by directly adding values to jacobianGM sparse triplets in object jacobian
								temp.jacobianODE2Container.GetInternalSparseTripletMatrix().SetAllZero();
							}
						} //if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector)
						else if (!numDiff.forODE2connectors)
						{	//*** go the lengthier way: compute connector jacobian, e.g., spring-damper
							CObjectConnector* connector = (CObjectConnector*)object;

							const ArrayIndex& markerNumbers = connector->GetMarkerNumbers();
							jacobianComputed = true;
							bool jacDerivNonZero = false;
							for (Index k = 0; k < markerNumbers.NumberOfItems(); k++)
							{
								jacobianComputed &= ((cSystemData.GetCMarker(markerNumbers[k]).GetType() & Marker::JacobianDerivativeAvailable) != 0);
								jacDerivNonZero |= ((cSystemData.GetCMarker(markerNumbers[k]).GetType() & Marker::JacobianDerivativeNonZero) != 0);
							}

							if (jacobianComputed)
							{
								//compute MarkerData for connector:
								const bool computeJacobian = true; //jacobian needed for jacobian computation ...
								cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);
								//pout << "compute connector " << j << " jacobian \n";
								if (jacDerivNonZero) //call needed, if one marker has non-zero derivative ==> compute jacobianForce for both cases
								{
									Vector6D jacobianForce;
									connector->ComputeJacobianForce6D(temp.markerDataStructure, j, jacobianForce);
									//even though that force on marker0 acts with negative sign, 
									//  the different signs are accounted for in connector->ComputeJacobianODE2_ODE2(...)
									//  ==> but this could also be done here !
									//pout << "  jacobian force = " << temp.jacobianForce << " \n";
									for (Index k = 0; k < markerNumbers.NumberOfItems(); k++)
									{
										cSystemData.GetCMarkers()[markerNumbers[k]]->ComputeMarkerDataJacobianDerivative(cSystemData,
											jacobianForce, temp.markerDataStructure.GetMarkerData(k));
										//pout << "  compute non-zero jacobian derivative" << k << ": " << temp.markerDataStructure.GetMarkerData(k).jacobianDerivative << " \n";
									}
								}
								else
								{
									//clear jacobianDerivative!!!
									for (Index k = 0; k < markerNumbers.NumberOfItems(); k++)
									{
										temp.markerDataStructure.GetMarkerData(k).jacobianDerivative.SetNumberOfRowsAndColumns(0, 0);
									}
								}

								connector->ComputeJacobianODE2_ODE2(temp.jacobianODE2Container, temp.jacobianTemp, 
									-factorODE2, -factorODE2_t, j, ltgODE2, temp.markerDataStructure);


								if (temp.jacobianODE2Container.UseDenseMatrix())
								{
									jacobianGM.AddSubmatrix(temp.jacobianODE2Container.GetInternalDenseMatrix(), 1., ltgODE2, ltgODE2);
									//pout << "jacA" << j << "=np.array(" << temp.jacobianODE2Container.GetInternalDenseMatrix() << ")\n";
								}
								else
								{
									jacobianGM.AddSparseTriplets(temp.jacobianODE2Container.GetInternalSparseTripletMatrix().GetTriplets());
								}
							}
						} //if (numDiff.forODE2connectors)
					}

					if (!jacobianComputed && ComputeObjectODE2LHS(temp, object, f0, j)) //check if it is a constraint, etc. which is not differentiated for ODE2 jacobian
					{
						localJacobian.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE2); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
						if (diffODE2)
						{
							Real xRefVal = 0;
							for (Index i = 0; i < nLocalODE2; i++) //differentiate w.r.t. every ltgODE2 coordinate
							{
								Real& xVal = x[ltgODE2[i]];
								if (numDiff.addReferenceCoordinatesToEpsilon) { xRefVal = xRef[ltgODE2[i]]; }

								eps = relEps * (EXUstd::Maximum(minCoord, fabs(xVal + xRefVal)));

								xStore = xVal;
								xVal += eps;
								ComputeObjectODE2LHS(temp, object, f1, j);
								xVal = xStore;

								epsInv = (1. / eps) * factorODE2;

								for (Index k = 0; k < nLocalODE2; k++)
								{
									//use local jacobian:
									localJacobian(k, i) = epsInv * (f0[k] - f1[k]); //-(f1-f0) == (f0-f1): negative sign, because object ODE2RHS is subtracted from global RHS-vector
								}
							}
						}
						else { localJacobian.SetAll(0.); }

						if (diffODE2_t && EXUstd::IsOfType(jacType, JacobianType::ODE2_ODE2_t))
						{
							for (Index i = 0; i < nLocalODE2; i++) //differentiate w.r.t. every ltgODE2 coordinate
							{
								Real& xVal = x_t[ltgODE2[i]];
								eps = relEps * (EXUstd::Maximum(minCoord, fabs(xVal)));

								xStore = xVal;
								xVal += eps;
								ComputeObjectODE2LHS(temp, object, f1, j);
								xVal = xStore;

								epsInv = (1. / eps) * factorODE2_t;

								for (Index k = 0; k < nLocalODE2; k++)
								{
									//use local jacobian:
									localJacobian(k, i) += epsInv * (f0[k] - f1[k]); //-(f1-f0) == (f0-f1): negative sign, because object ODE2RHS is subtracted from global RHS-vector
								}
							}
						}

						jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE2, ltgODE2);
						//pout << "jacN" << j << "=np.array(" << localJacobian << ")\n";
					}
				}
			}//isActive
		}//loop over objects
	}
	else
	{
		//done in solver: jacobian.SetNumberOfRowsAndColumns(nODE2, nODE2);

		//++++++++++++++++++++++++++++++++++++++++++++++++
		f0.SetNumberOfItems(nODE2);
		f1.SetNumberOfItems(nODE2);
		ComputeSystemODE2RHS(tempArray, f0); //compute nominal value for jacobian
		Real xRefVal = 0;

		if (diffODE2)
		{
			for (Index i = 0; i < nODE2; i++) //compute column i
			{
				if (numDiff.addReferenceCoordinatesToEpsilon) { xRefVal = xRef[i]; }
				eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i] + xRefVal)));

				xStore = x[i];
				x[i] += eps;
				ComputeSystemODE2RHS(tempArray, f1);
				x[i] = xStore;

				epsInv = (1. / eps) * factorODE2;

				f1 -= f0;
				f1 *= epsInv;
				jacobianGM.AddColumnVector(i, f1);
			}
		}

		if (diffODE2_t)
		{
			for (Index i = 0; i < nODE2; i++)
			{
				eps = relEps * (EXUstd::Maximum(minCoord, fabs(x_t[i])));

				xStore = x_t[i];
				x_t[i] += eps;
				ComputeSystemODE2RHS(tempArray, f1);
				x_t[i] = xStore;

				epsInv = (1. / eps) * factorODE2_t;

				f1 -= f0;
				f1 *= epsInv;
				jacobianGM.AddColumnVector(i, f1);
			}
		}
	}
	//pout << "ODE2jac=" << jacobian << "\n";
	//cSystemData.isODE2RHSjacobianComputation = false; //hack! only for debugging

	//this part is anyway done in parallel:
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		STARTGLOBALTIMER(TScomputeGeneralContact);
		gc->JacobianODE2LHS(*this, tempArray, numDiff, jacobianGM, -factorODE2, -factorODE2_t); //negative sign, because contact computes LHS jacobian!
		STOPGLOBALTIMER(TScomputeGeneralContact);
	}


}





//! compute numerical differentiation of ODE1RHS; result is a jacobian;  multiply the added entries with scalarFactor
//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
void CSystem::NumericalJacobianODE1RHS(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
	Vector& f0, Vector& f1, GeneralMatrix& jacobianGM, Real scalarFactor)
{
	//size needs to be set accordingly in the caller function; components are addd to massMatrix!

	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
	Vector& x = cSystemData.GetCData().currentState.ODE1Coords;			//current coordinates ==> this is what is differentiated for
	Vector& xRef = cSystemData.GetCData().referenceState.ODE1Coords;	//reference coordinates; might be important for numerical differentiation
	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation

	if (!numDiff.doSystemWideDifferentiation)
	{
		ResizableMatrix& localJacobian = temp.localJacobian;

		for (Index j : cSystemData.listComputeObjectODE1Rhs)
		{
			ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];
			CObject* object = cSystemData.GetCObjects()[j];

			Index nLocalODE1 = ltgODE1.NumberOfItems();
			f0.SetNumberOfItems(nLocalODE1);
			f1.SetNumberOfItems(nLocalODE1);
			if (ComputeObjectODE1RHS(temp, object, f0, j))
			{
				localJacobian.SetNumberOfRowsAndColumns(nLocalODE1, nLocalODE1); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
				Real xRefVal = 0;
				for (Index i = 0; i < nLocalODE1; i++) //differentiate w.r.t. every ltgODE1 coordinate
				{
					Real& xVal = x[ltgODE1[i]];
					if (numDiff.addReferenceCoordinatesToEpsilon) { xRefVal = xRef[ltgODE1[i]]; }

					eps = relEps * (EXUstd::Maximum(minCoord, fabs(xVal + xRefVal)));

					xStore = xVal;
					xVal += eps;
					ComputeObjectODE1RHS(temp, object, f1, j);
					xVal = xStore;

					epsInv = (1. / eps) * scalarFactor;

					for (Index k = 0; k < nLocalODE1; k++)
					{
						//use local jacobian:
						localJacobian(k, i) = epsInv * (f1[k] - f0[k]); 
					}
				}
				jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE1, ltgODE1, nODE2, nODE2);
			}
		}
	}
	else
	{

		//++++++++++++++++++++++++++++++++++++++++++++++++
		f0.SetNumberOfItems(nODE1);
		f1.SetNumberOfItems(nODE1);
		ComputeSystemODE1RHS(temp, f0); //compute nominal value for jacobian
		Index rowOffset = nODE2;
		Real xRefVal = 0;

		for (Index i = 0; i < nODE1; i++) //compute column i
		{
			if (numDiff.addReferenceCoordinatesToEpsilon) { xRefVal = xRef[i]; }
			eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i] + xRefVal)));

			xStore = x[i];
			x[i] += eps;
			ComputeSystemODE1RHS(temp, f1);
			x[i] = xStore;

			epsInv = (1. / eps) * scalarFactor;

			f1 -= f0;
			f1 *= epsInv;
			jacobianGM.AddColumnVector(nODE2+i, f1, rowOffset);//add rowOffset argument to AddColumnVector(..)
		}
	}
	//pout << "ODE2jac=" << jacobian << "\n";
	//cSystemData.isODE2RHSjacobianComputation = false; //hack! only for debugging
}





//! numerical computation of constraint jacobian with respect to ODE2 and ODE1 (fillIntoSystemMatrix=true: also w.r.t. AE) coordinates
//! factorODE2 is used to scale the ODE2-part of the jacobian (to avoid postmultiplication); 
//! velocityLevel = velocityLevel constraints are used, if available; 
//! fillIntoSystemMatrix=true: fill in g_q_ODE2, g_q_ODE2^T AND g_q_AE into system matrix at according positions
//! fillIntoSystemMatrix=false: fill in g_q_ODE2 into jacobian matrix at (0,0) ???REALLY
template<class TGeneralMatrix>
void CSystem::NumericalJacobianAE(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
	Vector& f0, Vector& f1, TGeneralMatrix& jacobianGM, Real factorAE_ODE2, Real factorAE_ODE2_t, 
	bool velocityLevel, Real factorODE2_AE, Real factorAE_AE)
{
	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
	
	//DELETE: CHECKandTHROW(nODE1 == 0, "CSystem::NumericalJacobianAE: nODE1 must be zero"); //check that offsetAE is correctly added
	Index offsetAE = nODE2 + nODE1; //offset for algebraic equations in system jacobian

	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;
	Vector& x_t = cSystemData.GetCData().currentState.ODE2Coords_t; //velocity coordinates
	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation

	Vector& y = cSystemData.GetCData().currentState.ODE1Coords;
	//Vector& y_t = cSystemData.GetCData().currentState.ODE1Coords_t; //velocity coordinates
	Real yStore; //store value of y; avoid roundoff error effects in numerical differentiation


	Vector& z = cSystemData.GetCData().currentState.AECoords;
	Real zStore; //store value of x; avoid roundoff error effects in numerical differentiation

	//++++++++++++++++++++++++++++++++++++++++++++++++
	//compute total jacobian ==> very time consuming ==> change this to local jacobian (use flag in numDiffParameters?)

	if (jacobianGM.GetSystemMatrixType() != LinearSolverType::EXUdense) { CHECKandTHROWstring("CSystem::NumericalJacobianAE: only works for LinearSolverType.EXUdense; illegal LinearSolverType!"); }
	ResizableMatrix& jacobian = ((GeneralMatrixEXUdense&)jacobianGM).GetMatrixEXUdense();

	f0.SetNumberOfItems(nAE);
	f1.SetNumberOfItems(nAE);

	ComputeAlgebraicEquations(temp, f0, velocityLevel); //compute nominal value for jacobian

	//differentiation w.r.t. ODE2 coordinates
	for (Index i = 0; i < nODE2; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";

		xStore = x[i];
		x[i] += eps;
		ComputeAlgebraicEquations(temp, f1, velocityLevel);
		x[i] = xStore;

		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real x = epsInv * (f1[j] - f0[j]);
			//if (fillIntoSystemMatrix)
			//{
			jacobian(offsetAE + j, i) = factorAE_ODE2 * x; //add Cq ==> factor only used for Position constraints ...
			jacobian(i, offsetAE + j) = factorODE2_AE * x; //add CqT ==> new factor
			//}
			//else
			//{
			//	jacobian(j, i) = /*factorAE_ODE2 * */ x; //add Cq which is lateron used as transposed matrix; factor is usually 1 in this case
			//}
		}
	}

	//differentiation w.r.t. ODE2_t coordinates
	for (Index i = 0; i < nODE2; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";

		xStore = x_t[i];
		x_t[i] += eps;
		ComputeAlgebraicEquations(temp, f1, velocityLevel);
		x_t[i] = xStore;

		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real x = epsInv * (f1[j] - f0[j]);
			//if (fillIntoSystemMatrix)
			//{
			jacobian(offsetAE + j, i) += factorAE_ODE2_t * x; //add Cq ==> factor only used for Position constraints ...
			jacobian(i, offsetAE + j) += factorODE2_AE * x; //add CqT; this term MUST be added for purly velocity-formulated constraints (e.g. velocity coordinate constraint, rolling joint, ...)
			//}
			//else
			//{
			//	jacobian(j, i) += x; //add Cq which is lateron used as transposed matrix; this term MUST be added for purly velocity-formulated constraints (e.g. velocity coordinate constraint, rolling joint, ...)
			//}
		}
	}

	//differentiation w.r.t. ODE1 coordinates
	for (Index i = 0; i < nODE1; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(y[i])));
		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";

		yStore = y[i];
		y[i] += eps;
		ComputeAlgebraicEquations(temp, f1, velocityLevel);
		y[i] = yStore;

		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real y = epsInv * (f1[j] - f0[j]);

			jacobian(offsetAE + j, i+nODE2) = y; //add Cq1
			jacobian(i+nODE2, offsetAE + j) = y; //add Cq1T
		}
	}

	//differentiation w.r.t. AE coordinates
	for (Index i = 0; i < nAE; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(z[i])));

		zStore = z[i];
		z[i] += eps;
		ComputeAlgebraicEquations(temp, f1, velocityLevel);
		z[i] = zStore;
		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			jacobian(offsetAE + j, offsetAE + i) = (factorAE_AE * epsInv) * (f1[j] - f0[j]);
		}
	}
}

//the NumericalJacobianAE ... _t  is never used
////! compute numerical differentiation of AE with respect to ODE2 velocity; factor is used to scale the Jacobian; if fillIntoSystemMatrix==true, the jacobian is filled directly into the system matrix; result is a jacobian; THIS FUNCTION IS ONLY FOR COMPARISON (SLOW!!!)
//void CSystem::NumericalJacobianAE_ODE2_t(const NumericalDifferentiation& numDiff,
//	TemporaryComputationData& temp, Vector& f0, Vector& f1, ResizableMatrix& jacobian, Real factor, bool velocityLevel)
//{
//	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
//	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
//	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate
//
//	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
//	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
//	Vector& x = cSystemData.GetCData().currentState.ODE2Coords_t;
//	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation
//
//	//++++++++++++++++++++++++++++++++++++++++++++++++
//	//compute total jacobian ==> very time consuming ==> change this to local jacobian (use flag in numDiffParameters?)
//
//	f0.SetNumberOfItems(nAE);
//	f1.SetNumberOfItems(nAE);
//
//	ComputeAlgebraicEquations(temp, f0, velocityLevel); //compute nominal value for jacobian
//
//
//	for (Index i = 0; i < nODE2; i++)
//	{
//		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
//		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";
//
//		xStore = x[i];
//		x[i] += eps;
//		ComputeAlgebraicEquations(temp, f1, velocityLevel);
//		x[i] = xStore;
//
//		epsInv = 1. / eps;
//
//		for (Index j = 0; j < nAE; j++)
//		{
//			Real x = epsInv * (f1[j] - f0[j]);
//			jacobian(j, i) = factor * x; //add CqT
//			//if (fillIntoSystemMatrix)
//			//{
//			//	jacobian(nODE2 + j, i) = factor * x; //add Cq
//			//	jacobian(i, nODE2 + j) = x; //add CqT
//			//}
//			//else
//			//{
//			//	jacobian(i, j) = x; //add CqT
//			//}
//		}
//	}
//}

//!compute per-object jacobians for object j, providing TemporaryComputationData;
//! returns ltgAE and ltgODE2 lists, and several flags on object velocity level equation and which jacobian parts have been computed
//! returns true, if jacobian is available, or false if not (e.g. body or ground object)
void CSystem::ComputeObjectJacobianAE(Index j, TemporaryComputationData& temp,
	bool& objectUsesVelocityLevel, bool& flagAE_ODE2filled, bool& flagAE_ODE2_tFilled, bool& flagAE_ODE1filled, bool& flagAE_AEfilled)
{
	objectUsesVelocityLevel = false;
	CObject& object = *(cSystemData.GetCObjects()[j]);

	//Index markerType[2]; //markertypes stored; NOT USED
	flagAE_ODE2filled = false; //true, if the jacobian AE_ODE2 is inserted
	flagAE_ODE2_tFilled = false; //true, if the jacobian AE_ODE2 is inserted
	flagAE_ODE1filled = false; //true, if the jacobian AE_ODE1 is inserted
	flagAE_AEfilled = false;   //true, if the jacobian AE_AE is inserted
	Real currentTime = cSystemData.GetCData().currentState.time;

	//for body, evaluate algebraic equations directly --> depend only on body coordinates
	if ((Index)object.GetType() & (Index)CObjectType::Body)
	{
		//this is currently only used, if Euler Parameter constraints are attached to bodies (deprecated mode)
		if (object.GetAlgebraicEquationsSize()) //either body or constraint
		{
			object.ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
			if (temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0) { flagAE_ODE2filled = true; }
			if (temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0) { flagAE_ODE2_tFilled = true; }
			if (temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0) { flagAE_ODE1filled = true; }
			if (temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0) { flagAE_AEfilled = true; }
		}
	}
	//for constraint, algebraic equations depend on Markers 
	else if ((Index)object.GetType() & (Index)CObjectType::Constraint)
	{
		CObjectConstraint& constraint = (CObjectConstraint&)object;

		const bool computeJacobian = true; //why needed for PostNewtonStep?==> check Issue #241
		//STARTGLOBALTIMER(TScomputeConnectorsMarkerData);
		cSystemData.ComputeMarkerDataStructure(&constraint, computeJacobian, temp.markerDataStructure);
		//STOPGLOBALTIMER(TScomputeConnectorsMarkerData);


		if (constraint.GetAvailableJacobians() & JacobianType::AE_ODE2)
		{
			flagAE_ODE2filled = true;
			CHECKandTHROW((constraint.GetAvailableJacobians() & JacobianType::AE_ODE2_function), "CSystem::JacobianAE: jacobian AE_ODE2 not implemented");
		}
		if (constraint.GetAvailableJacobians() & JacobianType::AE_ODE2_t)
		{
			flagAE_ODE2_tFilled = true;
			CHECKandTHROW((constraint.GetAvailableJacobians() & JacobianType::AE_ODE2_t_function), "CSystem::JacobianAE: jacobian AE_ODE2_t not implemented");
		}
		if (constraint.GetAvailableJacobians() & JacobianType::AE_ODE1)
		{
			flagAE_ODE1filled = true;
			CHECKandTHROW((constraint.GetAvailableJacobians() & JacobianType::AE_ODE1_function), "CSystem::JacobianAE: jacobian AE_ODE1 not implemented");
		}
		if (constraint.GetAvailableJacobians() & JacobianType::AE_AE)
		{
			flagAE_AEfilled = true;
			CHECKandTHROW((constraint.GetAvailableJacobians() & JacobianType::AE_AE_function), "CSystem::JacobianAE: jacobian AE_AE not implemented");
		}

		if (flagAE_ODE2filled || flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled)
		{
			constraint.ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1,
				temp.localJacobianAE_AE, temp.markerDataStructure, currentTime, j);
			objectUsesVelocityLevel = constraint.UsesVelocityLevel();
			//if (constraint.UsesVelocityLevel()) {factorVelocityLevel = factorAE_ODE2_t; } //in this case, always use the velocity level factor; then, the jacobian is interpreted as diff(AE_t, ODE2_t)
		}
		//else
		//{} //FUTURE: alternatively compute numerically ==> currently only analytical computation possible!!!

	}
	else
	{
		CHECKandTHROWstring("CSystem::ComputeObjectJacobianAE(...): object type not implemented");
	}
}


//implemented directly in JacobianAE
////!compute per-node jacobians for node j, providing TemporaryComputationData;
////! the jacobian computed in according temp structure
//void CSystem::ComputeNodeJacobianAE(Index j, TemporaryComputationData& temp,
//	bool& nodeUsesVelocityLevel, bool& flagAE_ODE2filled, bool& flagAE_ODE2_tFilled, bool& flagAE_ODE1filled, bool& flagAE_AEfilled)
//{
//	nodeUsesVelocityLevel = false;
//	CNode& node = *(cSystemData.GetCNodes()[j]);
//
//	//Index markerType[2]; //markertypes stored; NOT USED
//	flagAE_ODE2filled = false; //true, if the jacobian AE_ODE2 is inserted
//	flagAE_ODE2_tFilled = false; //true, if the jacobian AE_ODE2 is inserted
//	flagAE_ODE1filled = false; //true, if the jacobian AE_ODE1 is inserted
//	flagAE_AEfilled = false;   //true, if the jacobian AE_AE is inserted
//	Real currentTime = cSystemData.GetCData().currentState.time;
//
//	if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
//	{
//		((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
//		if (temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0) { flagAE_ODE2filled = true; }
//		if (temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0) { flagAE_ODE2_tFilled = true; }
//		if (temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0) { flagAE_ODE1filled = true; }
//		if (temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0) { flagAE_AEfilled = true; }
//	}
//
//}

//! compute constraint jacobian of AE with respect to ODE2 (fillIntoSystemMatrix=true: also w.r.t. ODE1 and AE) coordinates ==> direct computation given by access functions
//! factorODE2 is used to scale the ODE2-part of the jacobian (to avoid postmultiplication); 
//! velocityLevel = velocityLevel constraints are used, if available; 
//template<class TGeneralMatrix>
//bool warnedCSystemJacobianAE = false;
void CSystem::JacobianAE(TemporaryComputationData& temp, const NewtonSettings& newton, GeneralMatrix& jacobianGM,
	Real factorAE_ODE2, Real factorAE_ODE2_t, bool velocityLevel, Real factorODE2_AE, Real factorAE_AE)
{
	//size needs to be set accordingly in the caller function; components are addd to massMatrix!

	if (newton.numericalDifferentiation.forAE)
	{
		NumericalJacobianAE(temp, newton.numericalDifferentiation, temp.numericalJacobianf0, temp.numericalJacobianf1, jacobianGM, factorAE_ODE2, factorAE_ODE2_t, velocityLevel);// , fillIntoSystemMatrix);
	}
	else
	{
		if (velocityLevel) { CHECKandTHROWstring("CSystem::JacobianAE_ODE2: velocityLevel=true not implemented"); }
		//Index nAE = cSystemData.GetNumberOfCoordinatesAE();
		Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
		Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
		
		//DELETE: CHECKandTHROW(nODE1 == 0, "CSystem::JacobianAE: nODE1 must be zero"); //check that offsetAE is correctly added
		Index offsetAE = nODE2 + nODE1; //offset for algebraic equations in system jacobian
		Real factorAE_ODE1 = 1.; //currently no scaling from integrators
		Real factorODE1_AE = 1.; //currently no scaling from integrators

		//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
		//for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
		for (Index j: cSystemData.objectsWithAlgebraicEquations)
		{
			//work over bodies, connectors, etc.
			//CObject& object = *(cSystemData.GetCObjects()[j]);
			ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[j];
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
			ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];

			bool objectUsesVelocityLevel;// = false;
			bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
			bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
			bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
			bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

			ComputeObjectJacobianAE(j, temp, objectUsesVelocityLevel, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled);

			if (flagAE_ODE2filled)
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE2, factorAE_ODE2, ltgAE, ltgODE2, offsetAE);//depends, if velocity or position level is used
			}
			if (flagAE_ODE2_tFilled) //velocity or mixed pos/vel constraints
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE2_t, factorAE_ODE2_t, ltgAE, ltgODE2, offsetAE); //depends, if velocity or position level is used 
			}

			//this is either the dC/dq or the dC_t/dq_t matrix for reaction forces ==> may only be added once for ODE2 OR ODE2_t(e.g. for non-holonomic constraints such as rolling wheel)
			if (flagAE_ODE2filled && !objectUsesVelocityLevel)
			{
				jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE2, factorODE2_AE, ltgODE2, ltgAE, 0, offsetAE); //this is the dC/dq^T part, which is independent of index reduction
			}
			else if (flagAE_ODE2_tFilled) //newly added
			{
				jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE2_t, factorODE2_AE, ltgODE2, ltgAE, 0, offsetAE); //this is the dC_t/dq_t^T part, which is independent of index reduction
			}
			//else  //for pure algebraic constraints(e.g. if joints are deactivated) this is OK! {CHECKandTHROWstring("CSystem::JacobianAE(...): constraint jacobian must be consistent with UsesVelocityLevel flag"); }

			if (flagAE_ODE1filled)
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE1, factorAE_ODE1, ltgAE, ltgODE1, nODE2);
				jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE1, factorODE1_AE, ltgODE1, ltgAE, 0, nODE2);
			}

			if (flagAE_AEfilled) //pure algebraic equations: only depend on their algebraic part ...
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_AE, factorAE_AE, ltgAE, ltgAE, offsetAE, offsetAE);
			}

		}//cSystemData.objectsWithAlgebraicEquations

		for (Index j : cSystemData.nodesODE2WithAE)
		{
			bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
			bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
			bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
			bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

			CNode& node = *(cSystemData.GetCNodes()[j]);

			if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
			{
				((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
				flagAE_ODE2filled = temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0;
				flagAE_ODE2_tFilled = temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0;
				flagAE_ODE1filled = temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0;
				flagAE_AEfilled = temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0;

				if (flagAE_ODE2filled) //must have ODE size
				{
					//jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE2, factorAE_ODE2, ltgAE, ltgODE2, offsetAE);//depends, if velocity or position level is used
					//jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE2, factorODE2_AE, ltgODE2, ltgAE, 0, offsetAE); //this is the dC/dq^T part, which is independent of index reduction

					Index rowOffset = node.GetGlobalAECoordinateIndex();
					Index columnOffset = node.GetGlobalODE2CoordinateIndex();
					jacobianGM.AddSubmatrixWithFactor(temp.localJacobianAE_ODE2, factorAE_ODE2, rowOffset + offsetAE, columnOffset);//depends, if velocity or position level is used
					jacobianGM.AddSubmatrixTransposedWithFactor(temp.localJacobianAE_ODE2, factorODE2_AE, columnOffset, rowOffset + offsetAE);
				}
				//remaining part could be integrated according to code above: for (Index j: cSystemData.objectsWithAlgebraicEquations) {...}
				CHECKandTHROW(!(flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled), "CSystem: JacobianAE(...): mode not implemented for node algebraic equations");
			}
		}//for cSystemData.nodesODE2WithAE
	}//if(newton.useNumericalDifferentiationAE)

}

//Index TSreactionForces1;
//TimerStructureRegistrator TSRreactionForces1("TSreactionForces1", TSreactionForces1, globalTimers);
//Index TSreactionForces2;
//TimerStructureRegistrator TSRreactionForces2("TSreactionForces2", TSreactionForces2, globalTimers);

//! add the projected action of Lagrange multipliers (reaction forces) to the ODE2 coordinates and add it to the ode2ReactionForces residual:
//! ode2ReactionForces += C_{q2}^T * \lambda
void CSystem::ComputeODE2ProjectedReactionForces(TemporaryComputationData& temp, const Vector& reactionForces, Vector& ode2ReactionForces)
{
	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	//Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();

	CHECKandTHROW(reactionForces.NumberOfItems() == nAE, "CSystem::ComputeODE2ProjectedReactionForces: reactionForces size mismatch!");
	CHECKandTHROW(ode2ReactionForces.NumberOfItems() == nODE2, "CSystem::ComputeODE2ProjectedReactionForces: ode2ReactionForces size mismatch!");

	//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
	//for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
	for (Index j : cSystemData.listObjectProjectedReactionForcesODE2)
	{
		//work over bodies, connectors, etc.
		ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[j];
		ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
		//ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];

		bool objectUsesVelocityLevel;// = false;
		bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
		bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

		//STARTGLOBALTIMER(TSreactionForces1);
		ComputeObjectJacobianAE(j, temp, objectUsesVelocityLevel, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled);
		//STOPGLOBALTIMER(TSreactionForces1);

		//STARTGLOBALTIMER(TSreactionForces2);
		if (flagAE_ODE2filled || flagAE_ODE2_tFilled) //otherwise, no jacobians exist
		{
			if ((flagAE_ODE2filled && !objectUsesVelocityLevel) || flagAE_ODE2_tFilled) //must be consistent
			{
				const ResizableMatrix& jac = flagAE_ODE2filled ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;

				//multiply Cq^T * lambda:
				for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
				{
					for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
					{
						ode2ReactionForces[ltgODE2[jj]] += reactionForces[ltgAE[ii]] * jac(ii, jj);  //add terms to existing residual forces
					}
				}
			}
		}
		else if (flagAE_ODE1filled)
		{
			CHECKandTHROWstring("ComputeODE2ProjectedReactionForces: not implemented for ODE1 jacobian of algebraic equations");
			
			//use following code, but add ode1ReactionForces first to function interface ...

			//const ResizableMatrix& jac = temp.localJacobianAE_ODE1;

			////multiply Cq^T * lambda:
			//for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
			//{
			//	for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
			//	{
			//		ode1ReactionForces[ltgODE1[jj]] += reactionForces[ltgAE[ii]] * jac(ii, jj);  //add terms to existing residual forces
			//	}
			//}

		}
		//STOPGLOBALTIMER(TSreactionForces2);

		//else  //for pure algebraic constraints(e.g. if joints are deactivated), no projected reaction forces ...! 
	}

	//nodes with AE: usually only Euler Parameters
	for (Index j : cSystemData.nodesODE2WithAE)
	{
		bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
		bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

		CNode& node = *(cSystemData.GetCNodes()[j]);

		if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
		{
			((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
			flagAE_ODE2filled = temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0;
			flagAE_ODE2_tFilled = temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0;
			flagAE_ODE1filled = temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0;
			flagAE_AEfilled = temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0;

			if (flagAE_ODE2filled) //must have ODE size
			{
				Index rowOffset = node.GetGlobalAECoordinateIndex();
				Index columnOffset = node.GetGlobalODE2CoordinateIndex();

				const ResizableMatrix& jac = temp.localJacobianAE_ODE2;
				for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
				{
					for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
					{
						ode2ReactionForces[columnOffset + jj] += reactionForces[rowOffset + ii] * jac(ii, jj);  //add terms to existing residual forces
					}
				}
			}
			//remaining part could be integrated according to code above: for (Index j: cSystemData.objectsWithAlgebraicEquations) {...}
			CHECKandTHROW(!(flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled), "CSystem: JacobianAE(...): mode not implemented for node algebraic equations");
		}


	}//for cSystemData.nodesODE2WithAE
}

//! compute numerically the derivative of (C_{q2} * v), v being an arbitrary vector
//! jacobianCqV = scalarFactor*d/dq2(C_{q2} * v)
void CSystem::ComputeConstraintJacobianDerivative(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff, Vector& f0, Vector& f1, 
	const Vector& v, GeneralMatrix& jacobianCqV, Real scalarFactor, Index rowOffset, Index columnOffset)
{

	//+++++++++++++++++++++++++++++++++++++++++++++++++++
	//jacobian
	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;
	//Vector& x_t = cSystemData.GetCData().currentState.ODE2Coords_t; //velocity coordinates
	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation

	//Vector& z = cSystemData.GetCData().currentState.AECoords;
	//Real zStore; //store value of x; avoid roundoff error effects in numerical differentiation

	//++++++++++++++++++++++++++++++++++++++++++++++++

	if (jacobianCqV.GetSystemMatrixType() != LinearSolverType::EXUdense) { CHECKandTHROWstring("CSystem::ComputeConstraintJacobianDerivative: illegal LinearSolverType, only possible for dense matrix!"); }
	ResizableMatrix& jacobian = ((GeneralMatrixEXUdense&)jacobianCqV).GetMatrixEXUdense();
	
	f0.SetNumberOfItems(nAE);
	f1.SetNumberOfItems(nAE);
	ComputeConstraintJacobianTimesVector(temp, v, f0);
	//pout << "f0=" << f0 << "\n";
	//bool velocityLevel = false;

	//brute force approach, done for full matrix!
	//differentiation w.r.t. ODE2 coordinates
	for (Index i = 0; i < nODE2; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));

		xStore = x[i];
		x[i] += eps;
		ComputeConstraintJacobianTimesVector(temp, v, f1);
		x[i] = xStore;
		//pout << "f1=" << f1 << "\n";

		epsInv = scalarFactor / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real x = epsInv * (f1[j] - f0[j]);
			jacobian(j + rowOffset, i + columnOffset) = x;
		}
	}

}

//! compute (C_{q2} * v), v being an arbitrary vector
void CSystem::ComputeConstraintJacobianTimesVector(TemporaryComputationData& temp, const Vector& v, Vector& result)
{
	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	//Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();

	CHECKandTHROW(v.NumberOfItems() == nODE2, "CSystem::ComputeConstraintJacobianTimesVector: v size mismatch!");
	result.SetNumberOfItems(nAE);
	result.SetAll(0.);

	//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
	for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
	{
		//work over bodies, connectors, etc.
		//CObject& object = *(cSystemData.GetCObjects()[j]);
		ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[j];
		ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];

		bool objectUsesVelocityLevel;// = false;
		bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
		bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

		if (ltgAE.NumberOfItems() && ltgODE2.NumberOfItems() && cSystemData.GetCObjects()[j]->GetAlgebraicEquationsSize()) //omit bodies and ground objects ...
		{
			ComputeObjectJacobianAE(j, temp, objectUsesVelocityLevel, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled);
			
			if (!objectUsesVelocityLevel) //for velocity constraints, only Ct_t would be needed!
			{
				if (flagAE_ODE2filled)
				{
					//ResizableMatrix& jac = flagAE_ODE2filled ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;
					const ResizableMatrix& jac = temp.localJacobianAE_ODE2;

					//multiply Cq^T * lambda:
					for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
					{
						for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
						{
							result[ltgAE[ii]] += jac(ii, jj) * v[ltgODE2[jj]];  //add terms to existing residual forces
						}
					}
				}
			}

			if (flagAE_ODE1filled) //could be just ignored ==> check as soon as first ODE1 constraint jacobian exists
			{
				STDstring str = "CSystem::ComputeConstraintJacobianTimesVector(...) : not implemented for ODE1 coordinates, objectNr = ";
				str += EXUstd::ToString(j);
				PyWarning(str);
			} 
		}
	}

	for (Index j : cSystemData.nodesODE2WithAE)
	{
		bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
		bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
		bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

		CNode& node = *(cSystemData.GetCNodes()[j]);

		if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
		{
			((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
			flagAE_ODE2filled = temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0;
			flagAE_ODE2_tFilled = temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0;
			flagAE_ODE1filled = temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0;
			flagAE_AEfilled = temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0;

			if (flagAE_ODE2filled)
			{
				//ResizableMatrix& jac = flagAE_ODE2filled ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;
				const ResizableMatrix& jac = temp.localJacobianAE_ODE2;
				Index rowOffset = node.GetGlobalAECoordinateIndex();
				Index columnOffset = node.GetGlobalODE2CoordinateIndex();

				//multiply Cq^T * lambda:
				for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
				{
					for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
					{
						result[rowOffset + ii] += jac(ii, jj) * v[columnOffset + jj];  //add terms to existing residual forces
					}
				}
			}
			//remaining part could be integrated according to code above: for (Index j: cSystemData.objectsWithAlgebraicEquations) {...}
			CHECKandTHROW(!(flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled), "CSystem: JacobianAE(...): mode not implemented for node algebraic equations");
		}
	}

}


//! this function is used to copy the current state to the visualization state and to send a signal that the PostProcessData has been updated
void CSystem::UpdatePostProcessData(bool recordImage)
{
	Index timeOut = 1000;		 //max iterations to wait, before frame is redrawn and saved
	Index timerMilliseconds = 2; //this is a hard-coded value, as visualizationSettings are not available here ...

	Index i = 0;
	//wait with new update until last image recording has been finished
	while (i++ < timeOut && (postProcessData.recordImageCounter == postProcessData.updateCounter))
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(timerMilliseconds));
	}

	if (postProcessData.recordImageCounter == postProcessData.updateCounter)
	{
		PyWarning("CSystem::UpdatePostProcessData:: timeout for record image; try to decrease scene complexity");
	}

	//use semaphores, because the postProcessData.state is also accessed from the visualization thread
	EXUstd::WaitAndLockSemaphore(postProcessData.accessState); //lock PostProcessData

	postProcessData.updateCounter++;
	postProcessData.postProcessDataReady = true;
	if (recordImage) { postProcessData.recordImageCounter = postProcessData.updateCounter; } //this is the condition to record an image

	//GetSystemData().GetCData().visualizationState = GetSystemData().GetCData().currentState; //copy current (computation step result) to post process state

	//consider this, if more visualization crashes:
	//if (GetSystemData().GetCData().visualizationState.GetODE2Coords().NumberOfItems() != GetSystemData().GetCData().currentState.GetODE2Coords().NumberOfItems() ||
	//	GetSystemData().GetCData().visualizationState.GetODE1Coords().NumberOfItems() != GetSystemData().GetCData().currentState.GetODE1Coords().NumberOfItems() ||
	//	GetSystemData().GetCData().visualizationState.GetAECoords().NumberOfItems() != GetSystemData().GetCData().currentState.GetAECoords().NumberOfItems() ||
	//	GetSystemData().GetCData().visualizationState.GetDataCoords().NumberOfItems() != GetSystemData().GetCData().currentState.GetDataCoords().NumberOfItems()
	//	)
	//{
	//	GetSystemData().GetCData().visualizationState = GetSystemData().GetCData().currentState; //make immediate, not thread-safe update, which will however guarantee that next update is working
	//}

	postProcessData.GetVisualizationStateUpdate() = GetSystemData().GetCData().currentState;
	postProcessData.SetVisualizationStateUpdateAvailable(true);

	EXUstd::ReleaseSemaphore(postProcessData.accessState); //clear PostProcessData
}
























////! compute numerical differentiation of ODE2RHS; result is a jacobian;  multiply the added entries with scalarFactor
////template<class TGeneralMatrix>
//void CSystem::NumericalJacobianODE2RHS(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
//	Vector& f0, Vector& f1, GeneralMatrix& jacobianGM, Real scalarFactor) // , ResizableMatrix& jacobian)
//{
//	//size needs to be set accordingly in the caller function; components are addd to massMatrix!
//
//	//cSystemData.isODE2RHSjacobianComputation = true; //hack, use rarely this flag or only for debug!
//
//	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
//	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
//	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate
//
//	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
//	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;			//current coordinates ==> this is what is differentiated for
//	Vector& xRef = cSystemData.GetCData().referenceState.ODE2Coords;	//reference coordinates; might be important for numerical differentiation
//	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation
//
//	if (!numDiff.doSystemWideDifferentiation)
//	{
//		ResizableMatrix& localJacobian = temp.localJacobian;
//
//		//size already set by solver: jacobian.SetNumberOfRowsAndColumns(nODE2, nODE2);
//
//		//++++++++++++++++++++++++++++++++++++++++++++++++
//
//		//for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
//		for (Index j : cSystemData.listComputeObjectODE2Lhs)
//		{
//			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
//			Index nLocalODE2 = ltgODE2.NumberOfItems();
//			f0.SetNumberOfItems(nLocalODE2);
//			f1.SetNumberOfItems(nLocalODE2);
//			CObject* object = cSystemData.GetCObjects()[j];
//
//			if (!numDiff.forODE2 && EXUstd::IsOfType(object->GetAvailableJacobians(), JacobianType::ODE2_ODE2_function))
//			{
//				//localJacobian.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE2); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
//				//temp.localJacobian_t.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE2); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
//				object->ComputeJacobianODE2_ODE2(localJacobian, temp.localJacobian_t);
//				//pout << "here\n";
//				jacobianGM.AddSubmatrix(localJacobian, -scalarFactor, ltgODE2, ltgODE2); //minus (-) because in numerical mode, f0-f1 leads to negative sign (RHS ==> LHS)
//			}
//			else if (ComputeObjectODE2LHS(temp, object, f0, j)) //check if it is a constraint, etc. which is not differentiated for ODE2 jacobian
//			{
//				localJacobian.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE2); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
//				Real xRefVal = 0;
//				for (Index i = 0; i < nLocalODE2; i++) //differentiate w.r.t. every ltgODE2 coordinate
//				{
//					Real& xVal = x[ltgODE2[i]];
//					if (numDiff.addReferenceCoordinatesToEpsilon) { xRefVal = xRef[ltgODE2[i]]; }
//
//					eps = relEps * (EXUstd::Maximum(minCoord, fabs(xVal + xRefVal)));
//
//					xStore = xVal;
//					xVal += eps;
//					ComputeObjectODE2LHS(temp, object, f1, j);
//					xVal = xStore;
//
//					epsInv = (1. / eps) * scalarFactor;
//
//					for (Index k = 0; k < nLocalODE2; k++)
//					{
//						//use local jacobian:
//						localJacobian(k, i) = epsInv * (f0[k] - f1[k]); //-(f1-f0) == (f0-f1): negative sign, because object ODE2RHS is subtracted from global RHS-vector
//					}
//				}
//				jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE2, ltgODE2);
//			}
//		}
//	}
//	else
//	{
//		//done in solver: jacobian.SetNumberOfRowsAndColumns(nODE2, nODE2);
//
//		//++++++++++++++++++++++++++++++++++++++++++++++++
//		f0.SetNumberOfItems(nODE2);
//		f1.SetNumberOfItems(nODE2);
//		ComputeSystemODE2RHS(temp, f0); //compute nominal value for jacobian
//		Real xRefVal = 0;
//
//		for (Index i = 0; i < nODE2; i++) //compute column i
//		{
//			if (numDiff.addReferenceCoordinatesToEpsilon) { xRefVal = xRef[i]; }
//			eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i] + xRefVal)));
//
//			xStore = x[i];
//			x[i] += eps;
//			ComputeSystemODE2RHS(temp, f1);
//			x[i] = xStore;
//
//			epsInv = (1. / eps) * scalarFactor;
//
//			f1 -= f0;
//			f1 *= epsInv;
//			jacobianGM.AddColumnVector(i, f1);
//		}
//	}
//	//pout << "ODE2jac=" << jacobian << "\n";
//	//cSystemData.isODE2RHSjacobianComputation = false; //hack! only for debugging
//}
//
////! compute numerical differentiation of ODE2RHS; result is a jacobian;  multiply the added entries with scalarFactor
//void CSystem::NumericalJacobianODE2RHS_t(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
//	Vector& f0, Vector& f1, GeneralMatrix& jacobianGM, Real scalarFactor)
//{
//	//size needs to be set accordingly in the caller function; components are addd to massMatrix!
//
//	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
//	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
//	Real eps, epsInv;								//coordinate(column)-wise differentiation parameter; depends on size of coordinate
//	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
//	Vector& x = cSystemData.GetCData().currentState.ODE2Coords_t;
//	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation
//
//	if (!numDiff.doSystemWideDifferentiation)
//	{
//		//size already set by solver: jacobian.SetNumberOfRowsAndColumns(nODE2, nODE2);
//
//		ResizableMatrix& localJacobian_t = temp.localJacobian_t;
//
//		//size already set by solver: jacobian.SetNumberOfRowsAndColumns(nODE2, nODE2);
//		//jacobianGM.SetAllZero(); //now done in caller function
//
//		for (Index j : cSystemData.listComputeObjectODE2Lhs)
//		{
//			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
//			Index nLocalODE2 = ltgODE2.NumberOfItems();
//			f0.SetNumberOfItems(nLocalODE2);
//			f1.SetNumberOfItems(nLocalODE2);
//			CObject* object = cSystemData.GetCObjects()[j];
//
//			if (!numDiff.forODE2 && EXUstd::IsOfType(object->GetAvailableJacobians(), JacobianType::ODE2_ODE2_t_function))
//			{
//				object->ComputeJacobianODE2_ODE2(temp.localJacobian, localJacobian_t);
//				jacobianGM.AddSubmatrix(localJacobian_t, -scalarFactor, ltgODE2, ltgODE2);//-1. because in numerical mode, f0-f1 leads to negative sign (RHS ==> LHS)
//			}
//			else if (ComputeObjectODE2LHS(temp, object, f0, j)) //check if it is a constraint, etc. which is not differentiated for ODE2 jacobian
//			{
//				localJacobian_t.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE2); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
//				for (Index i = 0; i < nLocalODE2; i++) //differentiate w.r.t. every ltgODE2 coordinate
//				{
//					Real& xVal = x[ltgODE2[i]];
//					eps = relEps * (EXUstd::Maximum(minCoord, fabs(xVal)));
//
//					xStore = xVal;
//					xVal += eps;
//					ComputeObjectODE2LHS(temp, object, f1, j);
//					xVal = xStore;
//
//					epsInv = (1. / eps) * scalarFactor;
//
//					for (Index k = 0; k < nLocalODE2; k++)
//					{
//						//use local jacobian:
//						localJacobian_t(k, i) = epsInv * (f0[k] - f1[k]); //-(f1-f0) == (f0-f1): negative sign, because object ODE2RHS is subtracted from global RHS-vector
//					}
//				}
//				jacobianGM.AddSubmatrix(localJacobian_t, 1., ltgODE2, ltgODE2);
//			}
//		}
//
//	}
//	else
//	{
//		//jacobianGM.SetAllZero(); //now done outside
//
//		f0.SetNumberOfItems(nODE2);
//		f1.SetNumberOfItems(nODE2);
//		ComputeSystemODE2RHS(temp, f0); //compute nominal value for jacobian
//
//
//		for (Index i = 0; i < nODE2; i++)
//		{
//			eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
//
//			xStore = x[i];
//			x[i] += eps;
//			ComputeSystemODE2RHS(temp, f1);
//			x[i] = xStore;
//
//			epsInv = (1. / eps) * scalarFactor;
//
//			f1 -= f0;
//			f1 *= epsInv;
//			jacobianGM.AddColumnVector(i, f1);
//		}
//	}
//	//pout << "ODE2jac_t=" << jacobian << "\n";
//}






//OLD ComputeODE2Loads:
////! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
//void CSystem::ComputeODE2Loads(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
//{
//	TemporaryComputationData& temp = tempArray[0];
//	//++++++++++++++++++++++++++++++++++++++++++++++++++
//	//compute loads ==> not needed in jacobian, except for follower loads, 
//	//  using e.g. local body coordinate system
//
//	Index nLoads = cSystemData.GetCLoads().NumberOfItems();
//	Vector3D loadVector3D(0); //initialization in order to avoid gcc warnings
//	Vector1D loadVector1D(0); //scalar loads...//initialization in order to avoid gcc warnings
//	bool loadVector1Ddefined = false; //add checks such that wrong formats would fail
//	bool loadVector3Ddefined = false; //add checks such that wrong formats would fail
//
//	Real currentTime = cSystemData.GetCData().currentState.time;
//	for (Index j = 0; j < nLoads; j++)
//	{
//		CLoad* cLoad = cSystemData.GetCLoads()[j];
//		if (cLoad->IsVector())
//		{
//			loadVector3D = cLoad->GetLoadVector(cSystemData.GetMainSystemBacklink(), currentTime);
//			loadVector3Ddefined = true;
//		}
//		else
//		{
//			loadVector1D = Vector1D(cLoad->GetLoadValue(cSystemData.GetMainSystemBacklink(), currentTime));
//			loadVector1Ddefined = true;
//		}
//
//		Index markerNumber = cLoad->GetMarkerNumber();
//		CMarker* marker = cSystemData.GetCMarkers()[markerNumber];
//		LoadType loadType = cLoad->GetType();
//
//		ArrayIndex* ltg = nullptr;	//for objects
//		Index nodeCoordinate = 99999;//initialize with arbitrary value for gcc; starting index for nodes (consecutively numbered)
//		bool applyLoad = false;		//loads are not applied to ground objects/nodes
//
//		//loads only applied to Marker::Body or Marker::Node
//		if (marker->GetType() & Marker::Body) //code for body markers
//		{
//			Index markerBodyNumber = marker->GetObjectNumber();
//			if (!((Index)cSystemData.GetCObjectBody(markerBodyNumber).GetType() & (Index)CObjectType::Ground)) //no action on ground objects!
//			{
//				ltg = &cSystemData.GetLocalToGlobalODE2()[markerBodyNumber];
//				if (ltg->NumberOfItems() != 0) { applyLoad = true; } //only apply load, if object is not attached to ground node!
//			}
//		}
//		else if (marker->GetType() & Marker::Node) //code for body markers
//		{
//			Index markerNodeNumber = marker->GetNodeNumber();
//			if (!cSystemData.GetCNodes()[markerNodeNumber]->IsGroundNode()) //if node has zero coordinates ==> ground node; no action on ground nodes!
//			{
//				if (((marker->GetType() & Marker::Position) || (marker->GetType() & Marker::Coordinate)) && !(marker->GetType() & Marker::ODE1))
//				{
//					nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE2CoordinateIndex();
//					applyLoad = true;
//				}
//				else if (EXUstd::IsOfType((Index)marker->GetType(), Marker::Coordinate + Marker::ODE1))
//				{
//					applyLoad = false; //belongs to ODE1 coordinates, but valid load
//				}
//				else
//				{
//					CHECKandTHROWstring("ERROR: CSystem::ComputeSystemODE2RHS, marker type not implemented!");
//				}
//			}
//		}
//		else { pout << "ERROR: CSystem::ComputeSystemODE2RHS: marker must be Body or Node type\n"; }
//
//		if (applyLoad)
//		{
//			//AccessFunctionType aft = GetAccessFunctionType(loadType, marker->GetType());
//			//==> lateron: depending on AccessFunctionType compute jacobians, put into markerDataStructure as in connectors
//			//    and call according jacobian function
//			//    marker->GetAccessFunctionJacobian(AccessFunctionType, ...) ==> handles automatically the jacobian
//			Real loadFactor = solverData.loadFactor; //copy
//			if (cLoad->HasUserFunction())
//			{
//				loadFactor = 1.; //loadFactor not used for case of user functions, see issue #603
//			}
//
//			//bodyFixed (local) follower loads:
//			bool bodyFixed = false;
//			if (cLoad->IsBodyFixed())
//			{
//				bodyFixed = true;
//			}
//
//			if (loadType == LoadType::Force || loadType == LoadType::ForcePerMass)
//			{
//				const bool computeJacobian = true;
//				CHECKandTHROW(loadVector3Ddefined, "ComputeLoads(...): illegal force vector format (expected 3D load)");
//				//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
//				marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
//				//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
//				if (bodyFixed) { loadVector3D = temp.markerDataStructure.GetMarkerData(0).orientation * loadVector3D; }
//				EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).positionJacobian, loadVector3D, temp.generalizedLoad); //generalized load: Q = (dPos/dq)^T * Force
//
//				//marker->GetPositionJacobian(cSystemData, temp.loadJacobian);
//				//EXUmath::MultMatrixVector(temp.loadJacobian, loadVector3D, temp.generalizedLoad);
//			}
//			else if (loadType == LoadType::Torque)
//			{
//				const bool computeJacobian = true;
//				CHECKandTHROW(loadVector3Ddefined, "ComputeLoads(...): illegal force vector format (expected 3D torque)");
//				//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
//				marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
//				//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
//				if (bodyFixed) { loadVector3D = temp.markerDataStructure.GetMarkerData(0).orientation * loadVector3D; }
//				EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).rotationJacobian, loadVector3D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
//				//pout << "rotationJacobian=" << temp.markerDataStructure.GetMarkerData(0).rotationJacobian << "\n";
//				//pout << "loadVector3D=" << loadVector3D << "\n";
//			}
//			else if (loadType == LoadType::Coordinate)
//			{
//				const bool computeJacobian = true;
//				CHECKandTHROW(loadVector1Ddefined, "ComputeLoads(...): illegal force vector format (expected 1D load)");
//				//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
//				marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
//				//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
//				EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).jacobian, loadVector1D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
//				//pout << "jacobian=" << temp.markerDataStructure.GetMarkerData(0).jacobian << "\n";
//				//pout << "generalizedLoad=" << temp.generalizedLoad << "\n";
//				//pout << "loadVector1D=" << loadVector1D << "\n";
//			}
//			else { CHECKandTHROWstring("ERROR: CSystem::ComputeSystemODE2RHS, LoadType not implemented!"); }
//
//			//ResizableArray<CObject*>& objectList = cSystemData.GetCObjects();
//			//pout << "genLoad=" << temp.generalizedLoad << "\n";
//
//			if (ltg != nullptr) //must be object
//			{
//				for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
//				{
//					systemODE2Rhs[(*ltg)[k]] += loadFactor * temp.generalizedLoad[k];
//				}
//			}
//			else //must be node
//			{
//				//pout << "  nodeCoordinate=" << nodeCoordinate << "\n";
//				for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
//				{
//					systemODE2Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
//				}
//
//			}
//		}
//
//	}
//}
