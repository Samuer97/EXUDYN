/** ***********************************************************************************************
* @brief		Implementation of CSystem
*
* @author		Gerstmayr Johannes
* @date			2019-04-18 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

//++++++++++++++++ 
#include <iostream>
#include <chrono>
#include <thread>
//++++++++++++++++

#include <functional>					//for std::invoke
#include "Main/CSystemData.h"			//Basics, Vector/Array, OutputVariable, CData, Material, Body, Node, Marker, Load
#include "Main/CSystem.h"	

#include "Main/MainSystem.h"
#include "Linalg/LinearSolver.h" //for GeneralMatrixEXUdense
#include "Linalg/MatrixContainer.h" //for GeneralMatrixEXUdense
#include "Main/OutputVariable.h" //for GeneralMatrixEXUdense
#include "Autogenerated/CSensorSuperElement.h" //for sensor integrity checks
#include "Autogenerated/CSensorUserFunction.h" //for sensor integrity checks
//#include "Autogenerated/CSensorMarker.h" //for sensor integrity checks

#include "Utilities/TimerStructure.h" //for local CPU time measurement
#include "Main/rendererPythonInterface.h" //for regular call to PyExecuteQueue(...)

#include "Utilities/Parallel.h" //include after 

//#include "Utilities/AutomaticDifferentiation.h"
//#include "Utilities/AdvancedMath.h"
#include "Utilities/Differentiation.h" //include after 


//! Prepare a newly created System of nodes, objects, loads, ... for computation
void CSystem::Assemble(const MainSystem& mainSystem)
{
	globalTimers.Reset(); //timers already used by finalize contact ...
	for (CObject* object : cSystemData.GetCObjects())
	{
		object->PreAssemble();
	}
	//pout << "++++++++++++++++\nCheckSystemIntegrity ...\n";
	if (CheckSystemIntegrity(mainSystem)) //checks prior to Assemble() ==> after Assemble(), everything shall be ok.
	{
		//pout << "                        ... ok\n";
		AssembleCoordinates(mainSystem);
		AssembleLTGLists(mainSystem);
		AssembleInitializeSystemCoordinates(mainSystem); //mainSystem needed for initial displacements
		AssembleSystemInitialize(mainSystem);

		//now system is consistent and can safely be drawn
		SetSystemIsConsistent(true);
		postProcessData.postProcessDataReady = true;
		//cSystemData.isODE2RHSjacobianComputation = false; //hack
	}
	else
	{
		SetSystemIsConsistent(false);
	}
	for (CObject* object : cSystemData.GetCObjects())
	{
		object->PostAssemble();
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! Check if all references are valid (body->node number, marker->body/nodenumber, load->marker, etc.);
//  Function is called before 
bool CSystem::CheckSystemIntegrity(const MainSystem& mainSystem)
{
	//check that MarkerNodeCoordinate has a valid coordinate
	//check that initial values for generic nodes are consistent (e.g. NodeGenericData)
	//general check for length of initial coordinate (and time derivatives) is correct is checked in AssembleInitializeSystemCoordinates()
	//add CheckSystemIntegrity function to all MainItems?

	STDstring errorString;
	Index itemIndex;
	bool systemIsInteger = true;

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Index numberOfNodes = mainSystem.GetMainSystemData().GetMainNodes().NumberOfItems();
	Index numberOfObjects = mainSystem.GetMainSystemData().GetMainObjects().NumberOfItems();
	Index numberOfMarkers = mainSystem.GetMainSystemData().GetMainMarkers().NumberOfItems();
	Index numberOfLoads = mainSystem.GetMainSystemData().GetMainLoads().NumberOfItems();
	Index numberOfSensors = mainSystem.GetMainSystemData().GetMainSensors().NumberOfItems();

	itemIndex = 0;
	for (MainNode* mainNode : mainSystem.GetMainSystemData().GetMainNodes())
	{
		CNode* node = mainNode->GetCNode();
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			Index numberOfCoordinates = node->GetNumberOfODE2Coordinates();
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialCoordinateVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial displacement coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialCoordinateVector().NumberOfItems()) + ") != number of nodal ODE2 coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}

				if (numberOfCoordinates != mainNode->GetInitialCoordinateVector_t().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial velocity coordinate vector (" +
						EXUstd::ToString(mainNode->GetInitialCoordinateVector_t().NumberOfItems()) + ") != number of nodal ODE2 coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE1variables)
		{
			Index numberOfCoordinates = node->GetNumberOfODE1Coordinates();
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialCoordinateVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialCoordinateVector().NumberOfItems()) + ") != number of nodal ODE1 coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables)
		{
			Index numberOfCoordinates = node->GetNumberOfDataCoordinates();
			if (numberOfCoordinates)
			{
				if (numberOfCoordinates != mainNode->GetInitialCoordinateVector().NumberOfItems()) {
					PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial coordinates vector (" +
						EXUstd::ToString(mainNode->GetInitialCoordinateVector().NumberOfItems()) + ") != number of nodal Data coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
					systemIsInteger = false;
				}
			}
		}
		//2022-08-12: this code could not be reached so far; better delete; initial coordinates should only be used for
		//ODE2 or ODE1 coordinates, or Data variables; in mixed case ODE2+AE, only ODE2 get initial values; in ODE2+Data case, it should be similar?
		//else // mixed ODE1, ODE2 and/or AE variables
		//{
		//	Index numberOfCoordinates = node->GetNumberOfAccessibleCoordinates(); //ODE2+ODE1+AE
		//	if (numberOfCoordinates)
		//	{
		//		if (numberOfCoordinates != mainNode->GetInitialCoordinateVector().NumberOfItems()) {
		//			PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + " '" + mainNode->GetName() + "'" + "(type=" + mainNode->GetTypeName() + ") has inconsistent size of initial coordinates vector (" +
		//				EXUstd::ToString(mainNode->GetInitialCoordinateVector().NumberOfItems()) + ") != number of nodal coordinates (" + EXUstd::ToString(numberOfCoordinates) + ")");
		//			systemIsInteger = false;
		//		}
		//	}
		//}
		itemIndex++;
	}
	if (!systemIsInteger) { return false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid node numbers (objects)
	//check for valid marker numbers in connectors
	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainObjects())
	{
		//GetRequestedNodeType() must be implemented for all objects with nodes
		for (Index i = 0; i < item->GetCObject()->GetNumberOfNodes(); i++)
		{
			Index nodeItemIndex = item->GetCObject()->GetNodeNumber(i);
			if (!EXUstd::IndexIsInRange(nodeItemIndex, 0, numberOfNodes))
			{
				PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local node " +
					EXUstd::ToString(i) + " contains invalid (global) node number " + EXUstd::ToString(nodeItemIndex));
				systemIsInteger = false;
			}
			else //check if right nodeTypes are used
			{
				CNode* cNode = mainSystem.GetMainSystemData().GetMainNodes()[nodeItemIndex]->GetCNode();
				//if ((item->GetRequestedNodeType() & cNode->GetType()) != item->GetRequestedNodeType())
				if (!EXUstd::IsOfType(cNode->GetType(), item->GetRequestedNodeType()))
				{
					PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local node " +
						EXUstd::ToString(i) + " (global index = " + EXUstd::ToString(nodeItemIndex) + ")" +
						" contains invalid node type " + Node::GetTypeString(cNode->GetType()) +
						" while the requested node type was '" + Node::GetTypeString(item->GetRequestedNodeType()) + "'");
					systemIsInteger = false;
				}
			}
		}

		if ((Index)item->GetCObject()->GetType() & (Index)CObjectType::Connector)
		{
			CObjectConnector* connector = (CObjectConnector*)item->GetCObject();
			if (connector->RequestedNumberOfMarkers() != 0 && connector->GetMarkerNumbers().NumberOfItems() != connector->RequestedNumberOfMarkers())
			{
				PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + 
					" must have " + EXUstd::ToString(connector->RequestedNumberOfMarkers()) + " markers, but got " + EXUstd::ToString(connector->GetMarkerNumbers().NumberOfItems()) + " markers");
				systemIsInteger = false;
			}
			else
			{
				if (connector->GetMarkerNumbers().NumberOfItems() == 2) //check only performed for 2 markers; otherwise, user needs to take care of that!
				{
					if (connector->GetMarkerNumbers()[0] == connector->GetMarkerNumbers()[1])
					{
						PyWarning(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + ", contains two identical markers");
					}
				}
				for (Index i = 0; i < connector->GetMarkerNumbers().NumberOfItems(); i++)
				{
					Index markerItemIndex = connector->GetMarkerNumbers()[i];
					if (!EXUstd::IndexIsInRange(markerItemIndex, 0, numberOfMarkers))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local marker " +
							EXUstd::ToString(i) + " contains invalid (global) marker number " + EXUstd::ToString(markerItemIndex));
						systemIsInteger = false;
					}
					else
					{
						//now check Marker::Type flags
						CMarker* marker = mainSystem.GetMainSystemData().GetMainMarkers()[markerItemIndex]->GetCMarker();
						if ((connector->GetRequestedMarkerType() & marker->GetType()) != connector->GetRequestedMarkerType()) //marker must contain all requested flags
						{
							PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + ", local marker " +
								EXUstd::ToString(i) + " contains marker with invalid type '" + Marker::GetTypeString(marker->GetType()) +
								"', but expected marker type '" + Marker::GetTypeString(connector->GetRequestedMarkerType()) + "'");
							systemIsInteger = false;
						}
					}
				}
				if ((Index)item->GetCObject()->GetType() & (Index)CObjectType::Constraint)
				{
					if (((connector->GetAvailableJacobians() & JacobianType::AE_ODE2) != 0) != ((connector->GetAvailableJacobians() & JacobianType::AE_ODE2_function) != 0))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							": Internal error: connector JacobianType::AE_ODE2 must be consistent with JacobianType::AE_ODE2_function");
						systemIsInteger = false;
					}
					if (((connector->GetAvailableJacobians() & JacobianType::AE_ODE2_t) != 0) != ((connector->GetAvailableJacobians() & JacobianType::AE_ODE2_t_function) != 0))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							": Internal error: connector JacobianType::AE_ODE2_t must be consistent with JacobianType::AE_ODE2_t_function");
						systemIsInteger = false;
					}
					if (((connector->GetAvailableJacobians() & JacobianType::AE_ODE1) != 0) != ((connector->GetAvailableJacobians() & JacobianType::AE_ODE1_function) != 0))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							": Internal error: connector JacobianType::AE_ODE1 must be consistent with JacobianType::AE_ODE1_function");
						systemIsInteger = false;
					}
					if (((connector->GetAvailableJacobians() & JacobianType::AE_AE) != 0) != ((connector->GetAvailableJacobians() & JacobianType::AE_AE_function) != 0))
					{
						PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							": Internal error: connector JacobianType::AE_AE must be consistent with JacobianType::AE_AE_function");
						systemIsInteger = false;
					}
				}
			}

		}


		itemIndex++;
	}


	if (!systemIsInteger) { return false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid node/object numbers in markers; special markers can contain node+body!
	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainMarkers())
	{
		if (item->GetCMarker()->GetType() & Marker::Node)
		{
			Index nodeIndex = item->GetCMarker()->GetNodeNumber();
			if (!EXUstd::IndexIsInRange(nodeIndex, 0, numberOfNodes))
			{
				PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + 
					", contains invalid (global) node number " + EXUstd::ToString(nodeIndex));
				systemIsInteger = false;
			}
			if (systemIsInteger)
			{
				const CNode* node = mainSystem.GetMainSystemData().GetMainNode(nodeIndex).GetCNode();
				Node::Type nodeType = node->GetType();
				Marker::Type markerType = item->GetCMarker()->GetType();
				if (EXUstd::IsOfType(markerType, Marker::Position))
				{
					if (!EXUstd::IsOfType(nodeType, Node::Position) && !EXUstd::IsOfType(nodeType, Node::Position2D))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires a node with type Position or Position2D, but node number " + EXUstd::ToString(nodeIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
				if (EXUstd::IsOfType(markerType, Marker::Orientation))
				{
					if (!EXUstd::IsOfType(nodeType, Node::Orientation) && !EXUstd::IsOfType(nodeType, Node::Orientation2D))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires a node with type Orientation or Orientation2D, but node number " + EXUstd::ToString(nodeIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
			}
		}
		//else //must be object (usually body, but could also be connector)
		if (item->GetCMarker()->GetType() & Marker::Object) //might also be Marker::Body
		{
			Index objectIndex = item->GetCMarker()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(objectIndex, 0, numberOfObjects))
			{
				PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
					", contains invalid (global) object number " + EXUstd::ToString(objectIndex));
				systemIsInteger = false;
			}
			if (systemIsConsistent)
			{
				if (((Index)mainSystem.GetMainSystemData().GetMainObjects()[objectIndex]->GetCObject()->GetType() & (Index)CObjectType::Body) == 0)
				{
					PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
						": expected ObjectType::Body, but received object (object number=" + EXUstd::ToString(objectIndex) + ")");
					systemIsInteger = false;
				}
			}
			if (systemIsInteger)
			{
				const CObject* object = mainSystem.GetMainSystemData().GetMainObjects()[objectIndex]->GetCObject();
				AccessFunctionType afType = object->GetAccessFunctionTypes();
				Marker::Type markerType = item->GetCMarker()->GetType();
				if (EXUstd::IsOfType(markerType, Marker::Position))
				{
					if (!EXUstd::IsOfType(afType, AccessFunctionType::TranslationalVelocity_qt))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires an object with position information, but object number " + EXUstd::ToString(objectIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
				if (EXUstd::IsOfType(markerType, Marker::Orientation))
				{
					if (!EXUstd::IsOfType(afType, AccessFunctionType::AngularVelocity_qt))
					{
						PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
							" requires an object with orienation (rotation) information, but object number " + EXUstd::ToString(itemIndex) + " does not provide this");
						systemIsInteger = false;
					}
				}
			}
		}
		itemIndex++;
	}


	if (!systemIsInteger) { return false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid marker numbers in loads; check requested MarkerType; 
	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainLoads())
	{
		Index markerIndex = item->GetCLoad()->GetMarkerNumber();

		if (!EXUstd::IndexIsInRange(markerIndex, 0, numberOfMarkers))
		{
			PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() + 
				", contains invalid marker number " + EXUstd::ToString(markerIndex));
			systemIsInteger = false;
		}
		
		if (systemIsInteger) //only if markerNumber is valid
		{
			Marker::Type requestedType = item->GetCLoad()->GetRequestedMarkerType();
			Marker::Type markerType = mainSystem.GetMainSystemData().GetMainMarkers()[markerIndex]->GetCMarker()->GetType();
			if ((requestedType & markerType) != requestedType)
			{
				PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
					", contains marker with invalid type '" + Marker::GetTypeString(markerType) +
					"', but expected marker type '" + Marker::GetTypeString(requestedType) + "'");
				systemIsInteger = false;
			}
		}
		if (systemIsInteger) //only if markerNumber is valid
		{
			CLoad* cLoad = item->GetCLoad();

			if (cLoad->IsBodyFixed() && ((mainSystem.GetCSystem()->GetSystemData().GetCMarker(cLoad->GetMarkerNumber()).GetType() & Marker::Orientation) == 0))
			{
				PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type=" + item->GetTypeName() +
					": marker (marker number = " + EXUstd::ToString(cLoad->GetMarkerNumber()) + 
					") must provide orientation (e.g. RigidBody marker) in case that bodyFixed == True");
				systemIsInteger = false;
			}
		}

		itemIndex++;
	}

	if (!systemIsInteger) { return false; } //avoid crashes due to further checks!

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//check for valid sensors: valid node/object/... numbers and valid OutputVariableTypes

	itemIndex = 0;
	for (auto* item : mainSystem.GetMainSystemData().GetMainSensors())
	{
		if (item->GetCSensor()->GetType() == SensorType::Node)
		{
			Index n = item->GetCSensor()->GetNodeNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfNodes))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Node, contains invalid node number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Object)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + 
					"', type = SensorType::Object, contains invalid object number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Body)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Body, contains invalid object number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::SuperElement)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::SuperElement, contains invalid object number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::KinematicTree)
		{
			Index n = item->GetCSensor()->GetObjectNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfObjects))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::KinematicTree, contains invalid object number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Marker)
		{
			Index n = item->GetCSensor()->GetMarkerNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfMarkers))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Marker, contains invalid marker number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::Load)
		{
			Index n = item->GetCSensor()->GetLoadNumber();
			if (!EXUstd::IndexIsInRange(n, 0, numberOfLoads))
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::Load, contains invalid load number " + EXUstd::ToString(n));
			}
		}
		else if (item->GetCSensor()->GetType() == SensorType::UserFunction)
		{
			const CSensorUserFunction& sensorUserFunction = (const CSensorUserFunction&)(*item->GetCSensor());
			if (sensorUserFunction.GetParameters().sensorUserFunction == 0)
			{
				PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() + "', type = SensorType::UserFunction, contains empty user function");
			}
			for (Index m : sensorUserFunction.GetParameters().sensorNumbers)
			{
				if (!EXUstd::IndexIsInRange(m, 0, numberOfSensors))
				{
					PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + ", name = '" + item->GetName() +
						"', type = SensorType::UserFunction: local sensor number " + EXUstd::ToString(m) + " is invalid");
				}
			}
		}
		else
		{
			PyWarning("CheckSystemIntegrity: sensor type not implemented");
		}

		itemIndex++;
	}
	if (!systemIsInteger) { return false; } //avoid crashes due to further checks!

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++
	//now do object-specific checks!
	itemIndex = 0;
	for (MainNode* item : mainSystem.GetMainSystemData().GetMainNodes())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Node ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}

	itemIndex = 0;
	for (MainObject* item : mainSystem.GetMainSystemData().GetMainObjects())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Object ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}

	itemIndex = 0;
	for (MainMarker* item : mainSystem.GetMainSystemData().GetMainMarkers())
	{
		if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
		{
			PyError(STDstring("Marker ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
			systemIsInteger = false;
		}
		itemIndex++;
	}

    itemIndex = 0;
    for (MainLoad* item : mainSystem.GetMainSystemData().GetMainLoads())
    {
        if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
        {
            PyError(STDstring("Load ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
            systemIsInteger = false;
        }
        itemIndex++;
    }

    itemIndex = 0;
    for (MainSensor* item : mainSystem.GetMainSystemData().GetMainSensors())
    {
        if (!item->CheckPreAssembleConsistency(mainSystem, errorString))
        {
            PyError(STDstring("Sensor ") + EXUstd::ToString(itemIndex) + STDstring(" contains inconsistent data:\n") + errorString);
            systemIsInteger = false;
        }
        itemIndex++;
    }


	return systemIsInteger;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! assign coordinate numbers to nodes; LATER: prepare LinkedDataVectors (of coordinates) for nodes
void CSystem::AssembleCoordinates(const MainSystem& mainSystem)
{
	//pout << "Assemble nodes:\n";

	//make global node_DOF lists
	Index globalODE2Index = 0;
	Index globalODE1Index = 0;
	Index globalAEIndex = 0;
	Index globalDataIndex = 0;

	//+++++++++++++++++++++++++++
	//process nodes:
	Index node_ind = 0;
	for (CNode* node : cSystemData.GetCNodes())
	{
		//pout << "Assembling node " << node_ind << "\n";
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			//pout << "  NodeODE2 found\n";
			node->SetGlobalODE2CoordinateIndex(globalODE2Index); //use current index
			globalODE2Index += node->GetNumberOfODE2Coordinates(); //add counter in order to track number of ODE2-coordinates
			//pout << "  number of coordinates = " << node->GetNumberOfODE2Coordinates() << "\n";

			if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::AEvariables) //nodes might contain algebraic variables in addition to ODE-coordinates, e.g. Euler parameters
			{
				node->SetGlobalAECoordinateIndex(globalAEIndex); //use current index
				globalAEIndex += node->GetNumberOfAECoordinates(); //add counter in order to track number of AE-coordinates
			}

		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE1variables)
		{
			node->SetGlobalODE1CoordinateIndex(globalODE1Index); //use current index
			globalODE1Index += node->GetNumberOfODE1Coordinates(); //add counter in order to track number of ODE1-coordinates
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::AEvariables) //nodes might contain algebraic variables
		{
			node->SetGlobalAECoordinateIndex(globalAEIndex); //use current index
			globalAEIndex += node->GetNumberOfAECoordinates(); //add counter in order to track number of AE-coordinates
		}
		else if (!((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables) )
		{ CHECKandTHROWstring("CSystem::Assemble(): invalid node type!"); }

		//data coordinates can be present even in case of other variables!
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables) //
		{
			node->SetGlobalDataCoordinateIndex(globalDataIndex); //use current index
			globalDataIndex += node->GetNumberOfDataCoordinates(); //add counter in order to track number of Data-coordinates
		}

		node_ind++;
	}

	//+++++++++++++++++++++++++++
	//process constraints:
	for (CObject* object : cSystemData.GetCObjects())
	{
		if ((Index)object->GetType() & (Index)CObjectType::Constraint) //only constraints have algebraic variables not linked to nodes
		{
			CObjectConstraint* constraint = (CObjectConstraint*)object;

			constraint->SetGlobalAECoordinateIndex(globalAEIndex);
			//add counter in order to track number of AE-coordinates
			globalAEIndex += constraint->GetAlgebraicEquationsSize(); //number of Lagrange multipliers equals number of algebraic equations
		}
	}

	cSystemData.GetNumberOfCoordinatesODE2() = globalODE2Index;
	cSystemData.GetNumberOfCoordinatesODE1() = globalODE1Index;
	cSystemData.GetNumberOfCoordinatesAE() = globalAEIndex;
	cSystemData.GetNumberOfCoordinatesData() = globalDataIndex;
	//pout << "global ODE2 coordinates = " << globalODE2Index << "\n";
	//pout << "global ODE1 coordinates = " << globalODE1Index << "\n";
	//pout << "global AE coordinates = " << globalAEIndex << "\n";
	//pout << "global Data coordinates = " << globalDataIndex << "\n";
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! build ltg-coordinate lists for objects (used to build system ODE2RHS, MassMatrix, etc. vectors and matrices) 
//! and store special object lists (body, connector, constraint, ...)
void CSystem::AssembleLTGLists(const MainSystem& mainSystem)
{
	//pout << "Assemble LTG Lists\n";

	//build system-wide local to global lists for objects:
	ObjectContainer<ArrayIndex>& listODE2 = cSystemData.GetLocalToGlobalODE2();
	ObjectContainer<ArrayIndex>& listODE1 = cSystemData.GetLocalToGlobalODE1();
	ObjectContainer<ArrayIndex>& listAE = cSystemData.GetLocalToGlobalAE();
	ObjectContainer<ArrayIndex>& listData = cSystemData.GetLocalToGlobalData();
	listODE2.Flush();
	listODE1.Flush();
	listAE.Flush();
	listData.Flush();

	ObjectContainer<ArrayIndex>& listODE2numDiff = cSystemData.GetLocalToGlobalODE2NumDiff();
	listODE2numDiff.Flush();

    //reset load dependencies :
    cSystemData.GetLoadsODE2dependencies().Flush();
    cSystemData.GetLoadsODE1dependencies().Flush();
    cSystemData.GetLoadsAEdependencies().Flush();
    cSystemData.LoadsDependenciesInitialized() = false;

	//temporary lists per object:
	ArrayIndex ltgListODE2;
	ArrayIndex ltgListODE1;
	ArrayIndex ltgListAE;
	ArrayIndex ltgListData;

	ArrayIndex ltgListODE2numDiff;

	//compute localToGlobalODE2 coordinate indices
	for (Index i = 0; i < cSystemData.GetCObjects().NumberOfItems(); i++)
	{
		AssembleObjectLTGLists(i, ltgListODE2, ltgListODE1, ltgListAE, ltgListData);

		listODE2.Append(ltgListODE2);
		listODE1.Append(ltgListODE1);
		listAE.Append(ltgListAE);
		listData.Append(ltgListData);

		//check for duplicates in ODE2 lists (other lists may have problems as well; AE does not use numDiff, so it is safe; ODE1 needs to be checked as well)
		ltgListODE2numDiff = ltgListODE2;
		EXUstd::QuickSort(ltgListODE2numDiff); //additional overhead, but should not be too time critical!
		ltgListODE2.SetNumberOfItems(0); //new list without duplicates

		//first item always added
		if (ltgListODE2numDiff.NumberOfItems() != 0) { ltgListODE2.Append(ltgListODE2numDiff[0]); }

		//add only non-duplicates:
		for (Index j = 1; j < ltgListODE2numDiff.NumberOfItems(); j++)
		{
			if (ltgListODE2numDiff[j] != ltgListODE2numDiff[j - 1])
			{
				ltgListODE2.Append(ltgListODE2numDiff[j]);
			}
		}
		//if (ltgListODE2numDiff.NumberOfItems() != ltgListODE2.NumberOfItems())
		//{
		//	pout << "object " << i << ": ltgListODE2=" << ltgListODE2 << ": ltgListODE2numDiff=" << ltgListODE2numDiff << "\n";
		//}
		listODE2numDiff.Append(ltgListODE2);
	}
	//pout << "local to global ODE2 Indices:\n" << listODE2 << "\n\n";
	//pout << "local to global ODE1 Indices:\n" << listODE1 << "\n\n";
	//pout << "local to global AE Indices:\n" << listAE << "\n\n";
	//pout << "local to global Data Indices:\n" << listData << "\n\n";

	PreComputeItemLists();
	InitLieGroupLists();
}


//! build ltg-coordinate lists for object with 'objectIndex' and set indices in ltg lists
void CSystem::AssembleObjectLTGLists(Index objectIndex, ArrayIndex& ltgListODE2, ArrayIndex& ltgListODE1,
	ArrayIndex& ltgListAE, ArrayIndex& ltgListData)
{
	ltgListODE2.SetNumberOfItems(0);
	ltgListODE1.SetNumberOfItems(0);
	ltgListAE.SetNumberOfItems(0);
	ltgListData.SetNumberOfItems(0);

	CObject* object = cSystemData.GetCObjects()[objectIndex];

	//body not necessary here, works for all objects: if ((Index)object->GetType() & (Index)CObjectType::Body) //single and multinoded objects
	if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
	{
		//CObjectBody* objectBody = (CObjectBody*)object;

		//bool algebraicEquationsInNodes = false;
		//node-based elements (bodies, finite elements, ...)
		//for (Index nodeNumber : objectBody->GetCNode())
		for (Index j = 0; j < object->GetNumberOfNodes(); j++)
		{
			CNode* node = object->GetCNode(j);
			if (node->GetNumberOfODE2Coordinates())
			{
				Index gIndex = node->GetGlobalODE2CoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfODE2Coordinates(); i++)
				{
					ltgListODE2.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfODE1Coordinates())
			{
				Index gIndex = node->GetGlobalODE1CoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfODE1Coordinates(); i++)
				{
					ltgListODE1.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfAECoordinates()) //this is for algebraic nodes (e.g. Euler Parameters); but constraint equation handled by node!
			{
				Index gIndex = node->GetGlobalAECoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfAECoordinates(); i++)
				{
					ltgListAE.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfDataCoordinates()) //data/history variables - contact, friction, plasticity
			{
				Index gIndex = node->GetGlobalDataCoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfDataCoordinates(); i++)
				{
					ltgListData.Append(gIndex + i);
				}
			}
		}
	}
	else
	{
		CObjectConnector* connector = (CObjectConnector*)object;

		//connector may also contain Data nodes
		for (Index j = 0; j < connector->GetNumberOfNodes(); j++)
		{
			CNode* node = connector->GetCNode(j);
			if (node->GetNumberOfDataCoordinates()) //data/history variables - contact, friction, plasticity
			{
				Index gIndex = node->GetGlobalDataCoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfDataCoordinates(); i++)
				{
					ltgListData.Append(gIndex + i);
				}
			}
			if (node->GetNumberOfODE1Coordinates()) //controller: integrator; generic object with ODE1 coordinates
			{
				Index gIndex = node->GetGlobalODE1CoordinateIndex();
				for (Index i = 0; i < node->GetNumberOfODE1Coordinates(); i++)
				{
					ltgListODE1.Append(gIndex + i);
				}
			}
		}

		//+++++++++++++++++++++++++++++++++++++++
		//process markers --> they have associated coordinates
		for (Index markerNumber : connector->GetMarkerNumbers())
		{
			cSystemData.ComputeMarkerODE2LTGarray(markerNumber, ltgListODE2, false);

			cSystemData.ComputeMarkerODE1DataLTGarray(markerNumber, ltgListODE1, ltgListData, false);
		}

		//+++++++++++++++++++++++++++++++++++++++
		//now process algebraic equations of connector (algebraic variables are treated earlier!)
		//this is because LAGRANGE MULTIPLIERS DO NOT REQUIRE NODES
		if ((Index)object->GetType() & (Index)CObjectType::Constraint)
		{
			CObjectConstraint* constraint = (CObjectConstraint*)object;
			//build ltg-list directly from connector

			Index gIndex = constraint->GetGlobalAECoordinateIndex();
			for (Index i = 0; i < constraint->GetAlgebraicEquationsSize(); i++)
			{
				ltgListAE.Append(gIndex + i);
			}
		}
	}
	//else
	//{
	//	pout << "ERROR: ObjectType Nr. " << (Index)object->GetType() << " not implemented in CSystem::AssembleLTGLists!\n";
	//}

	//pout << "ltgODE1=" << ltgListODE1 << "\n";
	//pout << "ltgAE=" << ltgListAE << "\n";
}

//! precompute item lists (special lists for constraints, connectors, etc.)
void CSystem::PreComputeItemLists()
{
	cSystemData.objectsBodyWithODE2Coords.Flush();
	cSystemData.objectsBodyWithODE2CoordsUF.Flush();
	cSystemData.objectsBodyWithODE2CoordsNoUF.Flush();
	cSystemData.listComputeObjectODE2Lhs.Flush();
	cSystemData.listComputeObjectODE2LhsUF.Flush();
	cSystemData.listComputeObjectODE2LhsNoUF.Flush();
	cSystemData.listComputeObjectODE1Rhs.Flush();
	cSystemData.listDiscontinuousIteration.Flush();
	cSystemData.listOfLoadsNoUF.Flush();
	cSystemData.listOfLoadsUF.Flush();

	cSystemData.objectsBodyWithAE.Flush();
	cSystemData.nodesODE2WithAE.Flush();
	cSystemData.objectsWithAlgebraicEquations.Flush();
	cSystemData.objectsConstraintWithAE.Flush();
	cSystemData.objectsConstraintWithAEUF.Flush();
	cSystemData.objectsConstraintWithAENoUF.Flush();
	cSystemData.listObjectProjectedReactionForcesODE2.Flush();
	cSystemData.listObjectProjectedReactionForcesODE2UF.Flush();
	cSystemData.listObjectProjectedReactionForcesODE2NoUF.Flush();


	//compute localToGlobalODE2 coordinate indices
	for (Index i = 0; i < cSystemData.GetCObjects().NumberOfItems(); i++)
	{
		//unused
		CObject* object = cSystemData.GetCObjects()[i];

		//if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		//{
		//	cSystemData.objectsConnectors.Append(i);
		//}
		////unused
		//if (EXUstd::IsOfType(object->GetType(), CObjectType::Constraint))
		//{
		//	cSystemData.objectsConstraints.Append(i);
		//}

		
		//for ComputeObjectODE2Lhs
		if (cSystemData.GetLocalToGlobalODE2()[i].NumberOfItems() != 0 &&  //ground
			!EXUstd::IsOfType(object->GetType(), CObjectType::Constraint)) //only if ODE2 exists and if not constraint (Constraint force action added in solver)
		{
			//if object is a body, it must have ODE2RHS
			if (EXUstd::IsOfType(object->GetType(), CObjectType::Body) ||
				EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
			{
				cSystemData.listComputeObjectODE2Lhs.Append(i); 
				if (object->HasUserFunction()) { cSystemData.listComputeObjectODE2LhsUF.Append(i); }
				else { cSystemData.listComputeObjectODE2LhsNoUF.Append(i); }
			}
			else 
			{ 
				SysError("CSystem::PreComputeItemLists(...): object "+EXUstd::ToString(i) + ": ODE2 type not implemented"); 
			}
		}


		//for ComputeObjectODE1Rhs
		if (cSystemData.GetLocalToGlobalODE1()[i].NumberOfItems() != 0)
		{
			cSystemData.listComputeObjectODE1Rhs.Append(i);
		}

		//for ComputeMassMatrix
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Body))
		{
			if (cSystemData.GetLocalToGlobalODE2()[i].NumberOfItems() != 0)
			{
				cSystemData.objectsBodyWithODE2Coords.Append(i);
				if (object->HasUserFunction()) { cSystemData.objectsBodyWithODE2CoordsUF.Append(i); }
				else { cSystemData.objectsBodyWithODE2CoordsNoUF.Append(i); }
			}
		}
		//ComputeAlgebraicEquations:
		if (cSystemData.GetLocalToGlobalAE()[i].NumberOfItems() != 0)
		{
			bool AEavailable = false;
			if (EXUstd::IsOfType(object->GetType(), CObjectType::Body) &&
				object->GetAlgebraicEquationsSize() != 0)
			{
				AEavailable = true;
				cSystemData.objectsWithAlgebraicEquations.Append(i);
				cSystemData.objectsBodyWithAE.Append(i);
			}
			else if (EXUstd::IsOfType(object->GetType(), CObjectType::Constraint))
			{
				AEavailable = true;
				cSystemData.objectsWithAlgebraicEquations.Append(i);
				cSystemData.objectsConstraintWithAE.Append(i);
				if (object->HasUserFunction()) 
				{
					cSystemData.objectsConstraintWithAEUF.Append(i); //with UserFunctoin
				}
				else 
				{
					cSystemData.objectsConstraintWithAENoUF.Append(i); //without UserFunctoin
				}
			}
			//NOT AVAILABLE NOW: connectors or pure objects
			else if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
			{
				CHECKandTHROW(object->GetAlgebraicEquationsSize() == 0, "CSystem::PreComputeItemLists: not implemented for Connectors with AE");
			}
			else
			{
				CHECKandTHROW(object->GetAlgebraicEquationsSize() == 0, "CSystem::PreComputeItemLists: not implemented for pure objects with AE");
			}

			//add projected equations only if algebraic equation is available (i.e., do not add for rigid bodies, because this term is handled by nodes)
			if (AEavailable && cSystemData.GetLocalToGlobalODE2()[i].NumberOfItems() != 0)
			{
				cSystemData.listObjectProjectedReactionForcesODE2.Append(i); //for constraints, reaction forces on ODE2 coordinates
				if (object->HasUserFunction()) 
				{
					cSystemData.listObjectProjectedReactionForcesODE2UF.Append(i); //with UserFunctoin
				} 
				else 
				{
					cSystemData.listObjectProjectedReactionForcesODE2NoUF.Append(i); //without UserFunctoin
				}
			}

		}

		//PostNewtonStep, PostDiscontinuousIteration:
		//for constraint, algebraic equations depend on Markers
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		{
			//CObjectConnector* connector = (CObjectConnector*)object;

			if (((CObjectConnector*)object)->HasDiscontinuousIteration())
			{
				cSystemData.listDiscontinuousIteration.Append(i);
			}
		}
	}

	//compute list of nodes with constraint equations
	for (Index i = 0; i < cSystemData.GetCNodes().NumberOfItems(); i++)
	{
		CNode* node = cSystemData.GetCNodes()[i];
		if (EXUstd::IsOfType(node->GetNodeGroup(), CNodeGroup::ODE2variables) &&  node->GetAlgebraicEquationsSize() != 0)
			//&& EXUstd::IsOfType(((CNodeODE2*)node)->GetType(), Node::RotationEulerParameters
		{
			cSystemData.nodesODE2WithAE.Append(i);
		}
	}

	//compute list of loads with/without user functions
	for (Index i = 0; i < cSystemData.GetCLoads().NumberOfItems(); i++)
	{
		CLoad* load = cSystemData.GetCLoads()[i];
		if (load->HasUserFunction())
		{
			cSystemData.listOfLoadsUF.Append(i);
		}
		else
		{
			cSystemData.listOfLoadsNoUF.Append(i);
		}
	}

	//std::cout << "cSystemData.objectsBodyWithODE2Coords = " << cSystemData.objectsBodyWithODE2Coords << "\n";
	//std::cout << "cSystemData.listComputeObjectODE2Lhs = " << cSystemData.listComputeObjectODE2Lhs << "\n";
	//std::cout << "cSystemData.listComputeObjectODE1Rhs = " << cSystemData.listComputeObjectODE1Rhs << "\n";
	//std::cout << "cSystemData.objectsBodyWithAE = " << cSystemData.objectsBodyWithAE << "\n";
	//std::cout << "cSystemData.nodesODE2WithAE = " << cSystemData.nodesODE2WithAE << "\n";
	//std::cout << "cSystemData.listObjectProjectedReactionForcesODE2 = " << cSystemData.listObjectProjectedReactionForcesODE2 << "\n";

}

//! reset lists for Lie groups when Assemble is called; this should require no memory (e.g. in expl. integrators)
void CSystem::InitLieGroupLists()
{
	cSystemData.listLieGroupODE2toDUnode.SetNumberOfItems(0);	//!< this marks that is has not been initialized

	//nonLieODE2Coordinates.SetNumberOfItems(0);

	cSystemData.HasLieGroupDUNodes() = false; //if this flag is set true, lists will be created/updated in ComputeLieGroupLists()
	const auto& cNodes = cSystemData.GetCNodes();
	for (Index i = 0; i < cNodes.NumberOfItems(); i++)
	{
		if (EXUstd::IsOfType(cNodes[i]->GetType(), Node::LieGroupWithDirectUpdate))
		{
			cSystemData.HasLieGroupDUNodes() = true;
			break;
		}
	}
}

//! compute updates and lists for Lie groups (some of them are only initialized once)
void CSystem::ComputeLieGroupLists()
{
    //initialize lists if not yet created (only once per computation and only if needed, e.g. implicit integrator)
    if (cSystemData.HasLieGroupDUNodes() && cSystemData.listLieGroupODE2toDUnode.NumberOfItems() == 0)
	{
		Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
		const auto& cNodes = cSystemData.GetCNodes();

        //create list which allows us to see that a particular coordinate is from a Lie group node
		cSystemData.listLieGroupODE2toDUnode.SetNumberOfItems(nODE2);
		cSystemData.listLieGroupODE2toDUnode.SetAll(-1);

		for (Index i = 0; i < cNodes.NumberOfItems(); i++)
		{
			if (EXUstd::IsOfType(cNodes[i]->GetType(), Node::LieGroupWithDirectUpdate))
			{
				//cSystemData.listLieGroupDUNodes.Append(i);
				Index off = cNodes[i]->GetGlobalODE2CoordinateIndex();
				for (Index j = 0; j < cNodes[i]->GetNumberOfODE2Coordinates(); j++)
				{
					cSystemData.listLieGroupODE2toDUnode[j + off] = i;
				}
			}
		}
		//cSystemData.listLieGroupODE2coordUpdate.SetNumberOfItems(nODE2);
        //pout << "initialized listLieGroupODE2toDUnode = " << cSystemData.listLieGroupODE2toDUnode << "\n";
	}
}

//! compute epsilon increment for coordinate index of lie group node and 
//! to reset to stored values, do: refNodeODE2.CopyFrom(storedNodeODE2)
void CSystem::ComputeLieGroupNodeCompositionEps(Vector& currentODE2,
	Index coordinateIndex, Real absEps,
	ConstSizeVector<EXUmath::lieGroupDirectUpdateNodeSize>& storedNodeODE2,
	LinkedDataVector& nodeODE2coordsLink)
{
    Index nodeNumber = cSystemData.listLieGroupODE2toDUnode[coordinateIndex];
    const CNodeRigidBody& node = (const CNodeRigidBody&)(cSystemData.GetCNode(nodeNumber) );
    Index nodeGlobalCoordinate = node.GetGlobalODE2CoordinateIndex();
    Index nodeCoordinate = coordinateIndex - nodeGlobalCoordinate; //local coordinate number

    Index nPos = node.GetNumberOfDisplacementCoordinates(); //should be 3
	Index nRot = node.GetNumberOfRotationCoordinates();     //should be 3
	Index off = node.GetGlobalODE2CoordinateIndex();

	// current state:
    nodeODE2coordsLink.LinkDataTo(currentODE2, nodeGlobalCoordinate, nPos + nRot);
    
    //as incrementatlMotion is limited to 6, we need to limit this here!
    CHECKandTHROW(nPos + nRot <= 6, "CSystem::ComputeLieGroupNodeCompositionEps: only possible for node size <= 6");

    storedNodeODE2.CopyFrom(nodeODE2coordsLink);
	//LinkedDataVector currentPosition(storedNodeODE2, off, nPos); //wrong, no offset off needed here!
	//LinkedDataVector currentOrientation(storedNodeODE2, off + nPos, nRot);
	LinkedDataVector currentPosition(storedNodeODE2, 0, nPos);
	LinkedDataVector currentOrientation(storedNodeODE2, nPos, nRot);

	LinkedDataVector newPosition(currentODE2, off, nPos);
	LinkedDataVector newOrientation(currentODE2, off + nPos, nRot);

    Vector6D incrementalMotion(0.);
    incrementalMotion[nodeCoordinate] = absEps;
    //write directly to currentODE2 via newPosition/Orientation:
	node.CompositionRule(currentPosition, currentOrientation, incrementalMotion, newPosition, newOrientation); 
    //NOTE: Delta q in Arnold/Bruls is (-1)*Delta q here	
}

//! Use initial values of nodes to compute system-wide initial coordinate vectors
void CSystem::AssembleInitializeSystemCoordinates(const MainSystem& mainSystem)
{
	//pout << "Set initial system coordinates (for ODE2, ODE1 and Data coordinates) ...\n";

	//initial system vectors
	Vector ODE2u =  Vector(cSystemData.GetNumberOfCoordinatesODE2());
	Vector ODE2v =  Vector(cSystemData.GetNumberOfCoordinatesODE2());
	Vector ODE1x =  Vector(cSystemData.GetNumberOfCoordinatesODE1());
	Vector data =	Vector(cSystemData.GetNumberOfCoordinatesData());
	Vector AE =		Vector(cSystemData.GetNumberOfCoordinatesAE(), 0.); //algebraic variables initialized with zero!

	Vector ODE2uRef = Vector(cSystemData.GetNumberOfCoordinatesODE2()); 
	Vector ODE1xRef = Vector(cSystemData.GetNumberOfCoordinatesODE1());  
	//Vector ODE2vRef = Vector(cSystemData.GetNumberOfCoordinatesODE2(), 0.);
	//Vector dataRef =  Vector(cSystemData.GetNumberOfCoordinatesData(), 0.);
	//Vector AERef =    Vector(cSystemData.GetNumberOfCoordinatesAE(), 0.);

	const MainSystemData& mainSystemData = mainSystem.mainSystemData;

	//now extract initial coordinate information from nodes:
	Index nodeIndex = 0;
	for (auto mainNode : mainSystemData.GetMainNodes())
	{
		CNode* node = mainNode->GetCNode();
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			Index coordIndex = node->GetGlobalODE2CoordinateIndex();

			if (node->GetNumberOfODE2Coordinates())
			{
				Index numberOfCoordinates = node->GetNumberOfODE2Coordinates();

				//link to sublist of global coordinate vector:
				LinkedDataVector u(ODE2u, coordIndex, numberOfCoordinates);
				LinkedDataVector v(ODE2v, coordIndex, numberOfCoordinates);

				mainNode->SetInitialCoordinateVector(u);
				mainNode->SetInitialCoordinateVector_t(v);

				//also initialize global reference coordinate vector (used for differentiation and in finite elements)
				LinkedDataVector uRef(ODE2uRef, coordIndex, numberOfCoordinates);
				uRef = node->GetReferenceCoordinateVector();
			}
		}
		else if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::ODE1variables)
		{
			Index coordIndex = node->GetGlobalODE1CoordinateIndex();

			if (node->GetNumberOfODE1Coordinates())
			{
				Index numberOfCoordinates = node->GetNumberOfODE1Coordinates();
				LinkedDataVector x(ODE1x, coordIndex, numberOfCoordinates);

				mainNode->SetInitialCoordinateVector(x);
				//DELETE:
				//x = mainNode->GetInitialCoordinateVector(); //size must be compatible and is not checked!

				//also initialize global reference coordinate vector (used for differentiation and in finite elements)
				LinkedDataVector uRef(ODE1xRef, coordIndex, numberOfCoordinates);
				uRef = node->GetReferenceCoordinateVector();
			}
		}
		//else  //the following is always done:
		if ((Index)node->GetNodeGroup() & (Index)CNodeGroup::DataVariables)
		{
			Index coordIndex = node->GetGlobalDataCoordinateIndex();

			if (node->GetNumberOfDataCoordinates())
			{
				Index numberOfCoordinates = node->GetNumberOfDataCoordinates();
				LinkedDataVector x(data, coordIndex, numberOfCoordinates);

				mainNode->SetInitialDataCoordinateVector(x);
			}
		}
		//else { CHECKandTHROWstring("CSystem::AssembleInitializeSystemCoordinates: invalid Node type, not implemented"); }
		nodeIndex++;
	}

	cSystemData.GetCData().initialState.ODE2Coords = ODE2u;
	cSystemData.GetCData().initialState.ODE2Coords_t = ODE2v;
	cSystemData.GetCData().initialState.ODE2Coords_tt = 0*ODE2v; //use same size as in velocities for accelerations, but initialize with zeros
	cSystemData.GetCData().initialState.ODE1Coords = ODE1x;
	cSystemData.GetCData().initialState.ODE1Coords_t = 0*ODE1x; //use same size as at position level, but with zeros; could be necessary for some evaluations at initial state
	cSystemData.GetCData().initialState.dataCoords = data;
	cSystemData.GetCData().initialState.AECoords = AE;

	cSystemData.GetCData().referenceState.ODE2Coords = ODE2uRef;
	cSystemData.GetCData().referenceState.ODE1Coords = ODE1xRef;
	//cSystemData.GetCData().referenceState.ODE2Coords_t = ODE2vRef; //access to these coordinates will lead to crash
	//cSystemData.GetCData().referenceState.dataCoords = dataRef;
	//cSystemData.GetCData().referenceState.AECoords = AERef; 



	//initial values are also used for current step ==> from here on, the system can be visualized!
	cSystemData.GetCData().currentState = cSystemData.GetCData().initialState;
	cSystemData.GetCData().visualizationState = cSystemData.GetCData().initialState; //from this point on, drawing should be possible
	postProcessData.SetVisualizationStateUpdateAvailable(false);
	cSystemData.GetCData().startOfStepState = cSystemData.GetCData().initialState; //2023-01-12: done also at beginning of solver/time integration, but to be consistent with all configurations!
}


void CSystem::AssembleSystemInitialize(const MainSystem& mainSystem)
{
	//initialize all contacts (searchtree, etc)
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		gc->FinalizeContact(*this);
	}
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CSystem computation functions
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! compute system massmatrix; massmatrix must have according size; must be set to zero before calling!
void CSystem::ComputeMassMatrix(TemporaryComputationDataArray& tempArray, GeneralMatrix& massMatrix, bool computeInverse)
{
	//size needs to be set accordingly in the caller function; components are addd to massMatrix!
	//only call bodies with ODE2
    if (EXUstd::IsOfType(LinearSolverType::Dense, massMatrix.GetSystemMatrixType()))
    //if (massMatrix.GetSystemMatrixType() == LinearSolverType::EXUdense)
	{
		TemporaryComputationData& temp = tempArray[0]; //always exists
		temp.massMatrix.ClearAllMatrices(); //this resets both matrices (no new)

		for (Index j : cSystemData.objectsBodyWithODE2Coords)
		{
			temp.massMatrix.SetUseDenseMatrix(true); //this is default, mass matrix must either switch to sparse or 

			ArrayIndex& ltg = cSystemData.GetLocalToGlobalODE2()[j];
			((CObjectBody*)(cSystemData.GetCObjects()[j]))->ComputeMassMatrix(temp.massMatrix, ltg, j, computeInverse); //ltg only used in sparse mode

			if (temp.massMatrix.UseDenseMatrix()) //dense matrix filled in and this is now transferred to dense system matrix
			{
				massMatrix.AddSubmatrix(temp.massMatrix.GetInternalDenseMatrix(), 1., ltg, ltg);
			}
		}
		//add sparse triplets to the dense matrix
		temp.massMatrix.SetUseDenseMatrix(false); //for next operation needed
		//pout << "sys triplet mass=" << temp.massMatrix.GetInternalSparseTripletsAsMatrix() << "\n";

		const ResizableArray<EXUmath::Triplet>& triplets = temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets();
		ResizableMatrix& matrix = ((GeneralMatrixEXUdense&)massMatrix).GetMatrixEXUdense();
		for (const EXUmath::Triplet& triplet : triplets)
		{
			matrix(triplet.row(), triplet.col()) += triplet.value();
		}
	}
	else //GeneralMatrix is sparse matrix
	{
		Index nThreads = exuThreading::TaskManager::GetNumThreads();
		bool doParallel = (nThreads > 1) && (cSystemData.objectsBodyWithODE2CoordsNoUF.NumberOfItems() >= solverData.multithreadedLLimitMassMatrix);
		const ArrayIndex& processObjectsSerial = doParallel ? cSystemData.objectsBodyWithODE2CoordsUF : cSystemData.objectsBodyWithODE2Coords;
		//const ArrayIndex& processObjectsSerial = cSystemData.objectsBodyWithODE2Coords;

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//SERIAL PART   SERIAL PART   SERIAL PART; also done in parallel mode:
		{
			TemporaryComputationData& temp = tempArray[0]; //always exists
			temp.massMatrix.ClearAllMatrices(); //this resets both matrices (no new)

			//exchange GeneralMatrix and MatrixContainer triplets ==> mass matrix directly filled by objects!
			SparseTripletVector& generalMatrixTriplets = ((GeneralMatrixEigenSparse&)massMatrix).GetSparseTriplets();

			temp.massMatrix.SetUseDenseMatrix(false); //for next 2 operations needed
			generalMatrixTriplets.Swap(temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets());
			SparseTripletVector& sparseTriplets = temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets(); //link to current triplets in temp.massMatrix:

			temp.massMatrix.SetUseDenseMatrix(true); //for next operation needed
			Matrix& denseMatrix = temp.massMatrix.GetInternalDenseMatrix();

			for (Index j : processObjectsSerial) //cSystemData.objectsBodyWithODE2Coords)
			{
				temp.massMatrix.SetUseDenseMatrix(true); //this is default, mass matrix must either switch to sparse or just fill in

				ArrayIndex& ltg = cSystemData.GetLocalToGlobalODE2()[j];
				((CObjectBody*)(cSystemData.GetCObjects()[j]))->ComputeMassMatrix(temp.massMatrix, ltg, j, computeInverse); //ltg only used in sparse mode

				if (temp.massMatrix.UseDenseMatrix()) //dense matrix filled in and this is now transferred to dense system matrix
				{
					for (Index i = 0; i < denseMatrix.NumberOfRows(); i++)
					{
						for (Index j = 0; j < denseMatrix.NumberOfColumns(); j++)
						{
							Real value = denseMatrix(i, j);
							if (value != 0.)
							{
								sparseTriplets.AppendPure(SparseTriplet(ltg[i], ltg[j], value));
							}
						}
					}
				}
				//else: already added to sparse triplets!
			}

			//exchange back GeneralMatrix and MatrixContainer triplets
			temp.massMatrix.SetUseDenseMatrix(false); //for next operation needed
			generalMatrixTriplets.Swap(temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets());
		}
		
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//PARALLEL PART
		if (doParallel)
		{
			//parallel section, only for objects without user functions!
			//fill data into tempArray[i].massMatrix directly (sparse+dense)

			outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation

			tempArray.SetNumberOfItems(nThreads); //only affected, if nThreads changed
			//tempArray.ClearSparseMatrices(nThreads); //clears sparseTriplets, etc.

			////link all matrices
			for (Index i = 0; i < nThreads; i++)
			{
				//tempArray[i].massMatrix.SetUseDenseMatrix(false); //for next 2 operations needed
				//tempArray[i].sparseTriplets.Swap(tempArray[i].massMatrix.GetInternalSparseTripletMatrix().GetTriplets());
				tempArray[i].massMatrix.ClearAllMatrices(); //this resets both matrices (no new)
			}

			Index nItems = cSystemData.objectsBodyWithODE2CoordsNoUF.NumberOfItems();
			Index taskSplit = GetTaskSplit(nItems, nThreads);

			exuThreading::ParallelFor(nItems, [this, &tempArray, &nItems, &computeInverse](NGSsizeType i) //&temp,&systemODE2Rhs,&cSystemData
			{
				Index j = cSystemData.objectsBodyWithODE2CoordsNoUF[(Index)i];
				Index threadID = exuThreading::TaskManager::GetThreadId();

				TemporaryComputationData& temp = tempArray[threadID];

				temp.massMatrix.SetUseDenseMatrix(true); //this is default, mass matrix must either switch to sparse or just fill in

				ArrayIndex& ltg = cSystemData.GetLocalToGlobalODE2()[j];
				((CObjectBody*)(cSystemData.GetCObjects()[j]))->ComputeMassMatrix(temp.massMatrix, ltg, j, computeInverse); //ltg only used in sparse mode

				if (temp.massMatrix.UseDenseMatrix()) //dense matrix filled in and this is now transferred to dense system matrix
				{
					ResizableMatrix& denseMatrix = temp.massMatrix.GetInternalDenseMatrix();
					temp.massMatrix.SetUseDenseMatrix(false); //now copy items to sparse matrix
					SparseTripletVector& sparseTriplets = temp.massMatrix.GetInternalSparseTripletMatrix().GetTriplets();
					for (Index i = 0; i < denseMatrix.NumberOfRows(); i++)
					{
						for (Index j = 0; j < denseMatrix.NumberOfColumns(); j++)
						{
							Real value = denseMatrix(i, j);
							if (value != 0.)
							{
								sparseTriplets.AppendPure(SparseTriplet(ltg[i], ltg[j], value));
							}
						}
					}
					denseMatrix.Flush(); //for safety, could be omitted as local matrices are always overwritten!
				}
				//else: already added to sparse triplets!
			}, taskSplit);

			outputBuffer.SetSuspendWriting(false); //may not write to python during parallel computation


			SparseTripletVector& generalMatrixTriplets = ((GeneralMatrixEigenSparse&)massMatrix).GetSparseTriplets();

			//finally, we need to collect all triplets and fill into generalMatrix
			for (Index i = 0; i < nThreads; i++)
			{
				tempArray[i].massMatrix.SetUseDenseMatrix(false);
				generalMatrixTriplets.AppendArray(tempArray[i].massMatrix.GetInternalSparseTripletMatrix().GetTriplets());
				//const SparseTripletVector& sparseTriplets = tempArray[i].massMatrix.GetInternalSparseTripletMatrix().GetTriplets();
				//for (const SparseTriplet& item: sparseTriplets)
				//{
				//	generalMatrixTriplets.AppendPure(item);
				//}
			}
		}
	}

}

//! run through all bodies and check if has constant mass matrix; used for solver
bool CSystem::HasConstantMassMatrix()
{
	bool isConstant = true;
	for (Index j: cSystemData.objectsBodyWithODE2Coords)
	{
		//if object is a body, it must have a mass matrix
		if (!(((CObjectBody*)cSystemData.GetCObjects()[j])->HasConstantMassMatrix()) )
		{
			isConstant = false;
		}
	}
	return isConstant;
}

//Index TScomputeODE2LHSobject;
//TimerStructureRegistrator TSRcomputeODE2LHSobject("computeODE2LHSobject", TScomputeODE2LHSobject, globalTimers);
//Index TScomputeODE2LHSconnector;
//TimerStructureRegistrator TSRcomputeODE2LHSconnector("computeODE2LHSconnector", TScomputeODE2LHSconnector, globalTimers);
//Index TScomputeODE2LHSmarkerData;
//TimerStructureRegistrator TSRcomputeODE2LHSmarkerData("computeODE2LHSmarkerData", TScomputeODE2LHSmarkerData, globalTimers);
Index TScomputeLoads;
TimerStructureRegistrator TSRcomputeLoads("computeLoads", TScomputeLoads, globalTimers);

Index TScomputeObjectODE2;
TimerStructureRegistrator TSRcomputeObjectODE2("computeObjectODE2", TScomputeObjectODE2, globalTimers);
//Index TScomputeObjectODE2b;
//TimerStructureRegistrator TSRcomputeObjectODE2b("computeObjectODE2b", TScomputeObjectODE2b, globalTimers);

//Index TScomputeLoadsMarkerData;
//TimerStructureRegistrator TSRcomputeLoadsMarkerData("computeLoadsMarkerData", TScomputeLoadsMarkerData, globalTimers);
Index TScomputeConnectorsMarkerData;
TimerStructureRegistrator TSRcomputeConnectorsMarkerData("connectorsMarkerData", TScomputeConnectorsMarkerData, globalTimers);

Index TScomputeAlgebraicEquations;
TimerStructureRegistrator TSRcomputeAlgebraicEquations("computeAlgebraicEquations", TScomputeAlgebraicEquations, globalTimers);


Index TScomputeGeneralContact;
TimerStructureRegistrator TSRcomputeGeneralContact("Contact:overall", TScomputeGeneralContact, globalTimers);
//Index TScomputeMarkerDataODE2;
//TimerStructureRegistrator TSRcomputeMarkerDataODE2("computeMarkerDataODE2", TScomputeMarkerDataODE2, globalTimers);


//! compute left-hand-side (LHS) of second order ordinary differential equations (ODE) for every object (used in numerical differentiation and in RHS computation)
//! return true, if object has localODE2Lhs, false otherwise
inline bool CSystem::ComputeObjectODE2LHS(TemporaryComputationData& temp, CObject* object, Vector& localODE2Lhs, Index objectNumber)
{
	if (object->IsActive()) //usually is active ...
	{
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Body))
		{
			object->ComputeODE2LHS(localODE2Lhs, objectNumber);
		}
		else if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		{
			CObjectConnector* connector = (CObjectConnector*)object;

			//compute MarkerData for connector:
			const bool computeJacobian = true; //jacobian needed for connectors, to add correct projection of forces!
			cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);

			connector->ComputeODE2LHS(localODE2Lhs, temp.markerDataStructure, objectNumber);
		}
		return true;
	}
	return false;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
void CSystem::ComputeSystemODE2RHS(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
{
	//STARTGLOBALTIMER(TScomputeObjectODE2);
	systemODE2Rhs.SetAll(0.);

	int nItems = cSystemData.listComputeObjectODE2LhsNoUF.NumberOfItems();
	Index nThreads = exuThreading::TaskManager::GetNumThreads();
	if (nThreads > 1 && (nItems >= solverData.multithreadedLLimitResiduals) )
	{
		//std::mutex mtx;           // mutex for critical section
		outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation

        tempArray.SetNumberOfItems(nThreads); //only affected, if nThreads changed
		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}

		//STARTGLOBALTIMER(TScomputeObjectODE2);
		Index taskSplit = GetTaskSplit(nItems, nThreads);
		exuThreading::ParallelFor(nItems, [this, &systemODE2Rhs, &tempArray, &nItems](NGSsizeType j) //&temp,&systemODE2Rhs,&cSystemData
		{
			Index i = cSystemData.listComputeObjectODE2Lhs[(Index)j];
			Index threadID = exuThreading::TaskManager::GetThreadId();

			TemporaryComputationData& temp = tempArray[threadID];
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[i];

			if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[i], temp.localODE2LHS, i))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
				{
					tempArray[threadID].sparseVector.AddIndexAndValue(ltgODE2[k], temp.localODE2LHS[k]);
					//systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
				}
			}
		}, taskSplit);
		//STOPGLOBALTIMER(TScomputeObjectODE2);
		outputBuffer.SetSuspendWriting(false);

		//serial section for writing into system vector //for 3D bodies, using 12 threads, this is still less than 1% of overall time!
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				systemODE2Rhs[item.GetIndex()] -= item.GetValue(); //minus: LHS->RHS
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++
		//now work over objects with user functions:
		TemporaryComputationData& temp = tempArray[0]; //always exists

		for (Index j : cSystemData.listComputeObjectODE2LhsUF)
		{
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];

			if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[j], temp.localODE2LHS, j))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
				{
					systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
				}
			}
		}
		//STOPGLOBALTIMER(TScomputeObjectODE2);

	}
	else
	{	//conventional SERIAL version:
		TemporaryComputationData& temp = tempArray[0]; //always exists
		//STARTGLOBALTIMER(TScomputeObjectODE2);
		//systemODE2Rhs.SetAll(0.);

		for (Index j : cSystemData.listComputeObjectODE2Lhs)
		{
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];

			if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[j], temp.localODE2LHS, j))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
				{
					systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
				}
			}
		}
		//STOPGLOBALTIMER(TScomputeObjectODE2);

	}
	//pout << "systemODE2Rhs=" << systemODE2Rhs << "\n";
	//STOPGLOBALTIMER(TScomputeObjectODE2);

	//this part is anyway done in parallel:
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		STARTGLOBALTIMER(TScomputeGeneralContact);
		//gc->ComputeContactDataAndBoundingBoxes(*this, tempArray); //done in compute ODE2RHS ...
		gc->ComputeODE2RHS(*this, tempArray, systemODE2Rhs);
		STOPGLOBALTIMER(TScomputeGeneralContact);
	}

	//STARTGLOBALTIMER(TScomputeLoads);
	ComputeODE2LoadsRHS(tempArray, systemODE2Rhs);
	//STOPGLOBALTIMER(TScomputeLoads);

}

////+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
////! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
//void CSystem::ComputeSystemODE2RHS(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
//{
//	TemporaryComputationData& temp = tempArray[0]; //always exists
//	//STARTGLOBALTIMER(TScomputeObjectODE2);
//	systemODE2Rhs.SetAll(0.);
//
//	for (Index j : cSystemData.listComputeObjectODE2Lhs)
//	{
//		ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
//
//		if (ComputeObjectODE2LHS(temp, cSystemData.GetCObjects()[j], temp.localODE2LHS, j))
//		{
//			//now add RHS to system vector
//			for (Index k = 0; k < temp.localODE2LHS.NumberOfItems(); k++)
//			{
//				systemODE2Rhs[ltgODE2[k]] -= temp.localODE2LHS[k]; //negative sign ==> stiffness/damping on LHS of equations
//			}
//		}
//	}
//	//STOPGLOBALTIMER(TScomputeObjectODE2);
//
//	for (GeneralContact* gc : generalContacts) //usually only 1
//	{
//		STARTGLOBALTIMER(TScomputeGeneralContact);
//		gc->ComputeContactDataAndBoundingBoxes(*this, temp);
//		gc->ComputeODE2RHS(*this, temp, systemODE2Rhs);
//		STOPGLOBALTIMER(TScomputeGeneralContact);
//	}
//	//STARTGLOBALTIMER(TScomputeLoads);
//	ComputeODE2LoadsRHS(temp, systemODE2Rhs);
//	//STOPGLOBALTIMER(TScomputeLoads);
//}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//evaluate RHS of ODE1 objects (always right-hand-side as first order ODEs always read q_t=f(q, t) )
inline bool CSystem::ComputeObjectODE1RHS(TemporaryComputationData& temp, CObject* object, Vector& localODE1Rhs, Index objectNumber)
{
	if (object->IsActive())
	{
		if (EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
		{
			CObjectConnector* connector = (CObjectConnector*)object;

			const bool computeJacobian = true; //jacobian needed for connectors, to add correct projection of forces!
			cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);

			connector->ComputeODE1RHS(localODE1Rhs, temp.markerDataStructure, objectNumber);
		}
		else //must be body or similar object (in all cases, evaluate ComputeODE1LHS)
		{
			object->ComputeODE1RHS(localODE1Rhs, objectNumber);
		}
		return true;
	}
	return false;
}

void CSystem::ComputeSystemODE1RHS(TemporaryComputationData& temp, Vector& systemODE1Rhs)
{
	if (systemODE1Rhs.NumberOfItems() != 0) //usually not called
	{
		systemODE1Rhs.SetAll(0.);
		//std::cout << "ComputeSystemODE1RHS start\n";

		for (Index j : cSystemData.listComputeObjectODE1Rhs)
		{
			ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];

			if (ComputeObjectODE1RHS(temp, cSystemData.GetCObjects()[j], temp.localODE1RHS, j))
			{
				//now add RHS to system vector
				for (Index k = 0; k < temp.localODE1RHS.NumberOfItems(); k++)
				{
					systemODE1Rhs[ltgODE1[k]] += temp.localODE1RHS[k]; //positive sign as compared to ComputeSystemODE2RHS: in ODE1, everything is on RHS
				}
			}
		}
		ComputeODE1Loads(temp, systemODE1Rhs);
	}
	//std::cout << "ComputeSystemODE1RHS end\n";
}


//! compute system right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
void CSystem::ComputeODE2LoadsRHS(TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
{
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	//compute loads ==> not needed in jacobian, except for follower loads, 
	//  using e.g. local body coordinate system

	//Index nLoads = cSystemData.GetCLoads().NumberOfItems();
	Real currentTime = cSystemData.GetCData().currentState.time;

	Index nThreads = exuThreading::TaskManager::GetNumThreads();
	Index nItems = cSystemData.listOfLoadsNoUF.NumberOfItems(); 

	if (nThreads > 1 && nItems >= solverData.multithreadedLLimitLoads)
	{
        tempArray.SetNumberOfItems(nThreads); //only affected, if nThreads changed
		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}
		outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation


		Index taskSplit = GetTaskSplit(nItems, nThreads);
		exuThreading::ParallelFor(nItems, [this, &systemODE2Rhs, &tempArray, &currentTime, &nItems](NGSsizeType i) //&temp,&systemODE2Rhs,&cSystemData
		{
			Index threadID = exuThreading::TaskManager::GetThreadId();
			const bool fillSparseVector = true;

			ComputeODE2SingleLoad(cSystemData.listOfLoadsNoUF[(Index)i], tempArray[threadID], currentTime, systemODE2Rhs, fillSparseVector);
		}, taskSplit);
		outputBuffer.SetSuspendWriting(false); //may not write to python during parallel computation

		//serial section for writing sparseVectors into system vector
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				systemODE2Rhs[item.GetIndex()] += item.GetValue(); //minus: LHS->RHS
			}
		}

		//serial section for remaining loads with UF
		const bool fillSparseVector = false;
		TemporaryComputationData& temp = tempArray[0];
		for (Index j: cSystemData.listOfLoadsUF)
		{
			ComputeODE2SingleLoad(j, temp, currentTime, systemODE2Rhs, fillSparseVector);
		}
	}
	else
	{
		//serial version, directly writes into systemODE2Rhs
		const bool fillSparseVector = false;
		TemporaryComputationData& temp = tempArray[0];
		Index nLoads = cSystemData.GetCLoads().NumberOfItems();
		for (Index j = 0; j < nLoads; j++)
		{
			ComputeODE2SingleLoad(j, temp, currentTime, systemODE2Rhs, fillSparseVector);
		}
	}
}


//! compute part of load for 'ode2rhs' or to sparsevector; if fillSparseVector, values are added to temp.sparseVector; otherwise, filled directly into systemODE2Rhs
void CSystem::ComputeODE2SingleLoad(Index loadIndex, TemporaryComputationData& temp, Real currentTime, Vector& systemODE2Rhs, 
    bool fillSparseVector, bool fillInLocally)
{
	Vector3D loadVector3D(0); //initialization in order to avoid gcc warnings
	Vector1D loadVector1D(0); //scalar loads...//initialization in order to avoid gcc warnings
#ifndef __FAST_EXUDYN_LINALG
	bool loadVector1Ddefined = false; //add checks such that wrong formats would fail
	bool loadVector3Ddefined = false; //add checks such that wrong formats would fail
#endif

	CLoad* cLoad = cSystemData.GetCLoads()[(Index)loadIndex];
	if (cLoad->IsVector())
	{
		loadVector3D = cLoad->GetLoadVector(cSystemData.GetMainSystemBacklink(), currentTime);
#ifndef __FAST_EXUDYN_LINALG
		loadVector3Ddefined = true;
#endif
	}
	else
	{
		loadVector1D = Vector1D(cLoad->GetLoadValue(cSystemData.GetMainSystemBacklink(), currentTime));
#ifndef __FAST_EXUDYN_LINALG
		loadVector1Ddefined = true;
#endif
	}

	Index markerNumber = cLoad->GetMarkerNumber();
	CMarker* marker = cSystemData.GetCMarkers()[markerNumber];
	LoadType loadType = cLoad->GetType();

	ArrayIndex* ltg = nullptr;	//for objects
	Index nodeCoordinate = 99999;//initialize with arbitrary value for gcc; starting index for nodes (consecutively numbered)
	bool applyLoad = false;		//loads are not applied to ground objects/nodes

	//loads only applied to Marker::Body or Marker::Node
    if (!fillInLocally)
    {
        if (marker->GetType() & Marker::Body) //code for body markers
        {
            Index markerBodyNumber = marker->GetObjectNumber();
            if (!((Index)cSystemData.GetCObjectBody(markerBodyNumber).GetType() & (Index)CObjectType::Ground)) //no action on ground objects!
            {
                ltg = &cSystemData.GetLocalToGlobalODE2()[markerBodyNumber];
                if (ltg->NumberOfItems() != 0) { applyLoad = true; } //only apply load, if object is not attached to ground node!
            }
        }
        else if (marker->GetType() & Marker::Node) //code for body markers
        {
            Index markerNodeNumber = marker->GetNodeNumber();
            if (!cSystemData.GetCNodes()[markerNodeNumber]->IsGroundNode()) //if node has zero coordinates ==> ground node; no action on ground nodes!
            {
                if (((marker->GetType() & Marker::Position) || (marker->GetType() & Marker::Coordinate)) && !(marker->GetType() & Marker::ODE1))
                {
                    nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE2CoordinateIndex();
                    applyLoad = true;
                }
                else if (EXUstd::IsOfType((Index)marker->GetType(), Marker::Coordinate + Marker::ODE1))
                {
                    applyLoad = false; //belongs to ODE1 coordinates, but valid load
                }
                else
                {
                    CHECKandTHROWstring("ERROR: CSystem::ComputeODE2SingleLoad, marker type not implemented!");
                }
            }
        }
        else { CHECKandTHROWstring("CSystem::ComputeODE2SingleLoad: marker must be Body or Node type\n"); }
    }
    else 
    { 
        applyLoad = true; 
        //systemODE2Rhs.SetAll(0.); //values are filled into vector
    } //LTG already checked before call

    if (applyLoad)
	{
		//AccessFunctionType aft = GetAccessFunctionType(loadType, marker->GetType());
		//==> lateron: depending on AccessFunctionType compute jacobians, put into markerDataStructure as in connectors
		//    and call according jacobian function
		//    marker->GetAccessFunctionJacobian(AccessFunctionType, ...) ==> handles automatically the jacobian
		Real loadFactor = solverData.loadFactor; //copy
		if (cLoad->HasUserFunction())
		{
			loadFactor = 1.; //loadFactor not used for case of user functions, see issue #603
		}

		//bodyFixed (local) follower loads:
		bool bodyFixed = false;
		if (cLoad->IsBodyFixed())
		{
			bodyFixed = true;
		}

		if (loadType == LoadType::Force || loadType == LoadType::ForcePerMass)
		{
			const bool computeJacobian = true;
			CHECKandTHROW(loadVector3Ddefined, "ComputeODE2SingleLoad(...): illegal force vector format (expected 3D load)");
			//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
			marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
			//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
			if (bodyFixed) { loadVector3D = temp.markerDataStructure.GetMarkerData(0).orientation * loadVector3D; }
			EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).positionJacobian, loadVector3D, temp.generalizedLoad); //generalized load: Q = (dPos/dq)^T * Force

			//marker->GetPositionJacobian(cSystemData, temp.loadJacobian);
			//EXUmath::MultMatrixVector(temp.loadJacobian, loadVector3D, temp.generalizedLoad);
		}
		else if (loadType == LoadType::Torque)
		{
			const bool computeJacobian = true;
			CHECKandTHROW(loadVector3Ddefined, "ComputeODE2SingleLoad(...): illegal force vector format (expected 3D torque)");
			//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
			marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
			//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
			if (bodyFixed) { loadVector3D = temp.markerDataStructure.GetMarkerData(0).orientation * loadVector3D; }
			EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).rotationJacobian, loadVector3D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
			//pout << "rotationJacobian=" << temp.markerDataStructure.GetMarkerData(0).rotationJacobian << "\n";
			//pout << "loadVector3D=" << loadVector3D << "\n";
		}
		else if (loadType == LoadType::Coordinate)
		{
			const bool computeJacobian = true;
			CHECKandTHROW(loadVector1Ddefined, "ComputeODE2SingleLoad(...): illegal force vector format (expected 1D load)");
			//STARTGLOBALTIMER(TScomputeLoadsMarkerData);
			marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
			//STOPGLOBALTIMER(TScomputeLoadsMarkerData);
			EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).jacobian, loadVector1D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
			//pout << "jacobian=" << temp.markerDataStructure.GetMarkerData(0).jacobian << "\n";
			//pout << "generalizedLoad=" << temp.generalizedLoad << "\n";
			//pout << "loadVector1D=" << loadVector1D << "\n";
		}
		else { CHECKandTHROWstring("ERROR: CSystem::ComputeODE2SingleLoad, LoadType not implemented!"); }

		//ResizableArray<CObject*>& objectList = cSystemData.GetCObjects();
		//pout << "genLoad=" << temp.generalizedLoad << "\n";

        if (!fillInLocally)
        {
            if (fillSparseVector)
            {
                if (ltg != nullptr) //must be object
                {
                    for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
                    {
                        temp.sparseVector.AddIndexAndValue((*ltg)[k], loadFactor * temp.generalizedLoad[k]);
                        //systemODE2Rhs[(*ltg)[k]] += loadFactor * temp.generalizedLoad[k];
                    }
                }
                else //must be node
                {
                    for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
                    {
                        temp.sparseVector.AddIndexAndValue(nodeCoordinate + k, loadFactor * temp.generalizedLoad[k]);
                        //systemODE2Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
                    }
                }
            }
            else
            {
                if (ltg != nullptr) //must be object
                {
                    for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
                    {
                        systemODE2Rhs[(*ltg)[k]] += loadFactor * temp.generalizedLoad[k];
                    }
                }
                else //must be node
                {
                    for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
                    {
                        systemODE2Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
                    }
                }
            }
        }
        else //local computation, for jacobian
        {
            Index nLoadCoordinates = temp.generalizedLoad.NumberOfItems();
            CHECKandTHROW(systemODE2Rhs.NumberOfItems() == nLoadCoordinates, "ComputeODE2SingleLoad: Load jacobian: inconsistent size of generalized load vector and LTG");
            for (Index k = 0; k < nLoadCoordinates; k++)
            {
                systemODE2Rhs[k] = loadFactor * temp.generalizedLoad[k];
            }
        }
	}

}


//! compute LTG for ODE2 loads; separate between ltg for equations (action) and dependent coordinates
void CSystem::ComputeODE2SingleLoadLTG(Index loadIndex, ArrayIndex& ltgODE2equations, ArrayIndex& ltgODE2coords, ArrayIndex& ltgODE1coords)
{
    ltgODE2coords.SetNumberOfItems0();
    ltgODE1coords.SetNumberOfItems0();

    CLoad* cLoad = cSystemData.GetCLoads()[(Index)loadIndex];
    Index markerNumber = cLoad->GetMarkerNumber();
    CMarker* marker = cSystemData.GetCMarkers()[markerNumber];
    //LoadType loadType = cLoad->GetType();

    //loads only applied to Marker::Body or Marker::Node
    if (marker->GetType() & Marker::Body) //code for body markers
    {
        Index markerBodyNumber = marker->GetObjectNumber();
        if (!((Index)cSystemData.GetCObjectBody(markerBodyNumber).GetType() & (Index)CObjectType::Ground)) //no action on ground objects!
        {
            ltgODE2coords = cSystemData.GetLocalToGlobalODE2()[markerBodyNumber];
        }
    }
    else if (marker->GetType() & Marker::Node) //code for body markers
    {
        Index markerNodeNumber = marker->GetNodeNumber();
        if (!cSystemData.GetCNodes()[markerNodeNumber]->IsGroundNode()) //if node has zero coordinates ==> ground node; no action on ground nodes!
        {
            if (((marker->GetType() & Marker::Position) || (marker->GetType() & Marker::Coordinate)) && !(marker->GetType() & Marker::ODE1))
            {
                Index nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE2CoordinateIndex();
                for (Index i = 0; i < cSystemData.GetCNodes()[markerNodeNumber]->GetNumberOfODE2Coordinates(); i++)
                {
                    ltgODE2coords.Append(nodeCoordinate++);
                }
            }
            else if (EXUstd::IsOfType((Index)marker->GetType(), Marker::Coordinate + Marker::ODE1))
            {
                Index nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE1CoordinateIndex();
                for (Index i = 0; i < cSystemData.GetCNodes()[markerNodeNumber]->GetNumberOfODE1Coordinates(); i++)
                {
                    ltgODE1coords.Append(nodeCoordinate++);
                }
            }
            else
            {
                CHECKandTHROWstring("ERROR: CSystem::ComputeODE2SingleLoadLTG, marker type not implemented!");
            }
        }
    }
    else { pout << "ERROR: CSystem::ComputeODE2SingleLoadLTG: marker must be Body or Node type\n"; }

    ltgODE2equations = ltgODE2coords;

    if (cSystemData.GetLoadsODE2dependencies().NumberOfItems())
    {
        CHECKandTHROW(cSystemData.GetLoadsODE2dependencies().NumberOfItems() == cSystemData.GetCLoads().NumberOfItems(),
            "CSystem::ComputeODE2SingleLoadLTG: inconsistent load dependencies");
        ArrayIndex& dependencies = cSystemData.GetLoadsODE2dependencies()[loadIndex];
        //CHECKandTHROW(dependencies.NumberOfItems() == 0,
        //    "CSystem::ComputeODE2SingleLoadLTG: load dependencies not implemented");

        for (Index item : dependencies)
        {
            ltgODE2coords.AppendIfItemNotFound(item); //this search takes n*n operations, but n should be very small
        }
    }
    if (cSystemData.GetLoadsODE1dependencies().NumberOfItems())
    {
        CHECKandTHROW(cSystemData.GetLoadsODE1dependencies().NumberOfItems() == cSystemData.GetCLoads().NumberOfItems(),
            "CSystem::ComputeODE2SingleLoadLTG: inconsistent load dependencies");
        ArrayIndex& dependencies = cSystemData.GetLoadsODE1dependencies()[loadIndex];
        //CHECKandTHROW(dependencies.NumberOfItems() == 0,
        //    "CSystem::ComputeODE2SingleLoadLTG: load dependencies not implemented");

        for (Index item : dependencies)
        {
            ltgODE1coords.AppendIfItemNotFound(item); //this search takes n*n operations, but n should be very small
        }
    }
}

//! precompute load dependency lists needed for jacobians of loads
void CSystem::JacobianODE2Loads(TemporaryComputationDataArray& tempArray, const NumericalDifferentiationSettings& numDiff,
    GeneralMatrix& jacobianGM, Real factorODE2, Real factorODE2_t, Real factorODE1)
{

    //compute dependencies not needed, as ltgs can be easily retrieved on the fly

    //ComputeODE2LoadsJacobian:
    //  check jacobian computation template first => what information do we need (LTG, etc.)?
    //  ComputeSingleLoadMarkerLTG(ltg) => fill in ltg, also for node markers
    //  add flag for ComputeSingleLoad: noLTG=true/false: will fill into local vector
    TemporaryComputationData& temp = tempArray[0]; //always exists
    //temp.jacobianODE2Container.ClearAllMatrices();

    ResizableVector& f0 = temp.numericalJacobianf0;
    ResizableVector& f1 = temp.numericalJacobianf1;
    ResizableMatrix& localJacobian = temp.localJacobian;
    Real currentTime = cSystemData.GetCData().currentState.time;

    ArrayIndex& ltgODE2eq     = temp.tempIndex;
    ArrayIndex& ltgODE2coords = temp.tempIndex2;
    ArrayIndex& ltgODE1coords = temp.tempIndex3;
    //ArrayIndex ltgODE2eq; //causes new => put into tempArray
    //ArrayIndex ltgODE1coords; //causes new => put into tempArray
    //ArrayIndex ltgODE2coords; //causes new => put into tempArray

    //Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
    //Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
    //Vector& xODE1 = cSystemData.GetCData().currentState.ODE1Coords;			//current coordinates ==> this is what is differentiated for
    Vector& xODE2 = cSystemData.GetCData().currentState.ODE2Coords;			//current coordinates ==> this is what is differentiated for
    //Vector& xRefODE1 = cSystemData.GetCData().referenceState.ODE1Coords;	//reference coordinates; might be important for numerical differentiation
    Vector& xRefODE2 = cSystemData.GetCData().referenceState.ODE2Coords;	//reference coordinates; might be important for numerical differentiation
    Vector& xODE2_t = cSystemData.GetCData().currentState.ODE2Coords_t;		//for diff w.r.t. velocities

    const bool fillSparseVector = false;
    const bool fillInLocally = true;
    bool addODE2_t = (factorODE2_t != 0.);

    Index nLoads = cSystemData.GetCLoads().NumberOfItems();
    for (Index j = 0; j < nLoads; j++)
    {
        ComputeODE2SingleLoadLTG(j, ltgODE2eq, ltgODE2coords, ltgODE1coords);
        Index nLocalODE2eq = ltgODE2eq.NumberOfItems();
        Index nLocalODE2coords = ltgODE2coords.NumberOfItems();
        //Index nLocalODE1coords = ltgODE1coords.NumberOfItems();

        if (nLocalODE2eq != 0)
        {
            //pout << "load" << j << "jac LTGeq=" << ltgODE2eq << ", LTGco=" <<  ltgODE2coords << "\n";

            f0.SetNumberOfItems(nLocalODE2eq);
            f1.SetNumberOfItems(nLocalODE2eq);

            ComputeODE2SingleLoad(j, temp, currentTime, f0, fillSparseVector, fillInLocally);
            localJacobian.SetNumberOfRowsAndColumns(nLocalODE2eq, nLocalODE2coords); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM

            AddNumDiffObject(numDiff, -factorODE2, xODE2, xRefODE2, localJacobian, f0, f1, ltgODE2coords, //- in factorODE2 is questionable ...
                [this, &temp, &currentTime, &f1, &j, &fillSparseVector, &fillInLocally]
            {
                ComputeODE2SingleLoad(j, temp, currentTime, f1, fillSparseVector, fillInLocally);
                //ComputeObjectODE1RHS(temp, object, f1, j);
            }, true); //set values
            //pout << "add jac=" << localJacobian << "\n";

            if (addODE2_t)
            {
                AddNumDiffObject(numDiff, -factorODE2_t, xODE2_t, Vector(), localJacobian, f0, f1, ltgODE2coords,
                    [this, &temp, &currentTime, &f1, &j, &fillSparseVector, &fillInLocally]
                {
                    ComputeODE2SingleLoad(j, temp, currentTime, f1, fillSparseVector, fillInLocally);
                    //ComputeObjectODE1RHS(temp, object, f1, j);
                }, false); //add values

            }
            //pout << "jac LTG=" << ltgODE2 << "\n";
            //pout << "   jac =" << localJacobian << "\n";
            jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE2eq, ltgODE2coords, 0, 0);
        }
        if (ltgODE1coords.NumberOfItems() != 0)
        {
            CHECKandTHROWstring("JacobianODE2Loads: dependency on ODE1 coordinates not implemented; set computeLoadsJacobian=False in solver settings");
        }


    }
}


//! compute system right-hand-side (RHS) of first order ordinary differential equations (ODE) to 'ode1rhs' for ODE1 part
void CSystem::ComputeODE1Loads(TemporaryComputationData& temp, Vector& systemODE1Rhs)
{
	//STARTGLOBALTIMER(TScomputeLoads);

	Index nLoads = cSystemData.GetCLoads().NumberOfItems();
	//Vector3D loadVector3D(0); //initialization in order to avoid gcc warnings
	Vector1D loadVector1D(0); //scalar loads...//initialization in order to avoid gcc warnings
	bool loadVector1Ddefined = false; //add checks such that wrong formats would fail
	//bool loadVector3Ddefined = false; //add checks such that wrong formats would fail
    __UNUSED(loadVector1Ddefined); //avoid unused variable warnings

	Real currentTime = cSystemData.GetCData().currentState.time;
	for (Index j = 0; j < nLoads; j++)
	{
		CLoad* cLoad = cSystemData.GetCLoads()[j];
		Index markerNumber = cLoad->GetMarkerNumber();
		CMarker* marker = cSystemData.GetCMarkers()[markerNumber];

		Index nodeCoordinate = 99999;//initialize with arbitrary value for gcc; starting index for nodes (consecutively numbered)
		bool applyLoad = false;		//loads are not applied to ground objects/nodes

		if (marker->GetType() & Marker::Node) //code for body markers
		{
			Index markerNodeNumber = marker->GetNodeNumber();
			if (!cSystemData.GetCNodes()[markerNodeNumber]->IsGroundNode()) //if node has zero coordinates ==> ground node; no action on ground nodes!
			{
				if (EXUstd::IsOfType((Index)marker->GetType(), Marker::Coordinate + Marker::ODE1))
				{
					nodeCoordinate = cSystemData.GetCNodes()[markerNodeNumber]->GetGlobalODE1CoordinateIndex();
					applyLoad = true;
				}
			}
		}

		if (applyLoad)
		{
			if (cLoad->IsVector())
			{
				//loadVector3D = cLoad->GetLoadVector(cSystemData.GetMainSystemBacklink(), currentTime);
				//loadVector3Ddefined = true;
				CHECKandTHROW(true, "ComputeODE1Loads(...): illegal 3D force vector ");
			}
			else
			{
				loadVector1D = Vector1D(cLoad->GetLoadValue(cSystemData.GetMainSystemBacklink(), currentTime));
				loadVector1Ddefined = true;
			}

			//AccessFunctionType aft = GetAccessFunctionType(loadType, marker->GetType());
			//==> lateron: depending on AccessFunctionType compute jacobians, put into markerDataStructure as in connectors
			//    and call according jacobian function
			//    marker->GetAccessFunctionJacobian(AccessFunctionType, ...) ==> handles automatically the jacobian
			Real loadFactor = solverData.loadFactor; //copy
			if (cLoad->HasUserFunction())
			{
				loadFactor = 1.; //loadFactor not used for case of user functions, see issue #603
			}

			LoadType loadType = cLoad->GetType();
			if (loadType == LoadType::Coordinate)
			{
				const bool computeJacobian = true;
				CHECKandTHROW(loadVector1Ddefined, "ComputeODE1Loads(...): illegal force vector format (expected 1D load)");
				marker->ComputeMarkerData(cSystemData, computeJacobian, temp.markerDataStructure.GetMarkerData(0)); //currently, too much is computed; but could be pre-processed in parallel
				EXUmath::MultMatrixTransposedVector(temp.markerDataStructure.GetMarkerData(0).jacobian, loadVector1D, temp.generalizedLoad); //generalized load: Q = (dRot/dq)^T * Torque
			}
			else { CHECKandTHROWstring("ERROR: CSystem::ComputeSystemODE1RHS, LoadType not implemented!"); }

			//ResizableArray<CObject*>& objectList = cSystemData.GetCObjects();
			//pout << "genLoad=" << temp.generalizedLoad << "\n";

			//pout << "  nodeCoordinate=" << nodeCoordinate << "\n";
			for (Index k = 0; k < temp.generalizedLoad.NumberOfItems(); k++)
			{
				systemODE1Rhs[nodeCoordinate + k] += loadFactor * temp.generalizedLoad[k];
			}
		}

	}
	//STOPGLOBALTIMER(TScomputeLoads);
}

//! compute system right-hand-side (RHS) of algebraic equations (AE) to vector 'AERhs'
void CSystem::ComputeAlgebraicEquations(TemporaryComputationDataArray& tempArray, Vector& algebraicEquations, bool velocityLevel)
{
	//Still needed? algebraicEquations.SetNumberOfItems(cSystemData.GetNumberOfCoordinatesAE()); //needed for numerical differentiation
	algebraicEquations.SetAll(0.);
	TemporaryComputationData& temp = tempArray[0];

	//+++++++++++++++++++++++++++++++++++++++++++++++++
	//usually does not exist / rare!
	for (Index j : cSystemData.objectsBodyWithAE)
	{
		//work over bodies, connectors, etc.
		ArrayIndex& ltg = cSystemData.GetLocalToGlobalAE()[j];

		cSystemData.GetCObjects()[j]->ComputeAlgebraicEquations(temp.localAE, velocityLevel); //no time given for objects for now (only Euler parameters...)

		CHECKandTHROW(ltg.NumberOfItems() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: objectsBodyWithAE: ltg size mismatch");
		//now add RHS to system vector
		for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
		{
			algebraicEquations[ltg[k]] += temp.localAE[k];
		}
	}
	//+++++++++++++++++++++++++++++++++++++++++++++++++

	//algebraic equations only origin from objects (e.g. Euler parameters) and constraints

	int nItemsObjectsNoUF = cSystemData.objectsConstraintWithAENoUF.NumberOfItems();
	int nItemsNodes = cSystemData.nodesODE2WithAE.NumberOfItems();
	int nItemsNodesObjectsNoUF = nItemsObjectsNoUF + nItemsNodes;

	Index nThreads = exuThreading::TaskManager::GetNumThreads();
	bool doParallel = (nThreads > 1) && (nItemsNodesObjectsNoUF >= solverData.multithreadedLLimitResiduals);

	//+++++++++++++++++++++++++++++++++++++++
	//parallel objects, no user function
	if (doParallel)
	{
		//std::mutex mtx;           // mutex for critical section
		outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation
        tempArray.SetNumberOfItems(nThreads); //only affected, if nThreads changed

		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}

		//gives factor 7.5 for 12 threads with taskSplit nThreads*16, 100 bodies-revolute joint chain
		Index taskSplit = GetTaskSplit(nItemsNodesObjectsNoUF, nThreads);
		exuThreading::ParallelFor(nItemsNodesObjectsNoUF, [this, &algebraicEquations, &velocityLevel, &tempArray, 
			&nItemsNodes, &nItemsObjectsNoUF, &nItemsNodesObjectsNoUF](NGSsizeType j) 
		{
			Index threadID = exuThreading::TaskManager::GetThreadId();
			TemporaryComputationData& temp = tempArray[threadID];

			if ((Index)j < nItemsNodes)
			{
				Index i = cSystemData.nodesODE2WithAE[(Index)j];
				//for (Index i : cSystemData.nodesODE2WithAE)
				{
					Index aeIndex = cSystemData.GetCNode(i).GetGlobalAECoordinateIndex();

					((CNodeODE2&)(cSystemData.GetCNode(i))).ComputeAlgebraicEquations(temp.localAE, velocityLevel);

					//now add RHS to system vector
					for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
					{
						//algebraicEquations[k + aeIndex] += temp.localAE[k];
						tempArray[threadID].sparseVector.AddIndexAndValue(k + aeIndex, temp.localAE[k]);
					}
				}
			}
			else
			{
				Index i = cSystemData.objectsConstraintWithAENoUF[(Index)j - nItemsNodes];
				//for (Index j : listObjectsSerial)
				{
					CObjectConstraint* constraint = (CObjectConstraint*)(cSystemData.GetCObjects()[i]);
					ArrayIndex& ltg = cSystemData.GetLocalToGlobalAE()[i];

					const bool computeJacobian = false;
					cSystemData.ComputeMarkerDataStructure(constraint, computeJacobian, temp.markerDataStructure);

					constraint->ComputeAlgebraicEquations(temp.localAE, temp.markerDataStructure, cSystemData.GetCData().currentState.time, i, velocityLevel);

					//CHECKandTHROW(ltg.NumberOfItems() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: ltg size mismatch");
					//now add RHS to system vector
					for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
					{
						//algebraicEquations[ltg[k]] += temp.localAE[k]; //negative sign ==> check sign of Lagrange multipliers
						tempArray[threadID].sparseVector.AddIndexAndValue(ltg[k], temp.localAE[k]);
					}
				}
			}

		}, taskSplit);


		outputBuffer.SetSuspendWriting(false);

		//STARTGLOBALTIMER(TSreactionForces1);
		//serial section for writing into system vector //currently makes up 6 percent of total time for 1000 body-revolute chain!
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				algebraicEquations[item.GetIndex()] += item.GetValue(); //minus: LHS->RHS
			}
		}
		//STOPGLOBALTIMER(TSreactionForces1);

	}





	if (!doParallel) //SERIAL
	{

		for (Index i : cSystemData.nodesODE2WithAE)
		{
			//pout << "add algebraic equations for nodes\n";
			//work over bodies, connectors, etc.
			Index aeIndex = cSystemData.GetCNode(i).GetGlobalAECoordinateIndex();

			((CNodeODE2&)(cSystemData.GetCNode(i))).ComputeAlgebraicEquations(temp.localAE, velocityLevel);

			CHECKandTHROW(cSystemData.GetCNode(i).GetNumberOfAECoordinates() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: nodesODE2WithAE: size mismatch");
			//now add RHS to system vector
			for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
			{
				algebraicEquations[k + aeIndex] += temp.localAE[k];
			}
		}
	}

	//SERIAL / PARALLEL: either with user functions or all (serial):
	const ArrayIndex& listObjectsSerial = doParallel ? cSystemData.objectsConstraintWithAEUF : cSystemData.objectsConstraintWithAE;
	{
		for (Index i : listObjectsSerial)
		{
			CObjectConstraint* constraint = (CObjectConstraint*)(cSystemData.GetCObjects()[i]);
			ArrayIndex& ltg = cSystemData.GetLocalToGlobalAE()[i];

			const bool computeJacobian = false;
			//STARTGLOBALTIMER(TScomputeConnectorsMarkerData);
			cSystemData.ComputeMarkerDataStructure(constraint, computeJacobian, temp.markerDataStructure);
			//STOPGLOBALTIMER(TScomputeConnectorsMarkerData);

			//STARTGLOBALTIMER(TScomputeAlgebraicEquations);
			constraint->ComputeAlgebraicEquations(temp.localAE, temp.markerDataStructure, cSystemData.GetCData().currentState.time, i, velocityLevel);
			//STOPGLOBALTIMER(TScomputeAlgebraicEquations);

			CHECKandTHROW(ltg.NumberOfItems() == temp.localAE.NumberOfItems(), "CSystem::ComputeAlgebraicEquations: ltg size mismatch");
			//now add RHS to system vector
			for (Index k = 0; k < temp.localAE.NumberOfItems(); k++)
			{
				algebraicEquations[ltg[k]] += temp.localAE[k]; //negative sign ==> check sign of Lagrange multipliers
			}
		}
	}

}

//! PostNewtonStep: do this for every object (connector), which has a PostNewtonStep ->discontinuous iteration e.g. to resolve contact, friction or plasticity
//! recommendedStepSize must be initialized with -1 or previous recommendation: [< 0: no recommendation, 0: use minimum step size, >0: use specific step size, if no smaller size requested by other reason]
Real CSystem::PostNewtonStep(TemporaryComputationDataArray& tempArray, Real& recommendedStepSize)
{
	//recommendedStepSize (must be initialized with -1 or appropriately)
	Real PNerror = 0;
	int nItems = cSystemData.listDiscontinuousIteration.NumberOfItems();
	if (nItems != 0) //save time here!
	{
		Index nThreads = exuThreading::TaskManager::GetNumThreads();
		bool doMultiThreading = false;
		exuThreading::TotalCosts costs = 0; //costs < 1000 does no multithreading, ParallelFor turns into regular for loop [with small overhead]

		if (nThreads > 1)
		{
            tempArray.SetNumberOfItems(nThreads); //only affected, if nThreads changed
			
            if (nItems >= solverData.multithreadedLLimitResiduals)
            {
                outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation
                doMultiThreading = true;
                costs = 1000;
            }
		}
		for (Index k=0; k<nThreads; k++)
		{
			tempArray[k].tempValue = 0; //PNerror
			tempArray[k].tempValue2 = recommendedStepSize; //recommended step size
			tempArray[k].tempIndex.SetNumberOfItems0(); //stores object indices which shall get a ltg-rebuild
		}

		Index taskSplit = GetTaskSplit(nItems, nThreads);
		exuThreading::ParallelFor(nItems, [this, &tempArray, &nItems](NGSsizeType j)
		{
			Index i = cSystemData.listDiscontinuousIteration[(Index)j];
			Index threadID = exuThreading::TaskManager::GetThreadId();
			PostNewtonFlags::Type postNewtonFlags;

			TemporaryComputationData& temp = tempArray[threadID];
			Real& recommendedStepSizeLocal = temp.tempValue2;
			
			//for (Index i : cSystemData.listDiscontinuousIteration) //serial
			//{
			CObjectConnector* connector = (CObjectConnector*)(cSystemData.GetCObjects()[i]);

			if (connector->IsActive()) //usually is active ...
			{
				const bool computeJacobian = true; //why needed for PostNewtonStep?==> check Issue #241
				cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);

				Real objectRecomStepSize = -1;
				temp.tempValue = EXUstd::Maximum(connector->PostNewtonStep(temp.markerDataStructure, i, 
					postNewtonFlags, objectRecomStepSize), temp.tempValue);
				if (objectRecomStepSize >= 0 && (objectRecomStepSize < recommendedStepSizeLocal || recommendedStepSizeLocal == -1))
				{
					recommendedStepSizeLocal = objectRecomStepSize;
				}

				if (postNewtonFlags&PostNewtonFlags::UpdateLTGLists)
				{
					temp.tempIndex.Append(i);
				}
			}
		}, taskSplit, costs);

		if (doMultiThreading) { outputBuffer.SetSuspendWriting(false); } //may not write to python during parallel computation

		//now collect results from threads:
		for (Index k = 0; k < nThreads; k++)
		{
			TemporaryComputationData& temp = tempArray[k];
			PNerror = EXUstd::Maximum(temp.tempValue, PNerror);

			Real recommendedStepSizeThread = temp.tempValue2;
			if (recommendedStepSizeThread >= 0 && (recommendedStepSizeThread < recommendedStepSize || recommendedStepSize == -1))
			{
				recommendedStepSize = recommendedStepSizeThread;
			}

			//ltg-rebuild should be rare, but needs to be done in serial mode!
			for (Index i : temp.tempIndex)
			{
				//now update specific ltg lists, if e.g. due to contact or switching the connectivity has changed
				AssembleObjectLTGLists(i, cSystemData.GetLocalToGlobalODE2()[i], cSystemData.GetLocalToGlobalODE1()[i],
					cSystemData.GetLocalToGlobalAE()[i], cSystemData.GetLocalToGlobalData()[i]);
			}
		}

	}

	//this part is anyway done in parallel:
	for (GeneralContact* gc : generalContacts) //usually only 1
	{
		STARTGLOBALTIMER(TScomputeGeneralContact);
		PNerror = EXUstd::Maximum(gc->PostNewtonStep(*this, tempArray, recommendedStepSize),  PNerror);
		STOPGLOBALTIMER(TScomputeGeneralContact);
	}


	return PNerror;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CSystem::PostDiscontinuousIterationStep()
{
	//for (CObject* object : cSystemData.GetCObjects())
	for (Index i : cSystemData.listDiscontinuousIteration)
	{
		CObjectConnector* connector = (CObjectConnector*)(cSystemData.GetCObjects()[i]);

		if (connector->IsActive()) //usually is active ...
		{
			connector->PostDiscontinuousIterationStep();
		}
	}
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                          JACOBIANS
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! compute numerical differentiation of ODE2RHS w.r.t. ODE2 and ODE2_t quantities; 
//! multiply (before added to jacobianGM) ODE2 with factorODE2 and ODE2_t with factorODE2_t
//! the jacobian is ADDed to jacobianGM, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
void CSystem::JacobianODE2RHS(TemporaryComputationDataArray& tempArray, const NumericalDifferentiationSettings& numDiff,
	GeneralMatrix& jacobianGM, Real factorODE2, Real factorODE2_t, Real factorODE1, Index computeLoadsJacobian)
{
	TemporaryComputationData& temp = tempArray[0]; //always exists
	temp.jacobianODE2Container.ClearAllMatrices();

	ResizableVector& f0 = temp.numericalJacobianf0;
	ResizableVector& f1 = temp.numericalJacobianf1;

	//Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	//Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	//Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();

	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;			//current coordinates ==> this is what is differentiated for
	Vector& xRef = cSystemData.GetCData().referenceState.ODE2Coords;	//reference coordinates; might be important for numerical differentiation
	Vector& xODE1 = cSystemData.GetCData().currentState.ODE1Coords;			//current coordinates ==> this is what is differentiated for
	Vector& xRefODE1 = cSystemData.GetCData().referenceState.ODE1Coords;	//reference coordinates; might be important for numerical differentiation

	//Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation
	Vector& x_t = cSystemData.GetCData().currentState.ODE2Coords_t;		//for diff w.r.t. velocities

	bool diffODE2 = (factorODE2 != 0.);
	bool diffODE2_t = (factorODE2_t != 0.);
	bool diffODE1 = (factorODE1 != 0.);
	
	Vector emptyXRef; //for NumDiff template

	if (!numDiff.doSystemWideDifferentiation)
	{
		ResizableMatrix& localJacobian = temp.localJacobian;

		//++++++++++++++++++++++++++++++++++++++++++++++++
		//for parallelized version add list to distinguish between parallelizable jacs and serial
		for (Index j : cSystemData.listComputeObjectODE2Lhs)
		{
			CObject* object = cSystemData.GetCObjects()[j];
			if (object->IsActive())
			{
				ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];
				Index nLocalODE2 = ltgODE2.NumberOfItems();

				JacobianType::Type jacType = object->GetAvailableJacobians();

				bool jacobianComputed = false;
				if (jacType & (JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t + JacobianType::ODE2_ODE1)) //any ODE2 dependency
				{
					//pout << "jacobian object " << j << "\n";
					if (!numDiff.forODE2 && ((jacType & (JacobianType::ODE2_ODE2_function + JacobianType::ODE2_ODE2_t_function/* + JacobianType::ODE2_ODE1_function*/)) != 0))
					{
						if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
						{   // ++++++++++++++ compute object jacobian, e.g., finite element or rigid body
							jacobianComputed = true;

							//matrix size set inside object
							object->ComputeJacobianODE2_ODE2(temp.jacobianODE2Container, temp.jacobianTemp,
								-factorODE2, -factorODE2_t, j, ltgODE2); //minus (-) because in numerical mode, f0-f1 leads to negative sign (RHS ==> LHS)
							//ODE2_ODE1 missing here!
							if (temp.jacobianODE2Container.UseDenseMatrix())
							{
								jacobianGM.AddSubmatrix(temp.jacobianODE2Container.GetInternalDenseMatrix(), 1., ltgODE2, ltgODE2);
							}
							else
							{
								jacobianGM.AddSparseTriplets(temp.jacobianODE2Container.GetInternalSparseTripletMatrix().GetTriplets());
								//sparse matrix container cannot be reset in jacobian function for future implementations
								//==>replace this by directly adding values to jacobianGM sparse triplets in object jacobian
								temp.jacobianODE2Container.GetInternalSparseTripletMatrix().SetAllZero();
							}
						} //if (!EXUstd::IsOfType(object->GetType(), CObjectType::Connector)
						else if (!numDiff.forODE2connectors)
						{	// ++++++++++++++ go the lengthier way: compute connector jacobian, e.g., spring-damper
							CObjectConnector* connector = (CObjectConnector*)object;
							//pout << "analytic jac connector \n";
							const ArrayIndex& markerNumbers = connector->GetMarkerNumbers();
							jacobianComputed = true;
							bool jacDerivNonZero = false;
							if (numDiff.jacobianConnectorDerivative) //if ignored, it will not be considered
							{
								for (Index k = 0; k < markerNumbers.NumberOfItems(); k++)
								{
									jacobianComputed &= ((cSystemData.GetCMarker(markerNumbers[k]).GetType() & Marker::JacobianDerivativeAvailable) != 0);
									jacDerivNonZero |= ((cSystemData.GetCMarker(markerNumbers[k]).GetType() & Marker::JacobianDerivativeNonZero) != 0);
								}
							}

							if (jacobianComputed)
							{
								//pout << "  continue\n";
								//compute MarkerData for connector:
								const bool computeJacobian = true; //jacobian needed for jacobian computation ...
								cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, temp.markerDataStructure);
								//pout << "compute connector " << j << " jacobian \n";
								if (jacDerivNonZero) //call needed, if one marker has non-zero derivative ==> compute jacobianForce for both cases
								{
									Vector6D jacobianForce;
									connector->ComputeJacobianForce6D(temp.markerDataStructure, j, jacobianForce);
									//even though that force on marker0 acts with negative sign, 
									//  the different signs are accounted for in connector->ComputeJacobianODE2_ODE2(...)
									//  ==> but this could also be done here !
									//pout << "  jacobian force = " << temp.jacobianForce << " \n";
									for (Index k = 0; k < markerNumbers.NumberOfItems(); k++)
									{
										cSystemData.GetCMarkers()[markerNumbers[k]]->ComputeMarkerDataJacobianDerivative(cSystemData,
											jacobianForce, temp.markerDataStructure.GetMarkerData(k));
										//pout << "  compute non-zero jacobian derivative" << k << ": " << temp.markerDataStructure.GetMarkerData(k).jacobianDerivative << " \n";
									}
								}
								else
								{
									//clear jacobianDerivative!!!
									for (Index k = 0; k < markerNumbers.NumberOfItems(); k++)
									{
										temp.markerDataStructure.GetMarkerData(k).jacobianDerivative.SetNumberOfRowsAndColumns(0, 0);
									}
								}

								connector->ComputeJacobianODE2_ODE2(temp.jacobianODE2Container, temp.jacobianTemp, 
									-factorODE2, -factorODE2_t, j, ltgODE2, temp.markerDataStructure);


								if (temp.jacobianODE2Container.UseDenseMatrix())
								{
									jacobianGM.AddSubmatrix(temp.jacobianODE2Container.GetInternalDenseMatrix(), 1., ltgODE2, ltgODE2);
									//pout << "jacA" << j << "=np.array(" << temp.jacobianODE2Container.GetInternalDenseMatrix() << ")\n";
								}
								else
								{
									jacobianGM.AddSparseTriplets(temp.jacobianODE2Container.GetInternalSparseTripletMatrix().GetTriplets());
								}
							}
						} //if (numDiff.forODE2connectors)
					}


					//++++++++++++++++++++++++++++++++++++++++++++++++++++
					//no analytic jacobians so far? => do numerical differentiation!
					if (!jacobianComputed)
					{
						ArrayIndex& ltgODE2numDiff = cSystemData.GetLocalToGlobalODE2NumDiff()[j];
						//pout << "ltgODE2numDiff = " << ltgODE2numDiff << "\n";
						//ArrayIndex& ltgODE2numDiff = cSystemData.GetLocalToGlobalODE2()[j];
						Index nLocalODE2numDiff = ltgODE2numDiff.NumberOfItems(); //this is a possibly shorter list with no duplicates!
						nLocalODE2 = ltgODE2.NumberOfItems();

						f0.SetNumberOfItems(nLocalODE2); //size also correct for ODE1 derivatives
						f1.SetNumberOfItems(nLocalODE2);
						if (ComputeObjectODE2LHS(temp, object, f0, j)) //check if it is active; constraints not included any more in listComputeObjectODE2Lhs
						{
							//pout << "f0 = " << f0 << "\n";
							localJacobian.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE2numDiff); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
							if (diffODE2)
							{
								SetNumDiffObjectLieGroup(numDiff, factorODE2, x, xRef, localJacobian, f0, f1, ltgODE2numDiff, cSystemData,
									[this, &temp, &object, &f1, &j]
								{
									ComputeObjectODE2LHS(temp, object, f1, j);
								});

							}
							else { localJacobian.SetAll(0.); }

							if (diffODE2_t && EXUstd::IsOfType(jacType, JacobianType::ODE2_ODE2_t))
							{
								AddNumDiffObject(numDiff, factorODE2_t, x_t, emptyXRef, localJacobian, f0, f1, ltgODE2numDiff, 
									[this, &temp, &object, &f1, &j]
								{
									ComputeObjectODE2LHS(temp, object, f1, j);
								});
							}

							jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE2, ltgODE2numDiff);
							//pout << "jacN" << j << "=np.array(" << localJacobian << ")\n";

							if (diffODE1 && (jacType & JacobianType::ODE2_ODE1))
							{
								ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];
								Index nLocalODE1 = ltgODE1.NumberOfItems(); //here, duplicates would also need to be extracted!

								localJacobian.SetNumberOfRowsAndColumns(nLocalODE2, nLocalODE1); //needs not to be initialized, beause the matrix is fully computed and then added to jacobianGM

								AddNumDiffObject(numDiff, factorODE1, xODE1, xRefODE1, localJacobian, f0, f1, ltgODE1,
									[this, &temp, &object, &f1, &j]
								{
									ComputeObjectODE2LHS(temp, object, f1, j);
								}, true); //true=set values

								jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE2, ltgODE1, 0, nODE2); //fill into ODE2 rows, ODE1 columns
							}
						}
					}
				}
			}//isActive
		}//loop over objects
	}
	else
	{
		//done in solver: jacobian.SetNumberOfRowsAndColumns(nODE2, nODE2);

		//++++++++++++++++++++++++++++++++++++++++++++++++
		f0.SetNumberOfItems(nODE2);
		f1.SetNumberOfItems(nODE2);
		ComputeSystemODE2RHS(tempArray, f0); //compute nominal value for jacobian; same for Lie group and other nodes
        //Real xRefVal = 0;

		if (diffODE2)
		{
            if (!cSystemData.HasLieGroupDUNodes())
            {
                EXUmath::NumericalDifferentiation(0, nODE2, numDiff, factorODE2, x, xRef, jacobianGM, f0, f1, [this, &tempArray, &f1]
                {
                    ComputeSystemODE2RHS(tempArray, f1);
                });
            }
            else //Lie group derivatives need special treatment!
            {
				AddNumDiffLieGroup(0, nODE2, numDiff, factorODE2, x, xRef, jacobianGM, f0, f1, cSystemData,
					[this, &tempArray, &f1]
				{
					ComputeSystemODE2RHS(tempArray, f1);
                });
            }
		}

		if (diffODE2_t)
		{
            EXUmath::NumericalDifferentiation(0, nODE2, numDiff, factorODE2_t, x_t, jacobianGM, f0, f1, [this, &tempArray, &f1]
            {
                ComputeSystemODE2RHS(tempArray, f1);
            });
		}
		if (diffODE1 && nODE1 != 0)
		{
			//++++++++++++++++++++++++++++++++++++++++++++++++
			//for ODE2-ODE1:
            EXUmath::NumericalDifferentiation(0, nODE1, numDiff, factorODE1, xODE1, xRefODE1, jacobianGM, f0, f1, [this, &tempArray, &f1]
            {
                ComputeSystemODE2RHS(tempArray, f1);
            }, nODE2, 0); //columnOffset, rowOffset
		}
	}
	//pout << "ODE2jac=" << jacobian << "\n";
	//cSystemData.isODE2RHSjacobianComputation = false; //hack! only for debugging

    if (!numDiff.doSystemWideDifferentiation) //otherwise these parts would appear twice!
    {
        if (computeLoadsJacobian) //in case of doSystemWideDifferentiation it is done already above
        {
            Real loadsFactorODE2_t = (computeLoadsJacobian > 1) ? factorODE2_t : 0.;

            JacobianODE2Loads(tempArray, numDiff, jacobianGM, factorODE2, loadsFactorODE2_t, factorODE1);
        }


        //this part is anyway done in parallel:
        for (GeneralContact* gc : generalContacts) //usually only 1
        {
            STARTGLOBALTIMER(TScomputeGeneralContact);
            gc->JacobianODE2LHS(*this, tempArray, numDiff, jacobianGM, -factorODE2, -factorODE2_t); //negative sign, because contact computes LHS jacobian!
            STOPGLOBALTIMER(TScomputeGeneralContact);
        }
    }

}





//! compute numerical differentiation of ODE1RHS; result is a jacobian;  multiply the added entries with scalarFactor
//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
void CSystem::NumericalJacobianODE1RHS(TemporaryComputationDataArray& tempArray, const NumericalDifferentiationSettings& numDiff,
	GeneralMatrix& jacobianGM, Real factorODE2, Real factorODE2_t, Real factorODE1)
{
	//size needs to be set accordingly in the caller function; components are added to jacobian!
	TemporaryComputationData& temp = tempArray[0]; //first array does always exist!
	temp.jacobianODE2Container.ClearAllMatrices();

	ResizableVector& f0 = temp.numericalJacobianf0;
	ResizableVector& f1 = temp.numericalJacobianf1;


	//Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	//Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum

	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
	Vector& xODE1 = cSystemData.GetCData().currentState.ODE1Coords;			//current coordinates ==> this is what is differentiated for
	Vector& xODE2 = cSystemData.GetCData().currentState.ODE2Coords;			//current coordinates ==> this is what is differentiated for
	Vector& xRefODE1 = cSystemData.GetCData().referenceState.ODE1Coords;	//reference coordinates; might be important for numerical differentiation
	Vector& xRefODE2 = cSystemData.GetCData().referenceState.ODE2Coords;	//reference coordinates; might be important for numerical differentiation
	Vector& xODE2_t = cSystemData.GetCData().currentState.ODE2Coords_t;		//for diff w.r.t. velocities

	bool diffODE1 = (factorODE1 != 0. && nODE1 != 0);
	bool diffODE2 = (factorODE2 != 0. && nODE2 != 0);
	bool diffODE2_t = (factorODE2_t != 0. && nODE2 != 0);
	//diffODE2 = false;
	//diffODE2_t = false;

	if (!numDiff.doSystemWideDifferentiation)
	{
		ResizableMatrix& localJacobian = temp.localJacobian;

		for (Index j : cSystemData.listComputeObjectODE1Rhs)
		{
			ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2NumDiff()[j];
			CObject* object = cSystemData.GetCObjects()[j];

			Index nLocalODE1 = ltgODE1.NumberOfItems();
			Index nLocalODE2 = ltgODE2.NumberOfItems();
			f0.SetNumberOfItems(nLocalODE1);
			f1.SetNumberOfItems(nLocalODE1);
			JacobianType::Type jacType = object->GetAvailableJacobians();

			if (ComputeObjectODE1RHS(temp, object, f0, j))
			{
				//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				//compute ODE1-ODE1:
				localJacobian.SetNumberOfRowsAndColumns(nLocalODE1, nLocalODE1); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM

				AddNumDiffObject(numDiff, -factorODE1, xODE1, xRefODE1, localJacobian, f0, f1, ltgODE1,
					[this, &temp, &object, &f1, &j]
				{
					ComputeObjectODE1RHS(temp, object, f1, j);
				}, true); //set values

				jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE1, ltgODE1, nODE2, nODE2);

				//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				//compute ODE1-ODE2:
				if (nLocalODE2) //for ODE1-ODE2 coupling
				{
					localJacobian.SetNumberOfRowsAndColumns(nLocalODE1, nLocalODE2); //needs not to be initialized, because the matrix is fully computed and then added to jacobianGM
					localJacobian.SetAll(0.);
					if (diffODE2 && EXUstd::IsOfType(jacType, JacobianType::ODE1_ODE2))
					{
						AddNumDiffObject(numDiff, -factorODE2, xODE2, xRefODE2, localJacobian, f0, f1, ltgODE2, //(-) sign because of RHS, f1-f0 !
							[this, &temp, &object, &f1, &j]
						{
							ComputeObjectODE1RHS(temp, object, f1, j);
						}, true); //set values!

					}

					if (diffODE2_t && EXUstd::IsOfType(jacType, JacobianType::ODE1_ODE2_t))
					{
						AddNumDiffObject(numDiff, -factorODE2_t, xODE2_t, Vector(), localJacobian, f0, f1, ltgODE2, //(-) sign because of RHS, f1-f0 !
							[this, &temp, &object, &f1, &j]
						{
							ComputeObjectODE1RHS(temp, object, f1, j);
						});
					}
					jacobianGM.AddSubmatrix(localJacobian, 1., ltgODE1, ltgODE2, nODE2, 0);
				}
			}
		}
	}
	else
	{
        //systemwide differentiation
		//++++++++++++++++++++++++++++++++++++++++++++++++
		f0.SetNumberOfItems(nODE1);
		f1.SetNumberOfItems(nODE1);
		ComputeSystemODE1RHS(temp, f0); //compute nominal value for jacobian
		Index rowOffset = nODE2;
		//Real xRefVal = 0;

		//for ODE1-ODE1:
		if (diffODE1)
		{
            EXUmath::NumericalDifferentiation(0, nODE1, numDiff, factorODE1, xODE1, xRefODE1, jacobianGM, f0, f1, [this, &temp, &f1]
            {
                ComputeSystemODE1RHS(temp, f1);
            }, nODE2, rowOffset); //columnOffset, rowOffset

		}
		//++++++++++++++++++++++++++++++++++++++++++++++++
		//for ODE1-ODE2:
		if (diffODE2)
		{
			if (!cSystemData.HasLieGroupDUNodes())
			{
				EXUmath::NumericalDifferentiation(0, nODE2, numDiff, factorODE2, xODE2, xRefODE2, jacobianGM, f0, f1, [this, &temp, &f1]
				{
					ComputeSystemODE1RHS(temp, f1);
				}, 0, rowOffset); //columnOffset, rowOffset
			}
			else //Lie group derivatives need special treatment!
			{
				AddNumDiffLieGroup(0, nODE2, numDiff, factorODE2, xODE2, xRefODE2, jacobianGM, f0, f1, cSystemData,
					[this, &temp, &f1]
				{
					ComputeSystemODE1RHS(temp, f1);
				}, 0, rowOffset);
			}
		}
		if (diffODE2_t)
		{
            EXUmath::NumericalDifferentiation(0, nODE2, numDiff, factorODE2_t, xODE2_t, jacobianGM, f0, f1, [this, &temp, &f1]
            {
                ComputeSystemODE1RHS(temp, f1);
            }, 0, rowOffset); //columnOffset, rowOffset
		}
	}
	//pout << "ODE2jac=" << jacobian << "\n";
	//cSystemData.isODE2RHSjacobianComputation = false; //hack! only for debugging
}





//! numerical computation of constraint jacobian with respect to ODE2 and ODE1 (fillIntoSystemMatrix=true: also w.r.t. AE) coordinates
//! factorODE2 is used to scale the ODE2-part of the jacobian (to avoid postmultiplication); 
//! velocityLevel = velocityLevel constraints are used, if available; 
//! fillIntoSystemMatrix=true: fill in g_q_ODE2, g_q_ODE2^T AND g_q_AE into system matrix at according positions
//! fillIntoSystemMatrix=false: fill in g_q_ODE2 into jacobian matrix at (0,0) ???REALLY
template<class TGeneralMatrix>
void CSystem::NumericalJacobianAE(TemporaryComputationDataArray& tempArray, const NumericalDifferentiationSettings& numDiff,
	Vector& f0, Vector& f1, TGeneralMatrix& jacobianGM, Real factorAE_ODE2, Real factorAE_ODE2_t, Real factorAE_ODE1,
	bool velocityLevel, Real factorODE2_AE, Real factorODE1_AE, Real factorAE_AE)
{
	//TemporaryComputationData& temp = tempArray[0];
	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
	
	//DELETE: CHECKandTHROW(nODE1 == 0, "CSystem::NumericalJacobianAE: nODE1 must be zero"); //check that offsetAE is correctly added
	Index offsetAE = nODE2 + nODE1; //offset for algebraic equations in system jacobian

	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;
	Vector& x_t = cSystemData.GetCData().currentState.ODE2Coords_t; //velocity coordinates
	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation

	Vector& y = cSystemData.GetCData().currentState.ODE1Coords;
	//Vector& y_t = cSystemData.GetCData().currentState.ODE1Coords_t; //velocity coordinates
	Real yStore; //store value of y; avoid roundoff error effects in numerical differentiation


	Vector& z = cSystemData.GetCData().currentState.AECoords;
	Real zStore; //store value of x; avoid roundoff error effects in numerical differentiation

	//++++++++++++++++++++++++++++++++++++++++++++++++
	//compute total jacobian ==> very time consuming ==> change this to local jacobian (use flag in numDiffParameters?)

	if (!EXUstd::IsOfType(LinearSolverType::Dense, jacobianGM.GetSystemMatrixType())) { CHECKandTHROWstring("CSystem::NumericalJacobianAE: only works for LinearSolverType.EXUdense; illegal LinearSolverType!"); }
	ResizableMatrix& jacobian = ((GeneralMatrixEXUdense&)jacobianGM).GetMatrixEXUdense();

	f0.SetNumberOfItems(nAE);
	f1.SetNumberOfItems(nAE);

	ComputeAlgebraicEquations(tempArray, f0, velocityLevel); //compute nominal value for jacobian

	//differentiation w.r.t. ODE2 coordinates
	for (Index i = 0; i < nODE2; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";

		xStore = x[i];
		x[i] += eps;
		ComputeAlgebraicEquations(tempArray, f1, velocityLevel);
		x[i] = xStore;

		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real x = epsInv * (f1[j] - f0[j]);
			jacobian(offsetAE + j, i) = factorAE_ODE2 * x; //add Cq ==> factor only used for Position constraints ...
			jacobian(i, offsetAE + j) = factorODE2_AE * x; //add CqT ==> new factor
		}
	}

	//differentiation w.r.t. ODE2_t coordinates
	for (Index i = 0; i < nODE2; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";

		xStore = x_t[i];
		x_t[i] += eps;
		ComputeAlgebraicEquations(tempArray, f1, velocityLevel);
		x_t[i] = xStore;

		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real x = epsInv * (f1[j] - f0[j]);
			//if (fillIntoSystemMatrix)
			//{
			jacobian(offsetAE + j, i) += factorAE_ODE2_t * x; //add Cq ==> factor only used for Position constraints ...
			jacobian(i, offsetAE + j) += factorODE2_AE * x; //add CqT; this term MUST be added for purly velocity-formulated constraints (e.g. velocity coordinate constraint, rolling joint, ...)
			//}
			//else
			//{
			//	jacobian(j, i) += x; //add Cq which is lateron used as transposed matrix; this term MUST be added for purly velocity-formulated constraints (e.g. velocity coordinate constraint, rolling joint, ...)
			//}
		}
	}

	//differentiation w.r.t. ODE1 coordinates
	for (Index i = 0; i < nODE1; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(y[i])));
		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";

		yStore = y[i];
		y[i] += eps;
		ComputeAlgebraicEquations(tempArray, f1, velocityLevel);
		y[i] = yStore;

		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real y = epsInv * (f1[j] - f0[j]);

			jacobian(offsetAE + j, i+nODE2) = factorAE_ODE1 * y; //add Cq1
			jacobian(i+nODE2, offsetAE + j) = factorODE1_AE * y; //add Cq1T
		}
	}

	//differentiation w.r.t. AE coordinates
	for (Index i = 0; i < nAE; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(z[i])));

		zStore = z[i];
		z[i] += eps;
		ComputeAlgebraicEquations(tempArray, f1, velocityLevel);
		z[i] = zStore;
		epsInv = 1. / eps;

		for (Index j = 0; j < nAE; j++)
		{
			jacobian(offsetAE + j, offsetAE + i) = (factorAE_AE * epsInv) * (f1[j] - f0[j]);
		}
	}
}

//the NumericalJacobianAE ... _t  is never used
////! compute numerical differentiation of AE with respect to ODE2 velocity; factor is used to scale the Jacobian; if fillIntoSystemMatrix==true, the jacobian is filled directly into the system matrix; result is a jacobian; THIS FUNCTION IS ONLY FOR COMPARISON (SLOW!!!)
//void CSystem::NumericalJacobianAE_ODE2_t(const NumericalDifferentiation& numDiff,
//	TemporaryComputationData& temp, Vector& f0, Vector& f1, ResizableMatrix& jacobian, Real factor, bool velocityLevel)
//{
//	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
//	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
//	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate
//
//	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
//	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
//	Vector& x = cSystemData.GetCData().currentState.ODE2Coords_t;
//	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation
//
//	//++++++++++++++++++++++++++++++++++++++++++++++++
//	//compute total jacobian ==> very time consuming ==> change this to local jacobian (use flag in numDiffParameters?)
//
//	f0.SetNumberOfItems(nAE);
//	f1.SetNumberOfItems(nAE);
//
//	ComputeAlgebraicEquations(temp, f0, velocityLevel); //compute nominal value for jacobian
//
//
//	for (Index i = 0; i < nODE2; i++)
//	{
//		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));
//		//pout << "Jac i=" << i << ", diffEps = " << eps << "\n";
//
//		xStore = x[i];
//		x[i] += eps;
//		ComputeAlgebraicEquations(temp, f1, velocityLevel);
//		x[i] = xStore;
//
//		epsInv = 1. / eps;
//
//		for (Index j = 0; j < nAE; j++)
//		{
//			Real x = epsInv * (f1[j] - f0[j]);
//			jacobian(j, i) = factor * x; //add CqT
//			//if (fillIntoSystemMatrix)
//			//{
//			//	jacobian(nODE2 + j, i) = factor * x; //add Cq
//			//	jacobian(i, nODE2 + j) = x; //add CqT
//			//}
//			//else
//			//{
//			//	jacobian(i, j) = x; //add CqT
//			//}
//		}
//	}
//}

//!compute per-object jacobians for object j, providing TemporaryComputationData;
//! returns ltgAE and ltgODE2 lists, and several flags on object velocity level equation and which jacobian parts have been computed
//! returns true, if jacobian is available, or false if not (e.g. body or ground object)
void CSystem::ComputeObjectJacobianAE(Index j, TemporaryComputationData& temp,
	bool& objectUsesVelocityLevel, JacobianType::Type& filledJacobians/*,
	bool& flagAE_ODE2filled, bool& flagAE_ODE2_tFilled, bool& flagAE_ODE1filled, bool& flagAE_AEfilled*/)
{
	//TemporaryComputationData& temp = tempArray[0];

	objectUsesVelocityLevel = false;
	filledJacobians = JacobianType::_None;

	CObject& object = *(cSystemData.GetCObjects()[j]);

	//Index markerType[2]; //markertypes stored; NOT USED
	//flagAE_ODE2filled = false; //true, if the jacobian AE_ODE2 is inserted
	//flagAE_ODE2_tFilled = false; //true, if the jacobian AE_ODE2 is inserted
	//flagAE_ODE1filled = false; //true, if the jacobian AE_ODE1 is inserted
	//flagAE_AEfilled = false;   //true, if the jacobian AE_AE is inserted
	Real currentTime = cSystemData.GetCData().currentState.time;

	//for body, evaluate algebraic equations directly --> depend only on body coordinates
	if ((Index)object.GetType() & (Index)CObjectType::Body)
	{
		//this is currently only used, if Euler Parameter constraints are attached to bodies (deprecated mode)
		if (object.GetAlgebraicEquationsSize()) //either body or constraint
		{
			filledJacobians = object.GetAvailableJacobians();
			object.ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
			//if (temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0) { flagAE_ODE2filled = true; }
			//if (temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0) { flagAE_ODE2_tFilled = true; }
			//if (temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0) { flagAE_ODE1filled = true; }
			//if (temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0) { flagAE_AEfilled = true; }
		}
	}
	//for constraint, algebraic equations depend on Markers 
	else if ((Index)object.GetType() & (Index)CObjectType::Constraint)
	{
		CObjectConstraint& constraint = (CObjectConstraint&)object;

		const bool computeJacobian = true; //why needed for PostNewtonStep?==> check Issue #241
		cSystemData.ComputeMarkerDataStructure(&constraint, computeJacobian, temp.markerDataStructure);

		filledJacobians = constraint.GetAvailableJacobians();

		//if (constraint.GetAvailableJacobians() & JacobianType::AE_ODE2)
		//{
		//	flagAE_ODE2filled = true;
		//}
		//if (constraint.GetAvailableJacobians() & JacobianType::AE_ODE2_t)
		//{
		//	flagAE_ODE2_tFilled = true;
		//}
		//if (constraint.GetAvailableJacobians() & JacobianType::AE_ODE1)
		//{
		//	flagAE_ODE1filled = true;
		//}
		//if (constraint.GetAvailableJacobians() & JacobianType::AE_AE)
		//{
		//	flagAE_AEfilled = true;
		//}

		//if (flagAE_ODE2filled || flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled)
		if (filledJacobians & JacobianType::ALL_AE_DERIV)
		{
			constraint.ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1,
				temp.localJacobianAE_AE, temp.markerDataStructure, currentTime, j);
			objectUsesVelocityLevel = constraint.UsesVelocityLevel();
			//if (constraint.UsesVelocityLevel()) {factorVelocityLevel = factorAE_ODE2_t; } //in this case, always use the velocity level factor; then, the jacobian is interpreted as diff(AE_t, ODE2_t)
		}

	}
	else
	{
		CHECKandTHROWstring("CSystem::ComputeObjectJacobianAE(...): object type not implemented");
	}
}


//implemented directly in JacobianAE
////!compute per-node jacobians for node j, providing TemporaryComputationData;
////! the jacobian computed in according temp structure
//void CSystem::ComputeNodeJacobianAE(Index j, TemporaryComputationData& temp,
//	bool& nodeUsesVelocityLevel, bool& flagAE_ODE2filled, bool& flagAE_ODE2_tFilled, bool& flagAE_ODE1filled, bool& flagAE_AEfilled)
//{
//	nodeUsesVelocityLevel = false;
//	CNode& node = *(cSystemData.GetCNodes()[j]);
//
//	//Index markerType[2]; //markertypes stored; NOT USED
//	flagAE_ODE2filled = false; //true, if the jacobian AE_ODE2 is inserted
//	flagAE_ODE2_tFilled = false; //true, if the jacobian AE_ODE2 is inserted
//	flagAE_ODE1filled = false; //true, if the jacobian AE_ODE1 is inserted
//	flagAE_AEfilled = false;   //true, if the jacobian AE_AE is inserted
//	Real currentTime = cSystemData.GetCData().currentState.time;
//
//	if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
//	{
//		((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE); //for objects, all jacobians need to be set!
//		if (temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0) { flagAE_ODE2filled = true; }
//		if (temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0) { flagAE_ODE2_tFilled = true; }
//		if (temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0) { flagAE_ODE1filled = true; }
//		if (temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0) { flagAE_AEfilled = true; }
//	}
//
//}

//! compute constraint jacobian of AE with respect to ODE2 (fillIntoSystemMatrix=true: also w.r.t. ODE1 and AE) coordinates ==> direct computation given by access functions
//! factorODE2 is used to scale the ODE2-part of the jacobian (to avoid postmultiplication); 
//! velocityLevel = velocityLevel constraints are used, if available; 
//template<class TGeneralMatrix>
//bool warnedCSystemJacobianAE = false;
void CSystem::JacobianAE(TemporaryComputationDataArray& tempArray, const NewtonSettings& newton, GeneralMatrix& jacobianGM,
	Real factorAE_ODE2, Real factorAE_ODE2_t, Real factorAE_ODE1, bool velocityLevel, Real factorODE2_AE, Real factorODE1_AE, Real factorAE_AE)
{
	//size needs to be set accordingly in the caller function; components are addd to massMatrix!
	JacobianType::Type filledJacobians;
	TemporaryComputationData& temp = tempArray[0];

	if (newton.numericalDifferentiation.forAE)
	{
		NumericalJacobianAE(tempArray, newton.numericalDifferentiation, temp.numericalJacobianf0, temp.numericalJacobianf1, jacobianGM,
			factorAE_ODE2, factorAE_ODE2_t, factorAE_ODE1, velocityLevel);// , fillIntoSystemMatrix);
	}
	else
	{
		if (velocityLevel) { CHECKandTHROWstring("CSystem::JacobianAE_ODE2: velocityLevel=true not implemented"); }
		//Index nAE = cSystemData.GetNumberOfCoordinatesAE();
		Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
		Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
		
		//DELETE: CHECKandTHROW(nODE1 == 0, "CSystem::JacobianAE: nODE1 must be zero"); //check that offsetAE is correctly added
		Index offsetAE = nODE2 + nODE1; //offset for algebraic equations in system jacobian
		Real factorAE_ODE1 = 1.; //currently no scaling from integrators
		Real factorODE1_AE = 1.; //currently no scaling from integrators

		//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
		//for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
		for (Index j: cSystemData.objectsWithAlgebraicEquations)
		{
			//work over bodies, connectors, etc.
			//CObject& object = *(cSystemData.GetCObjects()[j]);
			ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[j];
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j]; //as we do not perform numerical differentiation, LTG duplicates are needed!
			ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[j];

			bool objectUsesVelocityLevel;// = false;
			//bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
			//bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
			//bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
			//bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

			CHECKandTHROW(ltgODE1.NumberOfItems() == 0, "CSystem::JacobianAE: not implemented for constraints/joints with ODE1 coordinates");

			ComputeObjectJacobianAE(j, temp, objectUsesVelocityLevel, filledJacobians/*, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled*/);

			if (filledJacobians & JacobianType::AE_ODE2) //(flagAE_ODE2filled)
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE2, factorAE_ODE2, ltgAE, ltgODE2, offsetAE);//depends, if velocity or position level is used
			}
			if (filledJacobians & JacobianType::AE_ODE2_t) //(flagAE_ODE2_tFilled) //velocity or mixed pos/vel constraints
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE2_t, factorAE_ODE2_t, ltgAE, ltgODE2, offsetAE); //depends, if velocity or position level is used 
			}

			//this is either the dC/dq or the dC_t/dq_t matrix for reaction forces ==> may only be added once for ODE2 OR ODE2_t(e.g. for non-holonomic constraints such as rolling wheel)
			if ((filledJacobians & JacobianType::AE_ODE2) && !objectUsesVelocityLevel) //(flagAE_ODE2filled && !objectUsesVelocityLevel)
			{
				jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE2, factorODE2_AE, ltgODE2, ltgAE, 0, offsetAE); //this is the dC/dq^T part, which is independent of index reduction
			}
			else if (filledJacobians & JacobianType::AE_ODE2_t) //(flagAE_ODE2_tFilled) //newly added
			{
				jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE2_t, factorODE2_AE, ltgODE2, ltgAE, 0, offsetAE); //this is the dC_t/dq_t^T part, which is independent of index reduction
			}
			//else  //for pure algebraic constraints(e.g. if joints are deactivated) this is OK! {CHECKandTHROWstring("CSystem::JacobianAE(...): constraint jacobian must be consistent with UsesVelocityLevel flag"); }

			if (filledJacobians & JacobianType::AE_ODE1) //(flagAE_ODE1filled)
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_ODE1, factorAE_ODE1, ltgAE, ltgODE1, nODE2);
				jacobianGM.AddSubmatrixTransposed(temp.localJacobianAE_ODE1, factorODE1_AE, ltgODE1, ltgAE, 0, nODE2);
			}

			if (filledJacobians & JacobianType::AE_AE) //(flagAE_AEfilled) //pure algebraic equations: only depend on their algebraic part ...
			{
				jacobianGM.AddSubmatrix(temp.localJacobianAE_AE, factorAE_AE, ltgAE, ltgAE, offsetAE, offsetAE);
			}

		}//cSystemData.objectsWithAlgebraicEquations

		for (Index j : cSystemData.nodesODE2WithAE)
		{
			//bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
			//bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
			//bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
			//bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

			CNode& node = *(cSystemData.GetCNodes()[j]);

			if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
			{
				((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE, 
					filledJacobians); //for objects, all jacobians need to be set!
				//flagAE_ODE2filled = temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0;
				//flagAE_ODE2_tFilled = temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0;
				//flagAE_ODE1filled = temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0;
				//flagAE_AEfilled = temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0;

				if (filledJacobians & JacobianType::AE_ODE2) //(flagAE_ODE2filled) //must have ODE size
				{
					Index rowOffset = node.GetGlobalAECoordinateIndex();
					Index columnOffset = node.GetGlobalODE2CoordinateIndex();
					jacobianGM.AddSubmatrixWithFactor(temp.localJacobianAE_ODE2, factorAE_ODE2, rowOffset + offsetAE, columnOffset);//depends, if velocity or position level is used
					jacobianGM.AddSubmatrixTransposedWithFactor(temp.localJacobianAE_ODE2, factorODE2_AE, columnOffset, rowOffset + offsetAE);
				}
				//remaining part could be integrated according to code above: for (Index j: cSystemData.objectsWithAlgebraicEquations) {...}
				//CHECKandTHROW(!(flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled), "CSystem: JacobianAE(...): mode not implemented for node algebraic equations");
				CHECKandTHROW(!(filledJacobians & (JacobianType::AE_ODE2_t + JacobianType::AE_ODE1 + JacobianType::AE_AE)),
					"CSystem: JacobianAE(...): mode not implemented for node algebraic equations");
			}
		}//for cSystemData.nodesODE2WithAE
	}//if(newton.useNumericalDifferentiationAE)

}

Index TSreactionForces1;
TimerStructureRegistrator TSRreactionForces1("TSreactionForces1", TSreactionForces1, globalTimers);
Index TSreactionForces2;
TimerStructureRegistrator TSRreactionForces2("TSreactionForces2", TSreactionForces2, globalTimers);

//! add the projected action of Lagrange multipliers (reaction forces) to the ODE2 coordinates and add it to the ode2ReactionForces residual:
//! ode2ReactionForces += C_{q2}^T * \lambda
void CSystem::ComputeODE2ProjectedReactionForces(TemporaryComputationDataArray& tempArray, const Vector& reactionForces, Vector& ode2ReactionForces)
{
	//Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	//Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	//Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();
	TemporaryComputationData& temp = tempArray[0];

	CHECKandTHROW(reactionForces.NumberOfItems() == cSystemData.GetNumberOfCoordinatesAE(), "CSystem::ComputeODE2ProjectedReactionForces: reactionForces size mismatch!");
	CHECKandTHROW(ode2ReactionForces.NumberOfItems() == cSystemData.GetNumberOfCoordinatesODE2(), "CSystem::ComputeODE2ProjectedReactionForces: ode2ReactionForces size mismatch!");

	int nItemsObjectsNoUF = cSystemData.listObjectProjectedReactionForcesODE2NoUF.NumberOfItems();
	int nItemsNodesObjectsNoUF = nItemsObjectsNoUF + cSystemData.nodesODE2WithAE.NumberOfItems();

	Index nThreads = exuThreading::TaskManager::GetNumThreads();
	bool doParallel = (nThreads > 1) && (nItemsNodesObjectsNoUF >= solverData.multithreadedLLimitResiduals);

	//+++++++++++++++++++++++++++++++++++++++
	//parallel objects, no user function
	if (doParallel)
	{
		//std::mutex mtx;           // mutex for critical section
		outputBuffer.SetSuspendWriting(true); //may not write to python during parallel computation
        tempArray.SetNumberOfItems(nThreads); //only affected, if nThreads changed

		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}

		//gives factor 7.5 for 12 threads with taskSplit nThreads*16, 100 bodies-revolute joint chain
		Index taskSplit = GetTaskSplit(nItemsNodesObjectsNoUF, nThreads);
		exuThreading::ParallelFor(nItemsNodesObjectsNoUF, [this, &reactionForces, &ode2ReactionForces, &tempArray, &nItemsNodesObjectsNoUF, &nItemsObjectsNoUF](NGSsizeType j) //&temp,&systemODE2Rhs,&cSystemData
		{
			JacobianType::Type filledJacobians;
			Index threadID = exuThreading::TaskManager::GetThreadId();
			TemporaryComputationData& temp = tempArray[threadID];

			//OBJECTS WITH AE
			if ((Index)j < nItemsObjectsNoUF)
			{
				Index i = cSystemData.listObjectProjectedReactionForcesODE2NoUF[(Index)j];

				ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[i];
				ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[i];
				//ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[i];

				bool objectUsesVelocityLevel;// = false;

				ComputeObjectJacobianAE(i, temp, objectUsesVelocityLevel, filledJacobians/*, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled*/);

				if (filledJacobians & (JacobianType::AE_ODE2 + JacobianType::AE_ODE2_t)) //(flagAE_ODE2filled || flagAE_ODE2_tFilled) //otherwise, no jacobians exist
				{
					if (((filledJacobians & JacobianType::AE_ODE2) && !objectUsesVelocityLevel) || (filledJacobians & JacobianType::AE_ODE2_t)) //((flagAE_ODE2filled && !objectUsesVelocityLevel) || flagAE_ODE2_tFilled) //must be consistent
					{
						const ResizableMatrix& jac = (filledJacobians & JacobianType::AE_ODE2) ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;

						//multiply Cq^T * lambda:
						for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
						{
							Real total = 0.;
							for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
							{
								total += reactionForces[ltgAE[ii]] * jac(ii, jj);
								//ode2ReactionForces[ltgODE2[jj]] += reactionForces[ltgAE[ii]] * jac(ii, jj);  //add terms to existing residual forces
							}
							tempArray[threadID].sparseVector.AddIndexAndValue(ltgODE2[jj], total);
						}
					}
				}
				else if (filledJacobians & JacobianType::AE_ODE1)//(flagAE_ODE1filled)
				{
					CHECKandTHROWstring("ComputeODE2ProjectedReactionForces: not implemented for ODE1 jacobian of algebraic equations");
				}
			}
			else //NODES WITH AE
			{
				Index i = cSystemData.nodesODE2WithAE[(Index)j- nItemsObjectsNoUF];
				CNode& node = *(cSystemData.GetCNodes()[i]);

				if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
				{
					((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE,
						filledJacobians); //for objects, all jacobians need to be set!

					if (filledJacobians & JacobianType::AE_ODE2) //must have ODE size
					{
						Index rowOffset = node.GetGlobalAECoordinateIndex();
						Index columnOffset = node.GetGlobalODE2CoordinateIndex();

						const ResizableMatrix& jac = temp.localJacobianAE_ODE2;
						for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
						{
							Real total = 0.;
							for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
							{
								total += reactionForces[rowOffset + ii] * jac(ii, jj);  //add terms to existing residual forces
								//ode2ReactionForces[columnOffset + jj] += reactionForces[rowOffset + ii] * jac(ii, jj);  //add terms to existing residual forces
							}
							tempArray[threadID].sparseVector.AddIndexAndValue(columnOffset + jj, total);
						}
					}
				}
			}

		}, taskSplit);

		outputBuffer.SetSuspendWriting(false);

		//STARTGLOBALTIMER(TSreactionForces1);
		//serial section for writing into system vector //currently makes up 6 percent of total time for 1000 body-revolute chain!
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				ode2ReactionForces[item.GetIndex()] += item.GetValue(); //minus: LHS->RHS
			}
		}
		//STOPGLOBALTIMER(TSreactionForces1);

	}

	
	JacobianType::Type filledJacobians;
	//+++++++++++++++++++++++++++++++++++++++
	//(remaining) serial objects; with user functions
	//STARTGLOBALTIMER(TSreactionForces2);
	{
		const ArrayIndex& listObjectsSerial = doParallel ? cSystemData.listObjectProjectedReactionForcesODE2UF : cSystemData.listObjectProjectedReactionForcesODE2;

		//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
		//for (Index i = 0; i < cSystemData.GetCObjects().NumberOfItems(); i++)
		for (Index i : listObjectsSerial)
		{
			//work over bodies, connectors, etc.
			ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[i];
			ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[i];
			//ArrayIndex& ltgODE1 = cSystemData.GetLocalToGlobalODE1()[i];

			bool objectUsesVelocityLevel;// = false;

			ComputeObjectJacobianAE(i, temp, objectUsesVelocityLevel, filledJacobians/*, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled*/);

			if (filledJacobians & (JacobianType::AE_ODE2 + JacobianType::AE_ODE2_t)) //(flagAE_ODE2filled || flagAE_ODE2_tFilled) //otherwise, no jacobians exist
			{
				if (((filledJacobians & JacobianType::AE_ODE2) && !objectUsesVelocityLevel) || (filledJacobians & JacobianType::AE_ODE2_t)) //((flagAE_ODE2filled && !objectUsesVelocityLevel) || flagAE_ODE2_tFilled) //must be consistent
				{
					const ResizableMatrix& jac = (filledJacobians & JacobianType::AE_ODE2) ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;

					//multiply Cq^T * lambda:
					for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
					{
						for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
						{
							ode2ReactionForces[ltgODE2[jj]] += reactionForces[ltgAE[ii]] * jac(ii, jj);  //add terms to existing residual forces
						}
					}
				}
			}
			else if (filledJacobians & JacobianType::AE_ODE1)//(flagAE_ODE1filled)
			{
				CHECKandTHROWstring("ComputeODE2ProjectedReactionForces: not implemented for ODE1 jacobian of algebraic equations");

				//use following code, but add ode1ReactionForces first to function interface ...
				//const ResizableMatrix& jac = temp.localJacobianAE_ODE1;
				////multiply Cq^T * lambda:
				//for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
				//{
				//	for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
				//	{
				//		ode1ReactionForces[ltgODE1[jj]] += reactionForces[ltgAE[ii]] * jac(ii, jj);  //add terms to existing residual forces
				//	}
				//}

			}
		}
	}
	//nodes with AE: usually only Euler Parameters
	if (!doParallel)
	{
		for (Index i : cSystemData.nodesODE2WithAE)
		{
			CNode& node = *(cSystemData.GetCNodes()[i]);

			if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
			{
				((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE,
					filledJacobians); //for objects, all jacobians need to be set!

				if (filledJacobians & JacobianType::AE_ODE2) //must have ODE size
				{
					Index rowOffset = node.GetGlobalAECoordinateIndex();
					Index columnOffset = node.GetGlobalODE2CoordinateIndex();

					const ResizableMatrix& jac = temp.localJacobianAE_ODE2;
					for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
					{
						for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
						{
							ode2ReactionForces[columnOffset + jj] += reactionForces[rowOffset + ii] * jac(ii, jj);  //add terms to existing residual forces
						}
					}
				}
			}
		}
	}//for cSystemData.nodesODE2WithAE
	//STOPGLOBALTIMER(TSreactionForces2);
}

//! compute numerically the derivative of (C_{q2} * v), v being an arbitrary vector
//! jacobianCqV = scalarFactor*d/dq2(C_{q2} * v)
void CSystem::ComputeConstraintJacobianDerivative(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff, Vector& f0, Vector& f1, 
	const Vector& v, GeneralMatrix& jacobianCqV, Real scalarFactor, Index rowOffset, Index columnOffset)
{

	//+++++++++++++++++++++++++++++++++++++++++++++++++++
	//jacobian
	Real relEps = numDiff.relativeEpsilon;			//relative differentiation parameter
	Real minCoord = numDiff.minimumCoordinateSize;	//absolute differentiation parameter is limited to this minimum
	Real eps, epsInv; //coordinate(column)-wise differentiation parameter; depends on size of coordinate

	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	Vector& x = cSystemData.GetCData().currentState.ODE2Coords;
	//Vector& x_t = cSystemData.GetCData().currentState.ODE2Coords_t; //velocity coordinates
	Real xStore; //store value of x; avoid roundoff error effects in numerical differentiation

	//Vector& z = cSystemData.GetCData().currentState.AECoords;
	//Real zStore; //store value of x; avoid roundoff error effects in numerical differentiation

	//++++++++++++++++++++++++++++++++++++++++++++++++

    if (!EXUstd::IsOfType(LinearSolverType::Dense, jacobianCqV.GetSystemMatrixType()))
    { CHECKandTHROWstring("CSystem::ComputeConstraintJacobianDerivative: illegal LinearSolverType, only possible for dense matrix!"); }
	
    ResizableMatrix& jacobian = ((GeneralMatrixEXUdense&)jacobianCqV).GetMatrixEXUdense();
	
	f0.SetNumberOfItems(nAE);
	f1.SetNumberOfItems(nAE);
	ComputeConstraintJacobianTimesVector(temp, v, f0);
	//pout << "f0=" << f0 << "\n";
	//bool velocityLevel = false;

	//brute force approach, done for full matrix!
	//differentiation w.r.t. ODE2 coordinates
	for (Index i = 0; i < nODE2; i++)
	{
		eps = relEps * (EXUstd::Maximum(minCoord, fabs(x[i])));

		xStore = x[i];
		x[i] += eps;
		ComputeConstraintJacobianTimesVector(temp, v, f1);
		x[i] = xStore;
		//pout << "f1=" << f1 << "\n";

		epsInv = scalarFactor / eps;

		for (Index j = 0; j < nAE; j++)
		{
			Real x = epsInv * (f1[j] - f0[j]);
			jacobian(j + rowOffset, i + columnOffset) = x;
		}
	}

}

//! compute (C_{q2} * v), v being an arbitrary vector
void CSystem::ComputeConstraintJacobianTimesVector(TemporaryComputationData& temp, const Vector& v, Vector& result)
{
	Index nAE = cSystemData.GetNumberOfCoordinatesAE();
	//Index nODE2 = cSystemData.GetNumberOfCoordinatesODE2();
	//Index nODE1 = cSystemData.GetNumberOfCoordinatesODE1();

	CHECKandTHROW(v.NumberOfItems() == cSystemData.GetNumberOfCoordinatesODE2(), "CSystem::ComputeConstraintJacobianTimesVector: v size mismatch!");
	result.SetNumberOfItems(nAE);
	result.SetAll(0.);

	JacobianType::Type filledJacobians;

	//algebraic equations only origin from objects (e.g. Euler parameters) and constraints
	for (Index j = 0; j < cSystemData.GetCObjects().NumberOfItems(); j++)
	{
		//work over bodies, connectors, etc.
		//CObject& object = *(cSystemData.GetCObjects()[j]);
		ArrayIndex& ltgAE = cSystemData.GetLocalToGlobalAE()[j];
		ArrayIndex& ltgODE2 = cSystemData.GetLocalToGlobalODE2()[j];

		bool objectUsesVelocityLevel;// = false;
		//bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
		//bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
		//bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
		//bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

		if (ltgAE.NumberOfItems() && ltgODE2.NumberOfItems() && cSystemData.GetCObjects()[j]->GetAlgebraicEquationsSize()) //omit bodies and ground objects ...
		{
			ComputeObjectJacobianAE(j, temp, objectUsesVelocityLevel, filledJacobians/*, flagAE_ODE2filled, flagAE_ODE2_tFilled, flagAE_ODE1filled, flagAE_AEfilled*/);
			
			if (!objectUsesVelocityLevel) //for velocity constraints, only Ct_t would be needed!
			{
				if (filledJacobians & JacobianType::AE_ODE2) //(flagAE_ODE2filled)
				{
					//ResizableMatrix& jac = flagAE_ODE2filled ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;
					const ResizableMatrix& jac = temp.localJacobianAE_ODE2;

					//multiply Cq^T * lambda:
					for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
					{
						for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
						{
							result[ltgAE[ii]] += jac(ii, jj) * v[ltgODE2[jj]];  //add terms to existing residual forces
						}
					}
				}
			}

			if (filledJacobians & JacobianType::AE_ODE1) //(flagAE_ODE1filled) //could be just ignored ==> check as soon as first ODE1 constraint jacobian exists
			{
				STDstring str = "CSystem::ComputeConstraintJacobianTimesVector(...) : not implemented for ODE1 coordinates, objectNr = ";
				str += EXUstd::ToString(j);
				PyWarning(str);
			} 
		}
	}

	for (Index j : cSystemData.nodesODE2WithAE)
	{
		//bool flagAE_ODE2filled; //true, if the jacobian AE_ODE2 is inserted
		//bool flagAE_ODE2_tFilled; //true, if the jacobian AE_ODE2 is inserted
		//bool flagAE_ODE1filled; //true, if the jacobian AE_ODE1 is inserted
		//bool flagAE_AEfilled;   //true, if the jacobian AE_AE is inserted

		CNode& node = *(cSystemData.GetCNodes()[j]);

		if (node.GetAlgebraicEquationsSize()) //currently, only used for Euler Parameter constraints
		{

			((CNodeODE2&)node).ComputeJacobianAE(temp.localJacobianAE_ODE2, temp.localJacobianAE_ODE2_t, temp.localJacobianAE_ODE1, temp.localJacobianAE_AE,
				filledJacobians); //for objects, all jacobians need to be set!
			//flagAE_ODE2filled = temp.localJacobianAE_ODE2.NumberOfColumns()   * temp.localJacobianAE_ODE2.NumberOfRows() != 0;
			//flagAE_ODE2_tFilled = temp.localJacobianAE_ODE2_t.NumberOfColumns() * temp.localJacobianAE_ODE2_t.NumberOfRows() != 0;
			//flagAE_ODE1filled = temp.localJacobianAE_ODE1.NumberOfColumns()   * temp.localJacobianAE_ODE1.NumberOfRows() != 0;
			//flagAE_AEfilled = temp.localJacobianAE_AE.NumberOfColumns()* temp.localJacobianAE_AE.NumberOfRows() != 0;

			if (filledJacobians & JacobianType::AE_ODE2)
			{
				//ResizableMatrix& jac = flagAE_ODE2filled ? temp.localJacobianAE_ODE2 : temp.localJacobianAE_ODE2_t;
				const ResizableMatrix& jac = temp.localJacobianAE_ODE2;
				Index rowOffset = node.GetGlobalAECoordinateIndex();
				Index columnOffset = node.GetGlobalODE2CoordinateIndex();

				//multiply Cq^T * lambda:
				for (Index ii = 0; ii < jac.NumberOfRows(); ii++)
				{
					for (Index jj = 0; jj < jac.NumberOfColumns(); jj++)
					{
						result[rowOffset + ii] += jac(ii, jj) * v[columnOffset + jj];  //add terms to existing residual forces
					}
				}
			}
			//remaining part could be integrated according to code above: for (Index j: cSystemData.objectsWithAlgebraicEquations) {...}
			//CHECKandTHROW(!(flagAE_ODE2_tFilled || flagAE_ODE1filled || flagAE_AEfilled), "CSystem: ComputeConstraintJacobianTimesVector(...): mode not implemented for node algebraic equations");
			CHECKandTHROW(!(filledJacobians & (JacobianType::AE_ODE2_t + JacobianType::AE_ODE1 + JacobianType::AE_AE)),
				"CSystem: ComputeConstraintJacobianTimesVector(...): mode not implemented for node algebraic equations");
		}
	}

}


//! this function is used to copy the current state to the visualization state and to send a signal that the PostProcessData has been updated
void CSystem::UpdatePostProcessData(bool recordImage)
{
	Index timeOut = 1000;		 //max iterations to wait, before frame is redrawn and saved
	Index timerMilliseconds = 2; //this is a hard-coded value, as visualizationSettings are not available here ...

	Index i = 0;

	//wait with new update until last image recording has been finished
	//this loop does not get caught except for we do recording of images
	while (i++ < timeOut && (postProcessData.recordImageCounter == postProcessData.updateCounter))
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(timerMilliseconds));
	}

	if (postProcessData.recordImageCounter == postProcessData.updateCounter)
	{
		PyWarning("CSystem::UpdatePostProcessData:: timeout for record image; try to decrease scene complexity");
	}

	//use semaphores, because the postProcessData.state is also accessed from the visualization thread
	EXUstd::WaitAndLockSemaphore(postProcessData.accessState); //lock PostProcessData

	postProcessData.updateCounter++;
	postProcessData.postProcessDataReady = true;
	if (recordImage) { postProcessData.recordImageCounter = postProcessData.updateCounter; } //this is the condition to record an image

	postProcessData.GetVisualizationStateUpdate() = GetSystemData().GetCData().currentState;
	postProcessData.SetVisualizationStateUpdateAvailable(true);

	EXUstd::ReleaseSemaphore(postProcessData.accessState); //clear PostProcessData
}






