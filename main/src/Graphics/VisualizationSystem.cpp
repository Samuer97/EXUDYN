/** ***********************************************************************************************
* @brief		Implementation of class VisualizationSystem
* @details		Details:
 				- a visualization system, containing data and functions for visualization
*
* @author		Gerstmayr Johannes
* @date			2019-05-24 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

//#include "System/CSystem.h"						//included in VisualizationSystem.h
//#include "Autogenerated/VisualizationSettings.h"  //included in VisualizationSystem.h
//#include "Graphics/GraphicsData.h"				//included in VisualizationSystem.h
//#include "Graphics/VisualizationSystem.h"
#include "Graphics/VisualizationSystemContainer.h"  //includes everything needed

#include "Main/MainSystemData.h"	//for backlink to main system
#include "Main/MainSystem.h"		//for backlink to main system

#include <thread>

#include "Main/rendererPythonInterface.h" //in order to link to graphics engine

#ifdef USE_GLFW_GRAPHICS
#include "Graphics/GlfwClient.h" //in order to link to graphics engine
#endif


void VisualizationSystem::Reset()
{
	graphicsData.GetVisualizationCounter() = 0;
	graphicsData.FlushData();
	graphicsData.GetUpdateGraphicsDataNow() = false;

	EXUstd::WaitAndLockSemaphore(postProcessData->requestUserFunctionDrawingAtomicFlag);
	postProcessData->requestUserFunctionDrawing = false;
	EXUstd::ReleaseSemaphore(postProcessData->requestUserFunctionDrawingAtomicFlag);

	GetVisualizationSystemData().Reset();
}

void VisualizationSystem::LinkToSystemData(CSystemData* systemDataInit)
{
	systemData = systemDataInit;
}

void VisualizationSystem::LinkToMainSystem(MainSystem* mainSystemInit)
{
	mainSystemUF = mainSystemInit;
}

void VisualizationSystem::LinkPostProcessData(PostProcessData* postProcessDataInit)
{
	postProcessData = postProcessDataInit;
	postProcessData->visualizationSystem = this;
}

Index VisualizationSystem::GetSystemID() const
{
	return mainSystemUF->GetMainSystemIndex();
}

MainSystem* VisualizationSystem::GetMainSystemBacklink()
{
	return mainSystemUF;
}


//! Renderer reports to simulation that simulation shall be interrupted
void VisualizationSystem::StopSimulation()
{
	postProcessData->stopSimulation = true;
}

bool visualizationSystemUpdateGraphicsDataTimeoutWarned = false;

//! OpenGL renderer calls UpdateGraphicsData (different thread) to update graphics data
// ==> do not call Python functions from here!
void VisualizationSystem::UpdateGraphicsData(VisualizationSystemContainer& visualizationSystemContainer)
{
	if (visualizationSystemContainer.GetVisualizationSettings().general.threadSafeGraphicsUpdate) //if not set, graphics will be sometimes distorted due to update of visualization state during rendering
	{
		//use semaphores, because the postProcessData.state is also accessed from the visualization thread
		EXUstd::WaitAndLockSemaphore(postProcessData->accessState); //computation thread must be interrupted before further update
	}

	if (postProcessData->GetVisualizationStateUpdateAvailable())
	{
		systemData->GetCData().visualizationState = postProcessData->GetVisualizationStateUpdate();
		postProcessData->SetVisualizationStateUpdateAvailable(false);
	}

	if (GetSystemHasChanged())
	{
		visualizationSystemContainer.SetComputeMaxSceneRequest(true);
		SetSystemHasChanged(false);
	}

	EXUstd::ReleaseSemaphore(postProcessData->accessState); //now visualizationStateUpdate can be written again in main thread

	try
	{

	if (postProcessData->updateCounter == postProcessData->recordImageCounter) //this is the signal that a frame shall be recorded
	{
		visualizationSystemContainer.saveImage = true;
		visualizationSystemContainer.saveImageOpenGL = true; //send immediately signal to openGL that frame needs to be recorded
		postProcessData->recordImageCounter--;				 //decrease value such that next update does not lead to image record
	}

	if (((postProcessData->postProcessDataReady && postProcessData->updateCounter > graphicsData.GetVisualizationCounter())
		|| visualizationSystemContainer.UpdateGraphicsDataNowInternal()) && systemData->GetCData().IsSystemConsistent())
	{
		graphicsData.GetVisualizationCounter() = postProcessData->updateCounter; //next update will only be done if postProcessData->updateCounter increases

		//flushdata also locks data ...
		graphicsData.FlushData(); //currently data is always recomputed; FUTURE: differ between structure update and vertex/rigid body update, etc.

		//put this after FlushData():
		graphicsData.LockData(); //avoid that data is cleared by computation/Python thread (should never happen, because updateGraphicsData is called usually from Render thread ...)

		Index cnt;

		//++++++++++++++++++++++++++++++++++++++++++++++
		//call object user functions
		bool systemHasUserFunction = false;
		for (auto item : vSystemData.GetVisualizationObjects())
		{
			if (item->GetShow() && ((!(item->IsConnector()) && visualizationSystemContainer.settings.bodies.show) ||
				(item->IsConnector() && visualizationSystemContainer.settings.connectors.show)))
			{
				if (item->HasUserFunction()) { systemHasUserFunction = true; break; };
			}
		}
		if (systemHasUserFunction)
		{
			if (!RendererIsSingleThreadedOrNotRunning())
			{
				EXUstd::WaitAndLockSemaphore(postProcessData->requestUserFunctionDrawingAtomicFlag);
				postProcessData->requestUserFunctionDrawing = true;
				EXUstd::ReleaseSemaphore(postProcessData->requestUserFunctionDrawingAtomicFlag);

				//visualizationSettingsUF = &visualizationSystemContainer.GetVisualizationSettings(); //removed because available via MainSystem backlink
				Index timeout = 100; //avoid complete hang up, if computation stucks ==> graphics data will be inconsistent ...
				Index cnt = 0;
				while (postProcessData->requestUserFunctionDrawing && cnt++ < timeout)
				{
					std::this_thread::sleep_for(std::chrono::milliseconds(2)); //wait for computation thread to complete computation of user function's graphicsData
				}
				//this will wait in case to complete the current drawing in python (and could possibly hang up ...)
				EXUstd::WaitAndLockSemaphore(postProcessData->requestUserFunctionDrawingAtomicFlag);
				postProcessData->requestUserFunctionDrawing = false;
				EXUstd::ReleaseSemaphore(postProcessData->requestUserFunctionDrawingAtomicFlag);

				if (cnt >= timeout && !visualizationSystemUpdateGraphicsDataTimeoutWarned)
				{
					visualizationSystemUpdateGraphicsDataTimeoutWarned = true;
					//std::cout << "timeout for user function drawing, reduce complexity of user function drawing. Further warnings suppressed!\n";
					PyQueueExecutableString("print('timeout for user function drawing, reduce complexity of user function drawing. Further warnings suppressed!')");
				}
			}
			else
			{
				//in single-threaded mode, ProcessUserFunctionDrawing() can be called from here
				postProcessData->requestUserFunctionDrawing = true;
				postProcessData->ProcessUserFunctionDrawing();
				postProcessData->requestUserFunctionDrawing = false;
			}
		}

		postProcessData->visualizationTime = systemData->GetCData().GetVisualization().GetTime(); //update time, synchronized with the state shown 

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize contact:
		//if (visualizationSystemContainer.settings.contact.showSearchTree)
		//{
		//	CSystem* cSystem = GetMainSystemBacklink()->GetCSystem();
		//	for (auto gContact : cSystem->GetGeneralContacts())
		//	{

		//	}
		//}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize nodes:
		//pout << "UpdateGraphicsData nodes1\n";
		if (visualizationSystemContainer.settings.nodes.show)
		{
			cnt = 0;
			for (auto item : vSystemData.GetVisualizationNodes())
			{
				if (item->GetShow()) { item->UpdateGraphics(visualizationSystemContainer.GetVisualizationSettings(), this, cnt); }
				cnt++; //synchronize itemNumber with item!!!
			}
		}
		//pout << "UpdateGraphicsData nodes2\n";

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize connectors: (draw connectors before objects, to make coordinate systems visible inside of bodies
		if (visualizationSystemContainer.settings.connectors.show)
		{
			cnt = 0;
			for (auto item : vSystemData.GetVisualizationObjects())
			{
				if (item->GetShow() && item->IsConnector()) { item->UpdateGraphics(visualizationSystemContainer.GetVisualizationSettings(), this, cnt); }
				cnt++; //synchronize itemNumber with item!!!
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize objects:
		if (visualizationSystemContainer.settings.bodies.show)
		{
			cnt = 0;
			for (auto item : vSystemData.GetVisualizationObjects())
			{
				if (item->GetShow() && !(item->IsConnector()))
				{
					item->UpdateGraphics(visualizationSystemContainer.GetVisualizationSettings(), this, cnt);
				}
				cnt++; //synchronize itemNumber with item!!!
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//recompute colors in contourplot objects (LATERON: add triangles ...!)
		if (visualizationSystemContainer.settings.contour.outputVariable != OutputVariableType::_None)
		{
			float minVal = visualizationSystemContainer.settings.contour.minValue;
			float maxVal = visualizationSystemContainer.settings.contour.maxValue;
			if (visualizationSystemContainer.settings.contour.automaticRange)
			{
				float storedMinVal = graphicsData.GetContourCurrentMinValue(); //store range, for reduceRange option
				float storedMaxVal = graphicsData.GetContourCurrentMaxValue();

				//std::cout << "compute automatic range\n";
				if (visualizationSystemContainer.settings.contour.reduceRange)
				{
					minVal = EXUstd::_MAXFLOAT;
					maxVal = EXUstd::_MINFLOAT;
				}
				else
				{
					minVal = storedMinVal;
					maxVal = storedMaxVal;
				}
				//normalize contour plot values
				for (auto item : graphicsData.glLines)
				{
					if (item.color1[3] == contourPlotFlag) //just check color1
					{
						minVal = EXUstd::Minimum(minVal, item.color1[0]); //contour plot value is given in RED channel
						minVal = EXUstd::Minimum(minVal, item.color2[0]);
						maxVal = EXUstd::Maximum(maxVal, item.color1[0]); //contour plot value is given in RED channel
						maxVal = EXUstd::Maximum(maxVal, item.color2[0]);
					}
				}
				for (auto item : graphicsData.glCirclesXY)
				{
					if (item.color[3] == contourPlotFlag)
					{
						minVal = EXUstd::Minimum(minVal, item.color[0]); //contour plot value is given in RED channel
						maxVal = EXUstd::Maximum(maxVal, item.color[0]); //contour plot value is given in RED channel
					}
				}
				for (auto item : graphicsData.glSpheres)
				{
					if (item.color[3] == contourPlotFlag)
					{
						minVal = EXUstd::Minimum(minVal, item.color[0]); //contour plot value is given in RED channel
						maxVal = EXUstd::Maximum(maxVal, item.color[0]); //contour plot value is given in RED channel
					}
				}
				for (auto item : graphicsData.glTriangles)
				{
					if (item.colors[0][3] == contourPlotFlag) //just check color of first node
					{
						for (const Float4& color : item.colors)
						{
							minVal = EXUstd::Minimum(minVal, color[0]); //contour plot value is given in RED channel
							maxVal = EXUstd::Maximum(maxVal, color[0]); //contour plot value is given in RED channel
						}
					}
				}

				//std::cout << "range=" << minVal << ", " << maxVal << "\n";
				if (minVal == EXUstd::_MAXFLOAT) { minVal = 0; } //introduce standard range if no items found!
				if (maxVal == EXUstd::_MINFLOAT) { maxVal = 1; }

				if (!visualizationSystemContainer.settings.contour.reduceRange)
				{
					if (minVal > storedMinVal) { minVal = storedMinVal; }
					if (maxVal < storedMaxVal) { maxVal = storedMaxVal; }
				}
			}

			//transfer computed or set values to renderer (color bar, etc.)
			graphicsData.GetContourCurrentMinValue() = minVal;
			graphicsData.GetContourCurrentMaxValue() = maxVal;

			//now recompute color as given in the colorbar
			for (auto& item : graphicsData.glLines)
			{
				if (item.color1[3] == contourPlotFlag)
				{
					item.color1 = VisualizationSystemContainerBase::ColorBarColor(minVal, maxVal, item.color1[0]);
					item.color2 = VisualizationSystemContainerBase::ColorBarColor(minVal, maxVal, item.color2[0]);
				}
			}
			for (auto& item : graphicsData.glCirclesXY)
			{
				if (item.color[3] == contourPlotFlag)
				{
					item.color = VisualizationSystemContainerBase::ColorBarColor(minVal, maxVal, item.color[0]);
				}
			}
			for (auto& item : graphicsData.glSpheres)
			{
				if (item.color[3] == contourPlotFlag)
				{
					item.color = VisualizationSystemContainerBase::ColorBarColor(minVal, maxVal, item.color[0]);
				}
			}
			for (auto& item : graphicsData.glTriangles)
			{
				if (item.colors[0][3] == contourPlotFlag) //just check color of first node
				{
					for (Float4& color : item.colors)
					{
						color = VisualizationSystemContainerBase::ColorBarColor(minVal, maxVal, color[0]);
					}
				}
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize markers:
		if (visualizationSystemContainer.settings.markers.show)
		{
			cnt = 0;
			for (auto item : vSystemData.GetVisualizationMarkers())
			{
				if (item->GetShow()) { item->UpdateGraphics(visualizationSystemContainer.GetVisualizationSettings(), this, cnt); }
				cnt++; //synchronize itemNumber with item!!!
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize loads:
		if (visualizationSystemContainer.settings.loads.show)
		{
			cnt = 0;
			for (auto item : vSystemData.GetVisualizationLoads())
			{
				if (item->GetShow()) { item->UpdateGraphics(visualizationSystemContainer.GetVisualizationSettings(), this, cnt); }
				cnt++; //synchronize itemNumber with item!!!
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize GeneralContacts:
		if (true)
		{
			const CSystem* cSystem = GetMainSystemBacklink()->GetCSystem();
			for (GeneralContact* gc : cSystem->GetGeneralContacts()) //usually only 1
			{
				gc->visualization.DrawContacts(*gc, visualizationSystemContainer.GetVisualizationSettings(), this);
			}
		}

		//++++++++++++++++++++++++++++++++++++++++++++++
		//visualize sensors:
		if (visualizationSystemContainer.settings.sensors.show)
		{
			cnt = 0;
			for (auto item : vSystemData.GetVisualizationSensors())
			{
				if (item->GetShow()) { item->UpdateGraphics(visualizationSystemContainer.GetVisualizationSettings(), this, cnt); }
				cnt++; //synchronize itemNumber with item!!!
			}
		}

		graphicsData.ClearLock();
	}
	}
	catch (const std::exception& e) // reference to the base of a polymorphic object
	{
		//std::cout <<       "++++++++++++++++++++\n" << "Exception in VisualizationSystem::UpdateGraphicsData:\n" << e.what() << "\n********************\n";
		
		//works from visualization thread:
		outputBuffer.WriteVisualization(STDstring("Exception in VisualizationSystem::UpdateGraphicsData(...):\n  ") + e.what() + "\n");
		//CHECKandTHROWstring(""); //not necessary, would lead to immediately closing of renderer
		graphicsData.ClearLock(); //MUST BE called before FlushData!!!
		//graphicsData.FlushData(); //otherwise is in an undefined state
		//outputBuffer.WriteVisualization("test2");
	}
	catch (...)
	{
		outputBuffer.WriteVisualization(STDstring("********************\n")+"unknown exception in VisualizationSystem::UpdateGraphicsData(...)\n********************\n");
		graphicsData.ClearLock(); //MUST BE called before FlushData!!!
		graphicsData.FlushData(); //otherwise is in an undefined state
	}
}

//! any multi-line text message from computation to be shown in renderer (e.g. time, solver, ...)
std::string VisualizationSystem::GetComputationMessage(bool solverInformation, bool solutionInformation, bool solverTime)
{
	//semaphore is in Set/GetSolver/SolutionMessage(...) !

	std::string str;
	if (solverInformation) { str += postProcessData->GetSolverMessage() + '\n'; }
	if (solutionInformation && !postProcessData->GetSolutionMessage().empty()) { str += postProcessData->GetSolutionMessage() + '\n'; }
	if (solverTime) { str += "time = " + EXUstd::ToString(postProcessData->visualizationTime); } //not thread safe, but ok

	return str;
}
