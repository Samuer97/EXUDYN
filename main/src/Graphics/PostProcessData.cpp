/** ***********************************************************************************************
* @brief		Implementation of class PostProcessData
* @details		Details: shared between CSystem and VisualizationSystem
*
* @author		Gerstmayr Johannes
* @date			2021-05-07 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

//++++++++++++++++ sleep_for():
#include <iostream>
#include <chrono>
#include <thread>
//++++++++++++++++

#include <functional>					//for std::invoke
#include "Main/CSystemData.h"			//Basics, Vector/Array, OutputVariable, CData, Material, Body, Node, Marker, Load
#include "Main/CSystem.h"	

#include "Main/MainSystem.h"
#include "Main/SystemContainer.h"
#include "Main/MainSystemContainer.h"
//#include "Linalg/LinearSolver.h" //for GeneralMatrixEXUdense
//#include "Main/OutputVariable.h" //for GeneralMatrixEXUdense
//#include "Autogenerated/CSensorSuperElement.h" //for sensor integrity checks
//#include "Autogenerated/CSensorUserFunction.h" //for sensor integrity checks
////#include "Autogenerated/CSensorMarker.h" //for sensor integrity checks
//
//#include "Utilities/TimerStructure.h" //for local CPU time measurement
#include "Main/rendererPythonInterface.h" //for regular call to PyExecuteQueue(...)



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! this function is used in Pyton to send a signal that the scene shall be redrawn (e.g.,  because the visualization state has been updated)
void PostProcessData::SendRedrawSignal()
{
	//use semaphores, because the postProcessData.state is also accessed from the visualization thread
	EXUstd::WaitAndLockSemaphoreIgnore(accessState); //lock PostProcessData

	updateCounter++;
	postProcessDataReady = true;

	EXUstd::ReleaseSemaphore(accessState);
}

//! wait for user to press space
void PostProcessData::WaitForUserToContinue(bool printMessage)
{
	if (visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainer().GetVisualizationSystemContainer().RendererIsRunning()) //do this only if visualization is running, otherwise application cannot recognize SPACE press
	{
		simulationPaused = true;
		STDstring strSolver = GetSolverMessage();
		SetSolverMessage("Computation paused... (press SPACE to continue / Q to quit)");
        if (printMessage)
        {
            pout << "Computation paused... (press SPACE in render window to continue / Q to quit)\n";
        }

		while (visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainer().GetVisualizationSystemContainer().DoIdleOperations() && simulationPaused)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(20)); //give thread time to finish the stop simulation command
		}

		simulationPaused = false; //in case that visualization system was closed in the meantime
		SetSolverMessage(strSolver);
	}
}

bool PostProcessData::VisualizationIsRunning() const
{
	return visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainer().GetVisualizationSystemContainer().RendererIsRunning();
}


void PostProcessData::ProcessUserFunctionDrawing()
{
	EXUstd::WaitAndLockSemaphore(requestUserFunctionDrawingAtomicFlag);

	if (requestUserFunctionDrawing)
	{
		const VisualizationSettings& visSettings = visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainerConst().PyGetVisualizationSettings();
		//std::cout << "requestUserFunctionDrawing ...\n";
		if (visSettings.bodies.show)
		{
			Index cnt = 0;
			for (auto item : visualizationSystem->vSystemData.GetVisualizationObjects())
			{
				if (item->GetShow() && !(item->IsConnector()) && item->HasUserFunction())
				{
					item->CallUserFunction(visSettings,
						visualizationSystem,
						*visualizationSystem->GetMainSystemBacklink(),
						cnt);
				}
				cnt++; //synchronize itemNumber with item!!!
			}
		}
		requestUserFunctionDrawing = false;
	}
	EXUstd::ReleaseSemaphore(requestUserFunctionDrawingAtomicFlag);
}
