/** ***********************************************************************************************
* @brief		Implementation of class PostProcessData
* @details		Details: shared between CSystem and VisualizationSystem
*
* @author		Gerstmayr Johannes
* @date			2021-05-07 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

//++++++++++++++++ sleep_for():
#include <iostream>
#include <chrono>
#include <thread>
//++++++++++++++++

#include <functional>					//for std::invoke
#include "Main/CSystemData.h"			//Basics, Vector/Array, OutputVariable, CData, Material, Body, Node, Marker, Load
#include "Main/CSystem.h"	
#include "Utilities/AdvancedStuff.h"


#include "Main/MainSystem.h"
#include "Main/SystemContainer.h"
#include "Main/MainSystemContainer.h"
//#include "Linalg/LinearSolver.h" //for GeneralMatrixEXUdense
//#include "Main/OutputVariable.h" //for GeneralMatrixEXUdense
//#include "Autogenerated/CSensorSuperElement.h" //for sensor integrity checks
//#include "Autogenerated/CSensorUserFunction.h" //for sensor integrity checks
////#include "Autogenerated/CSensorMarker.h" //for sensor integrity checks
//
//#include "Utilities/TimerStructure.h" //for local CPU time measurement
#include "Main/rendererPythonInterface.h" //for regular call to PyExecuteQueue(...)



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PostProcessData::Reset()
{
	postProcessDataReady = false;
	updateCounter = 1;				// must be larger than recordImageCounter, in order to avoid hang up in first UpdatePostProcessData(...) in CSystem
	recordImageCounter = 0;
	simulationFinished = false;
	stopSimulation = false;
	forceQuitSimulation = false;
	simulationPaused = false;
	visualizationTime = 0;
	systemHasChanged = true; // used to compute maxSceneSize at beginning

	visualizationStateUpdateAvailable = false;
	requestUserFunctionDrawing = false;

	solverMessage = "";
	solutionMessage = "";

	EXUstd::ReleaseSemaphore(accessState);
	EXUstd::ReleaseSemaphore(requestUserFunctionDrawingAtomicFlag);
	EXUstd::ReleaseSemaphore(accessMessage);
}

//! this function is used in Pyton to send a signal that the scene shall be redrawn (e.g.,  because the visualization state has been updated)
void PostProcessData::SendRedrawSignal()
{
	//use semaphores, because the postProcessData.state is also accessed from the visualization thread
	EXUstd::WaitAndLockSemaphoreIgnore(accessState); //lock PostProcessData

	updateCounter++;
	postProcessDataReady = true;

	EXUstd::ReleaseSemaphore(accessState);
}

//! wait for user to press space
void PostProcessData::WaitForUserToContinue(bool printMessage)
{
	if (visualizationSystem->GetMainSystemBacklink()->HasMainSystemContainer())
	{
		if (visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainer().GetVisualizationSystemContainer().RendererIsRunning()) //do this only if visualization is running, otherwise application cannot recognize SPACE press
		{
			simulationPaused = true;
			STDstring strSolver = GetSolverMessage();
			SetSolverMessage("Computation paused... (press SPACE to continue / Q to quit)");
			if (printMessage)
			{
				pout << "Computation paused... (press SPACE in render window to continue / Q to quit)\n";
			}

			while (visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainer().GetVisualizationSystemContainer().DoSingleIdleOperation() && simulationPaused)
			{
				std::this_thread::sleep_for(std::chrono::milliseconds(20)); //give thread time to finish the stop simulation command
			}

			simulationPaused = false; //in case that visualization system was closed in the meantime
			SetSolverMessage(strSolver); //restore solver message
		}
	}
	else
	{
		pout << "DoIdleTasks(): ignored, because no SystemContainer is linked to MainSystem.\n";
	}
}

bool PostProcessData::VisualizationIsRunning() const
{
	return visualizationSystem->GetMainSystemBacklink()->HasMainSystemContainer() && visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainer().GetVisualizationSystemContainer().RendererIsRunning();
}

//! set a visualization message into openGL window
void PostProcessData::SetSolverMessage(const std::string& solverMessageInit)
{
	//add separate semaphore for PostProcessData.accessMessages
	EXUstd::WaitAndLockSemaphore(accessMessage); //lock PostProcessData
	solverMessage = solverMessageInit;
	EXUstd::ReleaseSemaphore(accessMessage); //clear PostProcessData
}

void PostProcessData::SetSolutionMessage(const std::string& solutionMessageInit)
{
	EXUstd::WaitAndLockSemaphore(accessMessage); //lock PostProcessData
	solutionMessage = solutionMessageInit;
	EXUstd::ReleaseSemaphore(accessMessage); //clear PostProcessData
}

//! get the current solver message string
std::string PostProcessData::GetSolverMessage()
{
	EXUstd::WaitAndLockSemaphore(accessMessage); //lock PostProcessData
	std::string message = solverMessage; 		//copy message
	EXUstd::ReleaseSemaphore(accessMessage); //clear PostProcessData
	return message; //now safely return message
}

//! get the current solution message string
std::string PostProcessData::GetSolutionMessage()
{
	EXUstd::WaitAndLockSemaphore(accessMessage); //lock PostProcessData
	std::string message = solutionMessage; 		//copy message
	EXUstd::ReleaseSemaphore(accessMessage); //clear PostProcessData
	return message; //now safely return message
}


void PostProcessData::ProcessUserFunctionDrawing()
{
	EXUstd::WaitAndLockSemaphore(requestUserFunctionDrawingAtomicFlag);

	if (requestUserFunctionDrawing && visualizationSystem->GetMainSystemBacklink()->HasMainSystemContainer())
	{
		const VisualizationSettings& visSettings = visualizationSystem->GetMainSystemBacklink()->GetMainSystemContainerConst().PyGetVisualizationSettings();
		//std::cout << "requestUserFunctionDrawing ...\n";
		if (visSettings.bodies.show)
		{
			Index cnt = 0;
			for (auto item : visualizationSystem->vSystemData.GetVisualizationObjects())
			{
				if (item->GetShow() && !(item->IsConnector()) && item->HasUserFunction())
				{
					item->CallUserFunction(visSettings,
						visualizationSystem,
						*visualizationSystem->GetMainSystemBacklink(),
						cnt);
				}
				cnt++; //synchronize itemNumber with item!!!
			}
		}
		requestUserFunctionDrawing = false;
	}
	EXUstd::ReleaseSemaphore(requestUserFunctionDrawingAtomicFlag);
}
