/** ***********************************************************************************************
* @brief		Implentation for computational solver CSolverBase
* @details		Details:
* 				- base classes for computational solver (as compared to main solver, which interacts with Python, etc.)
*               - contains basic solver structures (Evaluation functions, jacobians, initialization, link to linear solvers, 
*				  solver statistics and output, solution files, Newton, nonlinear iteration, ...)
*
* @author		Gerstmayr Johannes
* @date			2019-12-11 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
************************************************************************************************ */

#include <chrono> //#sleep_for
#include <thread> //#sleep_for

#include <pybind11/pybind11.h> //for integrated python connectivity (==>put functionality into separate file ...!!!)
#include <pybind11/eval.h>

#include "Utilities/ExceptionsTemplates.h" //for exceptions in solver steps

#include "System/versionCpp.h"
#include "Linalg/BasicLinalg.h" //for Resizable Vector
#include "Main/CSystem.h"
#include "Autogenerated/CMarkerBodyPosition.h"
#include "Solver/CSolverBase.h" 

#include "Utilities/TimerStructure.h"
#include <fstream>
#include "Main/rendererPythonInterface.h" //for regular call to PyExecuteQueue(...)

extern STDstring GetExudynPythonVersionString(); //for sensor/solution file headers
extern STDstring GetExudynBuildVersionString(bool addDetails); //for sensor/solution file headers


namespace py = pybind11;	//for py::object

#include "Utilities/Parallel.h" //include after 
//
//#ifdef USE_NGSOLVE_TASKMANAGER
//#include "ngs-core-master/ngs_core.hpp"
//#include <thread>         // std::thread
//#include <mutex>          // std::mutex, std::unique_lock, std::defer_lock
////using namespace ngstd;
//#endif

//! initialize all data,it,conv; set/compute initial conditions (solver-specific!); initialize output files
bool CSolverBase::InitializeSolver(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//keep the following order!
	InitCSolverBase(); //reset all data, such that multiple calls to SolveSystem give same results

	PreInitializeSolverSpecific(computationalSystem, simulationSettings); //do solver specific things

	InitializeSolverOutput(computationalSystem, simulationSettings); //first needs to open files
	if (InitializeSolverPreChecks(computationalSystem, simulationSettings))
	{
		InitializeSolverData(computationalSystem, simulationSettings);
		InitializeSolverInitialConditions(computationalSystem, simulationSettings);

		PostInitializeSolverSpecific(computationalSystem, simulationSettings); //do solver specific things
		return true;
	}
	return false;
}

//! initialize output files; called from InitializeSolver(); must be done at the very beginning, as otherwise, no information is written!
void CSolverBase::InitializeSolverOutput(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration;
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;
	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	
	if (simulationSettings.outputPrecision >= 8) { file.binaryFileSettings.realSize = sizeof(double); }
	else { file.binaryFileSettings.realSize = sizeof(float); }

	if (IsStaticSolver())
	{
		output.verboseMode = staticSolver.verboseMode;
		output.verboseModeFile = staticSolver.verboseModeFile; //verbose mode of file
		output.stepInformation = staticSolver.stepInformation;
		newton = staticSolver.newton;
		discontinuous = staticSolver.discontinuous;
	} else
	{
		output.verboseMode = timeint.verboseMode;
		output.verboseModeFile = timeint.verboseModeFile; //verbose mode of file
		output.stepInformation = timeint.stepInformation;
		newton = timeint.newton;
		discontinuous = timeint.discontinuous;
	}

	//timer.Reset(simulationSettings.displayComputationTime); //done in SolveSteps

	STDstring solutionFileName = GetSolutionFileName(simulationSettings);
	STDstring solverFileName = solutionSettings.solverInformationFileName;

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open solution file
	output.writeToSolutionFile = solutionSettings.writeSolutionToFile;
	if (solutionFileName != "" && output.writeToSolutionFile)
	{
		CheckPathAndCreateDirectories(solutionFileName);

		std::ios_base::openmode fileMode = std::ofstream::out; //int does not work in linux!
		if (solutionSettings.appendToFile) 
		{ 
			fileMode = fileMode | std::ofstream::app; 
		}

		if (solutionSettings.binarySolutionFile) { fileMode = std::ofstream::binary; } //no append right now as loading is more involved!

		//if (solutionSettings.appendToFile) { file.solutionFile.open(solutionFileName, std::ofstream::app); }
		//else { file.solutionFile.open(solutionFileName, std::ofstream::out); }
		file.solutionFile.open(solutionFileName, fileMode);

		if (!file.solutionFile.is_open()) //failed to open file ...  e.g. invalid file name
		{
			output.writeToSolutionFile = false;
			SysError(STDstring("failed to open solution file '") + solutionFileName + "'", file.solverFile);
		}
		else
		{
			file.solutionFile.precision(solutionSettings.outputPrecision);
		}
	}
	else { output.writeToSolutionFile = false; }

	if (solutionSettings.writeRestartFile) { PyWarning("solutionSettings.writeRestartFile=True, but feature is yet not implemented"); }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open solver information file
	output.writeToSolverFile = false; //default
	if (output.verboseModeFile > 0 && solverFileName != "")
	{
		CheckPathAndCreateDirectories(solverFileName);
		if (solutionSettings.appendToFile) { file.solverFile.open(solverFileName, std::ofstream::app); }
		else { file.solverFile.open(solverFileName, std::ofstream::out); }
		
		if (!file.solverFile.is_open()) //failed to open file ...  e.g. invalid file name
		{
			SysError(STDstring("failed to open solution file '") + solverFileName + "'", file.solverFile);
		}
		else
		{
			output.writeToSolverFile = true;
			file.solverFile.precision(solutionSettings.outputPrecision);
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open sensor files
	//for every sensor there is an according enty in sensorFileList (may be Null pointer)
	//files need to be closed at any exit point!!!
	for (auto item : computationalSystem.GetSystemData().GetCSensors())
	{
		Index cnt = 0;
		if (item->GetWriteToFileFlag() && item->GetFileName().length() != 0)
		{
			std::ofstream* sensorFile = new std::ofstream;
			file.sensorFileList.push_back(sensorFile);
			auto fileMode = std::ofstream::out;
			if (solutionSettings.sensorsAppendToFile) { fileMode = std::ofstream::app; }

			CheckPathAndCreateDirectories(item->GetFileName());
			sensorFile->open(item->GetFileName(), fileMode);

			if (!sensorFile->is_open()) //failed to open file ...  e.g. invalid file name
			{
				SysError(STDstring("failed to open sensor file '") + item->GetFileName() + "' (sensor number " + EXUstd::ToString(cnt) + ")", file.solverFile);
				file.sensorFileList.back() = nullptr; //mark this ofstream as unwriteable
			}
			else
			{
				sensorFile->precision(solutionSettings.outputPrecision);
			}
			cnt++;
		}
		else
		{
			file.sensorFileList.push_back(nullptr);
		}
		
		//process for internal storage:
		if (item->GetStoreInternalFlag())
		{
			if (!solutionSettings.sensorsAppendToFile || item->GetInternalStorage().NumberOfRows() == 0)
			{

				Index stepsPlanned = 100; //allocate at least some space which makes no big problems
				if (IsStaticSolver())
				{
					stepsPlanned = EXUstd::Maximum(simulationSettings.staticSolver.numberOfLoadSteps, stepsPlanned);
				}
				else
				{ 
					Real writeSteps = simulationSettings.timeIntegration.endTime - simulationSettings.timeIntegration.startTime;
					if (simulationSettings.solutionSettings.sensorsWritePeriod != 0)
					{
						writeSteps /= simulationSettings.solutionSettings.sensorsWritePeriod;
					}
					stepsPlanned = EXUstd::Maximum((Index)writeSteps, stepsPlanned);
					stepsPlanned = EXUstd::Minimum(10000, stepsPlanned); //not too big, if they are never computed ...!
				}

				//pre-allocate data:
				item->GetInternalStorage().SetNumberOfRowsAndColumns(stepsPlanned, 4); //typical size for position sensor; will be less optimal for Coordinates sensor with 100+ coordinates, but only log2(nSteps) memory allocations

				//this marks that sensor data is reset ...
				item->GetInternalStorage().SetNumberOfRowsAndColumns(0, 0); 

			};
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	if (IsVerboseCheck(1))
	{
		VerboseWrite(1, STDstring("+++++++++++++++++++++++++++++++\nEXUDYN V") + EXUstd::ToString(EXUstd::exudynVersion) + " solver: " + GetSolverName() + "\n");
	}

}


//! initialize dense/sparse computation modes
bool CSolverBase::InitializeSolverPreChecks(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//now done separately
	computationalSystem.GetPostProcessData()->SetSolverMessage(STDstring(GetSolverName()) + " started");
	computationalSystem.GetPostProcessData()->SetSolutionMessage(simulationSettings.solutionSettings.solutionInformation);

	//some pre-checks for solver
	if (!computationalSystem.IsSystemConsistent()) { PyError("Solver: system is inconsistent and cannot be solved (call Assemble() and check error messages)", file.solverFile); return false; }

	computationalSystem.GetSystemData().GetNumberOfComputationCoordinates(data.nODE2, data.nODE1, data.nAE, data.nData);
	data.nSys = data.nODE2 + data.nODE1 + data.nAE;
	data.startAE = data.nODE2 + data.nODE1;
	if (data.startAE == data.nODE2 + data.nODE1 + data.nAE) { data.startAE = 0; } //data.startAE == data.nSys would lead to invalid pointer in LinkedDataVector; can only happen, if data.nAE==0

	//check for static solver, dynamic solver checked in solver specific implementation!
	if (IsStaticSolver() && data.nODE1 != 0) { SysError("StaticSolver cannot solve first order differential equations (ODE1) for now", file.solverFile); }

	if (data.nSys == 0)
	{
		PyError("Solver: cannot solve for system size = 0", file.solverFile);
		return false;
	}


	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		Index n = computationalSystem.GetSystemData().GetNumberOfComputationCoordinates();
		if (n > 1000) 
		{ 
			PyWarning("The number of total coordinates (unknowns) is larger than 1000. Consider a sparse solver (SimulationSettings().linearSolverType) to reduce memory consumption and computation time.", file.solverFile);
		}
	}
	else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse ||
		simulationSettings.linearSolverType == LinearSolverType::EigenSparseSymmetric)
	{
		EXUstd::AssignParallelizationParameters(simulationSettings);
	}
	else
	{
		PyError("Solver:InitializeSolverPreChecks: Unsupported simulationSettings.linearSolverType", file.solverFile);
		data.SetLinearSolverType(LinearSolverType::_None, false);
		return false;
	}

	computationalSystem.GetPostProcessData()->stopSimulation = false;
	computationalSystem.GetSolverData().Reset(); //e.g. set load factor to 1
	computationalSystem.GetPostProcessData()->simulationFinished = false;
	computationalSystem.GetPostProcessData()->postProcessDataReady = false;

	return true;
}


//! initialize all data,it,conv; called from InitializeSolver()
void CSolverBase::InitializeSolverData(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	conv.InitializeData();

	if ((simulationSettings.linearSolverType == LinearSolverType::EXUdense) ||
		(simulationSettings.linearSolverType == LinearSolverType::EigenSparse) ||
		(simulationSettings.linearSolverType == LinearSolverType::EigenSparseSymmetric))
	{
		data.SetLinearSolverType(simulationSettings.linearSolverType, simulationSettings.linearSolverSettings.reuseAnalyzedPattern);
	}
	//else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse)
	//{
	//	data.SetLinearSolverType(LinearSolverType::EigenSparse);
	//}
	//else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparseSymmetric)
	//{
	//	data.SetLinearSolverType(LinearSolverType::EigenSparseSymmetric);
	//}
	else
	{
		PyError("Solver:InitializeSolverData: Unsupported simulationSettings.linearSolverType", file.solverFile);
	}

	//++++++++++++++++++++++++++++++
	computationalSystem.GetSolverData().multithreadedLLimitLoads = simulationSettings.parallel.multithreadedLLimitLoads;
	computationalSystem.GetSolverData().multithreadedLLimitResiduals = simulationSettings.parallel.multithreadedLLimitResiduals;
	computationalSystem.GetSolverData().multithreadedLLimitJacobians = simulationSettings.parallel.multithreadedLLimitJacobians;
	computationalSystem.GetSolverData().multithreadedLLimitMassMatrix = simulationSettings.parallel.multithreadedLLimitMassMatrices;

	computationalSystem.GetSolverData().taskSplitMinItems = simulationSettings.parallel.taskSplitMinItems;
	computationalSystem.GetSolverData().taskSplitTasksPerThread = simulationSettings.parallel.taskSplitTasksPerThread;
	



	//++++++++++++++++++++++++++++++
	//initialize system vectors and matrices
	data.systemMassMatrix->SetNumberOfRowsAndColumns(data.nODE2, data.nODE2);
	data.systemJacobian->SetNumberOfRowsAndColumns(data.nSys, data.nSys);
	data.jacobianAE->SetNumberOfRowsAndColumns(data.nODE2, data.nAE);


	data.systemResidual.SetNumberOfItems(data.nSys);
	data.newtonSolution.SetNumberOfItems(data.nSys);	//temporary vector for Newton
	data.tempODE2.SetNumberOfItems(data.nODE2);			//temporary vector for ODE2 quantities; use in initial accelerations and during Newton
	data.tempODE2F0.SetNumberOfItems(data.nODE2);		//temporary vector for ODE2 Jacobian
	data.tempODE2F1.SetNumberOfItems(data.nODE2);		//temporary vector for ODE2 Jacobian
	data.tempODE1F0.SetNumberOfItems(data.nODE1);		//temporary vector for ODE1 Jacobian
	data.tempODE1F1.SetNumberOfItems(data.nODE1);		//temporary vector for ODE1 Jacobian
	//data.tempODE1.SetNumberOfItems(data.nODE1);			//temporary vector for ODE1 quantities

	//temp. structure to store start of discontinous iteration state:
	//  done in CleanUpMemory(): data.startOfDiscIteration.Reset();
	data.startOfStepStateAAlgorithmic.SetNumberOfItems(data.nODE2);


	it.newtonStepsCount = 0;				//count total number of Newton iterations
	it.newtonJacobiCount = 0;				//count total number of Jacobian computations and factorizations
	it.rejectedModifiedNewtonSteps = 0;		//count number of rejections of modifiedNewtonMethod
	it.discontinuousIterationsCount = 0;	//count total number of discontinuous iterations

	//used for computing average Newton iterations and jacobians:
	output.lastNewtonStepsCount = 0;
	output.lastNewtonJacobiCount = 0;
	output.lastDiscontinuousIterationsCount = 0;


	it.newtonSteps = 0;						//consistently initialize
	it.discontinuousIteration = 0;			//consistently initialize

	if (newton.weightTolerancePerCoordinate && data.nSys) { conv.errorCoordinateFactor = sqrt((Real)data.nSys); }
	else { conv.errorCoordinateFactor = 1.; }

	if (newton.newtonResidualMode != 0 && newton.newtonResidualMode != 1) //check residual mode: 0/1, otherwise not implemented by solvers!
	{ 
		PyError("Solver:InitializeSolverData: NewtonSettings.newtonResidualMode: unsupported mode"); 
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//parallelization started
	Index taskmanagerNumthreads = 1;
	output.multiThreadingMode = 0; //no multithreading
	output.numberOfThreadsUsed = 1;

	//Eigen::initParallel(); //with C++11 and eigen 3.3 optional
	Index nThreads = simulationSettings.parallel.numberOfThreads;
	//pout << "numThreads before init=" << exuThreading::TaskManager::GetNumThreads() << "\n";
	if (nThreads > 1)
	{
		//verboseMode not defined at this point ==> this part needs to move to initialization of solver!
		//VerboseWrite(1, STDstring("TaskManager::SetNumThreads = ") + EXUstd::ToString(simulationSettings.parallel.numberOfThreads) + "\n");
		exuThreading::TaskManager::SetNumThreads(simulationSettings.parallel.numberOfThreads);

		//for checking where time is lost
		//TaskManager::SetPajeTrace(true);
		//PajeTrace::SetMaxTracefileSize(100000000);

		taskmanagerNumthreads = exuThreading::EnterTaskManager(); //this is needed in order that any ParallelFor is executed in parallel during solving

		if (exuThreading::TaskManager::GetNumThreads() == 1) //this reflects that taskmanager is not running!
		{
			PyWarning("Initialize Solver: requested " + EXUstd::ToString(nThreads) + " threads, but taskmanager not available (Exudyn maybe not built with taskmanager?)");
		}
		else
		{
			//VerboseWrite(1, "EnterTaskManager with " + EXUstd::ToString(taskmanagerNumthreads) + " threads\n");
			STDstring strThreading;
#ifdef USE_MICROTHREADING
			strThreading = " (tiny threading)";
#endif 
			VerboseWrite(1, STDstring("Start multi-threading with ") + 
				EXUstd::ToString(exuThreading::TaskManager::GetNumThreads()) + " threads" + strThreading + "\n");

			output.multiThreadingMode = exuThreading::TaskManager::GetNumThreads(); //no multithreading
#ifdef USE_MICROTHREADING
			output.numberOfThreadsUsed = 2; //mode 2 = microthreading
#else
			output.numberOfThreadsUsed = 1; //mode 1 = NGsolve original
#endif

		}
	}
	else
	{
		//this is needed to set back number of threads to 0, which otherwise causes that CSystem functions are still using parallel mode if there was a parallel run before
		exuThreading::TaskManager::SetNumThreads(1); //necessary in order that computation functions have reserved correct size of arrays
		taskmanagerNumthreads = exuThreading::EnterTaskManager(); //this is needed in order that any ParallelFor is executed in parallel during solving
		exuThreading::ExitTaskManager(taskmanagerNumthreads);
	}
	//pout << "numThreads after init=" << exuThreading::TaskManager::GetNumThreads() << "\n";

	data.tempCompData = TemporaryComputationData();		//totally reset; for safety for now!
	data.tempCompDataArray.EraseData();		//totally reset; for safety for now!
	data.tempCompDataArray.SetNumberOfItems(taskmanagerNumthreads);
}



//! set/compute initial conditions (solver-specific!); called from InitializeSolver()
void CSolverBase::InitializeSolverInitialConditions(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//cache some variables
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

	if (!IsStaticSolver())
	{
		it.numberOfSteps = timeint.numberOfSteps;
		if (it.numberOfSteps == 0)
		{
			PyWarning("SolverInitialConditions: TimeIntegration.numberOfSteps == 0: setting number of steps to 1", file.solverFile);
			it.numberOfSteps = 1;
		}

		it.startTime = timeint.startTime;
		it.endTime = timeint.endTime;

		it.minStepSize = timeint.minimumStepSize;
		it.maxStepSize = (it.endTime - it.startTime) / (Real)(it.numberOfSteps);
		if (timeint.automaticStepSize) 
		{ 
			if (timeint.initialStepSize != 0.) { it.initialStepSize = timeint.initialStepSize; }
			else { it.initialStepSize = it.maxStepSize; } //chose max step size as initial guess if not provided
		}

		it.adaptiveStep = timeint.adaptiveStep;
		it.automaticStepSize = timeint.automaticStepSize && HasAutomaticStepSizeControl();
		it.automaticStepSizeError = 0;			//initialize stored step size error
		it.rejectedAutomaticStepSizeSteps = 0;	//initialize counter for rejected steps
	}
	else
	{
		it.numberOfSteps = staticSolver.numberOfLoadSteps;

		it.startTime = staticSolver.loadStepStart;
		it.endTime = staticSolver.loadStepStart + staticSolver.loadStepDuration;

		it.minStepSize = staticSolver.minimumStepSize;
		it.maxStepSize = staticSolver.loadStepDuration / (Real)(it.numberOfSteps);

		it.adaptiveStep = staticSolver.adaptiveStep;
		it.automaticStepSize = false; //not available for static solver, set false to be safe
		if (staticSolver.loadStepGeometric && staticSolver.adaptiveStep)
		{
			PyWarning("CSolverBase::InitializeSolverPreChecks: staticSolver.adaptiveStep is not possible for staticSolver.loadStepGeometric; adaptiveStep will be ignored", file.solverFile);
			it.adaptiveStep = false;
		}
	}
	if (IsVerbose(3))
	{
		Verbose(3, "number of steps = " + EXUstd::ToString(it.numberOfSteps) + "\n");
		Verbose(3, "start time = " + EXUstd::ToString(it.startTime) + "\n");
		Verbose(3, "end time = " + EXUstd::ToString(it.endTime) + "\n");
		Verbose(3, "minStepSize = " + EXUstd::ToString(it.minStepSize) + "\n");
		Verbose(3, "maxStepSize = " + EXUstd::ToString(it.maxStepSize) + "\n");
		Verbose(3, "adaptiveStep = " + EXUstd::ToString(it.adaptiveStep) + "\n");
	}

	//current values = initial values
	computationalSystem.GetSystemData().GetCData().initialState.time = it.startTime; //hereafter copied to currentState
	it.currentTime = it.startTime;
	computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().initialState;
	computationalSystem.GetSystemData().GetCData().startOfStepState = computationalSystem.GetSystemData().GetCData().initialState;

	if (!IsStaticSolver()) //not needed in static solver
	{
		//set according size of vectors, which are not initialized:
		data.aAlgorithmic.SetNumberOfItems(data.nODE2);
		computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt.SetNumberOfItems(data.nODE2);
		computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t.SetNumberOfItems(data.nODE1);
	}

	//+++++++++++++++++++++++++++++++++++++
	//timer functions: only work in combination with FinalizeSolver
	output.lastSolutionWritten = it.startTime;
	output.lastSensorsWritten = it.startTime;
	output.lastImageRecorded = it.startTime;
	output.cpuStartTime = EXUstd::GetTimeInSeconds();
	output.cpuLastTimePrinted = output.cpuStartTime;

	//+++++++++++++++++++++++++++++++++++++++++

	//do this not earlier than here, because checks need to be done prior to writing the header
	//2021-02-18: moved from end of function InitializeSolverPreChecks(...) to here in order to have current values available:
	WriteSolutionFileHeader(computationalSystem, simulationSettings); 
	WriteSensorsFileHeader(computationalSystem, simulationSettings);

}

//! specific call to the start solver
bool CSolverBase::SolveSystem(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{

	if (computationalSystem.GetPostProcessData()->forceQuitSimulation)
	{
		pout << "NOTE: Simulation stopped by user\n";
		pout << "      (to deactivate stop flag, re-start renderer or SetRenderEngineStopFlag(False)\n";
		return false; //no success because stopped
	}
	bool success = true; //local success variable
	SolverExceptionHandling([&]
	{
		success = InitializeSolver(computationalSystem, simulationSettings);
	}, "CSolverBase::InitializeSolver");

	globalTimers.Reset();
	timer.Reset(simulationSettings.displayComputationTime);
	timer.total = -EXUstd::GetTimeInSeconds();

	if (success)
	{
		SolverExceptionHandling([&]
		{
			success = SolveSteps(computationalSystem, simulationSettings);
		}, "CSolverBase::SolveSteps");
	}
	timer.total += EXUstd::GetTimeInSeconds();

	SolverExceptionHandling([&]
	{
		FinalizeSolver(computationalSystem, simulationSettings);
	}, "CSolverBase::FinalizeSolver");

	output.finishedSuccessfully = success;

	return success;
}


//! write concluding information (timer statistics, messages) and close files
//! main solver part: calls multiple InitializeStep(...)/PerformStep(...); do step reduction if necessary; return true if success, false else
void CSolverBase::FinalizeSolver(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Index nThreads = simulationSettings.parallel.numberOfThreads;
	if (nThreads > 1 && exuThreading::TaskManager::GetNumThreads() > 1)
	{
		VerboseWrite(1, "Stop multi-threading\n");
		exuThreading::ExitTaskManager(exuThreading::TaskManager::GetNumThreads());
	}

	if (IsVerboseCheck(1))
	{
		//write final step information if stopped or if failed
		if (conv.stepReductionFailed || conv.newtonSolutionDiverged ||
			computationalSystem.GetPostProcessData()->stopSimulation)
		{
			Real t = computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();
			Real tCPU = EXUstd::GetTimeInSeconds();
			STDstring str = "STEP" + EXUstd::ToString(it.currentStepIndex) + " (stopped)";
			if (!IsStaticSolver()) { str += ", t = " + EXUstd::ToString(t) + "s"; }
			else { str += ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings)); }

			if (output.stepInformation & StepInfo::timeToGo) {
				str += ", tCPU=" + EXUstd::ToString(tCPU - output.cpuStartTime) + "s";
			}

			if ((output.stepInformation & StepInfo::newtonIterations) && it.currentStepIndex != 0) {
				str += ", Nit/step = " + EXUstd::ToString(it.newtonStepsCount / (Real)(it.currentStepIndex));
			}
			if ((output.stepInformation & StepInfo::newtonJacobians) && it.currentStepIndex != 0) {
				str += " Dit/step = " + EXUstd::ToString(it.discontinuousIterationsCount / (Real)(it.currentStepIndex)) +
					" jac/step = " + EXUstd::ToString(it.newtonJacobiCount / (Real)(it.currentStepIndex));
			}
			str += "\n";
			if (output.verboseMode >= 1) { pout << str; }
			if (output.verboseModeFile >= 1) { file.solverFile << str; }

		}

		if (computationalSystem.GetPostProcessData()->stopSimulation)
		{
			VerboseWrite(1, STDstring("solver stopped by user after ") + EXUstd::ToString(timer.total) + " seconds.\n");
		}
		else
		{
			//if (simulationSettings.displayComputationTime) { VerboseWrite(1, STDstring("solver finished after ") + EXUstd::ToString(timer.total) + " seconds.\n"); }
			VerboseWrite(1, STDstring("solver finished after ") + EXUstd::ToString(timer.total) + " seconds.\n");
		}

		if (simulationSettings.displayComputationTime) //computation statistics
		{
			VerboseWrite(1, timer.ToString());
			if (simulationSettings.displayGlobalTimers) //contact, etc.
			{
				STDstring sGlobal;
				sGlobal = globalTimers.ToString();
				if (sGlobal.size())
				{
					sGlobal = "special timers:\n" + sGlobal + "\n";
					VerboseWrite(1, sGlobal);
				}
			}
		}
		if (simulationSettings.displayStatistics)
		{
			VerboseWrite(1, it.ToString());
		}
	}

	if (simulationSettings.solutionSettings.writeFileFooter && output.writeToSolutionFile)
	{
		STDstring footer = "";
		footer += "#simulation finished=" + EXUstd::GetDateTimeString() + "\n";
		footer += "#Solver Info:";
		footer += " cpuTime=" + EXUstd::ToString(timer.total);
		footer += " stepReductionFailed(or step failed)=" + EXUstd::ToString(conv.stepReductionFailed);
		footer += ",discontinuousIterationSuccessful=" + EXUstd::ToString(conv.discontinuousIterationSuccessful);
		footer += ",newtonSolutionDiverged=" + EXUstd::ToString(conv.newtonSolutionDiverged);
		footer += ",massMatrixNotInvertible=" + EXUstd::ToString(conv.massMatrixNotInvertible);
		footer += ",total time steps=" + EXUstd::ToString(it.currentStepIndex - 1); //initial step is also counted in it.currentStepIndex
		footer += ",total Newton iterations=" + EXUstd::ToString(it.newtonStepsCount);
		footer += ",total Newton jacobians=" + EXUstd::ToString(it.newtonJacobiCount) + "\n";

		if (!simulationSettings.solutionSettings.binarySolutionFile)
		{
			//file.solutionFile << "#simulation finished=" << EXUstd::GetDateTimeString() << "\n";
			//file.solutionFile << "#Solver Info:";
			//file.solutionFile << " stepReductionFailed(or step failed)=" << conv.stepReductionFailed;
			//file.solutionFile << ",discontinuousIterationSuccessful=" << conv.discontinuousIterationSuccessful;
			//file.solutionFile << ",newtonSolutionDiverged=" << conv.newtonSolutionDiverged;
			//file.solutionFile << ",massMatrixNotInvertible=" << conv.massMatrixNotInvertible;
			//file.solutionFile << ",total time steps=" << it.currentStepIndex - 1; //initial step is also counted in it.currentStepIndex
			//file.solutionFile << ",total Newton iterations=" << it.newtonStepsCount;
			//file.solutionFile << ",total Newton jacobians=" << it.newtonJacobiCount << "\n";

			file.solutionFile << footer;
		}
		else
		{
			const ExuFile::BinaryFileSettings& bfs = file.binaryFileSettings;

			ExuFile::BinaryWrite((Index)(-1), file.solutionFile, bfs); //indicating last line with -1

			ExuFile::BinaryWrite("simulation finished=", file.solutionFile, bfs);
			ExuFile::BinaryWrite(EXUstd::GetDateTimeString(), file.solutionFile, bfs);

			//write information as ArrayIndex, allows simpler change in size without adapting file structure:
			ArrayIndex info({ (Index)conv.stepReductionFailed,
				(Index)conv.discontinuousIterationSuccessful,
				(Index)conv.newtonSolutionDiverged,
				(Index)conv.massMatrixNotInvertible,
				(Index)(it.currentStepIndex - 1),
				(Index)it.newtonStepsCount,
				(Index)it.newtonJacobiCount });
			ExuFile::BinaryWrite(info, file.solutionFile, bfs);
			ExuFile::BinaryWrite("EXUEND", file.solutionFile, bfs);
		}

		if (simulationSettings.solutionSettings.sensorsWriteFileFooter)
		{
			Index cnt = 0;
			for (auto item : computationalSystem.GetSystemData().GetCSensors())
			{
				if ((Index)file.sensorFileList.size() > cnt && file.sensorFileList[cnt] != nullptr)
				{
					std::ofstream* sFile = file.sensorFileList[cnt];
					(*sFile) << footer;
				}
				else
				{
					//evaluate sensors, especially for UserSensors, which may do some tricky (recording) things internally, but which are not written
					item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current); //only for checking size of sensor output, computed values not used
				}
				cnt++;
			}

		}
	}

	computationalSystem.GetPostProcessData()->simulationFinished = true; //signal that last step should be rendered

	//clean up memory of large matrices
	if (simulationSettings.cleanUpMemory) { data.CleanUpMemory(); }

	if (!conv.stepReductionFailed)
	{
		computationalSystem.GetPostProcessData()->SetSolverMessage("Solver finished successfully");
	}
	else { computationalSystem.GetPostProcessData()->SetSolverMessage("Solver finished with errors"); }

	//++++++++++++++++++++++++++++++++++
	//final finalize: close files (NO EARLIER!)
	if (file.solutionFile.is_open()) { file.solutionFile.close(); }
	if (file.solverFile.is_open()) { file.solverFile.close(); }

	//close sensor files:
	for (auto* item : file.sensorFileList)
	{
		if (item != nullptr)
		{
			item->close();
			delete item;
			item = nullptr;
		}
	}
	file.sensorFileList.clear();
	//pout << "sensor list length=" << file.sensorFileList.size() << "\n";
}

//! main solver part: calls multiple InitializeStep(...)/PerformStep(...); do step reduction if necessary; return true if success, false else
bool CSolverBase::SolveSteps(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (IsVerbose(2)) { Verbose(2, "\nStart steps solving loop\n"); }

	if (it.automaticStepSize) { it.currentStepSize = it.initialStepSize; }
	else { it.currentStepSize = it.maxStepSize; }//initial value for step size

	it.currentStepIndex = 0;
	output.lastVerboseStepIndex = 0;

	conv.stepReductionFailed = false;
	conv.jacobianUpdateRequested = true;	//for modified Newton, only request Newton at first step

	Index stepsSinceLastStepSizeReduction = 0;

	if (IsVerbose(2)) { Verbose(2, "\nWrite initial step to solution file and visualize ...\n"); }
	//perform initialization for initial values (write to file, show solution, ...); 
	
	//flag to switch off writing of initial values for solution files and sensors
	FinishStep(computationalSystem, simulationSettings, simulationSettings.solutionSettings.writeInitialValues); //visualization, console output, file output, ...


	bool simulationEndTimeReached = false; //signals that end time has been reached (tEnd in time integration, loadFactor=1 in static solver)
	it.currentStepIndex++; //first step starts with stepIndex = 1

	while (!conv.stepReductionFailed && !simulationEndTimeReached &&
		!computationalSystem.GetPostProcessData()->stopSimulation)
	{
		computationalSystem.GetSystemData().GetCData().startOfStepState = computationalSystem.GetSystemData().GetCData().currentState; //for step reduction, disc. iteration, python functions, etc.
		data.startOfStepStateAAlgorithmic.CopyFrom(data.aAlgorithmic);

		//Real t = it.currentStepIndex * it.currentStepSize + it.startTime;
		//computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //update time in state --> also available in Python for user-defined functions

		bool stepAccomplished = false;
		//do step size reduction
		while (!stepAccomplished && !conv.stepReductionFailed)
		{

			//python linking, visualization, output, ... for every step
			InitializeStep(computationalSystem, simulationSettings);

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//Post Newton iteration for one time step
			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			if (newton.modifiedNewtonJacUpdatePerStep) { conv.jacobianUpdateRequested = true; }
			it.lastStepSize = it.currentStepSize; //store step size to check if automatic step size and adaptive step size fit
			
			if (!DiscontinuousIteration(computationalSystem, simulationSettings))
			{
				//try to reduce step size

				if (it.adaptiveStep || it.automaticStepSize)
				{
					computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().startOfStepState; //completely reset state including data variables and time

					if (!ReduceStepSize(computationalSystem, simulationSettings, 1, it.recommendedStepSize)) //only for adaptiveStep; automaticStepSize already done in Newton()
					{
						conv.stepReductionFailed = true;
						if (IsVerboseCheck(1))
						{
							VerboseWrite(1, "Solve steps: adaptive step reduction reached minimum step size; stop solver\n");
						}
					}
					else
					{
						if (IsVerboseCheck(1) && (output.stepInformation & StepInfo::stepReductionWarn) && (!it.automaticStepSize || !(conv.newtonConverged && !conv.stopNewton)))
						{
							//VerboseWrite(1, STDstring("  Solve steps: adaptive reduction to step size = ") + EXUstd::ToString(it.currentStepSize) + "\n");
							STDstring str = STDstring("  Solve steps: adaptive reduction to step size = ") + EXUstd::ToString(it.currentStepSize);
							if (IsStaticSolver()) { str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor); }
							else { str += ", time = " + EXUstd::ToString(it.currentTime); }
							VerboseWrite(1, str + "\n");
						}
						stepsSinceLastStepSizeReduction = 0;
					}
				}
				else
				{
					conv.stepReductionFailed = true;
				}
			}
			else
			{
				stepAccomplished = true;
				FinishStep(computationalSystem, simulationSettings); //visualization, console output, file output, ...

				//in case of good Newton convergence, increase step size
				stepsSinceLastStepSizeReduction++;
				Index recoverySteps = simulationSettings.timeIntegration.adaptiveStepRecoverySteps;
				Index recoveryStepsMaxIt = simulationSettings.timeIntegration.adaptiveStepRecoveryIterations;
				if (IsStaticSolver()) { 
					recoverySteps = simulationSettings.staticSolver.adaptiveStepRecoverySteps;
					recoveryStepsMaxIt = simulationSettings.staticSolver.adaptiveStepRecoveryIterations;
				}

				//OLD: if ((stepsSinceLastStepSizeReduction >= 10 || (IsStaticSolver() && stepsSinceLastStepSizeReduction > 3)) &&
				if ((stepsSinceLastStepSizeReduction >= recoverySteps) &&
						it.newtonSteps + it.discontinuousIteration <= recoveryStepsMaxIt) //previous: < 6 (2022-01-17); small iteration numbers needed to increase step ...
				{
					IncreaseStepSize(computationalSystem, simulationSettings);
					stepsSinceLastStepSizeReduction = 0;
				}
			}
		}

		it.currentStepIndex++; //increment iteration count
		if (it.currentTime >= it.endTime - 1e-10) { simulationEndTimeReached = true; } //accept small tolerance
	}//time integration loop

	return !conv.stepReductionFailed; //return success (true) or fail (false)
}


bool cSolverBaseInitializeStepPreStepFunctionWarned = false;

//! initialize static step / time step: do some outputs, checks, etc.
void CSolverBase::InitializeStep(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	UpdateCurrentTime(computationalSystem, simulationSettings);

	computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //update time in state --> also available in Python for user-defined functions

	if (IsVerbose(2)) {
		Real t = it.currentTime; // computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();
		STDstring str;
		str += "+++++++++++++++ COMPUTE STEP +++++++++++++++\n";
		if (!IsStaticSolver())
		{
			str += "STEP" + EXUstd::ToString(it.currentStepIndex) + ", t = " + EXUstd::ToString(t);
			if (it.adaptiveStep) { str += ", step size = " + EXUstd::ToString(it.currentStepSize); }
			str += "\n";
		}
		else
		{
			str += "STEP" + EXUstd::ToString(it.currentStepIndex) + ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings));
			if (t != ComputeLoadFactor(simulationSettings)) { str += ", t = " + EXUstd::ToString(t); }
			if (it.adaptiveStep) { str += ", step size = " + EXUstd::ToString(it.currentStepSize); }
			str += "\n";
		}

		Verbose(2, str);
	}
	if (!IsStaticSolver())
	{
		it.endTime = simulationSettings.timeIntegration.endTime; //update time, which may be updated for long integration time
	}

	STARTTIMER(timer.python);
	if (computationalSystem.GetPythonUserFunctions().preStepFunction)
	{
		bool rvPreStep = false; //initialize to suppress gcc warning
		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			rvPreStep = computationalSystem.GetPythonUserFunctions().preStepFunction(*(computationalSystem.GetPythonUserFunctions().mainSystem),
				it.currentTime);
		}, "CSolverBase::InitializeStep: PythonPreStepUserFunction failed (check code; check return value)");
		if (!rvPreStep)
		{
			if (IsVerbose(1)) { Verbose(1, STDstring("\n++++++++++++++++++++++++++++++\nPreStepUserFunction returned False; simulation is stopped after current step\n\n")); }
			computationalSystem.GetPostProcessData()->stopSimulation = true;
		}
	}

	//if (!IsStaticSolver())
	//{
	//	if (simulationSettings.timeIntegration.preStepPyExecute.size()) //if this string is not empty, execute the commands
	//	{
	//		if (!cSolverBaseInitializeStepPreStepFunctionWarned)
	//		{
	//			cSolverBaseInitializeStepPreStepFunctionWarned = true;
	//			PyWarning("simulationSettings.timeIntegration.preStepPyExecute and simulationSettings.staticSolver.preStepPyExecute are deprecated! Use mbs.SetPreStepUserFunction(...) instead.");
	//		}

	//		py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
	//		py::exec(simulationSettings.timeIntegration.preStepPyExecute.c_str(), scope);
	//	}
	//}
	//else
	//{
	//	if (simulationSettings.staticSolver.preStepPyExecute.size()) //if this string is not empty, execute the commands
	//	{
	//		if (!cSolverBaseInitializeStepPreStepFunctionWarned)
	//		{
	//			cSolverBaseInitializeStepPreStepFunctionWarned = true;
	//			PyWarning("simulationSettings.timeIntegration.preStepPyExecute and simulationSettings.staticSolver.preStepPyExecute are deprecated! Use mbs.SetPreStepUserFunction(...) instead.");
	//		}
	//		py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
	//		py::exec(simulationSettings.staticSolver.preStepPyExecute.c_str(), scope);
	//	}
	//}
	DoIdleOperations(computationalSystem);
	STOPTIMER(timer.python);
}


//! unique conversion of time into string (use seconds up to certain level, then hours, etc.)
STDstring SolverTimeToString(double timeInSeconds)
{
	if (timeInSeconds < 3600)
	{
		return EXUstd::ToString(timeInSeconds) + "s";
	}
	else if (timeInSeconds < 3600 * 24)
	{
		return EXUstd::ToString(timeInSeconds / 3600.) + "h";
	}
	else
	{
		return EXUstd::ToString(timeInSeconds / (3600.*24)) + " days";
	}
}
//! finish static step / time step; write output of results to file; writeSolution will switch on/off writing solution and sensor outputs
void CSolverBase::FinishStep(CSystem& computationalSystem, const SimulationSettings& simulationSettings, bool writeSolution)
{
	Real t = computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();
	Real tCPU = EXUstd::GetTimeInSeconds();
	Real timeDelay = 2.; //print output every 2 seconds
	if (tCPU - output.cpuStartTime > 3600) { timeDelay = 30; }

	//output step information to console and solverFile
	bool printFile = ((output.verboseModeFile == 1) && ((tCPU - output.cpuLastTimePrinted >= timeDelay)
		|| it.currentTime + 1e-10>=it.endTime )) || (output.verboseModeFile >= 2 || ((output.stepInformation & StepInfo::everyStep) != 0));
	bool printConsole = ((output.verboseMode == 1) && ((tCPU - output.cpuLastTimePrinted >= timeDelay)
		|| it.currentTime + 1e-10 >= it.endTime)) || (output.verboseMode >= 2 || ((output.stepInformation & StepInfo::everyStep) != 0));

	if (simulationSettings.timeIntegration.simulateInRealtime)
	{
		Real cpuTimeElapsed = simulationSettings.timeIntegration.realtimeFactor * (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		Real simTimeElapsed = t - it.startTime;
		Index waitMicroSeconds = simulationSettings.timeIntegration.realtimeWaitMicroseconds; //wait time until next computation

		while (cpuTimeElapsed < simTimeElapsed) //no workaround if simTimeElapsed would be much too big
		{
			if (waitMicroSeconds != 0)
			{
				std::this_thread::sleep_for(std::chrono::microseconds(waitMicroSeconds)); //avoid continuous computation
			}
			cpuTimeElapsed = (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		}
	}

	if (printFile || printConsole)
	{
		STARTTIMER(timer.overhead);
		output.cpuLastTimePrinted += timeDelay;
		
		//avoid large deviations between cpuLastTimePrinted and CPU time:
		if (tCPU - output.cpuLastTimePrinted > timeDelay*0.5) { output.cpuLastTimePrinted = EXUstd::GetTimeInSeconds();}

		Real timeToGo = 0;
		Real cpuTimeElapsed = (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		Real simTotalTime = it.endTime - it.startTime;
		Real simTimeRemaining = it.endTime - t;
		Real simTimeElapsed = t - it.startTime;

		if (cpuTimeElapsed > 0.2 && simTimeElapsed > EXUstd::Minimum(it.initialStepSize*10,1e-5*simTotalTime) && it.currentStepIndex != 0)
		{
			timeToGo = simTimeRemaining * (cpuTimeElapsed / simTimeElapsed);
			//old: based on steps: timeToGo = (double)(n - it.currentStepIndex) * timeToGo / (double)i;
		}

		STDstring str = "STEP" + EXUstd::ToString(it.currentStepIndex);
		if (!IsStaticSolver()) { str += ", t = " + EXUstd::ToString(t) + "s"; }
		else { str += ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings)); }

		//output.stepInformation: add up the following binary flags : 

		if (output.stepInformation & StepInfo::stepSize) {
			str += ", dt = " + SolverTimeToString(it.currentStepSize);
		}

		if (output.stepInformation & StepInfo::timeToGo) {
			str += ", timeToGo = " + SolverTimeToString(timeToGo);
		}
		if (output.stepInformation & StepInfo::CPUtimeSpent) {
			str += ", tCPU=" + SolverTimeToString(tCPU - output.cpuStartTime);
		}
		Index stepsSinceLastOutput = it.currentStepIndex - output.lastVerboseStepIndex;
		Index newtonStepsSinceLastOutput = it.newtonStepsCount - output.lastNewtonStepsCount;
		Index newtonJacobiSinceLastOutput = it.newtonJacobiCount - output.lastNewtonJacobiCount;
		Index discItSinceLastOutput = it.discontinuousIterationsCount - output.lastDiscontinuousIterationsCount;

		output.lastVerboseStepIndex = it.currentStepIndex;
		output.lastNewtonStepsCount = it.newtonStepsCount;
		output.lastNewtonJacobiCount = it.newtonJacobiCount;
		output.lastDiscontinuousIterationsCount = it.discontinuousIterationsCount;

		if ((output.stepInformation & StepInfo::newtonIterations) && stepsSinceLastOutput != 0) {
			str += ", Nit/step = " + EXUstd::ToString(newtonStepsSinceLastOutput / (Real)(stepsSinceLastOutput));
		}
		if ((output.stepInformation & StepInfo::newtonJacobians) && stepsSinceLastOutput != 0) {
			str += ", jac/step = " + EXUstd::ToString(newtonJacobiSinceLastOutput / (Real)(stepsSinceLastOutput));
		}
		if ((output.stepInformation & StepInfo::discIterations) && stepsSinceLastOutput != 0) {
			str += ", Dit/step = " + EXUstd::ToString(discItSinceLastOutput / (Real)(stepsSinceLastOutput));
		}
		str += "\n";
		if (printConsole) { pout << str; }
		if (printFile) { file.solverFile << str; }
		if (IsVerbose(2)) { Verbose(2, "+++++++++++++++ STEP FINISHED ++++++++++++++\n\n"); }

		STOPTIMER(timer.overhead);
	}

	if (output.writeToSolutionFile && writeSolution)
	{

		//modify lastSolutionWritten to include last step in output file
		if (fabs(t - it.endTime) <= 1e-10) {
			output.lastSolutionWritten = it.endTime - it.currentStepSize;
		}

		STARTTIMER(timer.writeSolution);
		WriteCoordinatesToFile(computationalSystem, simulationSettings);
		STOPTIMER(timer.writeSolution);
	}

	if (computationalSystem.GetSystemData().GetCSensors().NumberOfItems() != 0 && writeSolution)
	{
		//modify lastSolutionWritten to include last step in output file
		if (fabs(t - it.endTime) <= 1e-10) {
			output.lastSensorsWritten = it.endTime - it.currentStepSize;
		}

		STARTTIMER(timer.writeSolution);
		WriteSensorsToFile(computationalSystem, simulationSettings);
		STOPTIMER(timer.writeSolution);
	}

	STARTTIMER(timer.visualization);

	bool recordImage = false;

	if (simulationSettings.solutionSettings.recordImagesInterval >= 0)
	{
		if (t >= output.lastImageRecorded + simulationSettings.solutionSettings.recordImagesInterval)
		{
			output.lastImageRecorded += simulationSettings.solutionSettings.recordImagesInterval; //keep this interval constant to obtain frames recorded in constant time interval
			recordImage = true;
		}
	}

	//update postprocess data only if visualization is running ...
	if (computationalSystem.GetPostProcessData()->VisualizationIsRunning())
	{
		computationalSystem.UpdatePostProcessData(recordImage);
	}

	if (simulationSettings.pauseAfterEachStep) { computationalSystem.GetPostProcessData()->WaitForUserToContinue(); }
	STOPTIMER(timer.visualization);
}

//! perform discontinuousIteration for static step / time step
bool CSolverBase::DiscontinuousIteration(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{

	conv.discontinuousIterationError = 0;		//error of discontinuous iterations (contact, friction, ...) outside of Newton iteration

	//data.startOfStepStateAAlgorithmic = data.aAlgorithmic; //changed 2019-12-29; moved to SolveSteps(...)
	CSystemState& current = computationalSystem.GetSystemData().GetCData().GetCurrent();

	conv.discontinuousIterationSuccessful = false;
	it.discontinuousIteration = 0;

	while (it.discontinuousIteration < discontinuous.maxIterations && !conv.discontinuousIterationSuccessful)
	{
		if (IsVerbose(2)) { Verbose(2,STDstring("  START discontinuous iteration ")+EXUstd::ToString(it.discontinuousIteration) + ":\n"); }

		if (Newton(computationalSystem, simulationSettings))
		{
			FinalizeNewton(computationalSystem, simulationSettings);
			//conv.discontinuousIterationError = computationalSystem.PostNewtonStep(data.tempCompData);
			
			if (computationalSystem.GetSystemData().listDiscontinuousIteration.NumberOfItems() != 0)
			{ STARTTIMER(timer.postNewton); }
			conv.discontinuousIterationError = PostNewton(computationalSystem, simulationSettings);
			if (computationalSystem.GetSystemData().listDiscontinuousIteration.NumberOfItems() != 0)
			{ STOPTIMER(timer.postNewton); }


			if (IsVerbose(2))
			{
				STDstring str = STDstring("  discontinuous iteration error = ") + EXUstd::ToString(conv.discontinuousIterationError)
					+ " (disc.it.=" + EXUstd::ToString(it.discontinuousIteration)
					+ ", error goal = " + EXUstd::ToString(discontinuous.iterationTolerance);
				if (conv.discontinuousIterationError <= discontinuous.iterationTolerance)
				{
					str += " ... REACHED";
				}
				str += ")\n";
				Verbose(2, str);
			}
			if (IsVerbose(3)) //print more details about disc. iteration
			{
				STDstring str;
				str += "    disc.it. solU      = " + EXUstd::ToString(current.ODE2Coords) + "\n";
				if (!IsStaticSolver())
				{
					str += "    disc.it. solV      = " + EXUstd::ToString(current.ODE2Coords_t) + "\n";
					str += "    disc.it. solA      = " + EXUstd::ToString(current.ODE2Coords_tt) + "\n";
				}
				str += "    disc.it. solData   = " + EXUstd::ToString(current.dataCoords) + "\n";
				str += "    disc.it. solLambda = " + EXUstd::ToString(current.AECoords) + "\n";
				Verbose(3, str);
			}

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			it.discontinuousIteration++; it.discontinuousIterationsCount++;

			if (conv.discontinuousIterationError > discontinuous.iterationTolerance)
			{
				if (it.discontinuousIteration < discontinuous.maxIterations)
				{
					//start NEW DiscontinuousIteration
					//reset states to start of discontinuous iteration, EXCEPT for data variables!:
					current.ODE2Coords = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
					current.ODE2Coords_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_t;
					current.ODE2Coords_tt = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_tt;
					current.ODE1Coords = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords;
					current.ODE1Coords_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords_t;
					current.AECoords = computationalSystem.GetSystemData().GetCData().startOfStepState.AECoords;
					data.aAlgorithmic = data.startOfStepStateAAlgorithmic; //for generalized-alpha

					//check if some hints to reduce step size
					if (it.recommendedStepSize != -1 &&
						it.recommendedStepSize < (1+1e-8)*it.currentStepSize) //allow some tolerance to avoid many switches for linear problems
					{
						conv.discontinuousIterationSuccessful = false;
						return false;
					}
				}
				else
				{
					//MAX iterations reached --> stop
					if (!discontinuous.ignoreMaxIterations) { return false; }

					//continue solver if discontinuous iterations do not converge
					conv.discontinuousIterationSuccessful = true;
				}
			}
			else { conv.discontinuousIterationSuccessful = true; }

		}
		else
		{
			//NEWTON not successful --> terminate disc. iteration
			conv.discontinuousIterationError = discontinuous.iterationTolerance * 2.;
			conv.discontinuousIterationSuccessful = true; //in this case, it is the fault of Newton, not of discontinuous iteration

			return false;
		}
	} //discontinuous (postNewton) iteration
	if (discontinuous.maxIterations == 0) { conv.discontinuousIterationSuccessful = true; } //true because no iterations wanted
	return conv.discontinuousIterationSuccessful; //return success; in case that no discIter. are needed (==0), no error is returned
}

//Index TSfinalizeMatrix;
//TimerStructureRegistrator TSRfinalizeMatrix("finalize matrix", TSfinalizeMatrix, globalTimers);
//Index TSfactorize;
//TimerStructureRegistrator TSRfactorize("factorize", TSfactorize, globalTimers);

//! perform Newton method for given solver method
bool CSolverBase::Newton(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	STARTTIMER(timer.overhead);

	//LinkedDataVector ode2Residual(data.systemResidual, 0, data.nODE2); //link ODE2 coordinates
	//LinkedDataVector aeResidual(data.systemResidual, data.startAE, data.nAE); //link ae coordinates
	LinkedDataVector newtonSolutionODE2(data.newtonSolution, 0, data.nODE2); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionODE1(data.newtonSolution, data.nODE2, data.nODE1); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionAE(data.newtonSolution, data.startAE, data.nAE); //temporary subvector for ODE2 components

	//link current system vectors for ODE2
	Vector& solutionODE2 = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	Vector& solutionODE2_t = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	Vector& solutionODE2_tt = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	Vector& solutionODE1 = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords;
	Vector& solutionODE1_t = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t;
	Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;
	Vector& solutionAE = computationalSystem.GetSystemData().GetCData().currentState.AECoords;

	conv.linearSolverFailed = false;		//(errorOccurred) signals that linear solver failed ==> abort integration method or reduce step size
	conv.linearSolverCausingRow = -1;
	conv.newtonConverged = false;			//convergence of Newton reached by tolerance criteria
	conv.newtonSolutionDiverged = false;	//shows that solution diverged (e.g. in first step)

	bool ignoreRedundantEquations = false;
	Index redundantEqStart = 0;
	if (simulationSettings.linearSolverSettings.ignoreSingularJacobian || simulationSettings.linearSolverSettings.ignoreRedundantConstraints)
	{
		ignoreRedundantEquations = true;
		if (simulationSettings.linearSolverSettings.ignoreRedundantConstraints && !simulationSettings.linearSolverSettings.ignoreSingularJacobian)
		{
			redundantEqStart = data.startAE;
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//NEWTON method for one time step
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Real absError = -1; //current error
	Real initialResidual;

	
	solutionAE.SetAll(0.);		//use zero Lagrange multipliers as start guess for Newton iterations step ==> does not work for algebraic variables such as in sliding joint
	STOPTIMER(timer.overhead);

	//compute initial residual:
	data.newtonSolution.SetAll(0.); //no update yet
	//solutionODE2_tt must contain initial accelerations!
	ComputeNewtonUpdate(computationalSystem, simulationSettings, true); //for initial computations; better initial guess for Newton for old solver

	initialResidual = ComputeNewtonResidual(computationalSystem, simulationSettings);

	if (newton.newtonResidualMode == 1) { //coordinate update as residual
		initialResidual = 2*newton.relativeTolerance; //use some initial tolerance; if the step returns a higher residual, the initialResidual is reduced hereafter
	}

	if (initialResidual <= newton.absoluteTolerance)
	{
		initialResidual = 2.*newton.absoluteTolerance; //Make at least one Newton step and avoid division by zero! factor 2 is for safety
	}

	if (IsVerbose(2)) { Verbose(2, "Newton: initial residual = " + EXUstd::ToString(initialResidual) +
		"; goals: relTol=" + EXUstd::ToString(newton.relativeTolerance) +
		", absTol=" + EXUstd::ToString(newton.absoluteTolerance) + "\n"); }


	it.newtonSteps = 0; //current number of steps
	conv.residual = initialResidual;				//current residual
	conv.lastResidual = initialResidual;			//to determine contractivity
	conv.contractivity = 0;							//contractivity = geometric decay of error in every step
	bool modifiedNewtonRestarted = false;			//flag, which signals that modified Newton method has already been restarted
	bool fullNewtonRequested = !newton.useModifiedNewton; //in every step, the modified Newton method can switch to full Newton's method
	conv.stopNewton = false;						//flag which tells that Newton shall be stopped (Jacobian singular, full Newton not converged, ?)
	//conv.errorCoordinateFactor = 1.;				//2021-02-06: removed, because is treated in InitializeSolverData(...)


	bool addRestartNewtonStep = false; //request additional Newton step after restart (reduces disturbances due to algorithmic accelerations)

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Newton iterations
	while (!conv.linearSolverFailed && !conv.newtonConverged && 
		!conv.stopNewton && it.newtonSteps < newton.maxIterations)
	{
		if (data.nSys > 200) { 	DoIdleOperations(computationalSystem); } //do this task regularly, specifically in large scale systems

		it.newtonSteps++; it.newtonStepsCount++;
		if (IsVerbose(3)) { Verbose(3, "  Newton: STEP "  + EXUstd::ToString(it.newtonSteps) + ":\n"); }
		if (IsVerbose(3)) { Verbose(3, "    systemResidual = " + EXUstd::ToString(data.systemResidual) + "\n"); }

		//+++++++++++++++++++++++++++++
		//compute JACOBIAN if necessary
		if (conv.jacobianUpdateRequested || fullNewtonRequested || computationalSystem.GetSolverData().signalJacobianUpdate)
		{
			if (newton.useModifiedNewton && IsVerbose(2))
			{
				STDstring str = "  Update Jacobian ... (flags: jacUpdateReq=" + EXUstd::ToString(conv.jacobianUpdateRequested) +
					", fullNewtonReq=" + EXUstd::ToString(fullNewtonRequested) +
					", sigJacUpdate=" + EXUstd::ToString(computationalSystem.GetSolverData().signalJacobianUpdate) + "\n";
				Verbose(2, str);
			}
			ComputeNewtonJacobian(computationalSystem, simulationSettings);

			STARTTIMER(timer.factorization);

			//STARTGLOBALTIMER(TSfinalizeMatrix);
			data.systemJacobian->FinalizeMatrix();
			//STOPGLOBALTIMER(TSfinalizeMatrix);
			//STARTGLOBALTIMER(TSfactorize);

			Index factorizeOutput = data.systemJacobian->FactorizeNew(ignoreRedundantEquations, redundantEqStart);
			if (factorizeOutput != -1)
			{
				//if (IsVerboseCheck(1)) 
				//{
				//	STDstring str = "  Solver (time/load step #" + EXUstd::ToString(it.currentStepIndex) +
				//		"): factorization of system Jacobian failed";
				//	if (IsStaticSolver()) { str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor); }
				//	str += ", time = " + EXUstd::ToString(it.currentTime);
				//	str += "\n";
				//	VerboseWrite(1, str);
				//}
				std::string s = "CSolverBase::Newton: System Jacobian seems to be singular / not invertible!\n";
				s += "  time/load step #" + EXUstd::ToString(it.currentStepIndex);
				if (IsStaticSolver()) { s += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor); }
				s += ", time = " + EXUstd::ToString(it.currentTime) +"\n";

				if (factorizeOutput < data.systemJacobian->NumberOfRows())
				{
					s += "  causing system equation number (coordinate number) = " + EXUstd::ToString(factorizeOutput) + "\n";
				}
				conv.linearSolverFailed = true;
				conv.linearSolverCausingRow = factorizeOutput;
				SysError(s); //this error might not be recoverable
				conv.stopNewton = true;
			}
			//STOPGLOBALTIMER(TSfactorize);
			STOPTIMER(timer.factorization);

			it.newtonJacobiCount++;
			conv.jacobianUpdateRequested = false;
		}

		//+++++++++++++++++++++++++++++
		//perform step
		if (!conv.linearSolverFailed)
		{
			if (IsVerbose(4)) {Verbose(4, "    JacInv = " + EXUstd::ToString(*(data.systemJacobian)) + "\n"); }

			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//now compute descent of acceleration vector with jacobian

			STARTTIMER(timer.newtonIncrement);
			data.systemJacobian->Solve(data.systemResidual, data.newtonSolution);
			STOPTIMER(timer.newtonIncrement);

			ComputeNewtonUpdate(computationalSystem, simulationSettings);


			if (IsVerbose(3)) { Verbose(3, "    newtonIncrement = " + EXUstd::ToString(data.newtonSolution) + "\n    ... compute new residual\n"); }

			//++++++++++++++++++++++++++++++++++++++++++
			//compute residual from static step increment or from integration formula:
			conv.residual = ComputeNewtonResidual(computationalSystem, simulationSettings); 

			if (newton.newtonResidualMode == 1) //special case, not treated in ComputeNewtonResidual
			{
				conv.residual = (newtonSolutionODE2.GetL2Norm() + newtonSolutionODE1.GetL2Norm()) / conv.errorCoordinateFactor; //increment of newton ODE2/ODE1 coordinates used to determine error
			} 
			//++++++++++++++++++++++++++++++++++++++++++

			if (IsVerbose(2))
			{
				Verbose(2, "    NEWTON STEP " + EXUstd::ToString(it.newtonSteps) + 
					": residual = " + EXUstd::ToString(conv.residual) +
					": relTol = " + EXUstd::ToString(conv.residual / initialResidual) +
					": contr. = " + EXUstd::ToString(conv.residual / conv.lastResidual) +
					"\n");
			}
			if (IsVerbose(3))
			{
				STDstring str;
				str += "    Newton solU         = " + EXUstd::ToString(solutionODE2) + "\n";
				if (!IsStaticSolver())
				{
					str += "    Newton solV         = " + EXUstd::ToString(solutionODE2_t) + "\n";
					str += "    Newton solA         = " + EXUstd::ToString(solutionODE2_tt) + "\n";
				}
				if (data.nODE1)
				{
					str += "    Newton solODE1      = " + EXUstd::ToString(solutionODE1) + "\n";
					if (!IsStaticSolver())
					{
						str += "    Newton solODE1_t    = " + EXUstd::ToString(solutionODE1_t) + "\n";
					}
				}
				str += "    Newton solData      = " + EXUstd::ToString(solutionData) + "\n";
				str += "    Newton solLambda    = " + EXUstd::ToString(solutionAE) + "\n";
				str += "    Newton RESIDUAL     = " + EXUstd::ToString(data.systemResidual) + "\n";
				Verbose(3, str);
			}
			if (newton.adaptInitialResidual && conv.residual > initialResidual && it.newtonSteps <= 1) {
				initialResidual = conv.residual;
				conv.lastResidual = conv.residual; //for computation of contractivity lateron
				if (IsVerbose(2)) { Verbose(2, "    update initial residual with current residual; initial residual = " + EXUstd::ToString(initialResidual) + "\n"); }
			}

			if (conv.residual / initialResidual <= newton.relativeTolerance)
			{
				conv.newtonConverged = true;
			}
			else if (conv.residual <= newton.absoluteTolerance)
			{
				conv.newtonConverged = true;
				if (IsVerbose(2)) { Verbose(2, "  Newton convergence reached with absolute error = " + EXUstd::ToString(conv.residual) + "\n"); }
			}

			if (addRestartNewtonStep && conv.newtonConverged)
			{
				addRestartNewtonStep = false; //additional iteration done!
				conv.newtonConverged = false; //do another iteration!
			}
			else if (!conv.newtonConverged)
			{
				addRestartNewtonStep = false;
				Real normU = solutionODE2.GetL2NormSquared();
				Real normV = 0;
				if (!IsStaticSolver()) { normV = solutionODE2_t.GetL2NormSquared(); }

				Real normLambda = solutionAE.GetL2NormSquared();

				conv.newtonSolutionDiverged = false;
				//check, if solution has diverged
				if (normU >= newton.maximumSolutionNorm || normV >= newton.maximumSolutionNorm ||
					std::isnan(normU) || std::isnan(normV) || std::isnan(normLambda))
				{
					if (fullNewtonRequested)
					{
						conv.stopNewton = true;
						if (IsVerboseCheck(1)) { VerboseWrite(1, "  solution did not converge with full Newton\n"); }
						if (IsVerbose(4))
						{
							Verbose(4, "  Reasons for Newton divergence(maximum value=" + EXUstd::ToString(sqrt(newton.maximumSolutionNorm)) + 
								"): \n    normU = " + EXUstd::ToString(sqrt(normU)) + 
								"\n    normV = " + EXUstd::ToString(sqrt(normV)) +
								"\n    normLambda = " + EXUstd::ToString(sqrt(normLambda)) + "\n");
						}

					}
					else
					{
						if (IsVerbose(2)) { Verbose(2, "    ... full Newton requested because of diverged solution\n"); }
						conv.newtonSolutionDiverged = true; //previously only set in else case
					}
				}

				//bool maxModifiedNewtonStepsReached = false;
				if (!fullNewtonRequested && (it.newtonSteps > newton.maxModifiedNewtonIterations))
				{
					conv.jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations
				}

				bool switchToFullNewton = false;
				if (!fullNewtonRequested && (it.newtonSteps > newton.maxModifiedNewtonIterations + newton.maxModifiedNewtonRestartIterations*(1-(int)newton.modifiedNewtonJacUpdatePerStep)))
				{
					fullNewtonRequested = true;
					it.rejectedModifiedNewtonSteps++;
					switchToFullNewton = true;
				}

				//decide on modified Newton based on contractivity
				conv.contractivity = conv.residual / conv.lastResidual; //last residual must always be greater than 0!!!
				if (newton.useModifiedNewton)
				{
					if (IsVerbose(3)) { Verbose(3, "    contractivity = " + EXUstd::ToString(conv.contractivity) + "\n"); }
					if (IsVerbose(3)) { Verbose(3, "    last residual = " + EXUstd::ToString(conv.lastResidual) + "\n"); }
				}

				conv.lastResidual = conv.residual;
				//in case of modified newton try with jacobian update and full newton ...
				
				if (!fullNewtonRequested && newton.useModifiedNewton && (conv.newtonSolutionDiverged || switchToFullNewton || //ADDED switchToFullNewton; but do not enter this loop in case that solely fullNewtonRequested=true
					(conv.contractivity > newton.modifiedNewtonContractivity && it.newtonSteps > 2))) //only check contractivity at third step
				{
					conv.jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations

					if (modifiedNewtonRestarted && !fullNewtonRequested) //if modified Newton already restarted ==> use full Newton now!
					{
						fullNewtonRequested = true;
						it.rejectedModifiedNewtonSteps++;
						if (IsVerbose(2)) { Verbose(2, "    ... switch to full Newton due to repeated bad contractivity\n"); }
					}

					if (!conv.stopNewton && (conv.newtonSolutionDiverged || conv.contractivity > 2 || fullNewtonRequested))  //this might indicate divergence ==> restart Newton if modified newton is used
					{
						modifiedNewtonRestarted = true;
						conv.jacobianUpdateRequested = true;

						//lastResidual = EXUstd::Maximum(lastResidual, initialResidual)*1.e6; //safety of 1e6 to relieve the contracticity condition of next step

						conv.residual = initialResidual;  //current residual
						conv.lastResidual = initialResidual; //to determine contractivity

						//initialize states with beginning of time step; dataCoords are not changed here, as they are modified only outside Newton
						solutionODE2 = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
						if (!IsStaticSolver())
						{
							solutionODE2_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_t;
							//old solver: solutionODE2_tt.SetAll(0.) ==> now done in ComputeNewtonUpdate(..., initial=true) for 

							//new solver: solutionODE2_tt must contain initial accelerations
							solutionODE2_tt = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_tt;

							data.aAlgorithmic = data.startOfStepStateAAlgorithmic;
						}
						if (data.nODE1)
						{
							solutionODE1 = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords;
							//done in ComputeNewtonUpdate(..., initial=true): solutionODE1_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords_t;
						}
						solutionAE.SetAll(0.); //use zero Lagrange multipliers as start guess for Newton iterations step ==> does not work for algebraic variables such as in sliding joint

						//++++++++++++++++++++++++++++++++++++++++++++++++++++++
						//compute residual (for beginning of step, which means that delta_acc=0, lambda=0):
						data.newtonSolution.SetAll(0.); //no update yet
						ComputeNewtonUpdate(computationalSystem, simulationSettings, true); //better initial guess for Newton
						ComputeNewtonResidual(computationalSystem, simulationSettings);

						addRestartNewtonStep = true; //request additional Newton step after restart (request update of jacobian or switch to full Newton)

						if (IsVerbose(2) && !conv.newtonSolutionDiverged) { Verbose(2, "    ... Newton restarted due to bad contractivity, divergence or iterations count\n"); }
					}
				} //contractivity check
			}//converged
		} //Jacobian invert
	}//Newton iteration
	//double duration = EXUstd::GetTimeInSeconds() - output.cpuStartTime;

	if (conv.stopNewton || !conv.newtonConverged)
	{
		if ((IsVerboseCheck(1) && (output.stepInformation&StepInfo::stepReductionWarn)) || IsVerboseCheck(2)) {
			STDstring str = "  Newton (time/load step #" + EXUstd::ToString(it.currentStepIndex) +
				"): convergence failed after " + EXUstd::ToString(it.newtonSteps) +
				" iterations; relative error = " + EXUstd::ToString(conv.residual / initialResidual);
			if (IsStaticSolver()) {str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor);}
			else { str += ", time = " + EXUstd::ToString(it.currentTime); }
			str += "\n";
			VerboseWrite(1, str);
		}
	}
	else
	{
		if (IsVerbose(2)) { Verbose(2, "  Newton: converged after " + EXUstd::ToString(it.newtonSteps) +
			" steps; relative error = " + EXUstd::ToString(conv.residual / initialResidual) + "\n"); }
	}

	return !(conv.stopNewton || !conv.newtonConverged); //return success (true) or fail (false)
}


Real CSolverBase::PostNewton(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real discontinuousError = 0;	
	it.recommendedStepSize = -1;
	if (computationalSystem.GetPythonUserFunctions().postNewtonFunction)
	{
		STARTTIMER(timer.python);
		StdVector2D rv = {0,0};
		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			rv = computationalSystem.GetPythonUserFunctions().postNewtonFunction(*(computationalSystem.GetPythonUserFunctions().mainSystem),
				it.currentTime);
		}, "CSolverBase::InitializeStep: Python PostNewtonUserFunction failed (check code; check return value)");
		discontinuousError = fabs(rv[0]); //only use absolute error, in order to avoid problems, if user returns negative values ...
		if (rv[1] >= 0) //recommended step size \f$h_{recom}\f$ after PostNewton(...): \f$h_{recom} < 0\f$: no recommendation, \f$h_{recom}==0\f$: use minimum step size, \f$h_{recom}>0\f$: use specific step size, if no smaller size requested by other reason
		{
			it.recommendedStepSize = rv[1];
		}
		STOPTIMER(timer.python);
	}

	discontinuousError += computationalSystem.PostNewtonStep(data.tempCompDataArray, it.recommendedStepSize);

	return discontinuousError;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDstring CSolverBase::GetSolutionFileName(const SimulationSettings& simulationSettings)
{
	STDstring filename = simulationSettings.solutionSettings.coordinatesSolutionFileName;

	//check if file ending is provided (does not check if the dot appears somewhere in between!)
	if (filename.find(".") == std::string::npos)
	{
		if (simulationSettings.solutionSettings.binarySolutionFile)
		{
			filename += ".sol";
		}
		else
		{
			filename += ".txt";
		}
	}

	//Index len = filename.size();
	//if (len > 3)
	//{
	//	STDstring ending = filename.substr((size_t)(len - 3), 3);
	//}
	return filename;
}


//! write solution file header commonly for static and dynamic solvers
void CSolverBase::WriteSolutionFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	
	if (!output.writeToSolutionFile) { return; }

	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

	bool isStatic = IsStaticSolver();

	Index nVel1 = 0;
	Index nVel2 = 0;
	Index nAcc2 = 0;
	Index nAEexported = 0;
	Index nDataExported = 0;

	Index nODE2, nODE1, nAE, nData; //values could also been taken from SolverData ...
	computationalSystem.GetSystemData().GetNumberOfComputationCoordinates(nODE2, nODE1, nAE, nData);
	//Index nSys = nODE2 + nODE1 + nAE;

	if (solutionSettings.exportVelocities && !isStatic) { nVel2 = nODE2; nVel1 = nODE1; }
	if (solutionSettings.exportAccelerations && !isStatic) { nAcc2 = nODE2; }
	if (solutionSettings.exportAlgebraicCoordinates) { nAEexported = nAE; }
	if (solutionSettings.exportDataCoordinates) { nDataExported = nData; }

	std::ofstream& solFile = file.solutionFile;

	if (solutionSettings.writeFileHeader)
	{
		Index totalCoordinates = nODE2 + nVel2 + nAcc2 + nODE1 + nVel1 + nAEexported + nDataExported;
		if (!solutionSettings.binarySolutionFile)
		{
			solFile << "#Exudyn " << GetSolverName() << " ";
			if (isStatic) { solFile << "static "; }
			solFile << "solver solution file\n";
			solFile << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
			solFile << "#columns contain: time";
			if (nODE2) { solFile << ", ODE2 displacements"; }
			if (solutionSettings.exportVelocities && nODE2) { solFile << ", ODE2 velocities"; }
			if (solutionSettings.exportAccelerations && nODE2) { solFile << ", ODE2 accelerations"; }
			if (nODE1) { solFile << ", ODE1 coordinates"; } //currently not available, but for future solFile structure necessary!
			if (nVel1) { solFile << ", ODE1 velocities"; }
			if (solutionSettings.exportAlgebraicCoordinates && nAE) { solFile << ", AE coordinates"; }
			if (solutionSettings.exportDataCoordinates && nData) { solFile << ", Data coordinates"; }
			solFile << "\n";

			solFile << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
				nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
			solFile << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
				nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])

			solFile << "#total columns exported  (excl. time) = " << totalCoordinates << "\n";
			if (!isStatic) { solFile << "#number of time steps (planned) = " << timeint.numberOfSteps << "\n"; }
			else { solFile << "#number of load steps (planned) = " << staticSolver.numberOfLoadSteps << "\n"; }

			//solFile << "#Exudyn version = " << EXUstd::exudynVersion << "\n";
			solFile << "#Exudyn version = " << GetExudynBuildVersionString(true) << "\n";
			solFile << "#\n"; //empty line for extension ...

			if (solutionSettings.solutionInformation.length())
			{
				//remove line breaks, this would corrupt the file structure!
				STDstring solInfo = solutionSettings.solutionInformation;
				bool foundString = true;
				STDstring endLine = "\n";
				//size_t len = endLine.length();
				std::size_t found = 0;
				while (foundString)
				{
					found = solInfo.find(endLine,found);
					if (found != std::string::npos)
					{
						solInfo.replace(found, endLine.length(), "_");
					}
					else { foundString = false; }
					found++; //start at next character
				}
				solFile << "#solution information = " << solInfo << "\n";
			}
		}
		else
		{
			const ExuFile::BinaryFileSettings& bfs = file.binaryFileSettings;
			ExuFile::BinaryWriteHeader(solFile, bfs);

			//write version at beginning in order to determine if there is a change in solution files (order of data, ...)
			ExuFile::BinaryWrite(EXUstd::exudynVersion, solFile, bfs);
			ExuFile::BinaryWrite(STDstring("Mode0000"), solFile, bfs); //change this in future to add new features

			STDstring str = "Exudyn " + GetSolverName() + " ";
			if (isStatic) { str+="static "; }
			str+="solver solution file";
			ExuFile::BinaryWrite(str, solFile, bfs);

			//solFile << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
			ExuFile::BinaryWrite(EXUstd::GetDateTimeString(), solFile, bfs);

			//not needed in binary format:
			//solFile << "#columns contain: time, ODE2 displacements";
			//if (solutionSettings.exportVelocities) { solFile << ", ODE2 velocities"; }
			//if (solutionSettings.exportAccelerations) { solFile << ", ODE2 accelerations"; }
			//if (nODE1) { solFile << ", ODE1 coordinates"; } //currently not available, but for future solFile structure necessary!
			//if (nVel1) { solFile << ", ODE1 velocities"; }
			//if (solutionSettings.exportAlgebraicCoordinates) { solFile << ", AE coordinates"; }
			//if (solutionSettings.exportDataCoordinates) { solFile << ", ODE2 velocities"; }
			//solFile << "\n";

			//solFile << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
			//	nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
			ArrayIndex sysCoords({nODE2, nODE1, nAE, nData});
			ExuFile::BinaryWrite(sysCoords, solFile, bfs);

			//solFile << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
			//	nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])
			ArrayIndex writtenCoords({ nODE2, nVel2, nAcc2, nODE1, nVel1, nAEexported, nDataExported });
			ExuFile::BinaryWrite(writtenCoords, solFile, bfs);

			//solFile << "#total columns exported  (excl. time) = " << totalCoordinates << "\n";
			ExuFile::BinaryWrite(totalCoordinates, solFile, bfs);

			Index numberOfSteps;
			if (!isStatic) { numberOfSteps = timeint.numberOfSteps; }
			else { numberOfSteps = staticSolver.numberOfLoadSteps; }
			ExuFile::BinaryWrite(numberOfSteps, solFile, bfs);

			//solFile << "#Exudyn version = " << EXUstd::exudynVersion << "\n";
			//written at beginning

			//solFile << "#\n"; //empty line for extension ...

			//solution information: always export string, even if has zero length:
			ExuFile::BinaryWrite(solutionSettings.solutionInformation, solFile, bfs);

			//add some checksum ...
			ExuFile::BinaryWrite(STDstring("EndOfHeader"), solFile, bfs);
			//next byte starts with solution

		}
	}

}


void CSolverBase::WriteCoordinatesToFile(const CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
	Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

	const Vector& solutionU = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	const Vector& solutionV = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	const Vector& solutionA = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	const Vector& solutionODE1 = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords;
	const Vector& solutionODE1_t = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t;
	const Vector& solutionLambda = computationalSystem.GetSystemData().GetCData().currentState.AECoords;
	const Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;

	bool isStatic = IsStaticSolver();

	//OLD timeIntegrationSolver: if (t == startTime || (t - lastSolutionWritten) >= (0 * solutionSettings.GetSolutionWritePeriod() - 1e-10)) //1e-10 because of roundoff errors
	if (t == startTime || (t - output.lastSolutionWritten) >= -1e-10) //1e-10 because of roundoff errors
	{

		std::ofstream& solFile = file.solutionFile;
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

		output.lastSolutionWritten += solutionSettings.solutionWritePeriod;
		output.lastSolutionWritten = EXUstd::Maximum(output.lastSolutionWritten, t); //never accept smaller values ==> for adaptive solver

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//precompute size for binary output (allows to swap through data faster line-by-line?)
		Index nValues = solutionU.NumberOfItems() + solutionODE1.NumberOfItems();
		Index nVectors = 2; //number of vectors, giving amount of ints added for vectors
		if (solutionSettings.exportVelocities && !isStatic) { nValues += solutionV.NumberOfItems(); nVectors++; }
		if (solutionSettings.exportAccelerations && !isStatic) {nValues += solutionA.NumberOfItems(); nVectors++; }
		if (solutionSettings.exportODE1Velocities && !isStatic){nValues += solutionODE1_t.NumberOfItems(); nVectors++;}
		if (solutionSettings.exportAlgebraicCoordinates){nValues += solutionLambda.NumberOfItems(); nVectors++; }
		if (solutionSettings.exportDataCoordinates){nValues += solutionData.NumberOfItems(); nVectors++; }

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//write data (combined ASCII / binary mode):
		bool isBinary = solutionSettings.binarySolutionFile;
		const ExuFile::BinaryFileSettings& bfs = file.binaryFileSettings;

		if (isBinary) //add size, only in binary mode
		{
			//including 1 real for time+1 Index for nVectors, but excluding bytes for this Index
			//Index lineSizeBytes = nVectors * bfs.indexSize + nValues * bfs.realSize + bfs.indexSize + bfs.realSize;
			//ExuFile::BinaryWrite(lineSizeBytes, solFile, bfs); //size of line, for fast skipping of solution line 
			//ExuFile::BinaryWrite(nVectors, solFile, bfs); //number of vectors could vary if needed
			ExuFile::BinaryWrite(nValues+1, solFile, bfs); //total number of values including time; indicating last line with -1
		}


		ExuFile::Write(t, solFile, bfs, isBinary);
		//solFile << t;

		ExuFile::Write(solutionU, solFile, bfs, isBinary, false);

		if (solutionSettings.exportVelocities && !isStatic)
		{
			ExuFile::Write(solutionV, solFile, bfs, isBinary, false);
			//for (Index k = 0; k < solutionV.NumberOfItems(); k++) {
			//	solFile << "," << solutionV[k];
			//}
		}
		if (solutionSettings.exportAccelerations && !isStatic)
		{
			ExuFile::Write(solutionA, solFile, bfs, isBinary, false);
			//for (Index k = 0; k < solutionA.NumberOfItems(); k++) {
			//	solFile << "," << solutionA[k];
			//}
		}
		//++++++++++++++++++++++++++++++++++++
		//newly added ODE1 coordinates:
		nValues += solutionODE1.NumberOfItems();
		ExuFile::Write(solutionODE1, solFile, bfs, isBinary, false);
		//for (Index k = 0; k < solutionODE1.NumberOfItems(); k++) {
		//	solFile << "," << solutionODE1[k];
		//}
		if (solutionSettings.exportODE1Velocities && !isStatic)
		{
			ExuFile::Write(solutionODE1_t, solFile, bfs, isBinary, false);
			//for (Index k = 0; k < solutionODE1_t.NumberOfItems(); k++) {
			//	solFile << "," << solutionODE1_t[k];
			//}
		}
		//++++++++++++++++++++++++++++++++++++
		//algebraic and data coordinates:
		if (solutionSettings.exportAlgebraicCoordinates)
		{
			ExuFile::Write(solutionLambda, solFile, bfs, isBinary, false);
			//for (Index k = 0; k < solutionLambda.NumberOfItems(); k++) {
			//	solFile << "," << solutionLambda[k];
			//}
		}
		if (solutionSettings.exportDataCoordinates)
		{
			ExuFile::Write(solutionData, solFile, bfs, isBinary, false);
			//for (Index k = 0; k < solutionData.NumberOfItems(); k++) {
			//	solFile << "," << solutionData[k];
			//}
		}
		if (!isBinary)
		{
			solFile << "\n";
		}

		//+++++++++++++++++++++++++++++
		if (solutionSettings.flushFilesImmediately || nValues >= solutionSettings.flushFilesDOF)
		{
			solFile.flush();
		}
	}
}


//! write unique sensor file header, depending on static/dynamic simulation
void CSolverBase::WriteSensorsFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (!simulationSettings.solutionSettings.sensorsWriteFileHeader) { return; }

	Index cnt = 0;
	for (auto item : computationalSystem.GetSystemData().GetCSensors())
	{
		if ((Index)file.sensorFileList.size() > cnt && file.sensorFileList[cnt] != nullptr)
		{
			std::ofstream* sFile = file.sensorFileList[cnt];
			(*sFile) << "#Exudyn " << GetSolverName() << " ";
			if (IsStaticSolver()) { (*sFile) << "static "; }
			(*sFile) << "sensor output file\n";
			STDstring typeStr = GetSensorTypeString(item->GetType());

			if (item->GetType() != SensorType::UserFunction)
			{
				(*sFile) << "#measure " << typeStr << " number = " << item->GetTypeDependentIndex() << "\n";
			}
			else
			{
				(*sFile) << "#measure " << typeStr << "\n"; //no number!
			}
			(*sFile) << "#OutputVariableType = " << GetOutputVariableTypeString(item->GetOutputVariableType()) << "\n";

			(*sFile) << "#simulation started = " << EXUstd::GetDateTimeString() << "\n";
			(*sFile) << "#columns contain: time, comma separated sensor values (e.g, x,y,z position coordinates)\n";

			item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current); //only for checking size of sensor output, computed values not used

			(*sFile) << "#number of sensor values = " << output.sensorValuesTemp.NumberOfItems() << "\n";
			//(*sFile) << "#Exudyn version = " << EXUstd::exudynVersion << "\n";
			(*sFile) << "#Exudyn version = " << GetExudynBuildVersionString(true) << "\n";
			(*sFile) << "#\n";
		}
		else
		{
			//evaluate sensors, especially for UserSensors, which may do some tricky (recording) things internally, but which are not written
			item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current); //only for checking size of sensor output, computed values not used
		}
		cnt++;
	}
}

//! write unique sensor solution file
void CSolverBase::WriteSensorsToFile(const CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
	Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

	if (t == startTime || (t - output.lastSensorsWritten) >= -1e-10) //1e-10 because of roundoff errors
	{
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

		output.lastSensorsWritten += solutionSettings.sensorsWritePeriod;
		output.lastSensorsWritten = EXUstd::Maximum(output.lastSensorsWritten, t); //never accept smaller values ==> for adaptive solver

		Index cnt = 0;
		for (auto item : computationalSystem.GetSystemData().GetCSensors())
		{
			bool sensorValuesCalled = false;
			if ((Index)file.sensorFileList.size() > cnt && file.sensorFileList[cnt] != nullptr)
			{
				std::ofstream* sFile = file.sensorFileList[cnt];

				(*sFile) << t;
				
				item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current);

				for (auto value : output.sensorValuesTemp)
				{
					(*sFile) << "," << value;
				}
				(*sFile) << "\n";
				if (solutionSettings.flushFilesImmediately)
				{
					sFile->flush();
				}
				sensorValuesCalled = true;
			}
			if (item->GetStoreInternalFlag())
			{
				if (!sensorValuesCalled) //avoid second call to computation of sensor values ...
				{
					item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current);
				}
				Index n = output.sensorValuesTemp.NumberOfItems();
				output.sensorValuesTemp2.SetNumberOfItems(n + 1);
				output.sensorValuesTemp2[0] = t;
				for (Index i = 0; i < n; i++)
				{
					output.sensorValuesTemp2[i + 1] = output.sensorValuesTemp[i];
				}
				
				//this marks that new data is stored ...
				if (item->GetInternalStorage().NumberOfRows() != 0)
				{
					if (output.sensorValuesTemp2.NumberOfItems() != item->GetInternalStorage().NumberOfColumns())
					{
						STDstring msg = "CSolverBase::WriteSensorsToFile: storeInternal == True : seems that number of output values of sensor (sensor number ";
						msg += EXUstd::ToString(cnt) + ") changed; consider storeInternal == False for this sensor and write to file";
						PyError(msg, file.solverFile);
					}
				}
				item->GetInternalStorage().AppendRow(output.sensorValuesTemp2);
				sensorValuesCalled = true;

			}
			if (!sensorValuesCalled)
			{
				//evaluate sensors, especially for UserSensors, which may do some tricky (recording) things internally, but which are not written
				item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current); //only for checking size of sensor output, computed values not used
			}
			cnt++;
		}
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CSolverBase::DoIdleOperations(CSystem& computationalSystem)
{
	PyProcessExecuteQueue(); //execute incoming python tasks if available
	computationalSystem.GetPostProcessData()->ProcessUserFunctionDrawing(); //check if user functions to be drawn and do user function evaluations

	RendererDoSingleThreadedIdleTasks();
}


//! return true, if file or console output is at or above the given level
void CSolverBase::VerboseWrite(Index level, const STDstring& str)
{
	STARTTIMER(timer.overhead);
	if (output.verboseMode >= level)
	{
		pout << str;
	}
	if (output.verboseModeFile >= level)
	{
		file.solverFile << str;
	}
	STOPTIMER(timer.overhead);
}
