/** ***********************************************************************************************
* @brief		Implementation for MainSolverBase: python interface for solver structure classes
* @details		Details:
* 				- base classes for computational solver (as compared to main solver, which interacts with Python, etc.)
*
* @author		Gerstmayr Johannes
* @date			2020-01-05 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
************************************************************************************************ */

//#include <pybind11/pybind11.h> //for integrated python connectivity (==>put functionality into separate file ...!!!)
//#include <pybind11/eval.h>
//#include <pybind11/numpy.h>       //interface to numpy
//
//#include "Linalg/BasicLinalg.h"
//#include "Linalg/LinearSolver.h"
//
//#include "Linalg/Geometry.h"

//#include "Main/MainSystem.h"
//
//#include "Pymodules/PybindUtilities.h"
////#include "Autogenerated/MainObjectMassPoint.h"
////#include "Autogenerated/MainNodePoint.h"
////
//#include "Solver/TimeIntegrationSolver.h"
//#include "Main/SystemContainer.h"

//#include "Main/MainSystemContainer.h"
//
//#include "Solver/CSolverImplicitSecondOrder.h"
//#include "Solver/CSolverStatic.h"
#include "Solver/MainSolverBase.h" //pybind access to solvers
//#include "Autogenerated/SimulationSettings.h" 

namespace py = pybind11;

CSolverBase dummyCSolverBase; //to avoid warnings

const CSolverBase& MainSolverBase::GetCSolver() const 
{ 
	assert(0 && "MainSolverBase: const GetCSolver(): illegal call"); return dummyCSolverBase;
};
CSolverBase& MainSolverBase::GetCSolver() { CHECKandTHROWstring("MainSolverBase: GetCSolver(): illegal call"); return dummyCSolverBase; };


//! check if MainSolverBase is initialized ==> otherwise raise SysError
bool MainSolverBase::CheckInitialized(const MainSystem& mainSystem) const
{
	if (!mainSystem.cSystem->IsSystemConsistent())
	{
		SysError("MainSystem (mbs) is not correctly initialized; call MainSystem.Assemble() first");
		return false;
	}

	if (!(isInitialized &&
		GetCSolver().data.nODE2 == initializedSystemSizes[0] &&
		GetCSolver().data.nODE1 == initializedSystemSizes[1] &&
		GetCSolver().data.nAE == initializedSystemSizes[2] &&
		GetCSolver().data.nData == initializedSystemSizes[3]))
	{
		SysError("MainSolverBase is not correctly initialized; call InitializeSolver() first");
		return false;
	}

	if (!(GetCSolver().data.nODE2==mainSystem.cSystem->GetSystemData().GetNumberOfCoordinatesODE2() &&
		GetCSolver().data.nODE1 == mainSystem.cSystem->GetSystemData().GetNumberOfCoordinatesODE1() &&
		GetCSolver().data.nAE ==   mainSystem.cSystem->GetSystemData().GetNumberOfCoordinatesAE() &&
		GetCSolver().data.nData == mainSystem.cSystem->GetSystemData().GetNumberOfCoordinatesData()))
	{
		SysError("Systen sizes do not match; either MainSolverBase is not correctly initialized or MainSystem (mbs) has changed; call Assemble() and InitializeSolver() first");
		return false;
	}

	return true;
}

bool CheckInitializedData(const MainSolverBase& s)
{
	if (s.isInitialized &&
		s.GetCSolver().data.nODE2 == s.initializedSystemSizes[0] &&
		s.GetCSolver().data.nODE1 == s.initializedSystemSizes[1] &&
		s.GetCSolver().data.nAE == s.initializedSystemSizes[2] &&
		s.GetCSolver().data.nData == s.initializedSystemSizes[3])
	{
		return true; //correctly initialized
	}
	else
	{
		SysError("MainSolverBase is not correctly initialized; call InitializeSolver() first");
		return false;
	}
}

//! initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files
void MainSolverBase::InitializeCheckInitialized(const MainSystem& mainSystem)
{
	isInitialized = true;
	//workaround, as the cSolver is not initialized when this function is called!
	initializedSystemSizes[0] = mainSystem.GetCSystem()->GetSystemData().GetNumberOfCoordinatesODE2();
	initializedSystemSizes[1] = mainSystem.GetCSystem()->GetSystemData().GetNumberOfCoordinatesODE1();
	initializedSystemSizes[2] = mainSystem.GetCSystem()->GetSystemData().GetNumberOfCoordinatesAE();
	initializedSystemSizes[3] = mainSystem.GetCSystem()->GetSystemData().GetNumberOfCoordinatesData();
}

////! initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files
//bool MainSolverBase::InitializeSolver(MainSystem& mainSystem, const SimulationSettings& simulationSettings)
//{
//	bool returnValue = GetCSolver().InitializeSolver(*(mainSystem.cSystem), simulationSettings);
//	if (returnValue) { InitializeCheckInitialized(); }
//
//	//isInitialized = true;
//	////set the following variables such that at least some problems can be catched, if not initialized correctly
//	//initializedSystemSizes[0] = GetCSolver().data.nODE2;
//	//initializedSystemSizes[1] = GetCSolver().data.nODE1;
//	//initializedSystemSizes[2] = GetCSolver().data.nAE;
//	//initializedSystemSizes[3] = GetCSolver().data.nData;
//
//	return returnValue;
//}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//access to solver.data vectors
  //! get locally stored / last computed system jacobian of solver
py::array_t<Real> MainSolverBase::GetSystemJacobian() const
{
	return EPyUtils::Matrix2NumPy(this->GetCSolver().data.systemJacobian->GetEXUdenseMatrix());
}

//! get locally stored / last computed mass matrix of solver
py::array_t<Real> MainSolverBase::GetSystemMassMatrix() const
{
	return EPyUtils::Matrix2NumPy(this->GetCSolver().data.systemMassMatrix->GetEXUdenseMatrix());
}

//! get locally stored / last computed system residual
py::array_t<Real> MainSolverBase::GetSystemResidual() const
{
	return EPyUtils::Vector2NumPy(this->GetCSolver().data.systemResidual);
}

//! get locally stored / last computed solution (=increment) of Newton
py::array_t<Real> MainSolverBase::GetNewtonSolution() const
{
	return EPyUtils::Vector2NumPy(this->GetCSolver().data.newtonSolution);
}

//! set locally stored system jacobian of solver
void MainSolverBase::SetSystemJacobian(const py::array_t<Real>& systemJacobian)
{
	Matrix m;
	EPyUtils::NumPy2Matrix(systemJacobian, m);

	CheckInitializedData(*this);
	Index nSys = initializedSystemSizes[0] + initializedSystemSizes[1] + initializedSystemSizes[2]; //nODE2+nODE1+nAE; check initialized guarantees that this is same as in CSolver
	if (m.NumberOfColumns() != nSys || m.NumberOfRows() != nSys) { SysError("MainSolverBase::SetSystemJacobian(...): matrix has wrong size or MainSolverBase is not correctly initialized; call InitializeSolver() first"); }
	
	GetCSolver().data.systemJacobian->SetMatrix(m);
}

//! set locally stored mass matrix of solver
void MainSolverBase::SetSystemMassMatrix(const py::array_t<Real>& systemMassMatrix)
{
	Matrix m;
	EPyUtils::NumPy2Matrix(systemMassMatrix, m);

	CheckInitializedData(*this);
	Index nSys = initializedSystemSizes[0] + initializedSystemSizes[1] + initializedSystemSizes[2]; //nODE2+nODE1+nAE; check initialized guarantees that this is same as in CSolver
	if (m.NumberOfColumns() != nSys || m.NumberOfRows() != nSys) { SysError("MainSolverBase::SetSystemMassMatrix(...): matrix has wrong size or MainSolverBase is not correctly initialized; call InitializeSolver() first"); }

	GetCSolver().data.systemMassMatrix->SetMatrix(m);
}

//! set locally stored system residual
void MainSolverBase::SetSystemResidual(const Vector& systemResidual)
{
	CheckInitializedData(*this);
	Index nSys = initializedSystemSizes[0] + initializedSystemSizes[1] + initializedSystemSizes[2]; //nODE2+nODE1+nAE; check initialized guarantees that this is same as in CSolver
	if (systemResidual.NumberOfItems() != nSys) { SysError("MainSolverBase::SetSystemResidual(...): vector has wrong size or MainSolverBase is not correctly initialized; call InitializeSolver() first"); }

	GetCSolver().data.systemResidual.CopyFrom(systemResidual);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//computationalSystem functions

//! compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix
void MainSolverBase::ComputeMassMatrix(MainSystem& mainSystem/*, const SimulationSettings& simulationSettings*/, Real scalarFactor)
{
	CheckInitialized(mainSystem);

	GetCSolver().data.systemMassMatrix->SetAllZero();
	mainSystem.cSystem->ComputeMassMatrix(GetCSolver().data.tempCompData, *(GetCSolver().data.systemMassMatrix));
	if (scalarFactor != 1.) { GetCSolver().data.systemMassMatrix->MultiplyWithFactor(scalarFactor); }
}

//! set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver
void MainSolverBase::ComputeJacobianODE2RHS(MainSystem& mainSystem, Real scalarFactor_ODE2, Real scalarFactor_ODE2_t, Real scalarFactor_ODE1)
{
	CheckInitialized(mainSystem);

	Index nSys = initializedSystemSizes[0] + initializedSystemSizes[1] + initializedSystemSizes[2]; //nODE2+nODE1+nAE; check initialized guarantees that this is same as in mainSystem

	GetCSolver().data.systemJacobian->SetNumberOfRowsAndColumns(nSys, nSys);
	GetCSolver().data.systemJacobian->SetAllZero(); //entries are not set to zero inside jacobian computation!

	mainSystem.cSystem->JacobianODE2RHS(GetCSolver().data.tempCompDataArray, GetCSolver().newton.numericalDifferentiation,
		*(GetCSolver().data.systemJacobian), scalarFactor_ODE2, scalarFactor_ODE2_t, scalarFactor_ODE1); 
}

//! add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver
void MainSolverBase::ComputeJacobianODE1RHS(MainSystem& mainSystem, Real scalarFactor_ODE2, Real scalarFactor_ODE2_t, Real scalarFactor_ODE1)
{
	CheckInitialized(mainSystem);

	Index nSys = initializedSystemSizes[0] + initializedSystemSizes[1] + initializedSystemSizes[2]; //nODE2+nODE1+nAE; check initialized guarantees that this is same as in mainSystem

	mainSystem.cSystem->JacobianODE1RHS(GetCSolver().data.tempCompDataArray, GetCSolver().newton.numericalDifferentiation,
		*(GetCSolver().data.systemJacobian), scalarFactor_ODE2, scalarFactor_ODE2_t, scalarFactor_ODE1); 
}

//not needed any more:
////! add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver
//void MainSolverBase::ComputeJacobianODE2RHS_t(MainSystem& mainSystem/*, const SimulationSettings& simulationSettings*/, Real scalarFactor)
//{
//	CheckInitialized(mainSystem);
//
//	mainSystem.cSystem->JacobianODE2RHS(GetCSolver().data.tempCompDataArray, GetCSolver().newton.numericalDifferentiation,
//		*(GetCSolver().data.systemJacobian), 0., 0., scalarFactor); //only ODE2_t part computed
//}

//! add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver
void MainSolverBase::ComputeJacobianAE(MainSystem& mainSystem, 
	Real scalarFactor_ODE2, Real scalarFactor_ODE2_t, Real scalarFactor_ODE1, bool velocityLevel)
{
	CheckInitialized(mainSystem);

	//only add terms!
	mainSystem.cSystem->JacobianAE(GetCSolver().data.tempCompData, GetCSolver().newton, *(GetCSolver().data.systemJacobian), 
		scalarFactor_ODE2, scalarFactor_ODE2_t, scalarFactor_ODE1, velocityLevel);// , true);
}

//! compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)
void MainSolverBase::ComputeODE2RHS(MainSystem& mainSystem/*, const SimulationSettings& simulationSettings*/)
{
	CheckInitialized(mainSystem);
	LinkedDataVector linkODE2residual(GetCSolver().data.systemResidual, 0, GetCSolver().data.nODE2);

	mainSystem.cSystem->ComputeSystemODE2RHS(GetCSolver().data.tempCompDataArray, linkODE2residual); //entries initialized in ComputeSystemODE2RHS
}

//! compute the RHS of ODE1 equations in systemResidual in range(nODE2,nODE2+nODE1)
void MainSolverBase::ComputeODE1RHS(MainSystem& mainSystem/*, const SimulationSettings& simulationSettings*/)
{
	CheckInitialized(mainSystem);
	LinkedDataVector linkODE1residual(GetCSolver().data.systemResidual, GetCSolver().data.nODE2, GetCSolver().data.nODE2+ GetCSolver().data.nODE1);

	mainSystem.cSystem->ComputeSystemODE1RHS(GetCSolver().data.tempCompData, linkODE1residual); //entries initialized in ComputeSystemODE1RHS
}

//! compute the algebraic equations in systemResidual in range(nODE2+nODE1,nODE2+nODE1+nAE)
void MainSolverBase::ComputeAlgebraicEquations(MainSystem& mainSystem/*, const SimulationSettings& simulationSettings*/, bool velocityLevel)
{
	CheckInitialized(mainSystem);

	if (GetCSolver().data.nAE) //only if equations exist!
	{
		Index nODE21 = GetCSolver().data.nODE2 + GetCSolver().data.nODE1;
		LinkedDataVector linkAEresidual(GetCSolver().data.systemResidual, nODE21, nODE21 + GetCSolver().data.nAE);

		mainSystem.cSystem->ComputeAlgebraicEquations(GetCSolver().data.tempCompData, linkAEresidual, velocityLevel); //in staticsolver use always index2constraints simulationSettings.timeIntegration.generalizedAlpha.useIndex2Constraints);
	}
}






