/** ***********************************************************************************************
* @brief		Implentation for CSolverImplicitSecondOrderTimeInt
*
* @author		Gerstmayr Johannes
* @date			2021-01-21 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
************************************************************************************************ */

#include <pybind11/pybind11.h> //for integrated python connectivity (==>put functionality into separate file ...!!!)
#include <pybind11/eval.h>
#include <fstream>

#include "Linalg/BasicLinalg.h" //for Resizable Vector
#include "Main/CSystem.h"
//#include "Autogenerated/CMarkerBodyPosition.h"
#include "Solver/CSolverExplicit.h" 
#include "Linalg/MatrixContainer.h" 
#include "Linalg/RigidBodyMath.h" 

#include "Autogenerated/CObjectConnectorCoordinate.h" //for elimination of constraints
#include "Autogenerated/CNodePointGround.h" //for elimination of constraints
#include "Autogenerated/CMarkerNodeCoordinate.h" //for elimination of constraints

#include "Utilities/TimerStructure.h" //for local CPU time measurement
#include "Utilities/Parallel.h" //include after 

//needed?: namespace py = pybind11;	//for py::object


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++   EXPLICIT TIME INTEGRATION SOLVER   ++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! initialize things at the very beginning of initialize
void CSolverExplicitTimeInt::PreInitializeSolverSpecific(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//some variables are already needed in parent initialization functions
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration;

	dynamicSolverType = timeint.explicitIntegration.dynamicSolverType; //must be explicit; needed for GetSolverName()

	nStages = ComputeButcherTableau(dynamicSolverType, rk); //compute coefficients, number of stages, stepSizeControl
	CHECKandTHROW(rk.time[0] == 0, "SolverExplicit: c[0] in Butcher tableau must be zero");
	
	eliminateConstraints = timeint.explicitIntegration.eliminateConstraints;
	useLieGroupIntegration = timeint.explicitIntegration.useLieGroupIntegration;
	minStepSizeWarned = false;

}

////! set/compute initial conditions (solver-specific!); called from InitializeSolver()
//void CSolverExplicitTimeInt::InitializeSolverInitialConditions(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
//{
//	//call base class for general tasks
//	CSolverBase::InitializeSolverInitialConditions(computationalSystem, simulationSettings); //set currentState = initialState
//
//}

//! post-initialize for solver specific tasks; called at the end of InitializeSolver
void CSolverExplicitTimeInt::PostInitializeSolverSpecific(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//at this point, all pre-checks are done (e.g., if Assemble() has been called), system is consistent, and 
	if (useLieGroupIntegration)
	{
		PrecomputeLieGroupStructures(computationalSystem, simulationSettings);
		if (lieGroupDataNodes.NumberOfItems() == 0) { useLieGroupIntegration = false; } //to avoid overheads!
	}

	//it.automaticStepSize is used such that it is only on, if solver has automatic step size control
	if (!rk.hasStepSizeControl) { it.automaticStepSize = false; }

	//++++++++++++++++++++++++++++++++++++++++++++++
	//create list of constrained coordinates
	constrainedODE2Coordinates.SetNumberOfItems(0);
	if (data.nAE != 0)
	{
		PrecomputeConstraintElimination(computationalSystem, simulationSettings);
	}
	//++++++++++++++++++++++++++++++++++++++
	//initialize accelerations and ODE1 velocities; simply set to zero, but more accurate would be an evaluation at time=0
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt.SetAll(0.);
	computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t.SetAll(0.);
	computationalSystem.GetSystemData().GetCData().currentState.AECoords.SetAll(0.);		//use zero Lagrange multipliers; for constraint elimination, they are not computed

	//++++++++++++++++++++++++++++++++++++++
	//initialize special for Explicit solver:
	hasConstantMassMatrix = computationalSystem.HasConstantMassMatrix();
	computeMassMatrixInversePerBody = simulationSettings.timeIntegration.explicitIntegration.computeMassMatrixInversePerBody;

	if (!simulationSettings.timeIntegration.reuseConstantMassMatrix) { hasConstantMassMatrix = false; }

	if (hasConstantMassMatrix)
	{
		//compute mass matrix
		STARTTIMER(timer.massMatrix);
		data.systemMassMatrix->SetAllZero();
		computationalSystem.ComputeMassMatrix(data.tempCompDataArray, *(data.systemMassMatrix), computeMassMatrixInversePerBody);
		STOPTIMER(timer.massMatrix);

		if (!computeMassMatrixInversePerBody) //no factorization needed!
		{
			//factorize mass matrix
			STARTTIMER(timer.factorization); //for mass matrix
			data.systemMassMatrix->FinalizeMatrix();

			Index factorizeOutput = data.systemMassMatrix->FactorizeNew();
			if (factorizeOutput != -1)
			{
				std::string s = "CSolverExplicit: Initialization (with constant mass matrix): System mass matrix seems to be singular / not invertible!";
				if (factorizeOutput < data.systemJacobian->NumberOfRows())
				{
					s += "The solver returned the causing system equation number (coordinate number) = " + EXUstd::ToString(factorizeOutput) + "\n";
				}
				conv.linearSolverFailed = true;
				conv.massMatrixNotInvertible = true;
				conv.linearSolverCausingRow = factorizeOutput;
				SysError(s); //this error is not recoverable
			}
			STOPTIMER(timer.factorization);
		}
	}

	//++++++++++++++++++++++++++++++++++++++++++++++

	//initialize rk stages:
	for (Index i = 0; i < nStages; i++)
	{
		rk.stageDerivODE2[i].SetNumberOfItems(data.nODE2);
		rk.stageDerivODE2_t[i].SetNumberOfItems(data.nODE2);
		rk.stageDerivODE1[i].SetNumberOfItems(data.nODE1);
		if (useLieGroupIntegration)
		{
			//rk.stageDerivLieODE2[i].SetNumberOfItems(data.nODE2);
			//rk.stageDerivLieODE2[i].SetAll(1e10); //for index errors, should be visible in solution
			//rk.stageDerivODE2[i].SetAll(1e10);    //for index errors, should be visible in solution
		}
	}
	if (rk.hasStepSizeControl) //only to be initialized in case of error control
	{
		rk.solutionSecondApproxODE2.SetNumberOfItems(data.nODE2);
		rk.solutionSecondApproxODE2_t.SetNumberOfItems(data.nODE2);
		rk.solutionSecondApproxODE1.SetNumberOfItems(data.nODE1);
	}

	rk.startOfStepODE2.SetNumberOfItems(data.nODE2);
	rk.startOfStepODE2_t.SetNumberOfItems(data.nODE2);
	rk.startOfStepODE1.SetNumberOfItems(data.nODE1);

	computationalSystem.GetSolverData().doPostNewtonIteration = false; //no PostNewton step necessary for explicit solver; do this directly in contact iteration
}

//! initialize all data,it,conv; called from InitializeSolver()
void CSolverExplicitTimeInt::InitializeSolverData(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	CSolverBase::InitializeSolverData(computationalSystem, simulationSettings);

	//these sizes are different from implicit solvers:
	data.systemJacobian->SetNumberOfRowsAndColumns(0, 0);
	data.jacobianAE->SetNumberOfRowsAndColumns(0, 0);
	data.startOfStepStateAAlgorithmic.SetNumberOfItems(0);

}






//! this function computes one explicit step, overloading the Newton method
bool CSolverExplicitTimeInt::Newton(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	STARTTIMER(timer.overhead);

	//typedef Vector CastVectorType;
	typedef ResizableVectorParallel CastVectorType;
	//link current system vectors for ODE2
	CastVectorType& solutionODE2 =    computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	CastVectorType& solutionODE2_t =  computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	CastVectorType& solutionODE2_tt = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	CastVectorType& solutionODE1 =    computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords;
	CastVectorType& solutionODE1_t =  computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t;

	//Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;

	conv.linearSolverFailed = false;		//(errorOccurred) signals that linear solver failed (factorize mass matrix) ==> abort integration method or reduce step size
	conv.linearSolverCausingRow = -1;
	conv.newtonConverged = true;			//signals that "Newton" == explicit step worked
	conv.newtonSolutionDiverged = false;	//shows that solution diverged (e.g. in first step)


	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//one explicit time step
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//initialize g1 stage:
	//solutionODE1 = g1 = u(t); rk.startOfStepODE1 stores u(t)
	rk.startOfStepODE2.CopyFrom(solutionODE2);		//solutionODE2=currentState.ODE2Coords must be updated during step computation
	rk.startOfStepODE2_t.CopyFrom(solutionODE2_t);
	rk.startOfStepODE1.CopyFrom(solutionODE1);

	Real t0 = computationalSystem.GetSystemData().GetCData().startOfStepState.time; //it.currentTime already has the step end time
	STOPTIMER(timer.overhead);

	if (IsVerbose(2))
	{
		Verbose(2, "\n+++++++++++++++++++++++++++++\n");
		Verbose(2, "constant mass = " + EXUstd::ToString(hasConstantMassMatrix) + "\n");
		Verbose(2, "u0 = " + EXUstd::ToString(solutionODE2) + "\n");
		Verbose(2, "v0 = " + EXUstd::ToString(solutionODE2_t) + "\n");
		Verbose(2, "non-Lie coords = " + EXUstd::ToString(nonLieODE2Coordinates) + "\n");
	}

	//compute stage derivatives Ki:
	for (Index i = 0; i < nStages; i++)
	{
		STARTTIMER(timer.integrationFormula);
		//only computed for i > 0:
		//g[i] = u + h*sum_j A[i,j] * K[j]
		//write g[i] ==> currentState (solutionODE2, solutionODE2_t, solutionODE1)
		for (Index j = 0; j < i; j++)
		{
			if (rk.A(i, j) != 0.)
			{
				if (!useLieGroupIntegration)
				{
					solutionODE2.MultAdd(rk.A(i, j)*it.currentStepSize, rk.stageDerivODE2[j]);
				}
				solutionODE2_t.MultAdd(rk.A(i, j)*it.currentStepSize, rk.stageDerivODE2_t[j]);
				solutionODE1.MultAdd(rk.A(i, j)*it.currentStepSize, rk.stageDerivODE1[j]); //solutionODE1=g[i+1], ...
			}
		}
		if (useLieGroupIntegration)
		{
			if (i > 0)
			{  //otherwise makes no sense ...
				UpdateODE2StageCoordinatesLieGroup(computationalSystem, solutionODE2, it.currentStepSize, i);
			}

		}

		//+++++++++++++++++++++++++++++++++++++++++++++++++
		//update K-stage: K[i] = f(t+c[i], g[i]),
		//update time for time-dependent loads or connectors:
		computationalSystem.GetSystemData().GetCData().currentState.time = t0 + it.currentStepSize * rk.time[i];
		STOPTIMER(timer.integrationFormula);

		if (IsVerbose(2))
		{
			Verbose(2, "  sol ODE2  = " + EXUstd::ToString(solutionODE2) + "\n");
			Verbose(2, "  sol ODE2_t= " + EXUstd::ToString(solutionODE2_t) + "\n");
		}

		if (data.nODE1 != 0)
		{
			STARTTIMER(timer.ODE1RHS);
			computationalSystem.ComputeSystemODE1RHS(data.tempCompData, rk.stageDerivODE1[i]); //Ki=rk.stageDerivODE1[i]
			STOPTIMER(timer.ODE1RHS);
		}
		ComputeODE2Acceleration(computationalSystem, simulationSettings, data.tempODE2, rk.stageDerivODE2_t[i], data.systemMassMatrix);
		if (!useLieGroupIntegration)
		{
			rk.stageDerivODE2[i].CopyFrom(solutionODE2_t);
		}
		else
		{
			STARTTIMER(timer.integrationFormula);
			LieGroupComputeKstage(computationalSystem, solutionODE2_t, rk.stageDerivODE2[i],
				rk.stageDerivODE2[i], it.currentStepSize, i);  //stageDerivLieODE2 
			//if (doDebug)
			//{
			//	pout << "k" << i << "   =" << rk.stageDerivODE2_t[i] << "\n";
			//	pout << "K" << i << "   =" << rk.stageDerivODE2[i] << "\n";
			//}
			STOPTIMER(timer.integrationFormula);
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++

		//finally solutionODE1 = u(t) for next stage and for final step computation
		solutionODE2.CopyFrom(rk.startOfStepODE2);		//solutionODE2=currentState.ODE2Coords must be updated during step computation
		solutionODE2_t.CopyFrom(rk.startOfStepODE2_t);
		solutionODE1.CopyFrom(rk.startOfStepODE1);

	}

	STARTTIMER(timer.integrationFormula);
	//final evaluation step: (solutionODE2, solutionODE2_t and solutionODE1 have startOfStep configuration)
	for (Index i = 0; i < nStages; i++)
	{
		if (rk.weight[i] != 0.)
		{
			if (!useLieGroupIntegration)
			{
				solutionODE2.MultAdd(rk.weight[i] * it.currentStepSize, rk.stageDerivODE2[i]);
			}
			solutionODE2_t.MultAdd(rk.weight[i] * it.currentStepSize, rk.stageDerivODE2_t[i]);
			solutionODE1.MultAdd(rk.weight[i] * it.currentStepSize, rk.stageDerivODE1[i]);
		}
	}

	if (useLieGroupIntegration)
	{
		LieGroupODE2StepEvaluation(computationalSystem, solutionODE2, it.currentStepSize, rk.weight);
	}

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//eliminate constraints by setting coordinates to zero:
	EliminateCoordinateConstraints(computationalSystem, constrainedODE2Coordinates, solutionODE2);
	EliminateCoordinateConstraints(computationalSystem, constrainedODE2Coordinates, solutionODE2_t);
	STOPTIMER(timer.integrationFormula);

	//compute second approximation for automatic stepsize control
	if (rk.hasStepSizeControl)
	{
		STARTTIMER(timer.errorEstimator);
		rk.solutionSecondApproxODE2.CopyFrom(rk.startOfStepODE2);		//** 2023-02-10: set to zero, rename into solutionSecondApproxODE2inc
		rk.solutionSecondApproxODE2_t.CopyFrom(rk.startOfStepODE2_t);
		rk.solutionSecondApproxODE1.CopyFrom(rk.startOfStepODE1);

		//compute second approximation
		for (Index i = 0; i < nStages; i++)
		{
			if (rk.weightEE[i] != 0.)
			{
				if (!useLieGroupIntegration)
				{
					rk.solutionSecondApproxODE2.MultAdd(rk.weightEE[i] * it.currentStepSize, rk.stageDerivODE2[i]);
				}
				rk.solutionSecondApproxODE2_t.MultAdd(rk.weightEE[i] * it.currentStepSize, rk.stageDerivODE2_t[i]);
				rk.solutionSecondApproxODE1.MultAdd(rk.weightEE[i] * it.currentStepSize, rk.stageDerivODE1[i]);
			}
		}
		if (useLieGroupIntegration) //** 2023-02-10: remove this update
		{
			LieGroupODE2StepEvaluation(computationalSystem, rk.solutionSecondApproxODE2, it.currentStepSize, rk.weightEE);
		}
		//eliminate constraints for second approximation (otherwise problems with error control ...):
		EliminateCoordinateConstraints(computationalSystem, constrainedODE2Coordinates, rk.solutionSecondApproxODE2);
		EliminateCoordinateConstraints(computationalSystem, constrainedODE2Coordinates, rk.solutionSecondApproxODE2_t);
		STOPTIMER(timer.errorEstimator);
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++
	//compute final accelerations and velocities for ODE1 (could be taken cheaper from beginning of next step ...):
	//no special task for Lie group methods
	computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //it.currentTime has step endTime
	if (data.nODE1 != 0)
	{
		STARTTIMER(timer.ODE1RHS);
		computationalSystem.ComputeSystemODE1RHS(data.tempCompData, solutionODE1_t); //Ki=rk.stageDerivODE1[i]
		STOPTIMER(timer.ODE1RHS);
	}
	if (simulationSettings.timeIntegration.explicitIntegration.computeEndOfStepAccelerations) //this is the correct acceleration at end of step
	{
		ComputeODE2Acceleration(computationalSystem, simulationSettings, data.tempODE2, solutionODE2_tt, data.systemMassMatrix);
	}
	else //use this as an approximation; this will lead to a delay in accelerations; usually accelerations are only used in sensors, 
		//which shall be ok in most cases and it avoids a second call to the very expensive function ComputeODE2Acceleration(...)
	{
		solutionODE2_tt.CopyFrom(rk.stageDerivODE2_t[nStages-1]);
	}

	//also eliminate accelerations for constrained coordinates:
	EliminateCoordinateConstraints(computationalSystem, constrainedODE2Coordinates, solutionODE2_tt);

	bool stepRejected = false;
	//+++++++++++++++++++++++++++++++++++++++++++++++++
	//step size control: see Hairer and Wanner I, page 167
	if (rk.hasStepSizeControl)
	{
		STARTTIMER(timer.errorEstimator);
		//now suggest new step size for next time step
		//estimate error and stepsize control according to Hairer and Wanner I, pp 164ff, esp. p. 168:

		//store error in second approximation:
		Real atol = simulationSettings.timeIntegration.absoluteTolerance;
		Real rtol = simulationSettings.timeIntegration.relativeTolerance;
		CHECKandTHROW(atol > 0, "SolverExplicit: absolute tolerance must be > 0");
		
		CHECKandTHROW(data.nODE1 + data.nODE2 > 0, "SolverExplicit: total number of ODE1 and ODE2 coordinates must not be zero");

		Real scODE1, scODE2;
		Real err = 0;
		for (Index i = 0; i < data.nODE1; i++)
		{
			scODE1 = atol + EXUstd::Maximum(rk.solutionSecondApproxODE1[i], rk.startOfStepODE1[i])*rtol;
			err += EXUstd::Square((rk.solutionSecondApproxODE1[i] - solutionODE1[i]) / scODE1); //==> add up to error
		}
		for (Index i = 0; i < data.nODE2; i++)
		{
			scODE2 = atol + EXUstd::Maximum(rk.solutionSecondApproxODE2[i], rk.startOfStepODE2[i])*rtol;		//position error //** 2023-02-10: check Celledoni step size control
			err += EXUstd::Square((rk.solutionSecondApproxODE2[i] - solutionODE2[i]) / scODE2);					//==> add up to error //** 2023-02-10: wrong, CORRECT!
			//(rk.solutionSecondApproxODE2inc - rk.startOfStepODE2) - solutionODE2increment => this is then also valid for Lie group methods !!!!
			scODE2 = atol + EXUstd::Maximum(rk.solutionSecondApproxODE2_t[i], rk.startOfStepODE2_t[i])*rtol;	//velocity error
			err += EXUstd::Square((rk.solutionSecondApproxODE2_t[i] - solutionODE2_t[i]) / scODE2);				//==> add up to error
		}
		err = sqrt(err / (data.nODE1 + 2*data.nODE2)); //ODE2 displacements, ODE2 velocities and ODE1 coordinates
		it.automaticStepSizeError = err;			
		if (err == 0.) { err = 1e-12; } //set err to a very small error (based on atol and rtol, this is very small) and would lead to significant step size increase

		//stepsize control according to Hairer, Norsett and Wanner I, p. 168:
		Real h = it.currentStepSize;
		Real hOpt = h * pow((1. / err), 1. / (rk.orderMethod)); //rk.orderMethod = q+1 in Hairer, Norsett and Wanner

		Real hMax = EXUstd::Minimum(it.maxStepSize, h * simulationSettings.timeIntegration.stepSizeMaxIncrease);
		Real hMin = it.minStepSize;
		Real fSafe = simulationSettings.timeIntegration.stepSizeSafety; //safety factor for increasing step size
		Real hNew = EXUstd::Minimum(hMax, EXUstd::Maximum(hMin, fSafe*hOpt));

		if (hNew == hMin && !minStepSizeWarned)
		{
			PyWarning("ExplicitSolver: t="+ EXUstd::ToString(t0) + "; automatic stepsize control reached minStepSize; integration continued, but error will be larger than given tolerances; reduce timeIntegration.minStepSize or increase tolerances");
			minStepSizeWarned = true;
		}
		else if (hOpt < h)
		{
			stepRejected = true;
			it.rejectedAutomaticStepSizeSteps++;
		}

		//now set suggested step size
		it.currentStepSize = hNew;
		STOPTIMER(timer.errorEstimator);

		if (IsVerbose(2)) {
			Verbose(2, "  Explicit step: error estimation = " + EXUstd::ToString(err) + ", hOpt=" + EXUstd::ToString(hOpt) + ", hNew=" + EXUstd::ToString(hNew) + "\n");
			if (stepRejected) { Verbose(2, "    step REJECTED. Restart with h=hNew\n"); }
		}

	}
	else
	{
		if (IsVerbose(2)) {
			Verbose(2, "  Explicit step finished\n");
		}
	}




	//#K0 = np.zeros(nODE2)
	//mainSys.systemData.SetTime(t0)
	//k1 = h * ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)#velocities
	//#K1 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K0, K0, 0.)      #displacements; K0 == k0;
	//K1 = h * v0[0:nODE2]

	//mainSys.systemData.SetTime(t0 + 0.5*h)
	//LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K1, k1, 0.5)
	//k2 = h * ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
	//K2 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K1, k1, 0.5)

	//mainSys.systemData.SetTime(t0 + 0.5*h)
	//LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K2, k2, 0.5)
	//k3 = h * ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
	//K3 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K2, k2, 0.5)

	//mainSys.systemData.SetTime(t0 + h) #this is also the step end time
	//LieGroupUpdateStageSystemCoordinates(mainSys, u0, v0, nODE2, K3, k3, 1.)
	//k4 = h * ExplicitRKComputeSystemAcceleration(mainSolver, mainSys, nODE2)
	//K4 = LieGroupComputeKstage(mainSys, u0, v0, h, nODE2, K3, k3, 1.)

	//#++++++++++++++++++
	//mainSys.systemData.SetTime(tend)
	//# compute update for end of step
	//#global update for velocities(same for all velocities!)
	//vStep = v0 + 1. / 6. * (k1 + 2 * k2 + 2 * k3 + k4)
	//#incremental rotation vector, can be computed globally :
	//deltaU = 1. / 6. * (K1 + 2 * K2 + 2 * K3 + K4) #contains displacement updates and incremental velocity vectors

	//uStep = u0 + deltaU #standard update for non - LieGroup nodes

	if (!conv.linearSolverFailed)
	{
		if (IsVerbose(3))
		{
			STDstring str;
			if (data.nODE1)
			{
				str += "    solutionODE2   =\n" + EXUstd::ToString(solutionODE2) + "\n";
				str += "    solutionODE2_t =\n" + EXUstd::ToString(solutionODE2_t) + "\n";
				str += "    solutionODE2_tt=\n" + EXUstd::ToString(solutionODE2_tt) + "\n";
			}
			if (data.nODE1)
			{
				str += "    solutionODE1   =\n" + EXUstd::ToString(solutionODE1) + "\n";
				str += "    solutionODE1_t =\n" + EXUstd::ToString(solutionODE1_t) + "\n";
			}
			Verbose(3, str);
		}
	}

	return !(conv.linearSolverFailed) && !stepRejected; //return success (true) or fail (false)

}


//! reduce step size (severity: 1..normal, 2..severe problems: not relevant for explicit integrator); return true, if reduction was successful
bool CSolverExplicitTimeInt::ReduceStepSize(CSystem& computationalSystem, const SimulationSettings& simulationSettings,
	Index severity, Real suggestedStepSize)
{
	//it.currentTime is the only important value to be updated in order to reset the step time:
	it.currentTime = computationalSystem.GetSystemData().GetCData().currentState.time;

	if (!conv.discontinuousIterationSuccessful) //additionally reduce step size
	{
		if (it.lastStepSize > it.minStepSize)
		{
			if (it.recommendedStepSize != -1.)
			{
				it.currentStepSize = EXUstd::Minimum(0.75*it.lastStepSize, it.recommendedStepSize); //0.75: enforce some reduction in step size, because otherwise iterations could get stuck
			}
			else
			{
				//if automatic stepsize control active, currentStepSize may have been reduced already for next trial
				it.currentStepSize = EXUstd::Minimum(it.currentStepSize, 0.5*it.lastStepSize);
			}

			it.currentStepSize = EXUstd::Maximum(it.minStepSize, it.currentStepSize);
			return true;
		}
	}
	else
	{
		return true;
	}

	return false; //if no further reduction possible
}

//! increase step size if convergence is good; if suggestedStepSize == -1, a solver-specific factor will be used
void CSolverExplicitTimeInt::IncreaseStepSize(CSystem& computationalSystem, const SimulationSettings& simulationSettings,
	Real suggestedStepSize)
{
	if (it.automaticStepSize)
	{
		//in automatic step size control, step size is anyway increased
		//==> check in future, if it should stay smaller due to disc. iterations
	}
	else
	{
		it.currentStepSize = EXUstd::Minimum(it.maxStepSize, 2.*it.currentStepSize);
	}
}

//! return true, if solver supports automatic stepsize control
bool CSolverExplicitTimeInt::HasAutomaticStepSizeControl() const
{
	return rk.hasStepSizeControl;
}


//! initialize static step / time step: do some outputs, checks, etc.
void CSolverExplicitTimeInt::UpdateCurrentTime(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (!it.adaptiveStep && !it.automaticStepSize)
	{
		it.currentTime = it.currentStepIndex * it.currentStepSize + it.startTime; //use this to avoid round-off errors in time 
	}
	else
	{
		if (it.currentTime + it.currentStepSize > it.endTime)
		{
			it.currentStepSize = it.endTime - it.currentTime;
		}
		it.currentTime += it.currentStepSize;
	}

}



//! helper function that computes q_tt = M^-1*ODE2RHS for given q_t and q; return true, if successful
bool CSolverExplicitTimeInt::ComputeODE2Acceleration(CSystem& computationalSystem, const SimulationSettings& simulationSettings, Vector& ode2Rhs,
	Vector& ode2Acceleration, GeneralMatrix* massMatrix)
{
	if (!hasConstantMassMatrix)
	{
		STARTTIMER(timer.massMatrix);
		massMatrix->SetAllZero();
		computationalSystem.ComputeMassMatrix(data.tempCompDataArray, *massMatrix, computeMassMatrixInversePerBody);
		STOPTIMER(timer.massMatrix);
	}
	STARTTIMER(timer.ODE2RHS);
	computationalSystem.ComputeSystemODE2RHS(data.tempCompDataArray, ode2Rhs); //tempODE2 contains RHS (linear case: tempODE2 = F_applied - K*u - D*v)
	STOPTIMER(timer.ODE2RHS);

	if (IsVerbose(3))
	{
		if (!hasConstantMassMatrix) //in case hasConstantMassMatrix=true, this will be either the finalized sparse matrix or the inverted dense matrix ...
		{
			STDstring strInv = "";
			if (computeMassMatrixInversePerBody) { strInv = "inverted "; }
				Verbose(3, "  " + strInv + "mass matrix  = " + EXUstd::ToString(*(massMatrix)) + "\n");
		}
		Verbose(3, "  RHS          = " + EXUstd::ToString(ode2Rhs) + "\n");
	}

	if (!hasConstantMassMatrix && !computeMassMatrixInversePerBody)
	{
		//factorize mass matrix
		STARTTIMER(timer.factorization); //for mass matrix
		data.systemMassMatrix->FinalizeMatrix();

		Index factorizeOutput = data.systemMassMatrix->FactorizeNew(simulationSettings.linearSolverSettings.ignoreSingularJacobian);
		if (factorizeOutput != -1)
		{
			conv.linearSolverFailed = true;
			conv.linearSolverCausingRow = factorizeOutput;
			if (IsVerboseCheck(1)) {
				STDstring str = "  Explicit (time/load step #" + EXUstd::ToString(it.currentStepIndex) +
					"): inversion of mass matrix failed";
				//if (IsStaticSolver()) { str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor); }
				str += ", time = " + EXUstd::ToString(it.currentTime);
				str += "\n";
				VerboseWrite(1, str);
			}
			//now raise exception:
			std::string s = "CSolverExplicit: System mass matrix seems to be singular / not invertible!\n";
			if (factorizeOutput < data.systemJacobian->NumberOfRows())
			{
				s += "The solver returned the causing system equation number (coordinate number) = " + EXUstd::ToString(factorizeOutput) + "\n";
			}
			SysError(s); //this error is not recoverable
		}
		STOPTIMER(timer.factorization);
	}
	if (!conv.linearSolverFailed)
	{
		STARTTIMER(timer.newtonIncrement);
		if (!computeMassMatrixInversePerBody)
		{
			data.systemMassMatrix->Solve(ode2Rhs, ode2Acceleration);
		}
		else
		{
			data.systemMassMatrix->MultMatrixVector(ode2Rhs, ode2Acceleration);
		}
		STOPTIMER(timer.newtonIncrement);
	}
	return !conv.linearSolverFailed;
}


//! helper function to compute Butcher tableau for given integrator
Index CSolverExplicitTimeInt::ComputeButcherTableau(DynamicSolverType dynamicSolverType, RKdata& rkData)
{
	rkData.hasStepSizeControl = false;

	switch (dynamicSolverType)
	{
		case DynamicSolverType::ExplicitEuler:
		{
			//explicit Euler
			rkData.A = Matrix(1, 1, { 0 });
			rkData.time = Vector({ 0. }); //including zero time
			rkData.weight = Vector({ 1. });
			rkData.orderMethod = 1; //order of the method
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		case DynamicSolverType::ExplicitMidpoint:
		{
			rkData.A = Matrix(2, 2, { 0, 0,
								  0.5, 0 });
			rkData.time = Vector({ 0., 0.5 }); //including zero time
			rkData.weight = Vector({ 0., 1. });
			rkData.orderMethod = 2; //order of the method
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		case DynamicSolverType::RK33:
		{
			rkData.A = Matrix(3, 3, { 0    ,0    ,0,//first row always zero
								  1. / 3.,0    ,0,
								  0    ,2. / 3.,0 });
			rkData.time = Vector({ 0.,1. / 3.,2. / 3. }); //including zero time
			rkData.weight = Vector({ 1. / 4., 0., 3. / 4. });
			rkData.orderMethod = 3; //order of the method
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		case DynamicSolverType::RK44:
		{
			rkData.A = Matrix(4, 4, { 0  ,0  ,0,0,//first row always zero
							0.5,0  ,0,0,
							0  ,0.5,0,0,
							0  ,0  ,1,0 });
			rkData.time = Vector({ 0.,0.5,0.5,1. }); //including zero time
			rkData.weight = Vector({ 1. / 6., 1. / 3., 1. / 3., 1. / 6. });
			rkData.orderMethod = 4; //order of the method
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		case DynamicSolverType::RK67:
		{
			//according to 'On Runge-Kutta Processes of High Order', J. C. Butcher, J. Austr Math Soc 4, (1964)
			//parameters from http://www.peterstone.name/Maplepgs/RKcoeff_6.html
			//order 6 checked in numerical example
			rkData.A = Matrix(7, 7);
			rkData.A.SetAll(0);
			rkData.time = Vector({ 0., 1. / 2 - 1. / 10 * sqrt(5), 1. / 2 + 1. / 10 * sqrt(5),
				1. / 2 - 1. / 10 * sqrt(5), 1. / 2 + 1. / 10 * sqrt(5), 1. / 2 - 1. / 10 * sqrt(5), 1. }); //including zero time
			rkData.weight = Vector({ 1. / 12, 0., 0., 0., 5. / 12, 5. / 12, 1. / 12 });

			rkData.A(1, 0) = 1. / 2 - 1. / 10 * sqrt(5);
			rkData.A(2, 0) = -1. / 10 * sqrt(5);
			rkData.A(2, 1) = 1. / 2 + 1. / 5 * sqrt(5);
			rkData.A(3, 0) = 7. / 20 * sqrt(5) - 3. / 4;
			rkData.A(3, 1) = 1. / 4 * sqrt(5) - 1. / 4;
			rkData.A(3, 2) = 3. / 2 - 7. / 10 * sqrt(5);
			rkData.A(4, 0) = 1. / 12 - 1. / 60 * sqrt(5);
			rkData.A(4, 1) = 0;
			rkData.A(4, 2) = 1. / 6;
			rkData.A(4, 3) = 7. / 60 * sqrt(5) + 1. / 4;
			rkData.A(5, 0) = 1. / 60 * sqrt(5) + 1. / 12;
			rkData.A(5, 1) = 0;
			rkData.A(5, 2) = 3. / 4 - 5. / 12 * sqrt(5);
			rkData.A(5, 3) = 1. / 6;
			rkData.A(5, 4) = -1. / 2 + 3. / 10 * sqrt(5);
			rkData.A(6, 0) = 1. / 6;
			rkData.A(6, 1) = 0;
			rkData.A(6, 2) = -55. / 12 + 25. / 12 * sqrt(5);
			rkData.A(6, 3) = -7. / 12 * sqrt(5) - 25. / 12;
			rkData.A(6, 4) = 5 - 2 * sqrt(5);
			rkData.A(6, 5) = 5. / 2 + 1. / 2 * sqrt(5);

			rkData.orderMethod = 6; //order of the method
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		case DynamicSolverType::ODE23:
		{
			//values taken from Mathematica NDSolve / ExplicitRungeKutta tutorial
			rkData.A = Matrix(4,4,{0,0,0,0,
								  1. / 2.,0,0,0, 
								  0, 3. / 4.,0,0, 
								  2. / 9., 1. / 3., 4. / 9.,0 });
			rkData.time = Vector({ 0., 1. / 2., 3. / 4., 1. });
			rkData.weight = Vector({ 2. / 9., 1. / 3., 4. / 9., 0. });
			Vector delta({ -5. / 72., 1. / 12., 1. / 9., -1. / 8. }); //Mathematica provides evaluation formula for error directly
			rkData.weightEE = rkData.weight - delta;
			rkData.hasStepSizeControl = true;

			rkData.orderMethod = 3; //this is p+1, the higher value of the order, e.g., 5 in DOPRI5
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		case DynamicSolverType::DOPRI5:
		{
			//values taken from Hairer, Norsett, Wanner I, page. 178
			rkData.A = Matrix(7, 7, { 0, 0, 0, 0, 0, 0, 0,
			   1. / 5, 0, 0, 0, 0, 0, 0,
			   3. / 40, 9. / 40, 0, 0, 0, 0, 0,
			   44. / 45, -56. / 15, 32. / 9, 0, 0, 0, 0, 
			   19372. / 6561, -25360. / 2187, 64448. / 6561, -212. / 729, 0, 0, 0,
			   9017. / 3168, -355. / 33, 46732. / 5247, 49. / 176, -5103. / 18656, 0, 0,
			   35. / 384, 0, 500. / 1113, 125. / 192, -2187. / 6784, 11. / 84, 0 });
			rkData.time = Vector({ 0., 1. / 5, 3. / 10, 4. / 5, 8. / 9, 1., 1. });
			rkData.weight = Vector({ 35. / 384, 0., 500. / 1113, 125. / 192, -2187. / 6784, 11. / 84, 0. });
			//Vector delta({ 71. / 57600, 0, -71. / 16695, 71. / 1920, -17253. / 339200, 22. / 525, -1. / 40 }); //wrong in Mathematica tutorial ...
			rkData.weightEE = Vector({ 5179. / 57600, 0., 7571. / 16695, 393. / 640, -92097. / 339200, 187. / 2100, 1. / 40 });

			rkData.hasStepSizeControl = true;

			rkData.orderMethod = 5; //this is p+1, the higher value of the order, e.g., 5 in DOPRI5
			return rkData.time.NumberOfItems(); //nStages
			break;
		}
		default: 
		{
			PyError("SolverExplicit: invalid explicitIntegration.dynamicSolverType; must be explicit solver!", file.solverFile);
			return 0;
		}
	}

	//add Dormand and Prince, see Hairer and Wanner I, page 178
	//add DVERK, see Hairer and Wanner I, page 178

	return 0;
}

//! precompute list of coordinates (constraints) that are eliminated
void CSolverExplicitTimeInt::PrecomputeConstraintElimination(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (!eliminateConstraints)
	{
		PyWarning("SolverExplicit: number of algebraic equations (nAE) != 0: explicit INTEGRATOR WILL IGNORE CONSTRAINTS", file.solverFile);
	}
	else
	{
		//check all nodes:
		Index cnt = 0;
		for (CNode* node : computationalSystem.GetSystemData().GetCNodes())
		{
			if (node->GetNumberOfAECoordinates() != 0)
			{
				PyError(STDstring("SolverExplicit: explicit integrator detected node ") + EXUstd::ToString(cnt) + " which contains algebraic variables; aborting solver", file.solverFile);
			}
			cnt++;
		}
		//go through all objects and check constraints:
		cnt = 0;
		for (CObject* object : computationalSystem.GetSystemData().GetCObjects())
		{
			if (EXUstd::IsOfType(object->GetType(), CObjectType::Constraint) && !EXUstd::IsOfType(object->GetType(), CObjectType::Connector))
			{
				PyError("SolverExplicit: mode eliminateConstraints==True detected incompatible object " + EXUstd::ToString(cnt));
			}
			// constraint is also connector now ...
			if (EXUstd::IsOfType(object->GetType(), CObjectType::Constraint)) //has algebraic equations; only CObjectConnectorCoordinate allowed; 
			{
				//CObjectConnector* connector = (CObjectConnector*)object;
				bool failed = false;
				if (!ISCPPTYPE(*object, CObjectConnectorCoordinate))
				{
					failed = true;
				}
				else
				{
					CObjectConnectorCoordinate* cc = (CObjectConnectorCoordinate*)object;
					Index markerNodeCoordinate = 0; //count number of CMarkerNodeCoordinate markers (MUST BE 2)
					Index markerGroundNode = 0; //count number of ground node markers (MUST BE 1)
					for (Index i : cc->GetMarkerNumbers())
					{
						const CMarker& marker = computationalSystem.GetSystemData().GetCMarker(i);
						if (ISCPPTYPE(marker, CMarkerNodeCoordinate))
						{
							markerNodeCoordinate++;
							const CNode& node = computationalSystem.GetSystemData().GetCNode(marker.GetNodeNumber());
							if (EXUstd::IsOfType(node.GetType(), Node::Ground))
							{
								markerGroundNode++;
							}
							else if (!EXUstd::IsOfType(node.GetNodeGroup(), CNodeGroup::ODE2variables))
							{
								PyError(STDstring("SolverExplicit: explicit integrator detected CoordinateConstraint object ") + 
									EXUstd::ToString(cnt) + " which contains marker to node other than ODE2; aborting solver", file.solverFile);
							}
							else //this must give the coordinate that should be constrained
							{
								Index globalCoord = node.GetGlobalODE2CoordinateIndex();
								Index ind = globalCoord + ((const CMarkerNodeCoordinate&)marker).GetCoordinateNumber();
								constrainedODE2Coordinates.Append(ind);
							}
						}
						else
						{
							PyError(STDstring("SolverExplicit: explicit integrator detected CoordinateConstraint object ") + 
								EXUstd::ToString(cnt) + " which contains marker to node other than NodeCoordinate; aborting solver", file.solverFile);
						}
					}
					if (markerGroundNode != 1)
					{
						PyError(STDstring("SolverExplicit: explicit integrator detected CoordinateConstraint object ") + 
							EXUstd::ToString(cnt) + "  that does not have one ground node; aborting solver", file.solverFile);
					}
					else if (markerNodeCoordinate != 2)
					{
						PyError(STDstring("SolverExplicit: explicit integrator detected CoordinateConstraint object ") + 
							EXUstd::ToString(cnt) + " which contains markers other than MarkerNodeCoordinate; aborting solver", file.solverFile);
					}

				}

				if (failed)
				{
					PyError(STDstring("SolverExplicit: explicit integrator detected object ") + 
						EXUstd::ToString(cnt) + " which contains constraints that cannot be solved; aborting solver", file.solverFile);
				}
			}
			cnt++;
		}

		Verbose(2, "constrainedODE2Coordinates = " + EXUstd::ToString(constrainedODE2Coordinates) + "\n");
		//check if all constraints are of CoordinateConstraint type
		//SysError("SolverExplicit: eliminateCoordinateConstraints = True not implemented", file.solverFile);
	}

}

//! set all ODE2 coordinates given in cODE2 in solODE2 to zero; used for displacements and velocities
void CSolverExplicitTimeInt::EliminateCoordinateConstraints(CSystem& computationalSystem, const ArrayIndex& cODE2, Vector& solODE2)
{
	if (eliminateConstraints)
	{
		for (Index i : cODE2)
		{
			solODE2[i] = 0; //for now, only ground constriants; is simple
		}
	}
}









//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++                 LIE GROUP INTEGRATION                    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! precompute non-Lie group coordinates and Lie-group node indices
void CSolverExplicitTimeInt::PrecomputeLieGroupStructures(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	const auto& cNodes = computationalSystem.GetSystemData().GetCNodes();
	lieGroupDataNodes.SetNumberOfItems(0); //filled with lie group node indices during initialization; ONLY if useLieGroupIntegration=true
	nonLieODE2Coordinates.SetNumberOfItems(0); //filled with coordinates, for which no Lie group integration is used; ONLY if useLieGroupIntegration=true

	for (Index i = 0; i < cNodes.NumberOfItems(); i++)
	{
		if (EXUstd::IsOfType(cNodes[i]->GetType(), Node::LieGroupWithDirectUpdate))
		{
			lieGroupDataNodes.Append(i);
			//lie group node must be rigid body node for now:
			const CNodeRigidBody& rigidNode = (const CNodeRigidBody&)(*cNodes[i]);

			//add displacement coordinates to nonLie coordinates
			Index nDispODE2 = rigidNode.GetNumberOfDisplacementCoordinates();
			for (Index j = 0; j < nDispODE2; j++)
			{
				nonLieODE2Coordinates.Append(cNodes[i]->GetGlobalODE2CoordinateIndex() + j);
			}
		}
		else if (EXUstd::IsOfType(cNodes[i]->GetType(), Node::LieGroupWithDataCoordinates))
		{
			PyError(STDstring("Explicit time integration detected node ")+EXUstd::ToString(i)+ " of type Lie group with data coordinates, which is currently not allowed");
		}
		else
		{
			Index nODE2 = cNodes[i]->GetNumberOfODE2Coordinates();
			for (Index j = 0; j < nODE2; j++)
			{
				nonLieODE2Coordinates.Append(cNodes[i]->GetGlobalODE2CoordinateIndex() + j);
			}
		}
	}
}


Index TSupdateODE2StageCoordinatesLieGroup;
TimerStructureRegistrator TSRupdateODE2StageCoordinatesLieGroup("updateODE2StageCoordinatesLieGroup", TSupdateODE2StageCoordinatesLieGroup, globalTimers);
Index TSlieGroupComputeKstage;
TimerStructureRegistrator TSRlieGroupComputeKstage("lieGroupComputeKstage", TSlieGroupComputeKstage, globalTimers);
Index TSlieGroupODE2StepEvaluation;
TimerStructureRegistrator TSRlieGroupODE2StepEvaluation("lieGroupODE2StepEvaluation", TSlieGroupODE2StepEvaluation, globalTimers);

//! update stage coordinates for regular ODE2 coordinates and Lie group nodes, for stage i, component j A[i,j]
void CSolverExplicitTimeInt::UpdateODE2StageCoordinatesLieGroup(CSystem& computationalSystem, 
	ResizableVectorParallel& solutionODE2, Real stepSize, Index i)
{
	//STARTGLOBALTIMER(TSupdateODE2StageCoordinatesLieGroup);
	if (IsVerbose(4))
	{
		Verbose(4, "\nUpdateODE2StageCoordinatesLieGroup:\n");
	}

	//updates for regular coordinates
	for (Index j = 0; j < i; j++)
	{
		if (rk.A(i, j) != 0.)
		{
			//conventional coordinates:
			Real fact = rk.A(i, j)*stepSize;
			for (Index k : nonLieODE2Coordinates)
			{
				solutionODE2[k] += fact * rk.stageDerivODE2[j][k];
			}
		}
	}
	const Vector& refODE2 = computationalSystem.GetSystemData().GetCData().referenceState.ODE2Coords;

	int nItems = lieGroupDataNodes.NumberOfItems();
	Index nThreads = exuThreading::TaskManager::GetNumThreads();

	Index taskSplit = (nThreads > 1 && nItems >= 1000) ? 16 * nThreads : nThreads; //difficult to optimally set for nodes
	exuThreading::TotalCosts costs = (nThreads == 1 || nItems < 100) ? 0 : 1000;

	exuThreading::ParallelFor(nItems, [this, &computationalSystem, &solutionODE2, &refODE2, &stepSize, &i, &nItems](NGSsizeType j)
	{
		//as nodes are independent, tasks can be performed thread-independent!
		//Index threadID = exuThreading::TaskManager::GetThreadId();

		Index n = lieGroupDataNodes[(Index)j];
		//Lie group nodes:
	//for (Index n : lieGroupDataNodes)
	//{
		const CNodeRigidBody& node = (const CNodeRigidBody&)(computationalSystem.GetSystemData().GetCNode(n));
		Index nPos = node.GetNumberOfDisplacementCoordinates(); //should be 3
		Index nRot = node.GetNumberOfRotationCoordinates();     //should be 3
		Index off = node.GetGlobalODE2CoordinateIndex();

		LinkedDataVector vecRef(refODE2, off + nPos, nRot);
		LinkedDataVector vecSol(solutionODE2, off + nPos, nRot);
		Vector3D vec0;
		vec0.CopyFrom(vecSol);
		vec0 += vecRef;

		//go on here:
		Vector3D Ksum(0);
		for (Index j = 0; j < i; j++)
		{
			if (rk.A(i, j) != 0.)
			{
				//LinkedDataVector K(rk.stageDerivODE2[j], off + nPos, nRot); //stageDerivLieODE2 
				Vector3D K(rk.stageDerivODE2[j], off + nPos);
				Ksum += rk.A(i, j)*stepSize*K;
			}
		}

		Vector3D deltaRot = EXUlie::CompositionRotationVector(vec0, Ksum);
		if (IsVerbose(4))
		{
			Verbose(4, "  composition( " + EXUstd::ToString(vec0) + ", " + EXUstd::ToString(Ksum) + " = " + EXUstd::ToString(deltaRot) + "\n");
		}

		deltaRot -= vecRef;
		LinkedDataVector dest(solutionODE2, off + nPos, nRot); //update rotations
		dest.SetVector(deltaRot); //write into dest vector / solutionODE2
	}, taskSplit, costs);
	//STOPGLOBALTIMER(TSupdateODE2StageCoordinatesLieGroup);
}

//! compute displacement stage increment (stageDerivLieODE2) for Lie group nodes
void CSolverExplicitTimeInt::LieGroupComputeKstage(CSystem& computationalSystem, const ResizableVectorParallel& solutionODE2_t,
	ResizableVectorParallel& stageDerivODE2, ResizableVectorParallel& stageDerivLieODE2, Real stepSize, Index i)
{
	//STARTGLOBALTIMER(TSlieGroupComputeKstage);

	//updates for regular coordinates
	for (Index k : nonLieODE2Coordinates)
	{
		stageDerivODE2[k] = solutionODE2_t[k];
	}

	int nItems = lieGroupDataNodes.NumberOfItems();
	Index nThreads = exuThreading::TaskManager::GetNumThreads();

	Index taskSplit = (nThreads > 1 && nItems >= 1000) ? 16 * nThreads : nThreads; //difficult to optimally set for nodes
	exuThreading::TotalCosts costs = (nThreads == 1 || nItems < 100) ? 0 : 1000;

	exuThreading::ParallelFor(nItems, [this, &computationalSystem, &solutionODE2_t, &stageDerivODE2, &stageDerivLieODE2, &stepSize, &i, &nItems](NGSsizeType j)
	{
		//as nodes are independent, tasks can be performed thread-independent!
		//Index threadID = exuThreading::TaskManager::GetThreadId();

		Index n = lieGroupDataNodes[(Index)j];
		//Lie group nodes:
		const CNodeRigidBody& node = (const CNodeRigidBody&)(computationalSystem.GetSystemData().GetCNode(n));
		Index nPos = node.GetNumberOfDisplacementCoordinates(); //should be 3
		Index nRot = node.GetNumberOfRotationCoordinates();     //should be 3
		Index off = node.GetGlobalODE2CoordinateIndex();
		CHECKandTHROW(nRot == 3, "CSolverExplicitTimeInt::LieGroupComputeKstage: number of rotation coordinates must be 3");
		Vector3D omega0(rk.startOfStepODE2_t, off + nPos); //beginning of step

		Vector3D Ku0sum(0); //displacement level
		Vector3D Kv0sum(0); //velocity level
		for (Index j = 0; j < i; j++)
		{
			if (rk.A(i, j) != 0.)
			{
				Vector3D Ku(rk.stageDerivODE2[j], off + nPos); //stageDerivLieODE2 
				Ku0sum += rk.A(i, j)*stepSize*Ku;
				Vector3D Kv(rk.stageDerivODE2_t[j], off + nPos);
				Kv0sum += rk.A(i, j)*stepSize*Kv;
			}
		}

		Vector3D Ku = EXUlie::TExpSO3Inv(Ku0sum) * (omega0 + Kv0sum);
		//if (doDebug) { pout << "TExp(" << Ku0sum << ")*(" << omega0 << "+" << Kv0sum << ")=" << Ku << "\n"; }
		LinkedDataVector dest(stageDerivODE2, off + nPos, nRot); //stageDerivLieODE2 
		dest.SetVector(Ku); //writes into dest vector, linked to according stageDeriv(Lie)ODE2 part
	}, taskSplit, costs);
	//#K = np.zeros(nODE2)
	//	K = h * (v0[0:nODE2] + factK * kprev) #this is the correct displacement stage for non - LieGroup coordinates; LieGroup coordinates will be overwritten!
	//	for i in mainSys.sys['lieGroupODE2indices']:
	//i1 = i + 3 #start index of rotation
	//	i2 = i + 6 #end index of rotation
	//	omega0 = v0[i1:i2]
	//	K0 = Kprev[i1:i2]
	//	k0 = kprev[i1:i2]
	//	K[i1:i2] = h * np.dot(TExpSO3Inv(factK*K0), omega0 + factK * k0)

	//	return K
	//STOPGLOBALTIMER(TSlieGroupComputeKstage);
}

//! compute final integration formula for Runge-Kutta method, including Lie group nodes
void CSolverExplicitTimeInt::LieGroupODE2StepEvaluation(CSystem& computationalSystem, ResizableVectorParallel& solutionODE2,
	Real stepSize, const Vector& weights)
{
	//STARTGLOBALTIMER(TSlieGroupODE2StepEvaluation);
	//final step evaluation updates for regular coordinates
	for (Index i = 0; i < nStages; i++)
	{
		if (weights[i] != 0.)
		{
			Real fact = weights[i] * stepSize;
			const ResizableVector& Ku = rk.stageDerivODE2[i];
			for (Index k : nonLieODE2Coordinates)
			{
				solutionODE2[k] += fact * Ku[k];
			}
		}
	}

	const Vector& refODE2 = computationalSystem.GetSystemData().GetCData().referenceState.ODE2Coords;
	//Lie group nodes:

	int nItems = lieGroupDataNodes.NumberOfItems();
	Index nThreads = exuThreading::TaskManager::GetNumThreads();

	Index taskSplit = (nThreads > 1 && nItems >= 1000) ?  16 * nThreads : nThreads; //difficult to optimally set for nodes
	exuThreading::TotalCosts costs = (nThreads == 1 || nItems < 100) ? 0 : 1000;

	exuThreading::ParallelFor(nItems, [this, &computationalSystem, &solutionODE2, &stepSize, &weights, &refODE2, &nItems](NGSsizeType j) 
	{
		//as nodes are independent, tasks can be performed thread-independent!
		//Index threadID = exuThreading::TaskManager::GetThreadId();

		Index n = lieGroupDataNodes[(Index)j];

	//for (Index n : lieGroupDataNodes)
	//{
		const CNodeRigidBody& node = (const CNodeRigidBody&)(computationalSystem.GetSystemData().GetCNode(n));
		Index nPos = node.GetNumberOfDisplacementCoordinates(); //should be 3
		Index nRot = node.GetNumberOfRotationCoordinates();     //should be 3
		Index off = node.GetGlobalODE2CoordinateIndex();
		CHECKandTHROW(nRot == 3, "CSolverExplicitTimeInt::LieGroupODE2StepEvaluation: only implemented for 3 rotation coordinates");

		Vector3D Omega(0.);
		LinkedDataVector vecRef(refODE2, off + nPos, nRot);

		//deltaU = 1. / 6. * (K1 + 2 * K2 + 2 * K3 + K4) #contains displacement updates and incremental velocity vectors
		for (Index i = 0; i < nStages; i++)
		{
			if (weights[i] != 0.)
			{
				LinkedDataVector Ku(rk.stageDerivODE2[i], off + nPos, nRot); //
				Omega += weights[i] * stepSize * Vector3D({ Ku[0], Ku[1], Ku[2] });
			}
		}

		LinkedDataVector vecSol(solutionODE2, off + nPos, nRot);
		Vector3D vec0;
		vec0.CopyFrom(vecSol);
		vec0 += vecRef; //need reference values for correct rotation representation (nonlinear!)

		Vector3D uStep = EXUlie::CompositionRotationVector(vec0, Omega);
		uStep -= vecRef;
		vecSol.SetVector(uStep);

	}, taskSplit, costs);

	//STOPGLOBALTIMER(TSlieGroupODE2StepEvaluation);
}


