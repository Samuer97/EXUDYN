#autogenerated system data structures
#load this file into pythonAutoGenerateInterfaces.py (in same folder

#USAGE:
#  define a certain class with
#    class = [C++ class name]
#  define parameters per line, see pattern below, using types and flags
#  finally write:
#    writeFile=[C++ file name]
#
#text with "" may contain spaces and commas, etc; tabs will be erased
#
#[V|F[v]]: V...Value (=member variable), F...Function (access via member function); v ... virtual Function; VL ... linked variable: variable will be linked, but is no member
#pythonName: name which is used in Python
#cplusplusName: name which is used in C++ side of Exudyn (leave empty if it is the same)
#size = leave empty if size is variable; e.g. 3 (size of vector), 2x3 (2 rows, 3 columns)  %used for vectors and matrices only!
#type = Bool, Int, Real, UInt, UReal (unsigned Real), PInt (Int > 0), PReal (Real > 0), Vector, Matrix, VectorFloat, MatrixFloat, SymmetricMatrix
#defaultValue = default value or string (use "" to clearly identify strings incl. spaces); for 'V'-types: default initialization; vor 'F' and 'F'-types: C++ code of function;
#cFlags = A...add access functions (e.g. const Real&/Real&), D...no dictionary with type info, S...substructure (e.g. Newton), V... return value policy copy, O...move return policy, G... add args for pybind, R(read only), M(modifiableDuringSimulation), C...const function, D...definition only (implementation in separate file), P ... write Pybind11 interface [default is read/write access and that changes are immediately applied and need no reset of the system]
#parameterDescription = description for parameter used in C++ code

# classDescription = "parameters for CSystem"
# class = System2
# parentClass = System
# typicalPaths = simulationSettings. ... #use comma-separated paths to be shown in description
# latexText = ""        #text, which will be added before the class description (e.g., to start a new section)
# cppText = ""          #code which is added before class definition
# addConstructor = "",   #code added to default constructor
# addDictionaryAccess #add access function to export/import data to/from dictionary (with type information)
# linkedClass= "",       #member variable (representing a class) to which this object is linked
#V|F, pythonName, cplusplusName (or empty if same), size, type, defaultValue,args, cflags, parameterDescription
# name,           , 0     ,    String, "empty", , "this is a description,    using    comma"
# name2, , 0,Real, 12, , "this is a Real"
# writeFile=test.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#property classes for structural elements

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = PyBeamSection
parentClass = BeamSection
pythonClass = BeamSection
#appendToFile=True #not done in first class
writePybindIncludes = True
cppText = '#include "Main/StructuralElementsDataStructures.h"\n#include "Pymodules/PybindUtilities.h"\n'
#cppText = 'class PyNumpyArray; //declaration to avoid include of pybind\n'
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsection{Structures for structural elements}\nThis section includes data structures for structural elements, such as beams (and plates in future). These classes are used as interface between Python libraries for structural elements and Exudyn internal classes.\n"
classDescription = "Data structure for definition of 2D and 3D beam (cross) section mechanical properties. The beam has local coordinates, in which $X$ represents the beam centerline (beam axis) coordinate, being the neutral fiber w.r.t.\ bending; $Y$ and $Z$ are the local cross section coordinates. Note that most elements do not accept all parameters, which results in an error if those parameters (e.g., stiffness parameters) are non-zero."
#V|F, pythonName,          cplusplusName,   size, type,                     defaultValue,args,  cFlags, parameterDescription
#
#see Bauchau, 2010, page 620
#not part of section?: V,  length,                             ,       , PReal,                    0.,             ,  DP     , "$l_b$ [SI:m] length of beam element"
VL,  stiffnessMatrix,                   ,       , Matrix6D,                 "Matrix6D(6,6,0.)", ,  DP     , "$\LU{c}{\Cm} \in \Rcal^{6 \times 6}\,$ [SI:Nm$^2$, Nm and N (mixed)] sectional stiffness matrix related to $\vp{\LU{c}{\nv}}{\LU{c}{\mv}} = \LU{c}{\Cm} \vp{\LU{c}{\teps}}{\LU{c}{\tkappa}}$ with sectional normal force $\LU{c}{\nv}$, torque $\LU{c}{\mv}$, strain $\LU{c}{\teps}$ and curvature $\LU{c}{\tkappa}$, all quantities expressed in the cross section frame $c$. Set with list of lists or numpy array."
VL,  dampingMatrix,                     ,       , Matrix6D,                 "Matrix6D(6,6,0.)", ,  DP     , "$\LU{c}{\Dm} \in \Rcal^{6 \times 6}\,$ [SI:Nsm$^2$, Nsm and Ns (mixed)] sectional linear damping matrix related to $\vp{\LU{c}{\nv}}{\LU{c}{\mv}} = \LU{c}{\Dm} \vp{\LU{c}{\tepsDot}}{\LU{c}{\tkappaDot}}$; note that this damping models is highly simplified and usually, it cannot be derived from material parameters; however, it can be used to adjust model damping to observed damping behavior. Set with list of lists or numpy array."
VL,  massPerLength,                     ,       , UReal,                    0.,             ,  DP     , "$\rho A\,$ [SI:kg/m] mass per unit length of the beam"
VL,  inertia,                           ,       , Matrix3D,                 "EXUmath::zeroMatrix3D", ,  DP     , "$\LU{c}{\Jm} \in \Rcal^{3 \times 3}\,$ [SI:kg$\,$m$^2$] sectional inertia for shear-deformable beams. Set with list of lists or numpy array."
#optional, used by Bauchau:
#  sectionalCOM,                       ,       , Vector2D,                 "Vector2D(0.)", ,  DP     , "$\LU{c}{\vv_{com}} \in \Rcal^2\,$ [SI:m] sectional center of mass."
#
writeFile=PyStructuralElementsDataStructures.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = BeamSectionGeometry
#parentClass = BeamSectionGeometry
#pythonClass = BeamSectionGeometry
#appendToFile=True
writePybindIncludes = True
#cppText = '#include "Main/StructuralElementsDataStructures.h"\n'
classDescription = "Data structure for definition of 2D and 3D beam (cross) section geometrical properties. Used for visualization and contact."
#V|F, pythonName,          cplusplusName,   size, type,                     defaultValue,args,  cFlags, parameterDescription
#
V,  crossSectionType,                   ,       , CrossSectionType,         "CrossSectionType::Polygon", , DP, "Type of cross section: Polygon, Circular, etc."
V,  crossSectionRadiusY,                ,       , UReal,                    0.,         ,      DP     , "$c_Y\,$ [SI:m] $Y$ radius for circular cross section"
V,  crossSectionRadiusZ,                ,       , UReal,                    0.,         ,      DP     , "$c_Z\,$ [SI:m] $Z$ radius for circular cross section"
V,  polygonalPoints,                    ,       , Vector2DList,             "",         ,      DP     , "$\pv_{pg}\,$ [SI: (m,m) ] list of polygonal ($Y,Z$) points in local beam cross section coordinates, defined in positive rotation direction"
#
writeFile=BeamSectionGeometry.h

    
#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = SolutionSettings
#appendToFile=True #not done in first class
writePybindIncludes = True
typicalPaths = simulationSettings
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsectionlabel{Simulation settings}{sec:SimulationSettingsMain}\nThis section includes hierarchical structures for simulation settings, e.g., time integration, static solver, Newton iteration and solution file export.\n"
classDescription = "General settings for exporting the solution (results) of a simulation."
#V|F, pythonName,          cplusplusName,   size, type,                     defaultValue,args,  cFlags, parameterDescription
#
V,  coordinatesSolutionFileName,        ,       , FileName,                 "coordinatesSolution" , ,P, "filename and (relative) path of solution file (coordinatesSolutionFile) containing all multibody system coordinates versus time; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '_' only; filename ending will be added automatically if not provided: .txt in case of text mode and .sol in case of binary solution files (binarySolutionFile=True)"
V,  writeSolutionToFile,                ,       , bool,                     true,       ,       P   , "flag (true/false), which determines if (global) solution vector is written to the solution file (coordinatesSolutionFile); standard quantities that are written are: solution is written as displacements and coordinatesODE1; for additional coordinates in the solution file, see the options below"
V,  writeFileHeader,                    ,       , bool,                     true,       ,       P   , "flag (true/false); if true, file header is written (turn off, e.g. for multiple runs of time integration)"
V,  writeFileFooter,                    ,       , bool,                     true,       ,       P   , "flag (true/false); if true, information at end of simulation is written: convergence, total solution time, statistics"
V,  writeInitialValues,                 ,       , bool,                     true,       ,       P   , "flag (true/false); if true, initial values are exported for the start time; applies to coordinatesSolution and sensor files; this may not be wanted in the append file mode if the initial values are identical to the final values of a previous computation"
V,  solutionWritePeriod,                ,       , UReal,                    0.01,       ,       P   , "time span (period), determines how often the solution file (coordinatesSolutionFile) is written during a simulation"
V,  binarySolutionFile,                 ,       , bool,                     false,      ,       P   , "if true, the solution file is written in binary format for improved speed and smaller file sizes; setting outputPrecision >= 8 uses double (8 bytes), otherwise float (4 bytes) is used; note that appendToFile is ineffective and files are always replaced without asking! If not provided, file ending will read .sol in case of binary files and .txt in case of text files"
#                                                                                               
V,  appendToFile,                       ,       , bool,                     false,      ,       P   , "flag (true/false); if true, solution and solverInformation is appended to existing file (otherwise created); in BINARY mode, files are always replaced and this parameter is ineffective!"
V,  flushFilesImmediately,              ,       , bool,                     false,      ,       P   , "flush file buffers after every solution period written (coordinatesSolutionFile and sensor files); if set False, the output is written through a buffer, which is highly efficient, but during simulation, files may be always in an incomplete state; if set True, this may add a large amount of CPU time as the process waits until files are really written to hard disc (especially for simulation of small scale systems, writing 10.000s of time steps; at least 5us per step/file, depending on hardware)" 
V,  flushFilesDOF,                      ,       , PInt,                     10000,      ,       P   , "number of DOF, above which solution file (coordinatesSolutionFile) buffers are always flushed, irrespectively of whether flushFilesImmediately is set True or False (see also flushFilesImmediately); for larger files, writing takes so much time that flushing does not add considerable time" 
#                                                                                               
V,  exportAccelerations,                ,       , bool,                     true,       ,       P   , "add \hac{ODE2} accelerations to solution file (coordinatesSolutionFile)"
V,  exportAlgebraicCoordinates,         ,       , bool,                     true,       ,       P   , "add algebraicCoordinates (=Lagrange multipliers) to solution file (coordinatesSolutionFile)" 
V,  exportDataCoordinates,              ,       , bool,                     true,       ,       P   , "add DataCoordinates to solution file (coordinatesSolutionFile)"
V,  exportODE1Velocities,               ,       , bool,                     true,       ,       P   , "add coordinatesODE1_t to solution file (coordinatesSolutionFile)"
V,  exportVelocities,                   ,       , bool,                     true,       ,       P   , "add \hac{ODE2} velocities to solution file (coordinatesSolutionFile)"
#                                                                                               
V,  outputPrecision,                    ,       , UInt,                     10,         ,       P   , "precision for floating point numbers written to solution and sensor files"
#                                                                                               
V,  writeRestartFile,                   ,       , bool,                     false,      ,       P   , "flag (true/false), which determines if restart file is written regularly, see restartFileName for details"
V,  restartFileName,                    ,       , FileName,                 "restartFile.txt",, P   , "filename and (relative) path of text file for storing solution after every restartWritePeriod if writeRestartFile=True; backup file is created with ending .bck, which should be used if restart file is crashed; use Python utility function InitializeFromRestartFile(...) to consistently restart"
V,  restartWritePeriod,                 ,       , UReal,                    0.01,       ,       P   , "time span (period), determines how often the restart file is updated; this should be often enough to enable restart without too much loss of data; too low values may influence performance"
#   
V,  sensorsAppendToFile,                ,       , bool,                     false,      ,       P   , "flag (true/false); if true, sensor output is appended to existing file (otherwise created) or in case of internal storage, it is appended to existing currently stored data; this allows storing sensor values over different simulations"
V,  sensorsWriteFileHeader,             ,       , bool,                     true,       ,       P   , "flag (true/false); if true, file header is written for sensor output (turn off, e.g. for multiple runs of time integration)"
V,  sensorsWriteFileFooter,             ,       , bool,                     false,      ,       P   , "flag (true/false); if true, file footer is written for sensor output (turn off, e.g. for multiple runs of time integration)"
V,  sensorsWritePeriod,                 ,       , UReal,                    0.01,       ,       P   , "time span (period), determines how often the sensor output is written to file or internal storage during a simulation"
V,  sensorsStoreAndWriteFiles,          ,       , bool,                     true,       ,       P   , "flag (true/false); if false, no sensor files will be created and no sensor data will be stored; this may be advantageous for benchmarking as well as for special solvers which should not overwrite existing results (e.g. ComputeODE2Eigenvalues); settings this value to False may cause problems if sensors are required to perform operations which are needed e.g. in UserSensors as input of loads, etc."
#   
V,  solutionInformation,                ,       , String,                   "",         ,       P   , "special information added to header of solution file (e.g. parameters and settings, modes, ...); character encoding my be UTF-8, restricted to characters in \refSection{sec:utf8}, but for compatibility, it is recommended to use ASCII characters only (95 characters, see wiki)"
V,  solverInformationFileName,          ,       , FileName,                 "solverInformation.txt",,P, "filename and (relative) path of text file showing detailed information during solving; detail level according to yourSolver.verboseModeFile; if solutionSettings.appendToFile is true, the information is appended in every solution step; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '_' only"
#
V,  recordImagesInterval,               ,       , Real,                     -1.,        ,       P   , "record frames (images) during solving: amount of time to wait until next image (frame) is recorded; set recordImages = -1. if no images shall be recorded; set, e.g., recordImages = 0.01 to record an image every 10 milliseconds (requires that the time steps / load steps are sufficiently small!); for file names, etc., see VisualizationSettings.exportImages"
#
#
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = NumericalDifferentiationSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings.timeIntegration.newton,simulationSettings.staticSolver.newton
classDescription = "Settings for numerical differentiation of a function (needed for computation of numerical jacobian e.g. in implizit integration)."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  addReferenceCoordinatesToEpsilon,   ,       , bool,                     false,      ,       P   , "True: for the size estimation of the differentiation parameter, the reference coordinate $q^{Ref}_i$ is added to \hac{ODE2} coordinates --> see; False: only the current coordinate is used for size estimation of the differentiation parameter"
V,  doSystemWideDifferentiation,        ,       , bool,                     false,      ,       P   , "True: system wide differentiation (e.g. all \hac{ODE2} equations w.r.t. all \hac{ODE2} coordinates); False: only local (object) differentiation"
V,  forAE,                              ,       , bool,                     false,      ,       P   , "flag (true/false); false = perform direct computation of jacobian for algebraic equations (AE), true = use numerical differentiation; as there must always exist an analytical implemented jacobian for AE, 'true' should only be used for verification"
V,  forODE2,                            ,       , bool,                     false,      ,       P   , "flag (true/false); false = perform direct computation (e.g., using autodiff) of jacobian for ODE2 equations, true = use numerical differentiation; numerical differentiation is less efficient and may lead to numerical problems, but may smoothen problems of analytical derivatives; sometimes the analytical derivative may neglect terms"
V,  forODE2connectors,                  ,       , bool,                     false,      ,       P   , "flag (true/false); false: if also forODE2==false, perform direct computation of jacobian for ODE2 terms for connectors; else: use numerical differentiation; NOTE: THIS FLAG IS FOR DEVELOPMENT AND WILL BE ERASED IN FUTURE"
V,  minimumCoordinateSize,              ,       , UReal,                    1e-2,       ,       P   , "minimum size of coordinates in relative differentiation parameter"
V,  relativeEpsilon,                    ,       , UReal,                    1e-7,       ,       P   , "relative differentiation parameter epsilon; the numerical differentiation parameter $\varepsilon$ follows from the formula ($\varepsilon = \varepsilon_\mathrm{relative}*max(q_{min}, |q_i + [q^{Ref}_i]|)$, with $\varepsilon_\mathrm{relative}$=relativeEpsilon, $q_{min} = $minimumCoordinateSize, $q_i$ is the current coordinate which is differentiated, and $qRef_i$ is the reference coordinate of the current coordinate"
V,  jacobianConnectorDerivative,        ,       , bool,                     true,       ,       P   , "True: for analytic Jacobians of connectors, the Jacobian derivative is computed, causing additional CPU costs and not beeing available for all connectors or markers (thus switching to numerical differentiation); False: Jacobian derivative is neglected in analytic Jacobians (but included in numerical Jacobians), which often has only minor influence on convergence"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = DiscontinuousSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings.timeIntegration,simulationSettings.staticSolver
classDescription = "Settings for discontinuous iterations, as in contact, friction, plasticity and general switching phenomena."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  ignoreMaxIterations,                ,       , bool,                     true,       ,       P   , "continue solver if maximum number of discontinuous (post Newton) iterations is reached (ignore tolerance)"
V,  iterationTolerance,                 ,       , UReal,                    1,          ,       P   , "absolute tolerance for discontinuous (post Newton) iterations; the errors represent absolute residuals and can be quite high"
V,  maxIterations,                      ,       , UInt,                     5,          ,       P   , "maximum number of discontinuous (post Newton) iterations"
#
writeFile=SimulationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = NewtonSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings.timeIntegration,simulationSettings.staticSolver
classDescription = "Settings for Newton method used in static or dynamic simulation."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  numericalDifferentiation,, , NumericalDifferentiationSettings,          ,           ,       PS  , "numerical differentiation parameters for numerical jacobian (e.g. Newton in static solver or implicit time integration)"
V,  absoluteTolerance,                  ,       , UReal,                    1e-10,      ,       P   , "absolute tolerance of residual for Newton (needed e.g. if residual is fulfilled right at beginning); condition: sqrt(q*q)/numberOfCoordinates <= absoluteTolerance"
V,  relativeTolerance,                  ,       , UReal,                    1e-8,       ,       P   , "relative tolerance of residual for Newton (general goal of Newton is to decrease the residual by this factor)"
V,  useNewtonSolver,                    ,       , bool,                     true,       ,       P   , "flag (true/false); false = linear computation, true = use Newton solver for nonlinear solution"
V,  weightTolerancePerCoordinate,       ,       , bool,                     false,      ,       P   , "flag (true/false); false = compute error as L2-Norm of residual; true = compute error as (L2-Norm of residual) / (sqrt(number of coordinates)), which can help to use common tolerance independent of system size"
V,  newtonResidualMode,                 ,       , UInt,                     0,          ,       P   , "0 ... use residual for computation of error (standard); 1 ... use \hac{ODE2} and \hac{ODE1} newton increment for error (set relTol and absTol to same values!) ==> may be advantageous if residual is zero, e.g., in kinematic analysis; TAKE CARE with this flag"
V,  adaptInitialResidual,               ,       , bool,                     true,       ,       P   , "flag (true/false); false = standard; True: if initialResidual is very small (or zero), it may increase significantely in the first Newton iteration; to achieve relativeTolerance, the initialResidual will by updated by a higher residual within the first Newton iteration"
#                                                                                               
V,  modifiedNewtonContractivity,        ,       , PReal,                    0.5,        ,       P   , "maximum contractivity (=reduction of error in every Newton iteration) accepted by modified Newton; if contractivity is greater, a Jacobian update is computed"
V,  useModifiedNewton,                  ,       , bool,                     false,      ,       P   , "True: compute Jacobian only at first call to solver; the Jacobian (and its factorizations) is not computed in each Newton iteration, even not in every (time integration) step; False: Jacobian (and factorization) is computed in every Newton iteration (default, but may be costly)"
V,  modifiedNewtonJacUpdatePerStep,     ,       , bool,                     false,      ,       P   , "True: compute Jacobian at every time step (or static step), but not in every Newton iteration (except for bad convergence ==> switch to full Newton)"
V,  maxIterations,                      ,       , UInt,                     25,         ,       P   , "maximum number of iterations (including modified + restart Newton iterations); after that total number of iterations, the static/dynamic solver refines the step size or stops with an error"
V,  maxModifiedNewtonIterations,        ,       , UInt,                     8,          ,       P   , "maximum number of iterations for modified Newton (without Jacobian update); after that number of iterations, the modified Newton method gets a jacobian update and is further iterated"
V,  maxModifiedNewtonRestartIterations, ,       , UInt,                     7,          ,       P   , "maximum number of iterations for modified Newton after a Jacobian update; after that number of iterations, the full Newton method is started for this step"
V,  maximumSolutionNorm,                ,       , UReal,                    1e38,       ,       P   , "this is the maximum allowed value for solutionU.L2NormSquared() which is the square of the square norm (i.e., value=$u_1^2$+$u_2^2$+...), and solutionV/A...; if the norm of solution vectors is larger, Newton method is stopped; the default value is chosen such that it would still work for single precision numbers (float)"
#
writeFile=SimulationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = GeneralizedAlphaSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings.timeIntegration
classDescription = "Settings for generalized-alpha, implicit trapezoidal or Newmark time integration methods."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  newmarkBeta,                        ,       , UReal,                    0.25,       ,       P   , "value beta for Newmark method; default value beta = $\frac 1 4$ corresponds to (undamped) trapezoidal rule"
V,  newmarkGamma,                       ,       , UReal,                    0.5,        ,       P   , "value gamma for Newmark method; default value gamma = $\frac 1 2$ corresponds to (undamped) trapezoidal rule"
V,  useIndex2Constraints,               ,       , bool,                     false,      ,       P   , "set useIndex2Constraints = true in order to use index2 (velocity level constraints) formulation"
V,  useNewmark,                         ,       , bool,                     false,      ,       P   , "if true, use Newmark method with beta and gamma instead of generalized-Alpha"
V,  spectralRadius,                     ,       , UReal,                    0.9,        ,       P   , "spectral radius for Generalized-alpha solver; set this value to 1 for no damping or to 0 < spectralRadius < 1 for damping of high-frequency dynamics; for position-level constraints (index 3), spectralRadius must be < 1"
V,  computeInitialAccelerations,        ,       , bool,                     true,       ,       P   , "True: compute initial accelerations from system EOM in acceleration form; NOTE that initial accelerations that are following from user functions in constraints are not considered for now! False: use zero accelerations"
V,  resetAccelerations,                 ,       , bool,                     false,      ,       P   , "this flag only affects if computeInitialAccelerations=False: if resetAccelerations=True, accelerations are set zero in the solver function InitializeSolverInitialConditions; this may be unwanted in case of repeatedly called SolveSteps() and in cases where solutions shall be prolonged from previous computations"
V,  lieGroupAddTangentOperator,         ,       , bool,                     true,       ,       P   , "True: for Lie group nodes, in case that lieGroupSimplifiedKinematicRelations=True, the integrator adds the tangent operator for stiffness and constraint matrices, for improved Newton convergence; not available for sparse matrix mode (EigenSparse)"
V,  lieGroupSimplifiedKinematicRelations, ,     , bool,                     true,       ,       P   , "True: for Lie group nodes, the integrator uses the original kinematic relations of the Bruls and Cardona 2010 paper"
#
writeFile=SimulationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = ExplicitIntegrationSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings.timeIntegration
classDescription = "Settings for explicit solvers, like Explicit Euler, RK44, ODE23, DOPRI5 and others. The settings may significantely influence performance."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  dynamicSolverType,                  ,       , DynamicSolverType,"DynamicSolverType::DOPRI5",,P  , "selection of explicit solver type (DOPRI5, ExplicitEuler, ExplicitMidpoint, RK44, RK67, VelocityVerlet, ...), for detailed description see DynamicSolverType, \refSection{sec:DynamicSolverType}, but only referring to explicit solvers."
V,  eliminateConstraints,               ,       , bool,                     true,       ,       P   , "True: make explicit solver work for simple CoordinateConstraints, which are eliminated for ground constraints (e.g. fixed nodes in finite element models). False: incompatible constraints are ignored (BE CAREFUL)!"
V,  useLieGroupIntegration,             ,       , bool,                     true,       ,       P   , "True: use Lie group integration for rigid body nodes; must be turned on for Lie group nodes (without data coordinates) to work properly; does not work for nodes with data coordinates!"
V,  computeEndOfStepAccelerations,      ,       , bool,                     true,       ,       P   , "accelerations are computed at stages of the explicit integration scheme; if the user needs accelerations at the end of a step, this flag needs to be activated; if True, this causes a second call to the RHS of the equations, which may DOUBLE COMPUTATIONAL COSTS for one-step-methods; if False, the accelerations are re-used from the last stage, being slightly different"
V,  computeMassMatrixInversePerBody,    ,       , bool,                     false,      ,       P   , "If true, the solver assumes the bodies to be independent and computes the inverse of the mass matrix for all bodies independently; this may lead to WRONG RESULTS, if bodies share nodes, e.g., two MassPoint objects put on the same node or a beam with a mass point attached at a shared node; however, it may speed up explicit time integration for large systems significantly (multi-threaded)"
#
writeFile=SimulationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = TimeIntegrationSettings
appendToFile=True
typicalPaths = simulationSettings
classDescription = "General parameters used in time integration; specific parameters are provided in the according solver settings, e.g. for generalizedAlpha."
writePybindIncludes = True
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  newton,                             ,       , NewtonSettings,           ,           ,       PS  , "parameters for Newton method; used for implicit time integration methods only"
V,  discontinuous,                      ,       , DiscontinuousSettings,    ,           ,       PS  , "parameters for treatment of discontinuities"
# solver specific                   
V,  generalizedAlpha,                   ,       , GeneralizedAlphaSettings, ,           ,       PS  , "parameters for generalized-alpha, implicit trapezoidal rule or Newmark (options only apply for these methods)"
# name explicit cannot be used in C++ ! 
V,  explicitIntegration,                ,       , ExplicitIntegrationSettings,,         ,       PS  , "special parameters for explicit time integration"
#                       
V,  startTime,                          ,       , UReal,                    0,          ,       P   , "$t_{start}$: start time of time integration (usually set to zero)"
V,  endTime,                            ,       , UReal,                    1,          ,       P   , "$t_{end}$: end time of time integration"
V,  numberOfSteps,                      ,       , PInt,                     100,        ,       P   , "$n_{steps}$: number of steps in time integration; (maximum) stepSize $h$ is computed from $h = \frac{t_{end} - t_{start}}{n_{steps}}$; for automatic stepsize control, this stepSize is the maximum steps size, $h_{max} = h$"
V,  adaptiveStep,                       ,       , bool,                     true,       ,       P   , "True: the step size may be reduced if step fails; no automatic stepsize control"
V,  adaptiveStepRecoverySteps,          ,       , UInt,                     10,         ,       P   , "Number of steps needed after which steps will be increased after previous step reduction due to discontinuousIteration or Newton errors"
V,  adaptiveStepRecoveryIterations,     ,       , UInt,                     7,          ,       P   , "Number of max. (Newton iterations + discontinuous iterations) at which a step increase is considered; in order to immediately increase steps after reduction, chose a high value"
V,  adaptiveStepIncrease,               ,       , UReal,                    2,          ,       P   , "Multiplicative factor (MUST BE > 1) for step size to increase after previous step reduction due to discontinuousIteration or Newton errors"
V,  adaptiveStepDecrease,               ,       , UReal,                    0.5,        ,       P   , "Multiplicative factor (MUST BE: 0 < factor < 1) for step size to decrese due to discontinuousIteration or Newton errors"
#parameters for automatic step size control                     
V,  automaticStepSize,                  ,       , bool,                     true,       ,       P   , "True: for specific integrators with error control (e.g., DOPRI5), compute automatic step size based on error estimation; False: constant step size (step may be reduced if adaptiveStep=True); the maximum stepSize reads $h = h_{max} = \frac{t_{end} - t_{start}}{n_{steps}}$"
V,  minimumStepSize,                    ,       , PReal,                    1e-8,       ,       P   , "$h_{min}$: if automaticStepSize=True or adaptiveStep=True: lower limit of time step size, before integrator stops with adaptiveStep; lower limit of automaticStepSize control (continues but raises warning)"
V,  initialStepSize,                    ,       , UReal,                    0,          ,       P   , "$h_{init}$: if automaticStepSize=True, initial step size; if initialStepSize==0, max. stepSize, which is (endTime-startTime)/numberOfSteps, is used as initial guess; a good choice of initialStepSize may help the solver to start up faster."
V,  absoluteTolerance,                  ,       , UReal,                    1e-8,       ,       P   , "$a_{tol}$: if automaticStepSize=True, absolute tolerance for the error control; must fulfill $a_{tol} > 0$; see \refSection{sec:ExplicitSolver}"
V,  relativeTolerance,                  ,       , UReal,                    1e-8,       ,       P   , "$r_{tol}$: if automaticStepSize=True, relative tolerance for the error control; must fulfill $r_{tol} \ge 0$; see \refSection{sec:ExplicitSolver}"
V,  stepSizeSafety,                     ,       , UReal,                    0.90,       ,       P   , "$r_{sfty}$: if automaticStepSize=True, a safety factor added to estimated optimal step size, in order to prevent from many rejected steps, see \refSection{sec:ExplicitSolver}. Make this factor smaller if many steps are rejected."
V,  stepSizeMaxIncrease,                ,       , UReal,                    2,          ,       P   , "$f_{maxInc}$: if automaticStepSize=True, maximum increase of step size per step, see \refSection{sec:ExplicitSolver}; make this factor smaller (but $> 1$) if too many rejected steps"
V,  computeLoadsJacobian,               ,       , UInt,                     0,          ,       P   , "0:  jacobian of loads not considered (may lead to slow convergence or Newton failure); 1: in case of implicit integrators, compute (numerical) Jacobian of ODE2 and ODE1 coordinates for loads, causing additional computational costs; this is advantageous in cases where loads are related nonlinearly to coordinates; 2: also compute ODE2_t dependencies for jacobian; note that computeLoadsJacobian has no effect in case of doSystemWideDifferentiation, as this anyway includes all load dependencies"
# special:
V,  reuseConstantMassMatrix,            ,       , bool,                     true,       ,       P   , "True: does not recompute constant mass matrices (e.g. of some finite elements, mass points, etc.); if False, it always recomputes the mass matrix (e.g. needed, if user changes mass parameters via Python)"
#           
V,  simulateInRealtime,                 ,       , bool,                     false,      ,       P   , "True: simulate in realtime; the solver waits for computation of the next step until the CPU time reached the simulation time; if the simulation is slower than realtime, it simply continues"
V,  realtimeFactor,                     ,       , PReal,                    1,          ,       P   , "if simulateInRealtime=True, this factor is used to make the simulation slower than realtime (factor < 1) or faster than realtime (factor > 1)"
V,  realtimeWaitMicroseconds,           ,       , PInt,                     1000,       ,       P   , "if simulateInRealtime=True, a loop runs which waits realtimeWaitMicroseconds until checking again if the realtime is reached; using larger values leads to less CPU usage but less accurate realtime accuracy; smaller values (< 1000) increase CPU usage but improve realtime accuracy"
# information and output:                                   
V,  verboseMode,                        ,       , UInt,                     0,          ,       P   , "0 ... no output, 1 ... show short step information every 2 seconds (every 30 seconds after 1 hour CPU time), 2 ... show every step information, 3 ... show also solution vector, 4 ... show also mass matrix and jacobian (implicit methods), 5 ... show also Jacobian inverse (implicit methods)"
V,  verboseModeFile,                    ,       , UInt,                     0,          ,       P   , "same behaviour as verboseMode, but outputs all solver information to file"
V,  stepInformation,                    ,       , UInt,                     67,         ,       P   , "add up the following binary flags: 0 ... show only step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step or period, 4 ... show Newton jacobians (jac) per step or period, 8 ... show discontinuous iterations (Dit) per step or period, 16 ... show step size (dt), 32 ... show CPU time spent; 64 ... show adaptive step reduction warnings; 128 ... show step increase information; 1024 ... show every time step; time is usually shown in fractions of seconds (s), hours (h), or days"
#
writeFile=SimulationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = StaticSolverSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings
classDescription = "Settings for static solver linear or nonlinear (Newton)."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  newton,                         ,               , NewtonSettings,       ,  , PS     , "parameters for Newton method (e.g. in static solver or time integration)"
V,  discontinuous,                  ,               , DiscontinuousSettings,,  , PS     , "parameters for treatment of discontinuities"
#
V,  numberOfLoadSteps,              ,               , PInt,                 1,  ,P        , "number of load steps; if numberOfLoadSteps=1, no load steps are used and full forces are applied at once"
V,  loadStepDuration,               ,               , PReal,                1,  ,P        , "quasi-time for all load steps (added to current time in load steps)"
V,  loadStepStart,                  ,               , UReal,                0,  ,P        , "a quasi time, which can be used for the output (first column) as well as for time-dependent forces; quasi-time is increased in every step i by loadStepDuration/numberOfLoadSteps; loadStepTime = loadStepStart + i*loadStepDuration/numberOfLoadSteps, but loadStepStart untouched ==> increment by user"
V,  loadStepGeometric,              ,               , bool,                 false,,P    , "if loadStepGeometric=false, the load steps are incremental (arithmetic series, e.g. 0.1,0.2,0.3,...); if true, the load steps are increased in a geometric series, e.g. for $n=8$ numberOfLoadSteps and $d = 1000$ loadStepGeometricRange, it follows: $1000^{1/8}/1000=0.00237$, $1000^{2/8}/1000=0.00562$, $1000^{3/8}/1000=0.0133$, ..., $1000^{7/8}/1000=0.422$, $1000^{8/8}/1000=1$"
V,  loadStepGeometricRange,         ,               , PReal,                1000,,P     , "if loadStepGeometric=true, the load steps are increased in a geometric series, see loadStepGeometric"
V,  useLoadFactor,                  ,               , bool,                 true,,P     , "True: compute a load factor $\in [0,1]$ from static step time; all loads are scaled by the load factor; False: loads are always scaled with 1 -- use this option if time dependent loads use a userFunction"
V,  stabilizerODE2term,             ,               , UReal,                0,  ,P      , "add mass-proportional stabilizer term in \hac{ODE2} part of jacobian for stabilization (scaled ), e.g. of badly conditioned problems; the diagnoal terms are scaled with $stabilizer = (1-loadStepFactor^2)$, and go to zero at the end of all load steps: $loadStepFactor=1$ -> $stabilizer = 0$"
V,  adaptiveStep,                   ,               , bool,                 true,,P     , "True: use step reduction if step fails; False: fixed step size"
V,  adaptiveStepRecoverySteps,      ,               , UInt,                 4,   ,P     , "Number of steps needed after which steps will be increased after previous step reduction due to discontinuousIteration or Newton errors"
V,  adaptiveStepRecoveryIterations, ,               , UInt,                 7,   ,P     , "Number of max. (Newton iterations + discontinuous iterations) at which a step increase is considered; in order to immediately increase steps after reduction, chose a high value"
V,  adaptiveStepIncrease,           ,               , UReal,                 2,   ,P    , "Multiplicative factor (MUST BE > 1) for step size to increase after previous step reduction due to discontinuousIteration or Newton errors"
V,  adaptiveStepDecrease,           ,               , UReal,                 0.25,,P    , "Multiplicative factor (MUST BE: 0 < factor < 1) for step size to decrese due to discontinuousIteration or Newton errors"
V,  minimumStepSize,                ,               , PReal,                1e-8,,P     , "lower limit of step size, before nonlinear solver stops"
V,  computeLoadsJacobian,           ,               , bool,                 true,,P     , "True: compute (currently numerical) Jacobian for loads, causing additional computational costs; this is advantageous in cases where loads are related nonlinearly to coordinates; False: jacobian of loads not considered (may lead to slow convergence or Newton failure); note that computeLoadsJacobian has no effect in case of doSystemWideDifferentiation, as this anyway includes all load dependencies"
V,  constrainODE1coordinates,       ,               , bool,                 true,,P     , "True: ODE1coordinates are constrained to initial values; False: undefined behavior, currently not supported"
#
V,  verboseMode,                    ,               , UInt,                 1,   ,P     , "0 ... no output, 1 ... show errors and load steps, 2 ... show short Newton step information (error), 3 ... show also solution vector, 4 ... show also jacobian, 5 ... show also Jacobian inverse"
V,  verboseModeFile,                ,               , UInt,                 0,   ,P     , "same behaviour as verboseMode, but outputs all solver information to file"
V,  stepInformation,                ,               , UInt,                 67,  ,P     , "add up the following binary flags: 0 ... show only step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step or period, 4 ... show Newton jacobians (jac) per step or period, 8 ... show discontinuous iterations (Dit) per step or period, 16 ... show step size (dt), 32 ... show CPU time spent; 64 ... show adaptive step reduction warnings; 128 ... show step increase information; 1024 ... show every time step; time is usually shown in fractions of seconds (s), hours (h), or days"
#removed 2022-01-18: V,  preStepPyExecute,               ,               , String,               "",  ,P     , "DEPRECATED, use mbs.SetPreStepUserFunction(...); Python code to be executed prior to every load step and after last step, e.g. for postprocessing"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = LinearSolverSettings
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings
classDescription = "Settings for linear solver, both dense and sparse (Eigen)."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  pivotThreshold,                 ,               , UReal,                0,    ,P    , "[ONLY available for EXUdense and EigenDense (FullPivot) solver] threshold for dense linear solver, can be used to detect close to singular solutions, setting this to, e.g., 1e-12; solver then reports on equations that are causing close to singularity"
#V,  ignoreRedundantConstraints,     ,               , bool,                 false,,P    , "[ONLY implemented for dense matrices] False: standard way, fails if redundant equations or singular matrices occur; True: if redundant constraints appear, the solver tries to resolve them by setting according Lagrange multipliers to zero; in case of redundant constraints, this may help, but it may lead to erroneous behaviour"
V,  ignoreSingularJacobian,         ,               , bool,                 false,,P    , "[ONLY implemented for dense, Eigen matrix mode] False: standard way, fails if jacobian is singular; True: use Eigen's FullPivLU (thus only works with LinearSolverType.EigenDense) which handles over- and underdetermined systems; can often resolve redundant constraints, but MAY ALSO LEAD TO ERRONEOUS RESULTS!"
V,  reuseAnalyzedPattern,           ,               , bool,                 false,,P    , "[ONLY available for sparse matrices] True: the Eigen SparseLU solver offers the possibility to reuse an analyzed pattern of a previous factorization; this may reduce total factorization time by a factor of 2 or 3, depending on the matrix type; however, if the matrix patterns heavily change between computations, this may even slow down performance; this flag is set for SparseMatrices in InitializeSolverData(...) and should be handled with care!"
V,  showCausingItems,               ,               , bool,                 true,, P    , "False: no output, if solver fails; True: if redundant equations appear, they are resolved such that according solution variables are set to zero; in case of redundant constraints, this may help, but it may lead to erroneous behaviour; for static problems, this may suppress static motion or resolve problems in case of instabilities, but should in general be considered with care!"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = Parallel
appendToFile=True
writePybindIncludes = True
typicalPaths = simulationSettings
classDescription = "Settings for linear solver, both dense and sparse (Eigen)."
#V|F, pythonName,          cplusplusName,  size,   type,                    defaultValue,args,cFlags,   parameterDescription
V,  numberOfThreads,                ,                 , PInt,                 1,    ,P    , "number of threads used for parallel computation (1 == scalar processing); do not use more threads than available threads (in most cases it is good to restrict to the number of cores); currently, only one solver can be started with multithreading; if you use several mbs in parallel (co-simulation), you should use serial computing"
#V,  stopThreadsInSerialSections,    ,                 , bool,                 true, ,P    , "(not available yet) for large scale problems, if steps take longer than 5 ms, parallel threads are stopped in serial regions (etc. for solver) to improve overall performance"
#V,  useSIMDforSolver,               ,                 , bool,                 true, ,P    , "(not available yet) use AVX optimized vector, vector-matrix and matrix-matrix operations for solver and system operations (may already speedup for 16 coordinates)"
#V,  useMTforSolver,                 ,                 , bool,                 true, ,P    , "(not available yet) use multi-threaded optimized vector, vector-matrix and matrix-matrix operations for solver and system operations (only makes sense for medium to large systems!)"
V,  multithreadedLLimitLoads,       ,                 , PInt,                 20, ,P  , "compute loads multi-threaded; this is the limit number of loads from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)"
V,  multithreadedLLimitResiduals,   ,                 , PInt,                 20, ,P  , "compute RHS vectors, AE, and reaction forces multi-threaded; this is the limit number of objects from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)"
V,  multithreadedLLimitJacobians,   ,                 , PInt,                 20, ,P  , "compute jacobians (ODE2, AE, ...) multi-threaded; this is the limit number of according objects from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)"
V,  multithreadedLLimitMassMatrices,,                 , PInt,                 20, ,P  , "compute bodies mass matrices multi-threaded; this is the limit number of bodies from which on parallelization is used; flag is copied into MainSystem internal flag at InitializeSolverData(...)"
V,  taskSplitMinItems,              ,                 , PInt,                 50,  ,P  , "number of items from which on the tasks are split into subtasks (which slightly increases threading performance; this may be critical for smaller number of objects, should be roughly between 50 and 5000; flag is copied into MainSystem internal flag at InitializeSolverData(...)"
V,  taskSplitTasksPerThread,        ,                 , PInt,                 16,  ,P  , "this is the number of subtasks that every thread receives; minimum is 1, the maximum should not be larger than 100; this factor is 1 as long as the taskSplitMinItems is not reached; flag is copied into MainSystem internal flag at InitializeSolverData(...)"
#
writeFile=SimulationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = SimulationSettings
appendToFile=True
addDictionaryAccess = True
writePybindIncludes = True
typicalPaths = 
classDescription = "General Settings for simulation; according settings for solution and solvers are given in subitems of this structure"
#V|F, pythonName,                      cplusplusName,   size, type,                    defaultValue,args, cFlags, parameterDescription
V,  linearSolverSettings,            ,                  , LinearSolverSettings,          , , PS       , "linear solver parameters (used for dense and sparse solvers)"
V,  parallel,                        ,                  , Parallel,                      , , PS       , "parameters for vectorized and parallelized (multi-threaded) computations"
V,  solutionSettings,               ,                  , SolutionSettings,              , , PS   , "settings for solution files"
V,  staticSolver,                    ,                  , StaticSolverSettings,          , , PS       , "static solver parameters"
V,  timeIntegration,                ,                  , TimeIntegrationSettings,         , , PS        , "time integration parameters"
V,  linearSolverType,                ,                  , LinearSolverType,    "LinearSolverType::EXUdense", , P       , "selection of numerical linear solver: exu.LinearSolverType.EXUdense (dense matrix inverse), exu.LinearSolverType.EigenSparse (sparse matrix LU-factorization), ... (enumeration type)"
V,  cleanUpMemory,                  ,                 , bool,                false    , , P        , "True: solvers will free memory at exit (recommended for large systems); False: keep allocated memory for repeated computations to increase performance"
V,  displayComputationTime,         ,                 , bool,                false    , , P        , "display computation time statistics at end of solving"
V,  displayGlobalTimers,            ,                 , bool,                true     , , P        , "display global timer statistics at end of solving (e.g., for contact, but also for internal timings during development)"
V,  displayStatistics,              ,                 , bool,                false    , , P        , "display general computation information at end of time step (steps, iterations, function calls, step rejections, ..."
V,  outputPrecision,                ,                 , UInt,                6        , , P        , "precision for floating point numbers written to console; e.g. values written by solver"
V,  pauseAfterEachStep,             ,                  , bool,                  false  , , P        , "pause after every time step or static load step(user press SPACE)"
#moved to parallel 2022-01-18: V,  numberOfThreads,                ,                 , PInt,                1       , , P        , "number of threads used for parallel computation (1 == scalar processing); not yet implemented (status: Nov 2019)"
#
writeFile=SimulationSettings.h









#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#VISUALIZATION
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsGeneral
appendToFile=False
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsectionlabel{Visualization settings}{sec:VisualizationSettingsMain}\nThis section includes hierarchical structures for visualization settings, e.g., drawing of nodes, bodies, connectors, loads and markers and furthermore openGL, window and save image options. For further information, see \refSection{sec:overview:basics:visualizationsettings}.\n"
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "General settings for visualization."
#V|F,   pythonName,                     cplusplusName,     size, type,          defaultValue,args,      cFlags, parameterDescription
V,      graphicsUpdateInterval,         ,                  ,     float,        "0.1f",                 , P,      "interval of graphics update during simulation in seconds; 0.1 = 10 frames per second; low numbers might slow down computation speed"
V,      autoFitScene,                   ,                  ,     bool,         true,                   , P,      "automatically fit scene within startup after StartRenderer()"
V,      textSize,                       ,                  ,     float,        "12.f",                 , P,      "general text size (font size) in pixels if not overwritten; if useWindowsDisplayScaleFactor=True, the the textSize is multplied with the windows display scaling (monitor scaling; content scaling) factor for larger texts on on high resolution displays; for bitmap fonts, the maximum size of any font (standard/large/huge) is limited to 256 (which is not recommended, especially if you do not have a powerful graphics card)"
V,      textColor,                      ,                  4,    Float4,       "Float4({0.f,0.f,0.f,1.0f})", , P, "general text color (default); used for system texts in render window"
V,      textHasBackground,              ,                  ,     bool,         false,                  , P,      "if true, text for item numbers and other item-related text have a background (depending on text color), allowing for better visibility if many numbers are shown; the text itself is black; therefore, dark background colors are ignored and shown as white"
V,      textOffsetFactor,               ,                  ,     UFloat,       0.005f,                 , P,      "This is an additional out of plane offset for item texts (node number, etc.); the factor is relative to the maximum scene size and is only used, if textAlwaysInFront=False; this factor allows to draw text, e.g., in front of nodes"
V,      textAlwaysInFront,              ,                  ,     bool,         true,                   , P,      "if true, text for item numbers and other item-related text is drawn in front; this may be unwanted in case that you only with to see numbers of objects in front; currently does not work with perspective"
V,      rendererPrecision,              ,                  ,     PInt,         "4",                    , P,      "precision of general floating point numbers shown in render window: total number of digits used  (max. 16)"
V,      useWindowsDisplayScaleFactor,   ,                  ,     bool,         true,                   , P,      "the Windows display scaling (monitor scaling; content scaling) factor is used for increased visibility of texts on high resolution displays; based on GLFW glfwGetWindowContentScale; deactivated on linux compilation as it leads to crashes (adjust textSize manually!)"
V,      linuxDisplayScaleFactor,        ,                  ,     PFloat,       1.,                     , P,      "Scaling factor for linux, which cannot determined from system by now; adjust this value to scale dialog fonts and renderer fonts"
V,      useBitmapText,                  ,                  ,     bool,         true,                   , P,      "if true, texts are displayed using pre-defined bitmaps for the text; may increase the complexity of your scene, e.g., if many (>10000) node numbers shown"
V,      minSceneSize,                   ,                  ,     float,        "0.1f",                 , P,      "minimum scene size for initial scene size and for autoFitScene, to avoid division by zero; SET GREATER THAN ZERO"
V,      backgroundColor,                ,                  4,    Float4,       "Float4({1.0f,1.0f,1.0f,1.0f})", , P, "red, green, blue and alpha values for background color of render window (white=[1,1,1,1]; black = [0,0,0,1])"
V,      backgroundColorBottom,          ,                  4,    Float4,       "Float4({0.8f,0.8f,1.0f,1.0f})", , P, "red, green, blue and alpha values for bottom background color in case that useGradientBackground = True"
V,      useGradientBackground,          ,                  ,     bool,         false,                  , P,      "true = use vertical gradient for background; "
V,      coordinateSystemSize,           ,                  ,     float,        "5.f",                  , P,      "size of coordinate system relative to font size"
V,      drawCoordinateSystem,           ,                  ,     bool,         true,                   , P,      "false = no coordinate system shown"
V,      drawWorldBasis,                 ,                  ,     bool,         false,                  , P,      "true = draw world basis coordinate system at (0,0,0)"
V,      worldBasisSize,                 ,                  ,     float,        "1.0f",                 , P,      "size of world basis coordinate system"
V,      showHelpOnStartup,              ,                  ,     PInt,         5,                      , P,      "seconds to show help message on startup (0=deactivate)"
V,      showComputationInfo,            ,                  ,     bool,         true,                   , P,      "true = show (hide) all computation information including Exudyn and version"
V,      showSolutionInformation,        ,                  ,     bool,         true,                   , P,      "true = show solution information (from simulationSettings.solution)"
V,      showSolverInformation,          ,                  ,     bool,         true,                   , P,      "true = solver name and further information shown in render window"
V,      showSolverTime,                 ,                  ,     bool,         true,                   , P,      "true = solver current time shown in render window"
V,      renderWindowString,             ,                  ,     String,       "",                     , P,      "string shown in render window (use this, e.g., for debugging, etc.; written below EXUDYN, similar to solutionInformation in SimulationSettings.solutionSettings)"
V,      pointSize,                      ,                  ,     float,        "0.01f",                , P,      "global point size (absolute)"
V,      circleTiling,                   ,                  ,     PInt,         "16",                   , P,      "global number of segments for circles; if smaller than 2, 2 segments are used (flat)"
V,      cylinderTiling,                 ,                  ,     PInt,         "16",                   , P,      "global number of segments for cylinders; if smaller than 2, 2 segments are used (flat)"
V,      sphereTiling,                   ,                  ,     PInt,         "6",                    , P,      "global number of segments for spheres; if smaller than 2, 2 segments are used (flat)"
V,      axesTiling,                     ,                  ,     PInt,         "12",                   , P,      "global number of segments for drawing axes cylinders and cones (reduce this number, e.g. to 4, if many axes are drawn)"
V,      threadSafeGraphicsUpdate,       ,                  ,     bool,         true,                   , P,      "true = updating of visualization is threadsafe, but slower for complicated models; deactivate this to speed up computation, but activate for generation of animations; may be improved in future by adding a safe visualizationUpdate state"
V,      useMultiThreadedRendering,      ,                  ,     bool,         true,                   , P,      "true = rendering is done in separate thread; false = no separate thread, which may be more stable but has lagging interaction for large models (do not interact with models during simulation); set this parameter before call to exudyn.StartRenderer(); MAC OS: uses always false, because MAC OS does not support multi threaded GLFW"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsContour
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Settings for contour plots; use these options to visualize field data, such as displacements, stresses, strains, etc. for bodies, nodes and finite elements."
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
V,      outputVariableComponent,        ,                  1,    Int,          "0",                    , P,      "select the component of the chosen output variable; e.g., for displacements, 3 components are available: 0 == x, 1 == y, 2 == z component; for stresses, 6 components are available, see OutputVariableType description; to draw the norm of a outputVariable, set component to -1; if a certain component is not available by certain objects or nodes, no value is drawn (using default color)"
V,      outputVariable,                 ,                  ,     OutputVariableType,  "OutputVariableType::_None",  , P, "selected contour plot output variable type; select OutputVariableType._None to deactivate contour plotting."
V,      minValue,                       ,                  1,    float,        "0",                    , P,      "minimum value for contour plot; set manually, if automaticRange == False"
V,      maxValue,                       ,                  1,    float,        "1",                    , P,      "maximum value for contour plot; set manually, if automaticRange == False"
V,      automaticRange,                 ,                  ,     bool,         true,                   , P,      "if true, the contour plot value range is chosen automatically to the maximum range"
V,      reduceRange,                    ,                  ,     bool,         true,                   , P,      "if true, the contour plot value range is also reduced; better for static computation; in dynamic computation set this option to false, it can reduce visualization artifacts; you should also set minVal to max(float) and maxVal to min(float)"
V,      showColorBar,                   ,                  ,     bool,         true,                   , P,      "show the colour bar with minimum and maximum values for the contour plot"
V,      colorBarPrecision,              ,                  ,     PInt,         "4",                    , P,      "precision of floating point values shown in color bar; total number of digits used (max. 16)"
V,      colorBarTiling,                 ,                  1,    PInt,         "12",                   , P,      "number of tiles (segements) shown in the colorbar for the contour plot"
V,      rigidBodiesColored,             ,                  ,     bool,         true,                   , P,      "if true, the contour color is also applied to triangular faces of rigid bodies and mass points, otherwise the rigid body drawing are not influenced by contour settings; for general rigid bodies (except for ObjectGround), Position, Displacement, DisplacementLocal(=0), Velocity, VelocityLocal, AngularVelocity, and AngularVelocityLocal are available; may slow down visualization!"
V,      nodesColored,                   ,                  ,     bool,         true,                   , P,      "if true, the contour color is also applied to nodes (except mesh nodes), otherwise node drawing is not influenced by contour settings"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsNodes
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for nodes."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      show,                       ,                  ,     bool,         true,                     , P,      "flag to decide, whether the nodes are shown"
V,      showNumbers,                ,                  ,     bool,         false,                    , P,      "flag to decide, whether the node number is shown"
V,      drawNodesAsPoint,           ,                  ,     bool,         true,                     , P,      "simplified/faster drawing of nodes; uses general->pointSize as drawing size; if drawNodesAsPoint==True, the basis of the node will be drawn with lines"
V,      showBasis,                  ,                  ,     bool,         false,                    , P,      "show basis (three axes) of coordinate system in 3D nodes"
V,      basisSize,                  ,                  ,     float,        "0.2f",                   , P,      "size of basis for nodes"
V,      tiling,                     ,                  ,     PInt,         "4",                      , P,      "tiling for node if drawn as sphere; used to lower the amount of triangles to draw each node; if drawn as circle, this value is multiplied with 4"
V,      defaultSize,                ,                  ,     float,        "-1.f",                   , P,      "global node size; if -1.f, node size is relative to openGL.initialMaxSceneSize"
V,      defaultColor,               ,                  4,    Float4,       "Float4({0.2f,0.2f,1.f,1.f})",, P,  "default RGBA color for nodes; 4th value is alpha-transparency"
V,      showNodalSlopes,            ,                  ,     UInt,         false,                    , P,      "draw nodal slope vectors, e.g. in ANCF beam finite elements"
#
writeFile=VisualizationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsBeams
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings.bodies
classDescription = "Visualization settings for beam finite elements."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      axialTiling,                ,                  ,     PInt,          "8",                      , P,       "number of segments to discretise the beams axis"
V,      reducedAxialInterploation,  ,                  ,     bool,          true,                     , P,       "if True, the interpolation along the beam axis may be lower than the beam element order; this may be, however, show more consistent values than a full interpolation, e.g. for strains or forces"
V,      crossSectionTiling,         ,                  ,     PInt,          "4",                      , P,       "number of quads drawn over height of beam, if drawn as flat objects; leads to higher accuracy of components drawn over beam height or with, but also to larger CPU costs for drawing"
V,      crossSectionFilled,         ,                  ,     bool,          true,                     , P,       "if implemented for element, cross section is drawn as solid (filled) instead of wire-frame; NOTE: some quantities may not be interpolated correctly over cross section in visualization"
V,      drawVertical,               ,                  ,     bool,          false,                    , P,       "draw contour plot outputVariables 'vertical' along beam height; contour.outputVariable must be set accordingly"
V,      drawVerticalFactor,         ,                  ,     float,         "1.f",                    , P,       "factor for outputVariable to be drawn along cross section (vertically)"
V,      drawVerticalColor,          ,                  4,    Float4,        "Float4({0.2f,0.2f,0.2f,1.f})", , P, "color for outputVariable to be drawn along cross section (vertically)"
V,      drawVerticalLines,          ,                  ,     bool,          true,                     , P,       "draw additional vertical lines for better visibility"
V,      drawVerticalValues,         ,                  ,     bool,          false,                    , P,       "show values at vertical lines; note that these numbers are interpolated values and may be different from values evaluated directly at this point!"
V,      drawVerticalOffset,         ,                  ,     float,         "0.f",                    , P,       "offset for vertical drawn lines; offset is added before multiplication with drawVerticalFactor"
#
writeFile=VisualizationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsKinematicTree
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings.bodies
classDescription = "Visualization settings for kinematic trees."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      showCOMframes,              ,                  ,     bool,          false,                    , P,       "if True, a frame is attached to every center of mass"
V,      showJointFrames,            ,                  ,     bool,          true,                     , P,       "if True, a frame is attached to the origin of every joint frame"
V,      showFramesNumbers,          ,                  ,     bool,          false,                    , P,       "if True, numbers are drawn for joint frames (O[i]J[j]) and COM frames (O[i]COM[j]) for object [i] and local joint [j]"
V,      frameSize,                  ,                  ,     float,         "0.2f",                   , P,       "size of COM and joint frames"
#
writeFile=VisualizationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsBodies
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for bodies."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      show,                       ,                  ,     bool,         true,                       , P,    "flag to decide, whether the bodies are shown"
V,      showNumbers,                ,                  ,     bool,         false,                      , P,    "flag to decide, whether the body(=object) number is shown"
V,      defaultSize,                ,                  3,    Float3,       "Float3({1.f,1.f,1.f})",    , P,    "global body size of xyz-cube"
V,      defaultColor,               ,                  4,    Float4,       "Float4({0.3f,0.3f,1.f,1.f})",, P,  "default RGBA color for bodies; 4th value is "
V,      deformationScaleFactor,     ,                  ,     float,        "1",                        , P,    "global deformation scale factor; also applies to nodes, if drawn; currently only used for scaled drawing of (linear) finite elements in FFRF and FFRFreducedOrder objects"
V,      beams,                      ,                  ,     VSettingsBeams,   ,                       , PS,   "visualization settings for beams (e.g. ANCFCable or other beam elements)"
V,      kinematicTree,              ,                  ,     VSettingsKinematicTree,   ,               , PS,   "visualization settings for kinematic tree"
#
writeFile=VisualizationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsConnectors
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for connectors."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      show,                       ,                  ,     bool,         true,                       , P,    "flag to decide, whether the connectors are shown"
V,      showNumbers,                ,                  ,     bool,         false,                      , P,    "flag to decide, whether the connector(=object) number is shown"
V,      defaultSize,                ,                  ,     float,        "0.1f",                     , P,    "global connector size; if -1.f, connector size is relative to maxSceneSize"
#
V,      showJointAxes,              ,                  ,     bool,         false,                      , P,    "flag to decide, whether contact joint axes of 3D joints are shown"
V,      jointAxesLength,            ,                  ,     float,        "0.2f",                     , P,    "global joint axes length"
V,      jointAxesRadius,            ,                  ,     float,        "0.02f",                    , P,    "global joint axes radius"
V,      showContact,                ,                  ,     bool,         false,                      , P,    "flag to decide, whether contact points, lines, etc. are shown"
V,      springNumberOfWindings,     ,                  ,     PInt,         8,                          , P,    "number of windings for springs drawn as helical spring"
V,      contactPointsDefaultSize,   ,                  ,     float,        "0.02f",                      , P,    "DEPRECATED: do not use! global contact points size; if -1.f, connector size is relative to maxSceneSize"
V,      defaultColor,               ,                  4,    Float4,       "Float4({0.2f,0.2f,1.f,1.f})",, P,    "default RGBA color for connectors; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsMarkers
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for markers."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      show,                       ,                  ,     bool,         true,                       , P,    "flag to decide, whether the markers are shown"
V,      showNumbers,                ,                  ,     bool,         false,                      , P,    "flag to decide, whether the marker numbers are shown"
V,      drawSimplified,             ,                  ,     bool,         true,                       , P,    "draw markers with simplified symbols"
V,      defaultSize,                ,                  ,     float,        "-1.f",                     , P,    "global marker size; if -1.f, marker size is relative to maxSceneSize"
V,      defaultColor,               ,                  4,    Float4,       "Float4({0.1f,0.5f,0.1f,1.f})",, P,    "default RGBA color for markers; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsLoads
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for loads."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      show,                       ,                  ,     bool,         true,                       , P,    "flag to decide, whether the loads are shown"
V,      showNumbers,                ,                  ,     bool,         false,                      , P,    "flag to decide, whether the load numbers are shown"
V,      defaultSize,                ,                  ,     float,        "0.2f",                     , P,    "global load size; if -1.f, load size is relative to maxSceneSize"
V,      defaultRadius,              ,                  ,     float,        "0.005f",                   , P,    "global radius of load axis if drawn in 3D"
V,      fixedLoadSize,              ,                  ,     bool,         true,                       , P,    "if true, the load is drawn with a fixed vector length in direction of the load vector, independently of the load size"
V,      drawSimplified,             ,                  ,     bool,         true,                       , P,    "draw markers with simplified symbols"
V,      loadSizeFactor,             ,                  ,     float,        "0.1f",                     , P,    "if fixedLoadSize=false, then this scaling factor is used to draw the load vector"
V,      defaultColor,               ,                  4,    Float4,       "Float4({0.7f,0.1f,0.1f,1.f})",, P,    "default RGBA color for loads; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsSensorTraces
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for traces of sensors. Note that a large number of time points (influenced by simulationSettings.solutionSettings.sensorsWritePeriod) may lead to slow graphics."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      listOfPositionSensors,      ,                  -1,   ArrayIndex,   "ArrayIndex()",             , P,    "list of position sensors which can be shown as trace inside render window if sensors have storeInternal=True; if this list is empty and showPositionTrace=True, then all available sensors are shown"
V,      listOfVectorSensors,        ,                  -1,   ArrayIndex,   "ArrayIndex()",             , P,    "list of sensors with 3D vector quantities; this non-empty list needs to coincide in length with the listOfPositionSensors to be shown if showVectors=True; the vector quantity is drawn relative to the related position"
V,      listOfTriadSensors,         ,                  -1,   ArrayIndex,   "ArrayIndex()",             , P,    "list of sensors of with OutputVariableType RotationMatrix; this non-empty list needs to coincide in length with the listOfPositionSensors to be shown if showTriads=True; the triad is drawn at the related position"
V,      showPositionTrace,          ,                  ,     bool,         false,                      , P,    "show position trace of all position sensors if listOfPositionSensors=[] or of specified sensors; sensors need to activate storeInternal=True"
V,      showVectors,                ,                  ,     bool,         false,                      , P,    "if True, show vector quantities according to description in showPositionTrace"
V,      showTriads,                 ,                  ,     bool,         false,                      , P,    "if True, show basis vectors from rotation matrices provided by sensors"
V,      sensorsMbsNumber,           ,                  ,     Index,        "0",                        , P,    "number of main system which is used to for sensor lists; if only 1 mbs is in the SystemContainer, use 0; if there are several mbs, it needs to specify the number"
V,      showPast,                   ,                  ,     bool,         true,                       , P,    "show trace previous to current visualization state"
V,      showCurrent,                ,                  ,     bool,         true,                       , P,    "show current trace position (and especially vector quantity) related to current visualization state; this only works in solution viewer if sensor values are stored at time grid points of the solution file (up to a precision of 1e-10) and may therefore be temporarily unavailable"
V,      showFuture,                 ,                  ,     bool,         false,                      , P,    "show trace future to current visualization state if already computed (e.g. in SolutionViewer)"
V,      positionsShowEvery,         ,                  ,     PInt,         1,                          , P,    "integer value i; out of available sensor data, show every i-th position"
V,      vectorsShowEvery,           ,                  ,     PInt,         1,                          , P,    "integer value i; out of available sensor data, show every i-th vector"
V,      triadsShowEvery,            ,                  ,     PInt,         1,                          , P,    "integer value i; out of available sensor data, show every i-th triad"
V,      vectorScaling,              ,                  ,     float,        "0.01f",                    , P,    "scaling of vector quantities; if, e.g., loads, this factor has to be adjusted significantly"
V,      triadSize,                  ,                  ,     float,        "0.1f ",                    , P,    "length of triad axes if shown"
V,      lineWidth,                  ,                  ,     UFloat,       "2.f",                      , P,    "line width for traces"
V,      traceColors,                ,                  -1,   ArrayFloat,   "ArrayFloat({0.2f,0.2f,0.2f,1.f, 0.8f,0.2f,0.2f,1.f, 0.2f,0.8f,0.2f,1.f, 0.2f,0.2f,0.8f,1.f, 0.2f,0.8f,0.8f,1.f, 0.8f,0.2f,0.8f,1.f, 0.8f,0.4f,0.1f,1.f})",             , P,    "RGBA float values for traces in one array; using 6x4 values gives different colors for 6 traces; in case of triads, the 0/1/2-axes are drawn in red, green, and blue"
#

writeFile=VisualizationSettings.h

# settings and list of sensors provided in visualizationSettings.sensors.traces with 
# list of sensors, showPositionTrace, listOfPositionSensors=[] 
# (empty means all position sensors, listOfVectorSensors=[] which can provide according vector quantities for positions; 
# showVectors, vectorScaling=0.001, showPast=True, showFuture=False, showCurrent=True, lineWidth=2


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsSensors
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Visualization settings for sensors."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
V,      show,                       ,                  ,     bool,         true,                       , P,    "flag to decide, whether the sensors are shown"
V,      showNumbers,                ,                  ,     bool,         false,                      , P,    "flag to decide, whether the sensor numbers are shown"
V,      drawSimplified,             ,                  ,     bool,         true,                       , P,    "draw sensors with simplified symbols"
V,      defaultSize,                ,                  ,     float,        "-1.f",                     , P,    "global sensor size; if -1.f, sensor size is relative to maxSceneSize"
V,      defaultColor,               ,                  4,    Float4,       "Float4({0.6f,0.6f,0.1f,1.f})",, P, "default RGBA color for sensors; 4th value is alpha-transparency"
V,      traces,                     ,                  ,     VSettingsSensorTraces,  ,                 , PS,   "settings for showing (position) sensor traces and vector plots in the render window"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsContact
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Global visualization settings for GeneralContact. This allows to easily switch on/off during visualization"
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,args,           cFlags, parameterDescription
#      showContactObjects,         ,                  ,     bool,         true,                       , P,    "show or hide contact objects in all GeneralContacts"
V,      showSearchTree,             ,                  ,     bool,         false,                      , P,    "show outer box of search tree for all GeneralContacts"
V,      showSearchTreeCells,        ,                  ,     bool,         false,                      , P,    "show all cells of search tree; empty cells have colorSearchTree, cells with contact objects have higher red value; Warning: avoid for large number of search tree cells!"
V,      showBoundingBoxes,          ,                  ,     bool,         false,                      , P,    "show computed bounding boxes of all GeneralContacts; Warning: avoid for large number of contact objects!"
V,      showTriangles,              ,                  ,     bool,         false,                      , P,    "show contact triangles (TrianglesRigidBodyBased, ...)"
V,      showSpheres,                ,                  ,     bool,         false,                      , P,    "show contact spheres (SpheresWithMarker, ...)"
V,      tilingSpheres,              ,                  ,     PInt,         4,                          , P,    "tiling for spheres; higher values give smoother spheres, but may lead to lower frame rates"
#
V,      colorSearchTree,            ,                  4,    Float4,       "Float4({0.1f,0.1f,0.9f,1.f})",, P, "RGBA color for search tree, see showSearchTree"
V,      colorBoundingBoxes,         ,                  4,    Float4,       "Float4({0.9f,0.1f,0.1f,1.f})",, P, "RGBA color for boudnding boxes, see showBoundingBoxes"
V,      colorTriangles,             ,                  4,    Float4,       "Float4({0.5f,0.5f,0.5f,1.f})",, P, "RGBA color for contact triangles, see showTriangles"
V,      colorSpheres,               ,                  4,    Float4,       "Float4({0.8f,0.8f,0.2f,1.f})",, P, "RGBA color for contact spheres, see showSpheres"
#
#for connectors:
V,      contactPointsDefaultSize,   ,                  ,     float,        "0.001f",                   , P,    "global contact points size; if -1.f, connector size is relative to maxSceneSize; used for some contacts, e.g., in ContactFrictionCircle"
V,      showContactForces,          ,                  ,     bool,         false,                      , P,    "if True, contact forces are drawn for certain contact models"
V,      showContactForcesValues,    ,                  ,     bool,         false,                      , P,    "if True and showContactForces=True, numerical values for  contact forces are shown at certain points"
V,      contactForcesFactor,        ,                  ,     float,        "0.001f",                   , P,    "factor used for scaling of contact forces is showContactForces=True"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsWindow
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "OpenGL Window and interaction settings for visualization; handle changes with care, as they might lead to unexpected results or crashes."
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
V,      renderWindowSize,               ,                  2,    Index2,       "Index2({1024,768})",   , P,      "initial size of OpenGL render window in pixel"
V,      showWindow,                     ,                  ,     bool,         true,                   , P,      "True: OpenGL render window is shown on startup; False: window will be iconified at startup (e.g. if you are starting multiple computations automatically)"
V,      startupTimeout,                 ,                  ,     PInt,         "2500",                 , P,      "OpenGL render window startup timeout in ms (change might be necessary if CPU is very slow)"
V,      alwaysOnTop,                    ,                  ,     bool,         false,                  , P,      "True: OpenGL render window will be always on top of all other windows"
V,      maximize,                       ,                  ,     bool,         false,                  , P,      "True: OpenGL render window will be maximized at startup"
V,      limitWindowToScreenSize,        ,                  ,     bool,         true,                   , P,      "True: render window size is limited to screen size; False: larger window sizes (e.g. for rendering) allowed according to renderWindowSize"
V,      reallyQuitTimeLimit,            ,                  ,     UReal,        "900",                  , P,      "number of seconds after which user is asked a security question before stopping simulation and closing renderer; set to 0 in order to always get asked; set to 1e10 to (nearly) never get asked"
#special settings:
V,      keyPressUserFunction,           ,                  ,     KeyPressUserFunction,  0,             , P,      "add a Python function f(key, action, mods) here, which is called every time a key is pressed; function shall return true, if key has been processed; Example: \tabnewline def f(key, action, mods):\tabnewline \phantom{XXX} print('key=',key);\tabnewline use chr(key) to convert key codes [32 ...96] to ascii; special key codes (>256) are provided in the exudyn.KeyCode enumeration type; key action needs to be checked (0=released, 1=pressed, 2=repeated); mods provide information (binary) for SHIFT (1), CTRL (2), ALT (4), Super keys (8), CAPSLOCK (16)"
V,      showMouseCoordinates,           ,                  ,     bool,         "false",                , P,      "True: show OpenGL coordinates and distance to last left mouse button pressed position; switched on/off with key 'F3'"
V,      ignoreKeys,                     ,                  ,     bool,         "false",                , P,      "True: ignore keyboard input except escape and 'F2' keys; used for interactive mode, e.g., to perform kinematic analysis; This flag can be switched with key 'F2'"
F,      ResetKeyPressUserFunction,      ,                  ,     void,         "keyPressUserFunction = 0;", , P,      "set keyPressUserFunction to zero (no function); because this cannot be assign to the variable itself"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsDialogs
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Settings related to dialogs (e.g., visualization settings dialog)."
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
V,      multiThreadedDialogs,           ,                  ,     bool,         true,                   , P,      "True: During dialogs, the OpenGL render window will still get updates of changes in dialogs, etc., which may cause problems on some platforms or for some (complicated) models; False: changes of dialogs will take effect when dialogs are closed"
V,      alwaysTopmost,                  ,                  ,     bool,         true,                   , P,      "True: dialogs are always topmost (otherwise, they are sometimes hidden)"
V,      alphaTransparency,              ,                  ,     UFloat,       "0.94f",                , P,      "alpha-transparency of dialogs; recommended range 0.7 (very transparent) - 1 (not transparent at all)"
V,      fontScalingMacOS,               ,                  ,     UFloat,       "1.35f",                , P,      "font scaling value for MacOS systems (on Windows, system display scaling is used)"
V,      openTreeView,                   ,                  ,     bool,         false,                  , P,      "True: all sub-trees of the visusalization dialog are opened when opening the dialog; False: only some sub-trees are opened"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsOpenGL
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "OpenGL settings for 2D and 2D rendering. For further details, see the OpenGL functionality"
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
V,      initialCenterPoint,             ,                  3,    Float3,       "Float3({0.f,0.f,0.f})",, P,      "centerpoint of scene (3D) at renderer startup; overwritten if autoFitScene = True"
V,      initialZoom,                    ,                  ,     UFloat,       "1.f",                  , P,      "initial zoom of scene; overwritten/ignored if autoFitScene = True"
V,      initialMaxSceneSize,            ,                  ,     PFloat,       "1.f",                  , P,      "initial maximum scene size (auto: diagonal of cube with maximum scene coordinates); used for 'zoom all' functionality and for visibility of objects; overwritten if autoFitScene = True"
V,      initialModelRotation,           ,                  3x3,    StdArray33F,    "EXUmath::Matrix3DFToStdArray33(Matrix3DF(3,3,{1.f,0.f,0.f, 0.f,1.f,0.f, 0.f,0.f,1.f}))",      , P,      "initial model rotation matrix for OpenGl; in python use e.g.: initialModelRotation=[[1,0,0],[0,1,0],[0,0,1]]"
#
V,      perspective,                    ,                  ,     UFloat,       "0.f",                  , P,      "parameter prescribes amount of perspective (0=no perspective=orthographic projection; positive values increase perspective; feasible values are 0.001 (little perspective) ... 0.5 (large amount of perspective); mouse coordinates will not work with perspective"
V,      shadow,                         ,                  ,     UFloat,       "0.f",                  , P,      "parameter $\in [0 ... 1]$ prescribes amount of shadow for light0 (using light0position, etc.); if this parameter is different from 1, rendering of triangles becomes approx.\ 5 times more expensive, so take care in case of complex scenes; for complex object, such as spheres with fine resolution or for particle systems, the present approach has limitations and leads to artifacts and unrealistic shadows"
V,      shadowPolygonOffset,            ,                  ,     PFloat,       "0.1f",                 , P,      "some special drawing parameter for shadows which should be handled with care; defines some offset needed by openGL to avoid aritfacts for shadows and depends on maxSceneSize; this value may need to be reduced for larger models in order to achieve more accurate shadows, it may be needed to be increased for thin bodies"
V,      polygonOffset,                  ,                  ,     float,        "0.01f",                , P,      "general polygon offset for polygons, except for shadows; use this parameter to draw polygons behind lines to reduce artifacts for very large or small models"
# 
V,      multiSampling,                  ,                  1,    PInt,         "1",                    , P,      "NOTE: this parameter must be set before starting renderer; later changes are not affecting visualization; multi sampling turned off (<=1) or turned on to given values (2, 4, 8 or 16); increases the graphics buffers and might crash due to graphics card memory limitations; only works if supported by hardware; if it does not work, try to change 3D graphics hardware settings!"
V,      lineWidth,                      ,                  1,    UFloat,       "1.f",                  , P,      "width of lines used for representation of lines, circles, points, etc."
V,      lineSmooth,                     ,                  1,    bool,         true,                   , P,      "draw lines smooth"
V,      textLineWidth,                  ,                  1,    UFloat,       "1.f",                  , P,      "width of lines used for representation of text"
V,      textLineSmooth,                 ,                  1,    bool,         false,                  , P,      "draw lines for representation of text smooth"
V,      facesTransparent,               ,                  1,    bool,         false,                  , P,      "True: show faces transparent independent of transparency (A)-value in color of objects; allow to show otherwise hidden node/marker/object numbers"
V,      showFaces,                      ,                  1,    bool,         true,                   , P,      "show faces of triangles, etc.; using the options showFaces=false and showFaceEdges=true gives are wire frame representation"
V,      showFaceEdges,                  ,                  1,    bool,         false,                  , P,      "show edges of faces; using the options showFaces=false and showFaceEdges=true gives are wire frame representation"
V,      showLines,                      ,                  1,    bool,         true,                   , P,      "show lines (different from edges of faces)"
V,      showMeshFaces,                  ,                  1,    bool,         true,                   , P,      "show faces of finite elements; independent of showFaces"
V,      showMeshEdges,                  ,                  1,    bool,         true,                   , P,      "show edges of finite elements; independent of showFaceEdges"
V,      faceEdgesColor,                 ,                  4,    Float4,       "Float4({0.2f,0.2f,0.2f,1.f})",,P,"global RGBA color for face edges"
#
V,      shadeModelSmooth,               ,                  1,    bool,         true,                   , P,      "True: turn on smoothing for shaders, which uses vertex normals to smooth surfaces"
V,      materialAmbientAndDiffuse,      ,                  4,    Float4,       "Float4({0.6f,0.6f,0.6f,1.f})",, P,"4f ambient color of material"
V,      materialShininess,              ,                  1,    float,        "32.f",                 , P,      "shininess of material"
V,      materialSpecular,               ,                  4,    Float4,       "Float4({0.6f,0.6f,0.6f,1.f})",, P,  "4f specular color of material"
#lights:
V,      enableLighting,                 ,                  1,    bool,         true,                   , P,      "generally enable lighting (otherwise, colors of objects are used); OpenGL: glEnable(GL_LIGHTING)"
V,      lightModelLocalViewer,          ,                  1,    bool,         false,                  , P,      "select local viewer for light; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,...)"
V,      lightModelTwoSide,              ,                  1,    bool,         false,                  , P,      "enlighten also backside of object; may cause problems on some graphics cards and lead to slower performance; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,...)"
V,      lightModelAmbient,              ,                  4,    Float4,       "Float4({0.f,0.f,0.f,1.f})",,P,"global ambient light; maps to OpenGL glLightModeli(GL_LIGHT_MODEL_AMBIENT,[r,g,b,a])"
#
V,      enableLight0,                   ,                  1,    bool,         true,                   , P,      "turn on/off light0"
V,      light0position,                 ,                  4,    Float4,       "Float4({0.2f,0.2f,10.f,0.f})",, P,"4f position vector of GL_LIGHT0; 4th value should be 0 for lights like sun, but 1 for directional lights (and for attenuation factor being calculated); light0 is also used for shadows, so you need to adjust this position; see opengl manuals"
V,      light0ambient,                  ,                  1,    float,        "0.3f",                , P,      "ambient value of GL_LIGHT0"
V,      light0diffuse,                  ,                  1,    float,        "0.6f",                 , P,      "diffuse value of GL_LIGHT0"
V,      light0specular,                 ,                  1,    float,        "0.5f",                 , P,      "specular value of GL_LIGHT0"
V,      light0constantAttenuation,      ,                  1,    float,        "1.0f",                 , P,      "constant attenuation coefficient of GL_LIGHT0, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); (kc,kl,kq)=(1,0,0) means no attenuation; only used for lights, where last component of light position is 1"
V,      light0linearAttenuation,        ,                  1,    float,        "0.0f",                 , P,      "linear attenuation coefficient of GL_LIGHT0, this is a linear factor for attenuation of the light source with distance"
V,      light0quadraticAttenuation,     ,                  1,    float,        "0.0f",                 , P,      "quadratic attenuation coefficient of GL_LIGHT0, this is a quadratic factor for attenuation of the light source with distance"
#
V,      enableLight1,                   ,                  1,    bool,         true,                   , P,      "turn on/off light1"
V,      light1position,                 ,                  4,    Float4,       "Float4({1.f,1.f,-10.f,0.f})",, P, "4f position vector of GL_LIGHT0; 4th value should be 0 for lights like sun, but 1 for directional lights (and for attenuation factor being calculated); see opengl manuals"
V,      light1ambient,                  ,                  1,    float,        "0.0f ",                , P,      "ambient value of GL_LIGHT1"
V,      light1diffuse,                  ,                  1,    float,        "0.5f",                 , P,      "diffuse value of GL_LIGHT1"
V,      light1specular,                 ,                  1,    float,        "0.6f",                 , P,      "specular value of GL_LIGHT1"
V,      light1constantAttenuation,      ,                  1,    float,        "1.0f",                 , P,      "constant attenuation coefficient of GL_LIGHT1, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); only used for lights, where last component of light position is 1"
V,      light1linearAttenuation,        ,                  1,    float,        "0.0f",                 , P,      "linear attenuation coefficient of GL_LIGHT1, this is a linear factor for attenuation of the light source with distance"
V,      light1quadraticAttenuation,     ,                  1,    float,        "0.0f",                 , P,      "quadratic attenuation coefficient of GL_LIGHT1, this is a quadratic factor for attenuation of the light source with distance"

# debug:
V,      drawFaceNormals,                ,                  1,    bool,         false,                  , P,      "draws triangle normals, e.g. at center of triangles; used for debugging of faces"
V,      drawVertexNormals,              ,                  1,    bool,         false,                  , P,      "draws vertex normals; used for debugging"
V,      drawNormalsLength,              ,                  1,    PFloat,       "0.1f",                 , P,      "length of normals; used for debugging"
#
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = VSettingsExportImages
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Functionality to export images to files (PNG or TGA format) which can be used to create animations; to activate image recording during the solution process, set SolutionSettings.recordImagesInterval accordingly."
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
V,      saveImageTimeOut,               ,                  ,     PInt,         "5000",                 , P,      "timeout in milliseconds for saving a frame as image to disk; this is the amount of time waited for redrawing; increase for very complex scenes"
V,      saveImageFileName,              ,                  ,     FileName,     "images/frame",         , P,      "filename (without extension!) and (relative) path for image file(s) with consecutive numbering (e.g., frame0000.png, frame0001.png,...); ; directory will be created if it does not exist"
V,      saveImageFileCounter,           ,                  ,     UInt,         0,                      , P,      "current value of the counter which is used to consecutively save frames (images) with consecutive numbers"
V,      saveImageSingleFile,            ,                  ,     bool,         false,                  , P,      "True: only save single files with given filename, not adding numbering; False: add numbering to files, see saveImageFileName"
V,      saveImageFormat,                ,                  ,     String,       "PNG",                  , P,      "format for exporting figures: currently only PNG, TGA and TXT available; while PNG and TGA represent the according image file formats, the TXT format results in a text file containing the 3D graphics data information as lists of lines, triangles, etc; PNG is not available for Ubuntu18.04 (check  use TGA has highest compatibility with all platforms"
V,      saveImageAsTextCircles,         ,                  ,     bool,         true,                   , P,      "export circles in save image (only in TXT format)"
V,      saveImageAsTextLines,           ,                  ,     bool,         true,                   , P,      "export lines in save image (only in TXT format)"
V,      saveImageAsTextTriangles,       ,                  ,     bool,         false,                  , P,      "export triangles in save image (only in TXT format)"
V,      saveImageAsTextTexts,           ,                  ,     bool,         false,                  , P,      "export text in save image (only in TXT format)"
V,      widthAlignment,                 ,                  ,     PInt,         4,                      , P,      "alignment of exported image width; using a value of 4 helps to reduce problems with video conversion (additional vertical lines are lost)"
V,      heightAlignment,                ,                  ,     PInt,         2,                      , P,      "alignment of exported image height; using a value of 2 helps to reduce problems with video conversion (additional horizontal lines are lost)"
#
writeFile=VisualizationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#settings for openVR
class = VSettingsOpenVR
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings.interactive
classDescription = "Functionality to interact openVR; requires special hardware or software emulator, see steam / openVR descriptions"
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
#have been in VSettingsWindows earlier:
V,      enable,                         ,                  ,     bool,         false,                 , P,      "True: openVR enabled (if compiled with according flag and installed openVR)"
V,      showCompanionWindow,            ,                  ,     bool,         true,                  , P,      "True: openVR will show companion window containing left and right eye view"
V,      logLevel,                       ,                  ,     Int,          1,                     , P,      "integer value setting log level of openVR: -1 (no output), 0 (error), 1 (warning), 2 (info), 3 (debug); increase log level to get more output"
V,      actionManifestFileName,         ,                  ,     FileName,     "C:/openVRactionsManifest.json", , P,  "This string must contain a string representing a valid absolute path to a vr_actions.json manifest, which describes all HMD, tracker, etc. devices as given by openVR"
writeFile=VisualizationSettings.h

#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#settings that are used for interaction with renderer: 
class = VSettingsInteractive
appendToFile=True
writePybindIncludes = True
typicalPaths = SC.visualizationSettings
classDescription = "Functionality to interact with render window; will include left and right mouse press actions and others in future."
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
#have been in VSettingsWindows earlier:
V,      openVR,                         ,                  ,     VSettingsOpenVR,    ,                 , PS,     "openVR visualization settings"
V,      keypressRotationStep,           ,                  ,     float,        "5.f",                  , P,      "rotation increment per keypress in degree (full rotation = 360 degree)"
V,      mouseMoveRotationFactor,        ,                  ,     float,        "1.f",                  , P,      "rotation increment per 1 pixel mouse movement in degree"
V,      keypressTranslationStep,        ,                  ,     float,        "0.1f",                 , P,      "translation increment per keypress relative to window size"
V,      zoomStepFactor,                 ,                  ,     float,        "1.15f",                , P,      "change of zoom per keypress (keypad +/-) or mouse wheel increment"
V,      lockModelView,                  ,                  ,     bool,         false,                  , P,      "True: all movements (with mouse/keys), rotations, zoom are disabled; initial values are considered ==> initial zoom, rotation and center point need to be adjusted, approx. 0.4*maxSceneSize is a good value"
V,      pauseWithSpacebar,              ,                  ,     bool,         true,                   , P,      "True: during simulation, space bar can be pressed to pause simulation"
#
V,      highlightItemIndex,             ,                  ,     Int,          "-1",                   , P,      "index of item that shall be highlighted (e.g., need to find item due to errors); if set -1, no item is highlighted"
V,      highlightItemType,              ,                  ,     ItemType,     "ItemType::_None",      , P,      "item type (Node, Object, ...) that shall be highlighted (e.g., need to find item due to errors)"
V,      highlightMbsNumber,             ,                  ,     UInt,         "0",                    , P,      "index of main system (mbs) for which the item shall be highlighted; number is related to the ID in SystemContainer (first mbs = 0, second = 1, ...)"
V,      highlightColor,                 ,                  4,    Float4,       "Float4({0.8f,0.05f,0.05f,0.75f})",, P, "RGBA color for highlighted item; 4th value is alpha-transparency"
V,      highlightOtherColor,            ,                  4,    Float4,       "Float4({0.5f,0.5f,0.5f,0.4f})", , P, "RGBA color for other items (which are not highlighted); 4th value is alpha-transparency"
#marker tracking
V,      trackMarker,                    ,                  ,     Int,          "-1",                  , P,      "if valid marker index is provided and marker provides position (and orientation), the centerpoint of the scene follows the marker (and orientation); depends on trackMarkerPosition and trackMarkerOrientation; by default, only position is tracked"
V,      trackMarkerMbsNumber,           ,                  ,     Index,        "0",                   , P,      "number of main system which is used to track marker; if only 1 mbs is in the SystemContainer, use 0; if there are several mbs, it needs to specify the number"
V,      trackMarkerPosition,            ,                  3,    Float3,       "Float3({1.f,1.f,1.f})",,P,      "choose which coordinates or marker are tracked (x,y,z)"
V,      trackMarkerOrientation,         ,                  3,    Float3,       "Float3({0.f,0.f,0.f})",,P,      "choose which orientation axes (x,y,z) are tracked; currently can only be all zero or all one"
#
V,      selectionHighlights,            ,                  ,     bool,         true,                  , P,      "True: mouse click highlights item (default: red)"
V,      selectionLeftMouse,             ,                  ,     bool,         true,                  , P,      "True: left mouse click on items and show basic information"
V,      selectionRightMouse,            ,                  ,     bool,         true,                  , P,      "True: right mouse click on items and show dictionary (read only!)"
V,      selectionRightMouseGraphicsData,,                  ,     bool,         false,                 , P,      "True: right mouse click on items also shows GraphicsData information for inspectation (may sometimes be very large and may not fit into dialog for large graphics objects!)"
V,      useJoystickInput,               ,                  ,     bool,         true,                  , P,      "True: read joystick input (use 6-axis joystick with lowest ID found when starting renderer window) and interpret as (x,y,z) position and (rotx, roty, rotz) rotation: as available from 3Dconnexion space mouse and maybe others as well; set to False, if external joystick makes problems ..."
V,      joystickScaleTranslation,       ,                  ,     float,        "6.f",                 , P,      "translation scaling factor for joystick input"
V,      joystickScaleRotation,          ,                  ,     float,        "200.f",               , P,      "rotation scaling factor for joystick input"
writeFile=VisualizationSettings.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Visualization:General,Window(mouse move, zoom),OpenGL,System(Objects,Nodes,...),Text
class = VisualizationSettings
appendToFile=True
writePybindIncludes = True
addDictionaryAccess = True
typicalPaths = 
classDescription = "Settings for visualization"
#V|F,   pythonName,                   cplusplusName,      size, type,         defaultValue,args,           cFlags, parameterDescription
#
V,      nodes,                      ,                  ,     VSettingsNodes,    ,                 , PS,      "node visualization settings"
V,      bodies,                     ,                  ,     VSettingsBodies,   ,                 , PS,      "body visualization settings"
V,      connectors,                 ,                  ,     VSettingsConnectors,,                , PS,      "connector visualization settings"
V,      markers,                    ,                  ,     VSettingsMarkers,  ,                 , PS,      "marker visualization settings"
V,      loads,                      ,                  ,     VSettingsLoads,    ,                 , PS,      "load visualization settings"
V,      sensors,                    ,                  ,     VSettingsSensors,  ,                 , PS,      "sensor visualization settings"
#
V,      contour,                    ,                  ,     VSettingsContour,  ,                 , PS,      "contour plot visualization settings"
V,      contact,                    ,                  ,     VSettingsContact,  ,                 , PS,      "contact visualization settings"
V,      interactive,                ,                  ,     VSettingsInteractive, ,              , PS,      "Settings for interaction with renderer"
V,      dialogs,                    ,                  ,     VSettingsDialogs,  ,                 , PS,      "dialogs settings"
V,      exportImages,               ,                  ,     VSettingsExportImages,,              , PS,      "settings for exporting (saving) images to files in order to create animations"
V,      window,                     ,                  ,     VSettingsWindow,   ,                 , PS,      "visualization window and interaction settings"
V,      openGL,                     ,                  ,     VSettingsOpenGL,   ,                 , PS,      "OpenGL rendering settings"
V,      general,                    ,                  ,     VSettingsGeneral,  ,                 , PS,      "general visualization settings"
#
#done in WriteToPybind function FL,      GetDictionaryWithTypeInformation,  ,        ,     py::dict,          ,                 , DP,      "access function to dictionary of settings hierarchical structure including type information"
#
writeFile=VisualizationSettings.h




#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#CSolver Structures
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class = CSolverTimer
appendToFile=False
writePybindIncludes = True
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsectionlabel{Solver substructures}{sec:solverSubstructures}\nThis section includes structures contained in the solver, which can be accessed via the Python interface during solution or for building a customized solver in Python.\nThere is plenty of possibilities to interact with the solvers, being it the extraction of data at the end (such as .it or .conv), computation of mass matrix or system matrices, and finally the modification of solver structures (which may have effect or not). In any case, there is no full description for all these methods and the user must always consider the according C++ function to verify the desired behavior.\n"
classDescription = "Structure for timing in solver. Each Real variable is used to measure the CPU time which certain parts of the solver need. This structure is only active if the code is not compiled with the __FAST_EXUDYN_LINALG option and if displayComputationTime is set True. Timings will only be filled, if useTimer is True."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
V,      useTimer,                   ,                  ,     bool,         true,                   ,   P,    "flag to decide, whether the timer is used (true) or not"
V,      total,                      ,                  ,     Real,         0.,                     ,   P,    "total time measured between start and end of computation (static/dynamics)"
V,      factorization,              ,                  ,     Real,         0.,                     ,   P,    "solve or inverse"
V,      newtonIncrement,            ,                  ,     Real,         0.,                     ,   P,    "Jac$^{-1}$ * RHS; backsubstitution"
V,      integrationFormula,         ,                  ,     Real,         0.,                     ,   P,    "time spent for evaluation of integration formulas"
V,      ODE2RHS,                    ,                  ,     Real,         0.,                     ,   P,    "time for residual evaluation of \hac{ODE2} right-hand-side"
V,      ODE1RHS,                    ,                  ,     Real,         0.,                     ,   P,    "time for residual evaluation of \hac{ODE1} right-hand-side"
V,      AERHS,                      ,                  ,     Real,         0.,                     ,   P,    "time for residual evaluation of algebraic equations right-hand-side"
V,      totalJacobian,              ,                  ,     Real,         0.,                     ,   P,    "time for all jacobian computations"
V,      jacobianODE1,               ,                  ,     Real,         0.,                     ,   P,    "jacobian w.r.t. coordinates of \hac{ODE1} equations (not counted in sum)"
V,      jacobianODE2,               ,                  ,     Real,         0.,                     ,   P,    "jacobian w.r.t. coordinates of \hac{ODE2} equations (not counted in sum)"
V,      jacobianODE2_t,             ,                  ,     Real,         0.,                     ,   P,    "jacobian w.r.t. coordinates_t of \hac{ODE2} equations (not counted in sum)"
V,      jacobianAE,                 ,                  ,     Real,         0.,                     ,   P,    "jacobian of algebraic equations (not counted in sum)"
V,      massMatrix,                 ,                  ,     Real,         0.,                     ,   P,    "mass matrix computation"
V,      reactionForces,             ,                  ,     Real,         0.,                     ,   P,    "CqT * lambda"
V,      postNewton,                 ,                  ,     Real,         0.,                     ,   P,    "discontinuous iteration / PostNewtonStep"
#not used, for efficiency (added as special/global timer): V,      postNewton,                 ,                  ,     Real,         0.,                     ,   P,    "post newton step"
V,      errorEstimator,             ,                  ,     Real,         0.,                     ,   P,    "for explicit solvers, additional evaluation"
V,      writeSolution,              ,                  ,     Real,         0.,                     ,   P,    "time for writing solution"
V,      overhead,                   ,                  ,     Real,         0.,                     ,   P,    "overhead, such as initialization, copying and some matrix-vector multiplication"
V,      python,                     ,                  ,     Real,         0.,                     ,   P,    "time spent for Python functions"
V,      visualization,              ,                  ,     Real,         0.,                     ,   P,    "time spent for visualization in computation thread"
F,      Reset,                      ,                ,     void,         "*this = CSolverTimer(); useTimer = useSolverTimer;", "bool useSolverTimer", P, "reset solver timings to initial state by assigning default values; useSolverTimer sets the useTimer flag"
F,      Sum,                        ,                ,     Real,         ,                       ,   CDPV,    "compute sum of all timers (except for those counted multiple, e.g., jacobians"
F,      StartTimer,                 ,                ,     void,         "if (useTimer) { value -= EXUstd::GetTimeInSeconds();}", "Real& value",   P,    "start timer function for a given variable; subtracts current CPU time from value"
F,      StopTimer,                  ,                ,     void,         "if (useTimer) { value += EXUstd::GetTimeInSeconds();}", "Real& value",   P,    "stop timer function for a given variable; adds current CPU time to value"
F,      ToString,                   ,                ,     String,       ,                       ,   CDPV,    "converts the current timings to a string"
#
writeFile=CSolverStructures.h


class = SolverLocalData
appendToFile=True
writePybindIncludes = True
addConstructor = "    SetLinearSolverType(LinearSolverType::EXUdense); //for safety, data is linked initially\n"
classDescription = "Solver local data structure for solution vectors, system matrices and temporary vectors and data structures."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
V,      nODE2,                      ,                  ,     Index,        0,                      ,   P,    "number of second order ordinary diff. eq. coordinates"
V,      nODE1,                      ,                  ,     Index,        0,                      ,   P,    "number of first order ordinary diff. eq. coordinates"
V,      nAE,                        ,                  ,     Index,        0,                      ,   P,    "number of algebraic coordinates"
V,      nData,                      ,                  ,     Index,        0,                      ,   P,    "number of data coordinates"
V,      nSys,                       ,                  ,     Index,        0,                      ,   P,    "number of system (unknown) coordinates = nODE2+nODE1+nAE"
V,      startAE,                    ,                  ,     Index,        0,                      ,   P,    "start of algebraic coordinates, but set to zero if nAE==0"
#
V,      systemJacobian,             ,                  ,     GeneralMatrix*, nullptr,             ,    ,    "link to dense or sparse system jacobian"
V,      systemMassMatrix,           ,                  ,     GeneralMatrix*, nullptr,             ,    ,    "link to dense or sparse system mass matrix; in explicit solver, after a step, this will contain the factorized mass matrix"
V,      jacobianAE,                 ,                  ,     GeneralMatrix*, nullptr,             ,    ,    "link to dense or sparse algebraic equations jacobian"
#
V,      systemResidual,             ,                  ,     ResizableVectorParallel, ,            ,   P,    "system residual vector (vectors will be linked to this vector!)"
V,      newtonSolution,             ,                  ,     ResizableVectorParallel, ,            ,   P,    "Newton decrement (computed from residual and jacobian)"
V,      tempODE2,                   ,                  ,     ResizableVectorParallel, ,            ,   P,    "temporary vector for \hac{ODE2} quantities; use in initial accelerations and during Newton"
V,      temp2ODE2,                  ,                  ,     ResizableVectorParallel, ,            ,   P,    "second temporary vector for \hac{ODE2} quantities; use in static computation"
V,      tempODE2F0,                 ,                  ,     ResizableVectorParallel, ,            ,   P,    "temporary vector for \hac{ODE2} Jacobian"
V,      tempODE2F1,                 ,                  ,     ResizableVectorParallel, ,            ,   P,    "temporary vector for \hac{ODE2} Jacobian"
V,      tempODE1F0,                 ,                  ,     ResizableVectorParallel, ,            ,   P,    "temporary vector for \hac{ODE1} Jacobian"
V,      tempODE1F1,                 ,                  ,     ResizableVectorParallel, ,            ,   P,    "temporary vector for \hac{ODE1} Jacobian"
#V,      tempODE1,                   ,                  ,     ResizableVectorParallel, ,            ,   P,    "temporary vector for \hac{ODE1} quantities"
#
V,      startOfStepStateAAlgorithmic,,                 ,     ResizableVectorParallel, ,            ,   P,    "additional term needed for generalized alpha (startOfStep state)"
V,      aAlgorithmic,               ,                  ,     ResizableVectorParallel, ,            ,   P,    "additional term needed for generalized alpha (current state)"
#
V,      tempCompData,               ,                  ,     TemporaryComputationData, ,           ,    ,    "temporary data used during item-related residual and jacobian computation; duplicated for serial computation, will be removed in future"
V,      tempCompDataArray,          ,                  ,     TemporaryComputationDataArray, ,      ,    ,    "temporary data per thread, used during item-related residual and jacobian computation; for parallel computation"
#private members:
Vp,     linearSolverType,           ,                  ,     LinearSolverType,,                    ,    ,    "contains linear solver type value; cannot be accessed directly, because a change requires new linking of system matrices"
#DENSE:
Vp,     systemJacobianDense,        ,                  ,     GeneralMatrixEXUdense,,               ,    ,    "dense system jacobian"
Vp,     systemMassMatrixDense,      ,                  ,     GeneralMatrixEXUdense,,               ,    ,    "dense mass matrix"
Vp,     jacobianAEdense,            ,                  ,     GeneralMatrixEXUdense,,               ,    ,    "dense \hac{AE} jacobian"
#SPARSE:
Vp,     systemJacobianSparse,       ,                  ,     GeneralMatrixEigenSparse,,            ,    ,    "sparse system jacobian"
Vp,     systemMassMatrixSparse,     ,                  ,     GeneralMatrixEigenSparse,,            ,    ,    "sparse mass matrix"
Vp,     jacobianAEsparse,           ,                  ,     GeneralMatrixEigenSparse,,            ,    ,    "sparse \hac{AE} jacobian"
#
#now done with addConstructor flag; F,      SolverLocalData,            ,                ,     ,             "SetLinearSolverType(LinearSolverType::EXUdense);", ,   P,  "for safety, data is linked immediately to dense matrices"
F,      CleanUpMemory,              ,                ,     void,         ,                       ,    DP,  "if desired, temporary data is cleaned up to safe memory"
F,      SetLinearSolverType,        ,                ,     void,         ,                       "LinearSolverType linearSolverType, bool reuseAnalyzedPattern=false, bool ignoreSingularJacobian=false, Real pivotThreshold=0.",   DP,  "set linear solver type and matrix version: links system matrices to according dense/sparse versions and with option for singular jacobian (redundant constraints)"
F,      GetLinearSolverType,        ,                ,     LinearSolverType, "return linearSolverType;", ,   CPV,  "return current linear solver type (dense/sparse)"
#
writeFile=CSolverStructures.h


class = SolverIterationData
appendToFile=True
writePybindIncludes = True
#classDescription = "test"
classDescription = "Solver internal structure for counters, steps, step size, time, etc.; solution vectors, residuals, etc. are SolverLocalData. The given default values are overwritten by the simulationSettings when initializing the solver."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
V,      maxStepSize,                ,                  ,     Real,         0.,                     ,   P,    "constant or maximum stepSize"
V,      minStepSize,                ,                  ,     Real,         0.,                     ,   P,    "minimum stepSize for static/dynamic solver; only used, if automaticStepSize is activated"
V,      initialStepSize,            ,                  ,     Real,         1e-6,                   ,   P,    "initial stepSize for dynamic solver; only used, if automaticStepSize is activated"
V,      lastStepSize,               ,                  ,     Real,         0.,                     ,   P,    "stepSize suggested from last step or by initial step size; only used, if automaticStepSize is activated"
V,      currentStepSize,            ,                  ,     Real,         0.,                     ,   P,    "stepSize of current step"
V,      recommendedStepSize,        ,                  ,     Real,         -1.,                    ,   P,    "recommended step size $h_{recom}$ after PostNewton(...): $h_{recom} < 0$: no recommendation, $h_{recom}==0$: use minimum step size, $h_{recom}>0$: use specific step size, if no smaller size requested by other reason"
#
V,      numberOfSteps,              ,                  ,     Index,        0,                      ,   P,    "number of time steps (if fixed size); $n$"
V,      currentStepIndex,           ,                  ,     Index,        0,                      ,   P,    "current step index; $i$"
#
V,      adaptiveStep,               ,                  ,     bool,         true,                   ,   P,    "True: the step size may be reduced if step fails; no automatic stepsize control"
V,      automaticStepSize,          ,                   ,     bool,         true,                   ,   P,    "True: if timeIntegration.automaticStepSize == True AND chosen integrators supports automatic step size control (e.g., DOPRI5); False: constant step size used (step may be reduced if adaptiveStep=True)"
#
V,      currentTime,                ,                  ,     Real,         0.,                     ,   P,    "holds the current simulation time, copy of state.current.time; interval is [startTime,tEnd]; in static solver, duration is loadStepDuration"
V,      startTime,                  ,                  ,     Real,         0.,                     ,   P,    "time at beginning of time integration"
V,      endTime,                    ,                  ,     Real,         0.,                     ,   P,    "end time of static/dynamic solver"
#
V,      discontinuousIteration,     ,                  ,     Index,        0,                      ,   P,    "number of current discontinuous iteration"
V,      newtonSteps,                ,                  ,     Index,        0,                      ,   P,    "number of current newton steps"
#
V,      newtonStepsCount,           ,                  ,     Index,        0,                      ,   P,    "count total Newton steps"
V,      newtonJacobiCount,          ,                  ,     Index,        0,                      ,   P,    "count total Newton jacobian computations"
V,      rejectedModifiedNewtonSteps,,                  ,     Index,        0,                      ,   P,    "count the number of rejected modified Newton steps (switch to full Newton)"
V,      discontinuousIterationsCount,,                  ,     Index,        0,                      ,   P,    "count total number of discontinuous iterations (min. 1 per step)"
V,      rejectedAutomaticStepSizeSteps,,              ,     Index,        0,                      ,   P,    "count the number of rejected steps in case of automatic step size control (rejected steps are repeated with smaller step size)"
V,      automaticStepSizeError,     ,                  ,     Real,         0,                      ,   P,    "estimated error (relative to atol + rtol*solution) of last step; must be $\le 1$  for a step to be accepted"
#
F,      ToString,                   ,                ,     String,       ,                       ,   CDPV,  "convert iteration statistics to string; used for displayStatistics option"
#
writeFile=CSolverStructures.h


class = SolverConvergenceData
appendToFile=True
writePybindIncludes = True
classDescription = "Solver internal structure for convergence information: residua, iteration loop errors and error flags. For detailed behavior of these flags, visit the source code!"
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
V,      stepReductionFailed,        ,                  ,     bool,         false,                       ,   P,    "true, if iterations over time/static steps failed (finally, cannot be recovered)"
V,      discontinuousIterationSuccessful,,           ,     bool,         true,                        ,   P,    "true, if last discontinuous iteration had success (failure may be recovered by adaptive step)"
V,      linearSolverFailed,         ,                  ,     bool,         false,                       ,   P,    "true, if linear solver failed to factorize"
V,      linearSolverCausingRow,     ,                  ,     Index,        -1,                          ,   P,    "-1 if successful, 0 ... n-1, the system equation (=coordinate) index which may have caused the problem, at which the linear solver failed"
V,      stopNewton,                 ,                  ,     bool,         false,                       ,   P,    "set true by Newton, if Newton was stopped, e.g., because of exceeding iterations or linear solver failed"
V,      newtonConverged,            ,                  ,     bool,         false,                       ,   P,    "true, if Newton has (finally) converged"
V,      newtonSolutionDiverged,     ,                  ,     bool,         false,                       ,   P,    "true, if Newton diverged (may be recovered)"
V,      jacobianUpdateRequested,    ,                  ,     bool,         true,                        ,   P,    "true, if a jacobian update is requested in modified Newton (determined in previous step)"
V,      massMatrixNotInvertible,    ,                  ,     bool,         false,                       ,   P,    "true, if mass matrix is not invertable during initialization or solution (explicit solver)"
#RESIDUALS and ERRORS:
V,      discontinuousIterationError,,                  ,     Real,         0.,                          ,   P,    "error of discontinuous iterations (contact, friction, ...) outside of Newton iteration"
V,      residual,                   ,                  ,     Real,         0.,                          ,   P,    "current Newton residual"
V,      lastResidual,               ,                  ,     Real,         0.,                          ,   P,    "last Newton residual to determine contractivity"
V,      contractivity,              ,                  ,     Real,         0.,                          ,   P,    "Newton contractivity = geometric decay of error in every step"
V,      errorCoordinateFactor,      ,                  ,     Real,         1.,                          ,   P,    "factor may include the number of system coordinates to reduce the residual"
#
F,      InitializeData,             ,                ,     void,         "*this = SolverConvergenceData();",,P, "initialize SolverConvergenceData by assigning default values"
#
writeFile=CSolverStructures.h


class = SolverOutputData
appendToFile=True
writePybindIncludes = True
classDescription = "Solver internal structure for output modes, output timers and counters."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
V,      finishedSuccessfully,       ,                  ,     bool,         false,                  ,   P,    "flag is false until solver functions SolveSteps)...) or SolveSystem(...) finished successfully (can be used as external trigger)"
V,      initializationSuccessful,   ,                  ,     bool,         false,                  ,   P,    "flag is set during call to InitializeSolver(...); reasons for failure are multiple, either inconsistent solver settings are used, files cannot be written (file locked), or initial conditions could not be computed "
#write to file and console
V,      verboseMode,                ,                  ,     Index,        0,                      ,   P,    "this is a copy of the solvers verboseMode used for console output"
V,      verboseModeFile,            ,                  ,     Index,        0,                      ,   P,    "this is a copy of the solvers verboseModeFile used for file"
V,      stepInformation,            ,                  ,     Index,        0,                      ,   P,    "this is a copy of the solvers stepInformation used for console output"
V,      writeToSolutionFile,        ,                  ,     bool,         false,                  ,   P,    "if false, no solution file is generated and no file is written"
V,      writeToSolverFile,          ,                  ,     bool,         false,                  ,   P,    "if false, no solver output file is generated and no file is written"
V,      sensorValuesTemp,           ,                  ,     ResizableVector, ,                    ,   ,     "temporary vector for per sensor values (overwritten for every sensor; usually contains last sensor values)"
V,      sensorValuesTemp2,          ,                  ,     ResizableVector, ,                    ,   ,     "additional temporary vector for per sensor values (overwritten for every sensor; usually contains time+last sensor values)"
#simulation and CPU time of events:
V,      lastSolutionWritten,        ,                  ,     Real,         0.,                     ,   P,    "simulation time when last solution has been written"
V,      lastSensorsWritten,         ,                  ,     Real,         0.,                     ,   P,    "simulation time when last sensors have been written"
V,      lastImageRecorded,          ,                  ,     Real,         0.,                     ,   P,    "simulation time when last image has been recorded"
V,      cpuStartTime,               ,                  ,     Real,         0.,                     ,   P,    "CPU start time of computation (starts counting at computation of initial conditions)"
V,      cpuLastTimePrinted,         ,                  ,     Real,         0.,                     ,   P,    "CPU time when output has been printed last time"
#
V,      lastVerboseStepIndex,       ,                  ,     Index,        0,                      ,   P,    "step index when last time written to console (or file)"
V,      lastNewtonStepsCount,       ,                  ,     Index,        0,                      ,   P,    "newton steps count when written to console (or file) last time"
V,      lastNewtonJacobiCount,      ,                  ,     Index,        0,                      ,   P,    "jacobian update count when written to console (or file) last time"
V,      lastDiscontinuousIterationsCount, ,            ,     Index,        0,                      ,   P,    "discontinuous iterations count when written to console (or file) last time"
#for parallel
V,      numberOfThreadsUsed,        ,                  ,     Index,        1,                      ,   P,    "number of threads that have been used in simulation"
V,      multiThreadingMode,         ,                  ,     Index,        0,                      ,   P,    "multithreading mode that has been used: 0=None (serial), 1=NGsolve taskmanager, 2=MicroThreading (Exudyn)"
#
F,      InitializeData,             ,                ,     void,         "*this = SolverOutputData();",,P, "initialize SolverOutputData by assigning default values"
#
writeFile=CSolverStructures.h

class = SolverFileData
appendToFile=True
writePybindIncludes = True
classDescription = "Solver internal structure for output files. This structure is not linked to pybind, because std::ofstream is not supported."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
V,      solutionFile,               ,                  ,     std::ofstream,,                       ,    ,    "solution file with coordinate data"
V,      solverFile,                 ,                  ,     std::ofstream,,                       ,    ,    "file with detailed solver information"
V,      sensorFileList,             ,                  ,     std::vector<std::ofstream*>,,         ,    ,    "files for sensor output; the ofstream list corresponds exactly to the sensors in the computationalSystem (i.e., sensorFileList[0] is the ofstream for sensor 0, etc.); file lists need to be closed and deleted at end of simulation!"
V,      binaryFileSettings,         ,                  ,     ExuFile::BinaryFileSettings,,         ,    ,    "settings for binary file write mode"
#
#F,      InitializeData,             ,                ,     void,         "*this = SolverOutputData();",,P, "initialize SolverOutputData by assigning default values"
#
writeFile=CSolverStructures.h

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# MAIN SOLVER interfaces
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class = MainSolverStatic
parentClass="MainSolverBase"
appendToFile=False
writePybindIncludes = True
#linkedClass = "cSolver" #not needed any more
classDescription = "PyBind interface (trampoline) class for static solver. With this interface, the static solver and its substructures can be accessed via Python. NOTE that except from SolveSystem(...), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (performance much lower than internal solver) due to Python interfaces, and should thus be used for small systems. To access the solver in Python, write: \\ \n \texttt{solver = MainSolverStatic()} \\ \nand hereafter you can access all data and functions via 'solver'."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
VL,     timer,                    cSolver.timer ,            ,     CSolverTimer,      ,                  ,   PS,    "timer which measures the CPU time of solver sub functions"
VL,     it,                       cSolver.it    ,            ,     SolverIterationData, ,                ,   PS,    "all information about iterations (steps, discontinuous iteration, newton,...)"
VL,     conv,                     cSolver.conv  ,            ,     SolverConvergenceData, ,              ,   PS,    "all information about tolerances, errors and residua"
VL,     output,                   cSolver.output,            ,     SolverOutputData,  ,                  ,   PS,    "output modes and timers for exporting solver information and solution"
VL,     newton,                   cSolver.newton,            ,     NewtonSettings,    ,                  ,   PS,    "copy of newton settings from timeint or staticSolver"
#these structures cannot be accessed directly via pybind:
#VL,     data,                        ,                  ,     SolverLocalData,   ,                  ,   P,    "local solver vectors and matrices"
#VL,     file,                      ,                  ,     SolverFileData,  ,                  ,   P,    "output files for solver information and solution"
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized variables for CSolverStatic:
#
V,      cSolver,                     ,                  ,     CSolverStatic,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
V,      loadStepGeometricFactor,     cSolver.loadStepGeometricFactor,               ,     Real,              ,                  ,   P,    "multiplicative load step factor; this factor is computed from loadStepGeometric parameters in SolveSystem(...)"
#
V,      isInitialized,               ,                  ,     bool,              ,                  ,    ,   "variable is used to see, if system is initialized ==> avoid crashes; DO not change these variables: can easily lead to crash! "
V,      initializedSystemSizes,      ,                  ,     Index4,            ,                  ,    ,   "index-array contains 4 integers: nODE2, nODE1, nAE and nData of initialization: this guaranties, that no function is called with wrong system sizes; DO not change these variables: can easily lead to crash! "
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized functions for CSolverStatic:
F,      MainSolverStatic,            ,               ,     ,                  "isInitialized=false;",,,  "constructor, in order to set valid state (settings not initialized at beginning)"
Fv,     GetCSolver,                  ,                ,    const CSolverBase& ,            "return cSolver;",,C,  "const access to cSolver"
Fv,     GetCSolver,                  ,                ,    CSolverBase& ,                  "return cSolver;",,,  "reference access to cSolver"
FvL,    CheckInitialized,            ,               ,     bool,              ,                  "const MainSystem& mainSystem",   DGPV,  "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError"
F,      ComputeLoadFactor,           ,                ,    Real,        "return cSolver.ComputeLoadFactor(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "for static solver, this is a factor in interval [0,1]; MUST be overwritten"
#++++++++++++++++++++++++++++++++++++++++++++++
#this should be exactly the same as MainSolverImplicitSecondOrder
#general functions:
FvL,    GetErrorString,              ,                ,    "std::string", ,                     ,   CGPV,    "return error string if solver has not been successful"
FvL,    GetSolverName,               ,                ,    "std::string", ,                     ,   CGPV,    "get solver name - needed for output file header and visualization window"
FvL,    IsStaticSolver,              ,                ,    bool,        ,                       ,   CGPV,    "return true, if static solver; needs to be overwritten in derived class"
FvL,    GetSimulationEndTime,        ,                ,    Real,        ,                       "const SimulationSettings& simulationSettings",   CGPV,    "compute simulation end time (depends on static or time integration solver)"
FvL,    ReduceStepSize,              ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Index severity",   GPV,    "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful"
FvL,    IncreaseStepSize,            ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "increase step size if convergence is good"
FvL,    HasAutomaticStepSizeControl, ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "return true, if solver supports automatic stepsize control, otherwise false"
#initialization functions:
FvL,    InitializeSolver,            ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files"
FvL,    PreInitializeSolverSpecific, ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset"
FvL,    InitializeSolverOutput,      ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize output files; called from InitializeSolver()"
FvL,    InitializeSolverPreChecks,   ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "check if system is solvable; initialize dense/sparse computation modes"
FvL,    InitializeSolverData,        ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize all data,it,conv; called from InitializeSolver()"
FvL,    InitializeSolverInitialConditions, ,          ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "set/compute initial conditions (solver-specific!); called from InitializeSolver()"
FvL,    PostInitializeSolverSpecific,,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "post-initialize for solver specific tasks; called at the end of InitializeSolver"
#++++++++++++++++++++++++++++++++++
#solve functions:
FvL,    SolveSystem,                 ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "solve System: InitializeSolver, SolveSteps, FinalizeSolver"
FvL,    FinalizeSolver,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write concluding information (timer statistics, messages) and close files"
FvL,    SolveSteps,                  ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else"
FvL,    UpdateCurrentTime,           ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "update currentTime (and load factor); MUST be overwritten in special solver class"
FvL,    InitializeStep,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize static step / time step; Python-functions; do some outputs, checks, etc."
FvL,    FinishStep,                  ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "finish static step / time step; write output of results to file"
FvL,    DiscontinuousIteration,      ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual"
FvL,    Newton,                      ,                ,    bool,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform Newton method for given solver method"
FvL,    ComputeNewtonResidual,       ,                ,    Real,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)"
FvL,    ComputeNewtonUpdate,         ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, initial=true",   GPV,    "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0"
FvL,    ComputeNewtonJacobian,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute jacobian for newton method of given solver method; store result in systemJacobian"
#output functions:
FvL,    WriteSolutionFileHeader,     ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique file header, depending on static/ dynamic simulation"
FvL,    WriteCoordinatesToFile,      ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique coordinates solution file"
FvL,    IsVerboseCheck,              ,                ,    bool,        ,                                   "Index level",   CGPV,    "return true, if file or console output is at or above the given level"
FvL,    VerboseWrite,                ,                ,    void,        ,                                "Index level, const std::string& str",   GPV,    "write to console and/or file in case of level"

#special functions to access residua and system matrices
FvL,    GetODE2size,                 ,                ,    Index,       ,                                ,   CGP,    "number of \hac{ODE2} equations in solver"
FvL,    GetODE1size,                 ,                ,    Index,       ,                                ,   CGP,    "number of \hac{ODE1} equations in solver (not yet implemented)"
FvL,    GetAEsize,                   ,                ,    Index,       ,                                ,   CGP,    "number of algebraic equations in solver"
FvL,    GetDataSize,                 ,                ,    Index,       ,                                ,   CGP,    "number of data (history) variables in solver"
#
FvL,    GetSystemJacobian,           ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed system jacobian of solver"
FvL,    GetSystemMassMatrix,         ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed mass matrix of solver"
FvL,    GetSystemResidual,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed system residual"
FvL,    GetNewtonSolution,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed solution (=increment) of Newton"
FvL,    SetSystemJacobian,           ,                ,    void,        ,                       "const py::array_t<Real>& systemJacobian",   DGPV,      "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemMassMatrix,         ,                ,    void,        ,                       "const py::array_t<Real>& systemMassMatrix",   DGPV,    "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemResidual,           ,                ,    void,        ,                       "const Vector& systemResidual",   DGPV,    "set locally stored system residual; must have size nODE2+nODE1+nAE"
#
#special functions for interaction with mainSystem:
FvL,    ComputeMassMatrix,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "compute systemMassMatrix (multiplied with factor) in cSolver and return mass nODE2 x nODE2 matrix"
FvL,    ComputeJacobianODE2RHS,      ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=0., Real scalarFactor_ODE1=1., Index computeLoadsJacobian=0",   DGPV,    "set systemJacobian to zero, size = (nODE2+nODE1+nAE) x (nODE2+nODE1+nAE), and add jacobian (multiplied with factors for ODE2 and ODE1 coordinates) of ODE2RHS to systemJacobian in cSolver; using (scalarFactor_ODE2=-1,scalarFactor_ODE2=0) gives the stiffness matrix (=derivatives of ODE2 coords) in the nODE2 x nODE2 part, while using (scalarFactor_ODE2=0,scalarFactor_ODE2=-1) gives the damping matrix (= derivatives of ODE2 velocity coordinates) in the same part; a superposition of these two parts makes sense for implicit solvers; if , Index computeLoadsJacobian=0, loads are not considered in the Jacobian computation; for , Index computeLoadsJacobian=1 the ODE2 and ODE1 derivatives of loads are included and for , Index computeLoadsJacobian=2, also the ODE2_t dependencies are added"
FvL,    ComputeJacobianODE1RHS,      ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=0., Real scalarFactor_ODE1=1.",   DGPV,    "ADD jacobian of ODE1RHS (multiplied with factors for ODE2 and ODE1 coordinates) to the according rows (nODE2:nODE2+nODE1) of the exising systemJacobian in cSolver; it requires a prior call to ComputeJacobianODE2RHS(...); the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian"
FvL,    ComputeJacobianAE,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=0., Real scalarFactor_ODE1=1., bool velocityLevel=false",   DGPV,    "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. \hac{ODE2} coordinates, ODE2_t (velocity) coordinates and ODE1 coordinates; if velocityLevel == true, the constraints are evaluated at velocity level; the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian"
#removed: FvL,    ComputeJacobianODE2RHS_t,    ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2_t=1.",   DGPV,    "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver"
#
FvL,    ComputeODE2RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of \hac{ODE2} equations in systemResidual in range(0,nODE2)"
FvL,    ComputeAlgebraicEquations,   ,                ,    void,        ,                       "MainSystem& mainSystem, bool velocityLevel=false",   DGPV,    "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)"
#
#
writeFile=MainSolver.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = MainSolverImplicitSecondOrder
parentClass="MainSolverBase"
appendToFile=True
writePybindIncludes = True
classDescription = "PyBind interface (trampoline) class for dynamic implicit solver. Note that this solver includes the classical Newmark method (set useNewmark True; with option of index 2 reduction) as well as the generalized-alpha method. With the interface, the dynamic implicit solver and its substructures can be accessed via Python. NOTE that except from SolveSystem(...), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (still fast, but performance much lower than internal solver) due to Python interfaces, and should thus be used for small systems. To access the solver in Python, write: \\ \n \texttt{solver = MainSolverImplicitSecondOrder()} \\ \nand hereafter you can access all data and functions via 'solver'.\n In this solver, user functions are possible to extend the solver at certain parts, while keeping the overal C++ performance. User functions, which are added with SetUserFunction...(...), have the arguments (MainSolver, MainSystem, simulationSettings), except for ComputeNewtonUpdate which adds the initial flag as an additional argument and ComputeNewtonResidual, which returns the scalar residual."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
VL,     timer,                    cSolver.timer ,            ,     CSolverTimer,      ,                  ,   PS,    "timer which measures the CPU time of solver sub functions; note that solver structures can only be written indirectly, e.g.,  timer=dynamicSolver.timer; timer.useTimer = False; dynamicSolver.timer=timer; however, dynamicSolver.timer.useTimer cannot be written."
VL,     it,                       cSolver.it    ,            ,     SolverIterationData, ,                ,   PS,    "all information about iterations (steps, discontinuous iteration, newton,...)"
VL,     conv,                     cSolver.conv  ,            ,     SolverConvergenceData, ,              ,   PS,    "all information about tolerances, errors and residua"
VL,     output,                   cSolver.output,            ,     SolverOutputData,  ,                  ,   PS,    "output modes and timers for exporting solver information and solution"
VL,     newton,                   cSolver.newton,            ,     NewtonSettings,    ,                  ,   PS,    "copy of newton settings from timeint or staticSolver"
#these structures cannot be accessed directly via pybind:
#VL,     data,                        ,                  ,     SolverLocalData,   ,                  ,   P,    "local solver vectors and matrices"
#VL,     file,                      ,                  ,     SolverFileData,  ,                  ,   P,    "output files for solver information and solution"
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized variables for CSolverStatic:
# currently, both solvers are available, but cSolverOld is the standard
V,      cSolver,                     ,                  ,     CSolverImplicitSecondOrderTimeIntUserFunction,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
#DELETE: V,      cSolverNew,                  ,                  ,     CSolverImplicitSecondOrderTimeIntNew,              ,                  ,    ,    "link to C++ CSolver, not accessible from Python; new solver, only for experimental work"
#for tests; V,      experimentalUseSolverNew,    ,                  ,     bool,              "false",           ,   P,   "this is an experimental flag, which will be removed in the future"
#DELETE: V,      useOldAccBasedSolver,        ,                        ,     bool,              "false",           ,   P,    "set this flag True, to use old (until 2021-02-05) accelerations based generalized alpha solver; this is outdated, but kept in order to ensure compatibility for some time (will be ERASED in FUTURE!)"
#without user function: V,      cSolver,                     ,                  ,     CSolverImplicitSecondOrderTimeInt,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
#copy of parameters from integration scheme (cannot be changed during integration!)
V,      newmarkBeta,                 GetCSolverImplicitSecondOrder().newmarkBeta,                     ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      newmarkGamma,                GetCSolverImplicitSecondOrder().newmarkGamma,                    ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      alphaM,                      GetCSolverImplicitSecondOrder().alphaM,                          ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      alphaF,                      GetCSolverImplicitSecondOrder().alphaF,                          ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      spectralRadius,              GetCSolverImplicitSecondOrder().spectralRadius,                  ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      factJacAlgorithmic,          GetCSolverImplicitSecondOrder().factJacAlgorithmic,              ,     Real,              ,                  ,   P,    "locally computed parameter from generalizedAlpha parameters"
#
V,      isInitialized,               ,                  ,     bool,              "false",           ,    ,   "variable is used to see, if system is initialized ==> avoid crashes; DO not change these variables: can easily lead to crash! "
V,      initializedSystemSizes,      ,                  ,     Index4,            ,                  ,    ,   "index-array contains 4 integers: nODE2, nODE1, nAE and nData of initialization: this guaranties, that no function is called with wrong system sizes; DO not change these variables: can easily lead to crash! "
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized functions for CSolverImplicitSecondOrder:
#now auotmatically created: F,      MainSolverImplicitSecondOrder,,               ,    ,            ,,D,  "constructor, in order to set valid state (settings not initialized at beginning)"
Fv,     GetCSolver,                  ,                ,    const CSolverBase& ,            "return GetCSolverImplicitSecondOrder();",,C,  "const access to cSolver"
Fv,     GetCSolver,                  ,                ,    CSolverBase& ,                  "return GetCSolverImplicitSecondOrder();",,,  "reference access to cSolver"
F,      GetCSolverImplicitSecondOrder,,               ,    const CSolverImplicitSecondOrderTimeIntUserFunction& ,            "return cSolver;",,C,  "const access to cSolver"
F,      GetCSolverImplicitSecondOrder,,               ,    CSolverImplicitSecondOrderTimeIntUserFunction& ,                  "return cSolver;",,,  "reference access to cSolver"
#
FvL,    CheckInitialized,            ,                ,    bool,        ,                  "const MainSystem& mainSystem",   DGPV,  "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError"
F,      ComputeLoadFactor,           ,                ,    Real,        "return GetCSolverImplicitSecondOrder().ComputeLoadFactor(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "for static solver, this is a factor in interval [0,1]; MUST be overwritten"
#
F,      GetAAlgorithmic,             ,                ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed algorithmic accelerations"
F,      GetStartOfStepStateAAlgorithmic, ,            ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed algorithmic accelerations at start of step"
#++++++++++++++++++++++++++++++++++++++++++++++
#User functions: (must be initialized)
##
#V,      userFunctionUpdateCurrentTime,,               ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override UpdateCurrentTime()"
#V,      userFunctionInitializeStep,  ,                ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override InitializeStep()"
#V,      userFunctionFinishStep,      ,                ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override FinishStep()"
#V,      userFunctionDiscontinuousIteration,,          ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override DiscontinuousIteration()"
#V,      userFunctionNewton,          ,                 ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
#V,      userFunctionComputeNewtonUpdate,,             ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override ComputeNewtonUpdate()"
#V,      userFunctionComputeNewtonResidual,,           ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override ComputeNewtonResidual()"
#V,      userFunctionComputeNewtonJacobian,,           ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override ComputeNewtonJacobian()"
#
#V,      userFunctionPreInitializeSolverSpecific,,            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
#V,      userFunctionInitializeSolverInitialConditions,,            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
#V,      userFunctionPostInitializeSolverSpecific,,            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
F,       SetUserFunctionUpdateCurrentTime,,            ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionUpdateCurrentTime(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionInitializeStep,   ,            ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionInitializeStep(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionFinishStep,       ,            ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionFinishStep(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionDiscontinuousIteration,,       ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionDiscontinuousIteration(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionNewton,           ,            ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionNewton(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionComputeNewtonUpdate,,          ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionComputeNewtonUpdate(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunctionBool& userFunction", P,  "set user function"
F,       SetUserFunctionComputeNewtonResidual,,        ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionComputeNewtonResidual(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunctionReal& userFunction", P,  "set user function"
F,       SetUserFunctionComputeNewtonJacobian,,        ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionComputeNewtonJacobian(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionPostNewton,,                   ,    void,            "GetCSolverImplicitSecondOrder().SetUserFunctionPostNewton(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunctionReal& userFunction", P,  "set user function"
#
#++++++++++++++++++++++++++++++++++++++++++++++
#this should be exactly the same as MainSolverStatic
#general functions:
FvL,    GetErrorString,              ,                ,    "std::string", ,                     ,   CGPV,    "return error string if solver has not been successful"
FvL,    GetSolverName,               ,                ,    "std::string", ,                     ,   CGPV,    "get solver name - needed for output file header and visualization window"
FvL,    IsStaticSolver,              ,                ,    bool,        ,                       ,   CGPV,    "return true, if static solver; needs to be overwritten in derived class"
FvL,    GetSimulationEndTime,        ,                ,    Real,        ,                       "const SimulationSettings& simulationSettings",   CGPV,    "compute simulation end time (depends on static or time integration solver)"
FvL,    ReduceStepSize,              ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Index severity",   GPV,    "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful"
FvL,    IncreaseStepSize,            ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "increase step size if convergence is good"
FvL,    HasAutomaticStepSizeControl, ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "return true, if solver supports automatic stepsize control, otherwise false"
#initialization functions:
FvL,    InitializeSolver,            ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files"
FvL,    PreInitializeSolverSpecific, ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset"
FvL,    InitializeSolverOutput,      ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize output files; called from InitializeSolver()"
FvL,    InitializeSolverPreChecks,   ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "check if system is solvable; initialize dense/sparse computation modes"
FvL,    InitializeSolverData,        ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize all data,it,conv; called from InitializeSolver()"
FvL,    InitializeSolverInitialConditions, ,          ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "set/compute initial conditions (solver-specific!); called from InitializeSolver()"
FvL,    PostInitializeSolverSpecific,,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "post-initialize for solver specific tasks; called at the end of InitializeSolver"
#++++++++++++++++++++++++++++++++++
#solve functions:
FvL,    SolveSystem,                 ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "solve System: InitializeSolver, SolveSteps, FinalizeSolver"
FvL,    FinalizeSolver,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write concluding information (timer statistics, messages) and close files"
FvL,    SolveSteps,                  ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else"
#
FvL,    UpdateCurrentTime,           ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "update currentTime (and load factor); MUST be overwritten in special solver class"
FvL,    InitializeStep,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize static step / time step; Python-functions; do some outputs, checks, etc."
FvL,    FinishStep,                  ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",  DGPV,    "finish static step / time step; write output of results to file"
FvL,    DiscontinuousIteration,      ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual"
FvL,    Newton,                      ,                ,    bool,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform Newton method for given solver method"
FvL,    PostNewton,                  ,                ,    Real,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "call PostNewton for all relevant objects (contact, friction, ... iterations); returns error for discontinuous iteration"
FvL,    ComputeNewtonResidual,       ,                ,    Real,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)"
FvL,    ComputeNewtonUpdate,         ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, initial=true",   GPV,    "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0"
FvL,    ComputeNewtonJacobian,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute jacobian for newton method of given solver method; store result in systemJacobian"
#output functions:
FvL,    WriteSolutionFileHeader,     ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique file header, depending on static/ dynamic simulation"
FvL,    WriteCoordinatesToFile,      ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique coordinates solution file"
FvL,    IsVerboseCheck,              ,                ,    bool,        ,                                   "Index level",   CGPV,    "return true, if file or console output is at or above the given level"
FvL,    VerboseWrite,                ,                ,    void,        ,                                "Index level, const std::string& str",   GPV,    "write to console and/or file in case of level"

#special functions to access residua and system matrices
FvL,    GetODE2size,                 ,                ,    Index,       ,                                ,   CGP,    "number of \hac{ODE2} equations in solver"
FvL,    GetODE1size,                 ,                ,    Index,       ,                                ,   CGP,    "number of \hac{ODE1} equations in solver (not yet implemented)"
FvL,    GetAEsize,                   ,                ,    Index,       ,                                ,   CGP,    "number of algebraic equations in solver"
FvL,    GetDataSize,                 ,                ,    Index,       ,                                ,   CGP,    "number of data (history) variables in solver"
#
FvL,    GetSystemJacobian,           ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed system jacobian of solver"
FvL,    GetSystemMassMatrix,         ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed mass matrix of solver"
FvL,    GetSystemResidual,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed system residual"
FvL,    GetNewtonSolution,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed solution (=increment) of Newton"
FvL,    SetSystemJacobian,           ,                ,    void,        ,                       "const py::array_t<Real>& systemJacobian",   DGPV,      "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemMassMatrix,         ,                ,    void,        ,                       "const py::array_t<Real>& systemMassMatrix",   DGPV,    "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemResidual,           ,                ,    void,        ,                       "const Vector& systemResidual",   DGPV,    "set locally stored system residual; must have size nODE2+nODE1+nAE"
#
#special functions for interaction with mainSystem:
FvL,    ComputeMassMatrix,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "compute systemMassMatrix (multiplied with factor) in cSolver and return mass nODE2 x nODE2 matrix"
FvL,    ComputeJacobianODE2RHS,      ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=0., Real scalarFactor_ODE1=1., Index computeLoadsJacobian=0",   DGPV,    "set systemJacobian to zero, size = (nODE2+nODE1+nAE) x (nODE2+nODE1+nAE), and add jacobian (multiplied with factors for ODE2 and ODE1 coordinates) of ODE2RHS to systemJacobian in cSolver; using (scalarFactor_ODE2=-1,scalarFactor_ODE2=0) gives the stiffness matrix (=derivatives of ODE2 coords) in the nODE2 x nODE2 part, while using (scalarFactor_ODE2=0,scalarFactor_ODE2=-1) gives the damping matrix (= derivatives of ODE2 velocity coordinates) in the same part; a superposition of these two parts makes sense for implicit solvers; if , Index computeLoadsJacobian=0, loads are not considered in the Jacobian computation; for , Index computeLoadsJacobian=1 the ODE2 and ODE1 derivatives of loads are included and for , Index computeLoadsJacobian=2, also the ODE2_t dependencies are added"
FvL,    ComputeJacobianODE1RHS,      ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=0., Real scalarFactor_ODE1=1.",   DGPV,    "ADD jacobian of ODE1RHS (multiplied with factors for ODE2 and ODE1 coordinates) to the according rows (nODE2:nODE2+nODE1) of the exising systemJacobian in cSolver; it requires a prior call to ComputeJacobianODE2RHS(...); the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian"
FvL,    ComputeJacobianAE,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=0., Real scalarFactor_ODE1=1., bool velocityLevel=false",   DGPV,    "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. \hac{ODE2} coordinates, ODE2_t (velocity) coordinates and ODE1 coordinates; if velocityLevel == true, the constraints are evaluated at velocity level; the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian"
#removed: FvL,    ComputeJacobianODE2RHS_t,    ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2_t=1.",   DGPV,    "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver"
#
FvL,    ComputeODE2RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of \hac{ODE2} equations in systemResidual in range(0,nODE2)"
FvL,    ComputeODE1RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of \hac{ODE1} equations in systemResidual in range(0,nODE1)"
FvL,    ComputeAlgebraicEquations,   ,                ,    void,        ,                       "MainSystem& mainSystem, bool velocityLevel=false",   DGPV,    "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)"
#
#
writeFile=MainSolver.h


#%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = MainSolverExplicit
parentClass="MainSolverBase"
appendToFile=True
writePybindIncludes = True
classDescription = "PyBind interface (trampoline) class for dynamic explicit solver. Note that this solver includes the 1st order explicit Euler scheme and the 4th order Runge-Kutta scheme with 5th order error estimation (DOPRI5). With the interface, the solver and its substructures can be accessed via Python. NOTE that except from SolveSystem(...), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (still fast, but performance much lower than internal solver) due to Python interfaces, and should thus be used for small systems. To access the solver in Python, write \\ \n \texttt{solver = MainSolverExplicit()} \\ \nand hereafter you can access all data and functions via 'solver'.\n In this solver, no user functions are possible, but you can use SolverImplicitSecondOrder instead (turning off Newton gives explicit scheme ...)."
#V|F,   pythonName,                   cplusplusName,      size, type,          defaultValue,            args,           cFlags, parameterDescription
VL,     timer,                    cSolver.timer ,       ,     CSolverTimer,      ,                  ,   PS,    "timer which measures the CPU time of solver sub functions"
VL,     it,                       cSolver.it    ,       ,     SolverIterationData, ,                ,   PS,    "all information about iterations (steps, discontinuous iteration, newton,...)"
VL,     conv,                     cSolver.conv  ,       ,     SolverConvergenceData, ,              ,   PS,    "all information about tolerances, errors and residua"
VL,     output,                   cSolver.output,       ,     SolverOutputData,  ,                  ,   PS,    "output modes and timers for exporting solver information and solution"
#VL,     newton,                   cSolver.newton,       ,     NewtonSettings,    ,                  ,   P,    "copy of newton settings from timeint or staticSolver"
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized variables for CSolverStatic:
#
V,      cSolver,                     ,                   ,     CSolverExplicitTimeInt,              ,   ,,   "link to C++ CSolver, not accessible from Python"
#copy of parameters from integration scheme (cannot be changed during integration!)
#
V,      isInitialized,               ,                   ,     bool              ,                  ,   ,,   "variable is used to see, if system is initialized ==> avoid crashes; DO not change these variables: can easily lead to crash! "
V,      initializedSystemSizes,      ,                   ,     Index4            ,                  ,   ,,   "index-array contains 4 integers: nODE2, nODE1, nAE and nData of initialization: this guaranties, that no function is called with wrong system sizes; DO not change these variables: can easily lead to crash! "
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized functions for CSolverImplicitSecondOrder:
F,      MainSolverExplicit,          ,                ,                       ,                  ,   ,D,  "constructor, in order to set valid state (settings not initialized at beginning)"
Fv,     GetCSolver,                  ,                ,     const CSolverBase&, "return cSolver;",   ,C,  "const access to cSolver"
Fv,     GetCSolver,                  ,                ,     CSolverBase&      , "return cSolver;",   ,,   "reference access to cSolver"
#
#FvL,    CheckInitialized,            ,                ,     bool,             ,  "const MainSystem& mainSystem",   DGPV,  "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError"
F,      ComputeLoadFactor,           ,                ,     Real,  "return cSolver.ComputeLoadFactor(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "for static solver, this is a factor in interval [0,1]; MUST be overwritten"
#
#++++++++++++++++++++++++++++++++++++++++++++++
#special interface to explicit solver:
F,      GetNumberOfStages,           ,                ,    Index,       "return cSolver.nStages;",, CP,      "return number of stages in current method"
F,      GetMethodOrder,              ,                ,    Index,       "return cSolver.rk.orderMethod;",,CP,"return order of method (higher value in methods with automatic step size, e.g., DOPRI5=5)"
#++++++++++++++++++++++++++++++++++++++++++++++
FvL,    GetErrorString,              ,                ,    "std::string", ,                     ,   CGPV,    "return error string if solver has not been successful"
FvL,    GetSolverName,               ,                ,    "std::string", ,                     ,   CGPV,    "get solver name - needed for output file header and visualization window"
FvL,    IsStaticSolver,              ,                ,    bool,        ,                       ,   CGPV,    "return true, if static solver; needs to be overwritten in derived class"
FvL,    GetSimulationEndTime,        ,                ,    Real,        ,                       "const SimulationSettings& simulationSettings",   CGPV,    "compute simulation end time (depends on static or time integration solver)"
FvL,    ReduceStepSize,              ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Index severity",   GPV,    "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful"
FvL,    IncreaseStepSize,            ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "increase step size if convergence is good"
FvL,    HasAutomaticStepSizeControl, ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "return true, if solver supports automatic stepsize control, otherwise false"
#initialization functions:
FvL,    InitializeSolver,            ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files"
FvL,    PreInitializeSolverSpecific, ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset"
FvL,    InitializeSolverOutput,      ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize output files; called from InitializeSolver()"
FvL,    InitializeSolverPreChecks,   ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "check if system is solvable; initialize dense/sparse computation modes"
FvL,    InitializeSolverData,        ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize all data,it,conv; called from InitializeSolver()"
FvL,    InitializeSolverInitialConditions, ,          ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "set/compute initial conditions (solver-specific!); called from InitializeSolver()"
FvL,    PostInitializeSolverSpecific,,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "post-initialize for solver specific tasks; called at the end of InitializeSolver"
#++++++++++++++++++++++++++++++++++
#solve functions:
FvL,    SolveSystem,                 ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "solve System: InitializeSolver, SolveSteps, FinalizeSolver"
FvL,    FinalizeSolver,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write concluding information (timer statistics, messages) and close files"
FvL,    SolveSteps,                  ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else"
#
FvL,    UpdateCurrentTime,           ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "update currentTime (and load factor); MUST be overwritten in special solver class"
FvL,    InitializeStep,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize static step / time step; Python-functions; do some outputs, checks, etc."
FvL,    FinishStep,                  ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",  DGPV,    "finish static step / time step; write output of results to file"
FvL,    DiscontinuousIteration,      ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual"
FvL,    Newton,                      ,                ,    bool,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform Newton method for given solver method"
#FvL,    PostNewton,                  ,                ,    Real,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "call PostNewton for all relevant objects (contact, friction, ... iterations); returns error for discontinuous iteration"
FvL,    ComputeNewtonResidual,       ,                ,    Real,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)"
FvL,    ComputeNewtonUpdate,         ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, initial=true",   GPV,    "compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0"
FvL,    ComputeNewtonJacobian,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute jacobian for newton method of given solver method; store result in systemJacobian"
#output functions:
FvL,    WriteSolutionFileHeader,     ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique file header, depending on static/ dynamic simulation"
FvL,    WriteCoordinatesToFile,      ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique coordinates solution file"
FvL,    IsVerboseCheck,              ,                ,    bool,        ,                                   "Index level",   CGPV,    "return true, if file or console output is at or above the given level"
FvL,    VerboseWrite,                ,                ,    void,        ,                                "Index level, const std::string& str",   GPV,    "write to console and/or file in case of level"

#special functions to access residua and system matrices
FvL,    GetODE2size,                 ,                ,    Index,       ,                                ,   CGP,    "number of \hac{ODE2} equations in solver"
FvL,    GetODE1size,                 ,                ,    Index,       ,                                ,   CGP,    "number of \hac{ODE1} equations in solver (not yet implemented)"
FvL,    GetAEsize,                   ,                ,    Index,       ,                                ,   CGP,    "number of algebraic equations in solver"
FvL,    GetDataSize,                 ,                ,    Index,       ,                                ,   CGP,    "number of data (history) variables in solver"
#
#FvL,    GetSystemJacobian,           ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed system jacobian of solver"
FvL,    GetSystemMassMatrix,         ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed mass matrix of solver"
FvL,    GetSystemResidual,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed system residual"
#FvL,    GetNewtonSolution,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed solution (=increment) of Newton"
#FvL,    SetSystemJacobian,           ,                ,    void,        ,                       "const py::array_t<Real>& systemJacobian",   DGPV,      "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemMassMatrix,         ,                ,    void,        ,                       "const py::array_t<Real>& systemMassMatrix",   DGPV,    "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemResidual,           ,                ,    void,        ,                       "const Vector& systemResidual",   DGPV,    "set locally stored system residual; must have size nODE2+nODE1+nAE"
#
#special functions for interaction with mainSystem:
FvL,    ComputeMassMatrix,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix"
#
FvL,    ComputeODE2RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of \hac{ODE2} equations in systemResidual in range(0,nODE2)"
FvL,    ComputeODE1RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of \hac{ODE1} equations in systemResidual in range(0,nODE1)"
#FvL,    ComputeAlgebraicEquations,   ,                ,    void,        ,                       "MainSystem& mainSystem, bool velocityLevel=false",   DGPV,    "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)"
#
#
writeFile=MainSolver.h









