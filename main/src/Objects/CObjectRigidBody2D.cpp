/** ***********************************************************************************************
* @brief        CObjectRigidBody2D implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectRigidBody2D.h"


//! Computational function: compute mass matrix
void CObjectRigidBody2D::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	//Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	//massMatrix.SetMatrix(nODE2Coordinates, nODE2Coordinates,
	//	{ parameters.physicsMass,0.,0., 
	//	  0.,parameters.physicsMass,0., 
	//	  0.,0.,parameters.physicsInertia });

	massMatrixC.SetUseDenseMatrix(false);
	SparseTripletVector& triplets = massMatrixC.GetInternalSparseTripletMatrix().GetTriplets();
	
	if (parameters.physicsMass != 0.)
	{
		triplets.AppendPure(EXUmath::Triplet(ltg[0], ltg[0], parameters.physicsMass));
		triplets.AppendPure(EXUmath::Triplet(ltg[1], ltg[1], parameters.physicsMass));
	}
	if (parameters.physicsInertia != 0.)
	{
		triplets.AppendPure(EXUmath::Triplet(ltg[2], ltg[2], parameters.physicsInertia));
	}

}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectRigidBody2D::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	ode2Lhs.SetNumberOfItems(nODE2Coordinates);
	ode2Lhs.SetAll(0.);
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectRigidBody2D::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt + 
		(Index)AccessFunctionType::DisplacementMassIntegral_q +
		(Index)AccessFunctionType::JacobianTtimesVector_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectRigidBody2D::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		Real phi = GetCNode(0)->GetCurrentCoordinate(2) + GetCNode(0)->GetCoordinateVector(ConfigurationType::Reference)[2];

		Real dAvxdphi = -sin(phi) * localPosition[0] - cos(phi) * localPosition[1];   //d(Av)x/dphi
		Real dAvydphi = cos(phi) * localPosition[0] - sin(phi) * localPosition[1];   //d(Av)x/dphi
		value.SetMatrix(3, 3, { 1.,0.,dAvxdphi, 0.,1.,dAvydphi, 0.,0.,0. }); //a 3D Vector (e.g. 3D ForceVector), acts in the (x,y)-plane on three coordinates (x,y,phi)
		break;
	}
	case AccessFunctionType::AngularVelocity_qt:
	{
		//this function relates a 3D angular velocity to the time derivative of all coordinates: omega = Jac*q_dot
		value.SetMatrix(3, 3, {0.,0.,0., 0.,0.,0., 0.,0.,1.  }); //the 3D torque vector (only z-component) acts on the 3rd coordinate phi_t
		break;
	}
	case AccessFunctionType::JacobianTtimesVector_q: //jacobian w.r.t. global position and global orientation; HACK: Matrix value(0,0:6) contains 3D force + 3D torque
	{
		//value(0,0:6) must always be set prior to this call!
		Vector3D force({ value(0,0), value(0,1), value(0,2) });
		//Vector3D torque({ value(0,3), value(0,4), value(0,5) }); //not needed, because this part is zero!

		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		Real phi = GetCNode(0)->GetCurrentCoordinate(2) + GetCNode(0)->GetCoordinateVector(ConfigurationType::Reference)[2];

		//Real dAvxdphi = -sin(phi) * localPosition[0] - cos(phi) * localPosition[1];   //d(Av)x/dphi
		//Real dAvydphi = cos(phi) * localPosition[0] - sin(phi) * localPosition[1];   //d(Av)x/dphi

		//jacT = 
		//  1., 0., 0.,
		//	0., 1., 0.,
		//	dAvxdphi, dAvydphi, 0. }); 
		//jacT*f = Vector3D({
		//        1.*f[0]+       0.*f[1]+ 0.*f[2],
		//	      0.*f[0]+       1.*f[1]+ 0.*f[2],
		//	dAvxdphi*f[0]+ dAvydphi*f[1]+ 0.*f[2] }); 
		Real d2Avxdphi2 = -cos(phi) * localPosition[0] + sin(phi) * localPosition[1];   
		Real d2Avydphi2 = -sin(phi) * localPosition[0] - cos(phi) * localPosition[1];   

		//d(jacT*f)/dq:
		value.SetMatrix(3, 3, {
		    0., 0., 0.,
			0., 0., 0.,
			0., 0., d2Avxdphi2*force[0]+ d2Avydphi2*force[1]}); 

		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetMatrix(3, 3, { parameters.physicsMass,0.,0., 0.,parameters.physicsMass,0., 0.,0.,0. }); //a 3D Vector (e.g. 3D ForceVector) acts on three coordinates (x,y,phi)
		break;
	}
	default:
		SysError("CObjectRigidBody2D:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectRigidBody2D::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::VelocityLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetVelocity(localPosition, configuration)); break; //inefficient, but useful
	case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	case OutputVariableType::AccelerationLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetAcceleration(localPosition, configuration)); break;

	case OutputVariableType::Rotation: value.CopyFrom(Vector1D( GetCNode(0)->GetCoordinateVector(configuration)[2])); break;
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::AngularAcceleration: value.CopyFrom(GetAngularAcceleration(localPosition, configuration)); break;
	case OutputVariableType::AngularAccelerationLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetAngularAcceleration(localPosition, configuration)); break;

	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(localPosition, configuration);
		value.SetVector(rot.NumberOfColumns()*rot.NumberOfRows(), rot.GetDataPointer()); 
		break;
	}
	default:
		SysError("CObjectRigidBody2D::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody2D::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + ((CNodeODE2*)GetCNode(0))->GetRotationMatrix(configuration) *localPosition;
}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectRigidBody2D::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration) +
		((CNodeODE2*)GetCNode(0))->GetRotationMatrix(configuration) *
		((CNodeODE2*)GetCNode(0))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectRigidBody2D::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \ddot R + \alpha x (A * \localPosition) + \omega x (\omega x (A * \localPosition))

	//compute local position in global coordinates (=global position of point relative to origin of body coordinate system)
	Vector3D relativePosition = ((CNodeODE2*)GetCNode(0))->GetRotationMatrix(configuration) * localPosition;
	Vector3D omega = ((CNodeODE2*)GetCNode(0))->GetAngularVelocity(configuration);

	//could be done much simpler, but kept like this as this is only used in sensors and output (not time critical)
	return ((CNodeODE2*)GetCNode(0))->GetAcceleration(configuration) +
		((CNodeODE2*)GetCNode(0))->GetAngularAcceleration(configuration).CrossProduct(relativePosition) +
		omega.CrossProduct(omega.CrossProduct(relativePosition));
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody2D::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

Matrix3D CObjectRigidBody2D::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetRotationMatrix(configuration);
}

//! AUTO:  return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CObjectRigidBody2D::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetAngularVelocity(configuration);
}

//! AUTO:  return configuration dependent angular acceleration of node; returns always a 3D Vector
Vector3D CObjectRigidBody2D::GetAngularAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetAngularAcceleration(configuration);
}

