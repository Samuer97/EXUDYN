/** ***********************************************************************************************
* @brief        CObjectFFRF implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"

#include "Autogenerated/CObjectFFRF.h"
#include "Linalg/RigidBodyMath.h"

//**delete:
//#include "Main/MainSystem.h"
//#include "Pymodules/PybindUtilities.h"
//#include "Autogenerated/MainObjectFFRF.h"
//#include <pybind11/pybind11.h>
//#include <pybind11/stl.h>
//#include <pybind11/stl_bind.h>
//#include <pybind11/operators.h>
//#include <pybind11/numpy.h>       //interface to numpy
//#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
//#include <pybind11/embed.h>       //scoped interpreter
////does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
////#include <pybind11/cast.h> //for arguments
//#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CObjectFFRF::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE2Size());
	coordinates_t.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}
}

void CObjectFFRF::ComputeObjectCoordinates_tt(Vector& coordinates_tt, ConfigurationType configuration) const
{
	coordinates_tt.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode_tt(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_tt(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates_tt[cnt + i] = vNode_tt[i];
		}
		cnt += nc;
	}
}

Index CObjectFFRF::GetODE2Size() const
{
	//Index s = 0;
	//for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	//{
	//	s += GetCNode(i)->GetNumberOfODE2Coordinates();
	//}
	//return s;
	CHECKandTHROW(coordinateIndexPerNode.NumberOfItems() != 0, "CObjectFFRF::GetODE2Size internal error: called before coordinateIndexPerNode has been initialized");
	//faster version, does not require iterations:
	Index nn = parameters.nodeNumbers.NumberOfItems();
	if (nn) { return coordinateIndexPerNode.Last() + GetCNode(nn - 1)->GetNumberOfODE2Coordinates(); }
	else { return 0; }
}

void CObjectFFRF::InitializeObject()
{
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//initialize coordinate indices
	coordinateIndexPerNode.SetNumberOfItems(parameters.nodeNumbers.NumberOfItems());

	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		coordinateIndexPerNode[i] = s;
		s += GetCNode(i)->GetNumberOfODE2Coordinates();
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//initialize all inertia shape matrices
	//Index nODE2 = GetODE2Size(); //needed here?
	Index nM = GetNumberOfMeshNodes();
	Index nODE2FF = nM * ffrfNodeDim;

	Matrix PHIt;// = np.kron(np.ones(nNodes), unit3D).T
	RigidBodyMath::ComputeBlockColumnMatrix(nM, EXUmath::unitMatrix3D, PHIt);

	//compute PHItTM;
	parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(PHIt, PHItTM); //PHItTM = PHIt^T * M

	//compute Mtt and total mass
	Matrix3D Mtt;
	EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, PHIt, Mtt);

	//Mtt = PHIt.T @ massMatrix @ PHIt
	//Mnew[0:3, 0 : 3] = Mtt
	physicsMass = Mtt(0, 0); //must be diagonal matrix with mass in diagonal

	referencePositions = Vector(nODE2FF);

	//compute center of mass //2021-03-25
	physicsCenterOfMass.CopyFrom(PHItTM * referencePositions);
	if (physicsMass != 0.)
	{
		physicsCenterOfMass *= 1 / physicsMass; //needed for application of force
	}
	else
	{
		PyWarning("CObjectFFRF::InitializeObject(): total mass is zero");
	}

	//xRefNodes = nodes.flatten() #node reference values in single vector(can be added then to q[7:])
	//xRefTilde = ComputeSkewMatrix(xRefNodes) #rfTilde without q
	Matrix xRefTilde(nODE2FF, ffrfNodeDim);
	for (Index i = 0; i < nM; i++)
	{
		Vector3D x = GetMeshNodeLocalPosition(i, ConfigurationType::Reference); //previously: GetMeshNodePosition ==> leads to wrong results, if reference position is wrong ...!

		for (Index j = 0; j < ffrfNodeDim; j++)
		{
			referencePositions[i * ffrfNodeDim + j] = x[j];
		}
		Matrix3D xTilde = RigidBodyMath::Vector2SkewMatrix(x);
		xRefTilde.SetSubmatrix(xTilde, i * ffrfNodeDim, 0);

		//LinkedDataVector xRefSub(xRefNodes, i * 3, 3);
		//xRefSub.CopyFrom(x);
		//LinkedDataVector(xRefNodes, i * 3, 3) = x; //works?
	}

	//inertiaLocal = xRefTilde.T @ massMatrix @ xRefTilde
	Matrix xRefTildeTM;
	parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(xRefTilde, xRefTildeTM);
	EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(xRefTildeTM, xRefTilde, physicsInertia);

//#define CObjectFFRFInitializeObjectOutput
#ifdef CObjectFFRFInitializeObjectOutput
	pout << "PHIt = " << PHIt.GetSubmatrix(0, 0, 6, 3) << "\n";
	pout << "PHItTM = " << PHItTM.GetSubmatrix(0, 0, 3, 6) << "\n";
	pout << "xRefTilde size = " << xRefTilde.NumberOfRows() << "," << xRefTilde.NumberOfColumns() << "\n";
	pout << "xRefTilde = " << xRefTilde.GetSubmatrix(0, 0, 6, 3) << "\n";
	pout << "inertiaLocal = " << physicsInertia << "\n";
	pout << "parameters.physicsMass = " << physicsMass << "\n";
	pout << "Mtt = " << Mtt << "\n";
#endif

	//++++++++++++++++++++++++++
	//finally
	objectIsInitialized = true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Computational function: compute mass matrix
void CObjectFFRF::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();

	//#define CObjectFFRFComputeMassMatrixOutput
	if (!objectIsInitialized) { PyError("CObjectFFRF::ComputeMassMatrix: objectIsInitialized = false: run Assemble() before computation."); }

	Index nODE2 = GetODE2Size();
	if (parameters.massMatrixUserFunction)
	{
		Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		Vector coordinates_t(nODE2);
		ComputeObjectCoordinates(coordinates, coordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		EvaluateUserFunctionMassMatrix(massMatrix, cSystemData->GetMainSystemBacklink(), t, objectNumber, coordinates, coordinates_t);
	}
	else //initialize with zero
	{
		massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
		massMatrix.SetAll(0.);
	}
	if (parameters.computeFFRFterms)
	{
		Index nODE2FF = GetNumberOfMeshNodes() * ffrfNodeDim;
		Index nODE2Rigid = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfODE2Coordinates();

		tempCoordinates.SetNumberOfItems(nODE2); 
		tempCoordinates_t.SetNumberOfItems(nODE2); 
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		//LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF);

		ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);
		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12

		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();


		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		coordinatesFF += referencePositions; //this are now the local nodal positions for mesh (FF) coordinates

		RigidBodyMath::ComputeSkewMatrix(coordinatesFF, tempRefPosSkew);

		//Mtt
		Matrix3D Mtt(3, 3);
		Mtt.SetScalarMatrix(3, physicsMass);
		massMatrix.AddSubmatrix(Mtt, 0, 0);

		//++++++++++++++++++++++++++++++++
		//Mtr = -A @ PHItTM @ rfTilde @ G
		//Mnew[0:dim3D, dim3D : dim3D + nODE2rot] = Mtr
		//Mnew[dim3D:dim3D + nODE2rot, 0 : dim3D] = Mtr.T
		Matrix3D X;
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempRefPosSkew, X);
		X = -1.*A*X;
		ConstSizeMatrix<GMaxSize> Mtr;
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, ConstSizeMatrix<GMaxSize>, ConstSizeMatrix<GMaxSize>>(X, Glocal, Mtr);

		massMatrix.AddSubmatrix(Mtr, 0, ffrfNodeDim);
		massMatrix.AddSubmatrixTransposed(Mtr, ffrfNodeDim, 0);

		//++++++++++++++++++++++++++++++++
		//#Mtf:
		//Mtf = A @ PHItTM
		//Mnew[0:dim3D, nODE2rigid : ] = Mtf
		//Mnew[nODE2rigid:, 0 : dim3D] = Mtf.T
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, Matrix, Matrix>(A, PHItTM, tempMatrix);
		massMatrix.AddSubmatrix(tempMatrix, 0, nODE2Rigid);
		massMatrix.AddSubmatrixTransposed(tempMatrix, nODE2Rigid, 0);


		//++++++++++++++++++++++++++++++++
		//#Mrf:
		//Mrf = -G.T @ rfTilde.T @ massMatrix
		//Mnew[dim3D:dim3D + nODE2rot, nODE2rigid : ] = Mrf
		//Mnew[nODE2rigid:, dim3D : dim3D + nODE2rot] = Mrf.T
		parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(tempRefPosSkew, tempMatrix);
		EXUmath::MultMatrixMatrixTemplate<ConstSizeMatrix<GMaxSize>, Matrix, Matrix>(-1.*GlocalT, tempMatrix, tempMatrix2);
		massMatrix.AddSubmatrix(tempMatrix2, ffrfNodeDim, nODE2Rigid);
		massMatrix.AddSubmatrixTransposed(tempMatrix2, nODE2Rigid, ffrfNodeDim);

		
		//++++++++++++++++++++++++++++++++
		//#Mrr:
		const Index MrrMaxSize = CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::maxRotationCoordinates;
		ConstSizeMatrix<MrrMaxSize> Mrr;
		ConstSizeMatrix<GMaxSize> temp; //gives a 4x3 matrix for EP
		//Mnew[dim3D:dim3D + nODE2rot, dim3D : dim3D + nODE2rot] = -Mrf @ rfTilde @ G   #G.T @ rfTilde.T @ massMatrix @ rfTilde @ G
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, ConstSizeMatrix<GMaxSize>>(tempMatrix2, tempRefPosSkew, temp);
		EXUmath::MultMatrixMatrixTemplate<ConstSizeMatrix<GMaxSize>, 
			ConstSizeMatrix<GMaxSize>, 
			ConstSizeMatrix<MrrMaxSize>>(temp, -1.*Glocal, Mrr);
		massMatrix.AddSubmatrix(Mrr, ffrfNodeDim, ffrfNodeDim);

		//++++++++++++++++++++++++++++++++
		//Mff:
		Index nR = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
		massMatrix.AddSubmatrix(parameters.massMatrixFF.GetEXUdenseMatrix(), nR, nR);

#ifdef CObjectFFRFComputeMassMatrixOutput
		pout << "Mtt Mtr Mtf=" << massMatrix.GetSubmatrix(0, 0, 3, 10) << "\n";
		pout << "Mrr        =" << massMatrix.GetSubmatrix(3, 3, 4, 4) << "\n";
		pout << "Mff        =" << massMatrix.GetSubmatrix(7, 7, 3, 6) << "\n";
#endif
	}
}








//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//in fact, this is the LHS function!
void CObjectFFRF::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	Index nODE2 = GetODE2Size(); //total number of coordinates
	Index nODE2FF = GetNumberOfMeshNodes() * ffrfNodeDim;
	Index nODE2Rigid = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfODE2Coordinates();

	ode2Lhs.SetNumberOfItems(nODE2);
	ode2Lhs.SetAll(0.);

	//tempCoordinates.SetNumberOfItems(nODE2); //delete
	//tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

	if (parameters.computeFFRFterms)
	{
		//K*q and D*q_T put to LHS !!!
		//link to flexible parts of vectors:
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF); //cF_t in python
		LinkedDataVector ode2LhsTT(ode2Lhs, 0, ffrfNodeDim);
		LinkedDataVector ode2LhsRR(ode2Lhs, ffrfNodeDim, nODE2Rigid-ffrfNodeDim);
		LinkedDataVector ode2LhsFF(ode2Lhs, nODE2Rigid, nODE2FF);

		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12


		if (parameters.stiffnessMatrixFF.NumberOfRows() != 0)
		{
			//EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrixFF, coordinatesFF, ode2LhsFF);
			parameters.stiffnessMatrixFF.MultMatrixVectorAdd(coordinatesFF, ode2LhsFF);
		}

		if (parameters.dampingMatrixFF.NumberOfRows() != 0)
		{
			parameters.dampingMatrixFF.MultMatrixVectorAdd(coordinatesFF_t, ode2LhsFF);

			//delete:
			//Vector test = ode2LhsFF;
			//test *= 0;
			//parameters.dampingMatrixFF.MultMatrixVectorAdd(coordinatesFF_t, test);
			//pout << "|damping term|=" << test.GetL2Norm() << "\n";
		}

		if (parameters.forceVector.NumberOfItems() != 0)
		{
			//CHECKandTHROWstring("CObjectFFRF::ComputeODE2LHS: forceVector not implemented!");
			//transformation needed, which transforms f_{ff} components from global to local coordiantes
			LinkedDataVector forceVectorRigid(parameters.forceVector, 0, nODE2Rigid);
			LinkedDataVector forceVectorFF(parameters.forceVector, nODE2Rigid, nODE2FF);
			LinkedDataVector ode2LhsRigid(ode2Lhs, 0, nODE2Rigid);

			ode2LhsRigid -= forceVectorRigid;
			Matrix3D AT = GetRotationMatrix(Vector3D({ 0, 0, 0 })).GetTransposed();
			AT *= -1; //because forceVector is subtracted
			RigidBodyMath::ApplyTransformationAndAdd(AT, forceVectorFF, ode2LhsFF);

			//ode2Lhs -= parameters.forceVector;
		}

		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();

		coordinatesFF += referencePositions; //this are now the local nodal positions for mesh (FF) coordinates; rF in python

		Vector3D omega3D = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal();
		Matrix3D omega3Dtilde = RigidBodyMath::Vector2SkewMatrix(omega3D);
		Matrix3D omega3Dtilde2 = omega3Dtilde * omega3Dtilde;

		RigidBodyMath::ComputeSkewMatrix(coordinatesFF, tempRefPosSkew); //tempRefPosSkew = rfTilde in python
		RigidBodyMath::ComputeSkewMatrix(coordinatesFF_t, tempVelSkew); //tempVelSkew = cF_tTilde in python

		//    omega = np.array(list(omega3D)*nNodes)
		//    omegaTilde = np.kron(np.eye(nNodes),omega3Dtilde)
		//    omegaTilde2 = np.kron(np.eye(nNodes),omega3Dtilde2)


		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fTrans = A @ (omega3Dtilde @ PHItTM @ rfTilde @ omega3D + 2*PHItTM @ cF_tTilde @ omega3D)
		//force[0:dim3D] = fTrans
		Matrix3D temp;
		//omega3Dtilde @ PHItTM @ rfTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempRefPosSkew, temp);
		Vector3D tempVec = temp * omega3D;
		tempVec = omega3Dtilde * tempVec;

		//2*PHItTM @ cF_tTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempVelSkew, temp);
		tempVec += temp * (2. * omega3D);
		ode2LhsTT -= A * tempVec; //-= for all ode2Lhs terms

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fRot = -G.T@(omega3Dtilde @ rfTilde.T @ massMatrix @ rfTilde @ omega3D + 
		//		        2*rfTilde.T @ massMatrix @ cF_tTilde @ omega3D)
		//force[dim3D:nODE2rigid] = fRot
		//omega3Dtilde @ (rfTilde.T @ massMatrix @ rfTilde) @ omega3D 
		parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(tempRefPosSkew, tempMatrix); //tempMatrix=rfTilde.T @ massMatrix
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(tempMatrix, tempRefPosSkew, temp);
		tempVec = omega3Dtilde * (temp * omega3D);

		//2*rfTilde.T @ massMatrix @ cF_tTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(tempMatrix, tempVelSkew, temp);
		tempVec += 2.*(temp * omega3D);

		//ode2LhsRR -= -1.*(GlocalT * tempVec); //-= for all ode2Lhs terms; NOT IMPLEMENTED, because cannot decide result vector at compile time
		EXUmath::MultMatrixVectorAdd(GlocalT, tempVec, ode2LhsRR); //double negative signs cancel!



		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fFlex = -massMatrix @ (omegaTilde2 @ rF + 2*(omegaTilde @ cF_t))
		//force[nODE2rigid:] = fFlex
		tempVector = coordinatesFF;
		RigidBodyMath::ApplyTransformation(omega3Dtilde2, tempVector);
		RigidBodyMath::ApplyTransformationAndAdd(2.*omega3Dtilde, coordinatesFF_t, tempVector);
		parameters.massMatrixFF.MultMatrixVectorAdd(tempVector, ode2LhsFF); //two negative signs cancel: fFlex = - ... and ode2LhsFF -= ...
		

		//#add gravity:
		//if False:
		//    fGrav = np.array(fGravRigid + list(PHItTM.T @ (A.T @ g)) ) #only local vector, without rotation
		//    force += fGrav
		//

	}
	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce;

		EvaluateUserFunctionForce(userForce, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t);
		//UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		//{
		//	//user function args:(t, coordinates, coordinates_t)
		//	userForce = (Vector)(parameters.forceUserFunction(t, tempCoordinates, tempCoordinates_t));
		//}, "ObjectFFRF::forceUserFunction");

		ode2Lhs -= userForce;
	}

}




//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectFFRF::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt+
		(Index)AccessFunctionType::AngularVelocity_qt + 
		//(Index)AccessFunctionType::JacobianTtimesVector_q + //to be implemented!
		(Index)AccessFunctionType::DisplacementMassIntegral_q + 
		(Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" ONLY OF reference frame, according to configuration type
void CObjectFFRF::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
#ifndef __EXUDYN__APPLE__ //static_assert not supported by older MAC compilers
	static_assert(CNodeRigidBody::nDim3D == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!
#endif
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -A*uLocalTilde*Glocal
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal
		//uLocalTilde *= -1.;//moved into (-localPosition)

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> G;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = G(i, j);
			}
		}
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());

		Real m = physicsMass;

		if (physicsCenterOfMass == 0.)
		{
			for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
			{
				for (Index j = 0; j < GetODE2Size(); j++)
				{
					if (i != j) { value(i, j) = 0.; }
					else { value(i, j) = m; } //only diagonal 3x3 term!
				}
			}
		}
		else
		{
			//gives m* \partial p_COM / \partial q
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
			((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
			CHECKandTHROW(physicsCenterOfMass == localPosition, "CObjectFFRF::GetAccessFunctionBody: inconsistent localPosition");


			ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*physicsCenterOfMass); //negative sign in -A*uLocalTilde*Glocal
			//uLocalTilde *= -1.;//moved into ((-m)*parameters.physicsCenterOfMass)

			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
			EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
			EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal=A*(-m*uLocalTilde)*Glocal

			//unit matrix
			value(0, 0) = m; value(0, 1) = 0.; value(0, 2) = 0.;
			value(1, 0) = 0.; value(1, 1) = m; value(1, 2) = 0.;
			value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m;

			//-A*uLocalTilde*Glocal part (=L in this case
			for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
			{
				for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
				{
					value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
				}
			}
		}

		break;
	}
	default:
		SysError("CObjectFFRF:GetAccessFunctionBody illegal accessType");
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     REFERENCE FRAME FUNCTIONS     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! provide according output variable in "value", localPosition ONLY REFERS TO THE REFERENCE FRAME!
void CObjectFFRF::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	Index nODE2 = GetODE2Size();
	Vector coordinates(nODE2);
	Vector coordinates_t(nODE2);
	ComputeObjectCoordinates(coordinates, coordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(coordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(coordinates_t);	break;
	case OutputVariableType::Coordinates_tt:
	{
		Vector coordinates_tt(nODE2);
		ComputeObjectCoordinates_tt(coordinates_tt, configuration);
		value.CopyFrom(coordinates_tt);
		break;
	}
	case OutputVariableType::Force:			ComputeODE2LHS(value, objectNumber);	break; //no index available
	default:
		SysError("CObjectFFRF::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}


//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRF::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * localPosition;

}

//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRF::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) displacement of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRF::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) - ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//! return the rotation matrix ONLY OF reference frame (localPosition ignored), according to configuration type
Matrix3D CObjectFFRF::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRF::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRF::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! for definition see CObjectSuperElement
void CObjectFFRF::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, Matrix& value) const
{
	CObjectSuperElement::GetAccessFunctionSuperElement(accessType, weightingMatrix, meshNodeNumbers, value);
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectFFRF::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetOutputVariableTypesSuperElement: meshNodeNumber out of range ");

	//return GetCNode(meshNodeNumber + 1)->GetOutputVariableTypes();

	//the following types are available independent of node output capabilities, as the MeshNode functions are implemented here ...
	//additional outputvariables could be added in future...
	return (OutputVariableType)(
		(Index)OutputVariableType::Position +
		(Index)OutputVariableType::Displacement +
		(Index)OutputVariableType::Velocity +
		(Index)OutputVariableType::Acceleration +
		(Index)OutputVariableType::DisplacementLocal +
		(Index)OutputVariableType::VelocityLocal);
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectFFRF::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	//return GetCNode(meshNodeNumber + 1)->GetOutputVariable(variableType, configuration, value);

	switch (variableType)
	{
	case OutputVariableType::Position:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration));	break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration) - GetMeshNodePosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::Velocity:	value.CopyFrom(GetMeshNodeVelocity(meshNodeNumber, configuration));	break;
	case OutputVariableType::Acceleration:	value.CopyFrom(GetMeshNodeAcceleration(meshNodeNumber, configuration));	break;

	case OutputVariableType::DisplacementLocal:	value.CopyFrom(GetMeshNodeLocalPosition(meshNodeNumber, configuration) - GetMeshNodeLocalPosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::VelocityLocal:	value.CopyFrom(GetMeshNodeLocalVelocity(meshNodeNumber, configuration));	break;
	default:
		SysError("CObjectFFRF::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! return the mesh node pointer; for consistency checks
CNodeODE2* CObjectFFRF::GetMeshNode(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNode: meshNodeNumber out of range");

	return (CNodeODE2*)(GetCNode(meshNodeNumber+1));
}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeLocalPosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber + 1)))->GetPosition(configuration);
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeLocalVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber + 1)))->GetVelocity(configuration);
}

//! return the (local) acceleration of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeLocalAcceleration(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeLocalAcceleration: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber + 1)))->GetAcceleration(configuration);
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodePosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	Matrix3D refRot = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	Vector3D refPos = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration);

	return refPos + refRot * GetMeshNodeLocalPosition(meshNodeNumber, configuration); //no "+1", because it is already the mesh function
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	// \dot R + A * (localVelocity +  localOmega x localPosition)
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		(GetMeshNodeLocalVelocity(meshNodeNumber, configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(GetMeshNodeLocalPosition(meshNodeNumber, configuration)));
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeAcceleration(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeAcceleration: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	Vector3D xloc = GetMeshNodeLocalPosition(meshNodeNumber, configuration);
	Vector3D xglob = A * xloc;
	Vector3D vloc = GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
	Vector3D aloc = GetMeshNodeLocalAcceleration(meshNodeNumber, configuration);
	Vector3D vglob = A * vloc;
	Vector3D omega = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocity(configuration);
	Vector3D alpha = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularAcceleration(configuration);

	// \ddot R + A * \ddot xloc + 2*omega x vglob + alpha x xglob + omega x omega x xglob
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAcceleration(configuration) +
		A * aloc + 2 * omega.CrossProduct(vglob) + alpha.CrossProduct(xglob) + omega.CrossProduct(omega.CrossProduct(xglob));
}




