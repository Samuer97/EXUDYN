/** ***********************************************************************************************
* @brief		Implementation for NodePoint2DSlope1
*
* @author		Gerstmayr Johannes
* @date			2019-06-15 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodePoint2DSlope1.h"				//includes ReleaseAssert.h, BasicDefinitions.h, ResizeableArray.h, LinkedDataVector.h

////for CallFunction(...)
//#include "Main/MainSystem.h"
//#include "Pymodules/PybindUtilities.h"
//#include "Autogenerated/MainNodePoint2DSlope1.h"


Vector3D CNodePoint2DSlope1::GetPosition(ConfigurationType configuration) const
{
	//p = pRef + u = reference position + displacement
	LinkedDataVector pRef2D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef2D[0], pRef2D[1], 0. });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	LinkedDataVector u2D = GetCoordinateVector(configuration);
	Vector3D displacement({ u2D[0], u2D[1], 0. });
	return pRef + displacement;
}

Vector3D CNodePoint2DSlope1::GetVelocity(ConfigurationType configuration) const
{
    LinkedDataVector u2D_t = GetCoordinateVector_t(configuration);
    return Vector3D({ u2D_t[0], u2D_t[1], 0. });
}

Vector3D CNodePoint2DSlope1::GetAcceleration(ConfigurationType configuration) const
{
    LinkedDataVector u2D_tt = GetCoordinateVector_tt(configuration);
    return Vector3D({ u2D_tt[0], u2D_tt[1], 0. });
}

//! AUTO:  provide position jacobian of node; derivative of 3D Position with respect to 4 coordinates ux,uy and x/y "displacements" of slopex
void CNodePoint2DSlope1::GetPositionJacobian(Matrix& value) const
{
	//derivative of position with respect to all coordinates
	value.SetMatrix(3, 4, {1.,0.,0.,0., 0.,1.,0.,0., 0.,0.,0.,0.});
}

Matrix3D CNodePoint2DSlope1::GetRotationMatrix(ConfigurationType configuration) const
{
	//slope vector = pRef' + u'
	LinkedDataVector vRef = GetCoordinateVector(ConfigurationType::Reference);
	Real phi;
	if (!(configuration == ConfigurationType::Reference))
	{
		LinkedDataVector v = GetCoordinateVector(configuration);
		phi = atan2(vRef[3] + v[3], vRef[2] + v[2]); //slope vector [1,0] is defined as zero angle
	}
	else
	{ //Reference configuration:
		phi = atan2(vRef[3], vRef[2]); //slope vector [0,1] is defined as zero angle
	}
	//phi is the total angle
	return Matrix3D(3,3,{ cos(phi),-sin(phi),0.,  sin(phi),cos(phi),0., 0.,0.,1.});
}

//! AUTO:  return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CNodePoint2DSlope1::GetAngularVelocity(ConfigurationType configuration) const
{
	//atan2(y,x) = atan(y/x)
	//diff(atan2(y,x),x) = -y/(x^2+y^2)
	//diff(atan2(y,x),y) =  x/(x^2+y^2)
	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	LinkedDataVector u = GetCoordinateVector(configuration);
	LinkedDataVector u_t = GetCoordinateVector_t(configuration);

	Real x = u[2]; //x-slopex
	Real y = u[3]; //y-slopex
	if (configuration != ConfigurationType::Reference)
	{
		x += ref[2];
		y += ref[3];
	}
	//SysError("CNodePoint2DSlope1::GetAngularVelocity: check if computation of angular velocity is correct!");
	//Real diffX = -y / (x*x + y * y)*u_t[2];
	//Real diffY =  x / (x*x + y * y)*u_t[3];

	return Vector3D({ 0., 0., (-y*u_t[2] + x*u_t[3]) / (x*x + y*y) }); 
}

void CNodePoint2DSlope1::GetRotationJacobian(Matrix& value) const
{
	//only in current configuration!
	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	LinkedDataVector u = GetCurrentCoordinateVector();

	Real x = u[2] + ref[2]; //x-slopex
	Real y = u[3] + ref[3]; //y-slopex

	Real g = (x*x + y * y);
	CHECKandTHROW(g != 0., "CNodePoint2DSlope1::GetRotationJacobian: slope vector has zero length; check initial values!");
	value.SetMatrix(3, 4, { 0.,0.,0.,0., 
							0.,0.,0.,0.,
							0.,0.,-y / g, x / g });
}

//! provide derivative w.r.t. coordinates of rotation Jacobian times vector; for current configuration
//! 4x4 matrix for all nodal coordinates
void CNodePoint2DSlope1::GetRotationJacobianTTimesVector_q(const Vector3D& vector, Matrix& jacobian_q) const 
{ 
	//only in current configuration!
	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	LinkedDataVector u = GetCurrentCoordinateVector();

	Real x = u[2] + ref[2]; //x-slopex
	Real y = u[3] + ref[3]; //y-slopex

	//{ 0.,0.,0.,
	//  0.,0.,0.,
	//	0.,0.,-y / (x*x + y * y), 
	//  0.,0., x / (x*x + y * y) }^T * v = 
	// [0.                     ]
	// [0.                     ]
	// [v[2]*(-y / (x*x + y * y))]
	// [v[2]*( x / (x*x + y * y))]
	//
	// [ v[2]*(-u'[3] * (x*x + y*y) + y*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]   //(f'g-f*g')/g^2
	// [ v[2]*(u'[2] * (x*x + y*y) - x*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]
	//
	// g2 = (x*x + y*y)^2 //(f'g-f*g')/g^2
	// d(J^T*v) / q =
	// [0.,0.,0.,0.]
	// [0.,0.,0.,0.]
	// [0.,0.,               v[2]*(y*(2*x) ) / g2, v[2]*(-(x*x + y*y) + y*(2*y) ) / g2]   
	// [0.,0., v[2]*((x*x + y*y) - x*(2*x) ) / g2, v[2]*( - x*(2*y) ) / g2            ]

	jacobian_q.SetNumberOfRowsAndColumns(4, 4);
	jacobian_q.SetAll(0.);
	Real g2 = EXUstd::Square(x*x + y * y);
	CHECKandTHROW(g2 != 0., "CNodePoint2DSlope1::GetRotationJacobianTTimesVector_q: slope vector has zero length; check initial values!");

	Real divG2 = 1. / g2;
	jacobian_q(2, 2) = vector[2] * (y*(2 * x)) * divG2;
	jacobian_q(2, 3) = vector[2] * (-(x*x + y * y) + y * (2 * y)) * divG2;
	jacobian_q(3, 2) = vector[2] * ((x*x + y * y) - x * (2 * x)) * divG2;
	jacobian_q(3, 3) = vector[2] * (-x * (2 * y)) * divG2;
}


//! provide according output variable in "value"
void CNodePoint2DSlope1::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
    case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
    case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(configuration)); break;
    case OutputVariableType::Coordinates:
	{
		if (IsValidConfiguration(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodePoint2DSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodePoint2DSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_tt:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_tt(configuration);
		}
		else
		{
			PyError("CNodePoint2DSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodePoint2DSlope1::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}


//delete:
////! call a certain function of object (autogenerated in future!)
//py::object MainNodePoint2DSlope1::CallFunction(STDstring functionName, py::dict args) const
//{
//	//these calls should be automated by python script ...
//	if (functionName == "GetTypeName")
//	{
//		return py::str(GetTypeName());
//	}
//	else if (functionName == "GetNodeType")
//	{
//		return py::cast(GetCNodePoint2DSlope1()->GetType());
//	}
//	else if (functionName == "GetNodeGroup")
//	{
//		return py::cast(GetCNodePoint2DSlope1()->GetNodeGroup());
//	}
//	else if (functionName == "GetNumberOfODE2Coordinates")
//	{
//		return py::int_(GetCNodePoint2DSlope1()->GetNumberOfODE2Coordinates());
//	}
//	else if (functionName == "GetGlobalODE2CoordinateIndex")
//	{
//		return py::int_(GetCNodePoint2DSlope1()->GetGlobalODE2CoordinateIndex());
//	}
//	else if (functionName == "GetCurrentCoordinateVector")
//	{
//		LinkedDataVector v(GetCNodePoint2DSlope1()->GetCurrentCoordinateVector());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetInitialCoordinateVector")
//	{
//		LinkedDataVector v(GetCNodePoint2DSlope1()->GetInitialCoordinateVector());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetCurrentCoordinateVector_t")
//	{
//		LinkedDataVector v(GetCNodePoint2DSlope1()->GetCurrentCoordinateVector_t());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetInitialCoordinateVector_t")
//	{
//		LinkedDataVector v(GetCNodePoint2DSlope1()->GetInitialCoordinateVector_t());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetCurrentPosition")
//	{
//		Vector3D v = GetCNodePoint2DSlope1()->GetPosition(ConfigurationType::Current);
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	//before doing so, use : https://pybind11.readthedocs.io/en/master/advanced/pycpp/numpy.html?highlight=numpy#f
//	// and matrix example : https://github.com/pybind/pybind11/blob/master/tests/test_buffers.cpp
//	//else if (functionName == "GetCurrentRotationMatrix")
//	//{
//	//	Matrix3D m = GetCNodeRigidBody2D()->GetRotationMatrix(ConfigurationType::Current);
//	//	return py::array_t<Real>(m.NumberOfItems(), m.GetDataPointer());
//	//}
//
//	PyError(STDstring("MainNodePoint2DSlope1::CallFunction called with invalid functionName '" + functionName + "'"));
//	return py::int_(EXUstd::InvalidIndex);
//}
