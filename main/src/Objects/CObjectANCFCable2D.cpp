/** ***********************************************************************************************
* @brief        CObjectANCFCable2D implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Objects/CObjectANCFCable2DBase.h"
#include "Autogenerated/CObjectANCFCable2D.h"

#include "Utilities/AutomaticDifferentiation.h"
typedef EXUmath::AutoDiff<16, Real> DReal16;

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//ANCFCable2D BASE class

//! get compressed shape function vector
//MATLAB: [(2 * x ^ 3) / L ^ 3 - (3 * x ^ 2) / L ^ 2 + 1, x - (2 * x ^ 2) / L + x ^ 3 / L ^ 2, (3 * x ^ 2) / L ^ 2 - (2 * x ^ 3) / L ^ 3, x ^ 3 / L ^ 2 - x ^ 2 / L]
Vector4D CObjectANCFCable2DBase::ComputeShapeFunctions(Real x, Real L)
{
	//Real L = GetLength();
	Real x0 = x / L;
	return Vector4D({ 1. - 3. * EXUstd::Square(x0) + 2. * EXUstd::Cube(x0),
					 x - 2. * EXUstd::Square(x) / L + x * EXUstd::Square(x0),
					 3. * EXUstd::Square(x0) - 2. * EXUstd::Cube(x0),
					 -x * (x0) + x * EXUstd::Square(x0) });
}

//! get derivative of compressed shape function vector for slopes
//MATLAB: [(6 * x ^ 2) / L ^ 3 - (6 * x) / L ^ 2, (3 * x ^ 2) / L ^ 2 - (4 * x) / L + 1, (6 * x) / L ^ 2 - (6 * x ^ 2) / L ^ 3, (3 * x ^ 2) / L ^ 2 - (2 * x) / L]
Vector4D CObjectANCFCable2DBase::ComputeShapeFunctions_x(Real x, Real L)
{
	//Real L = GetLength();
	Real L2 = L*L;
	Real L3 = L2*L;
	return Vector4D({ - 6. * x / L2+ 6. * EXUstd::Square(x)/L3,
					 1 - 4. * x / L + 3.* EXUstd::Square(x)/L2,
					 6. * x / L2 - 6. * EXUstd::Square(x)/L3,
					 -2.*x / L + 3.*EXUstd::Square(x)/L2 });
}

//! get second derivative of compressed shape function vector for slopes
//MATLAB: [(12 * x) / L ^ 3 - 6 / L ^ 2, (6 * x) / L ^ 2 - 4 / L, 6 / L ^ 2 - (12 * x) / L ^ 3, (6 * x) / L ^ 2 - 2 / L]
Vector4D CObjectANCFCable2DBase::ComputeShapeFunctions_xx(Real x, Real L)
{
	//Real L = GetLength();
	Real L2 = L * L;
	Real L3 = L2 * L;
	return Vector4D({ (12. * x) / L3 - 6. / L2,
					 (6. * x) / L2 - 4. / L,
					 6. / L2 - (12. * x) / L3,
					 (6. * x) / L2 - 2. / L });
}

//! get third derivative of compressed shape function vector for slopes
Vector4D CObjectANCFCable2DBase::ComputeShapeFunctions_xxx(Real x, Real L)
{
	//Real L = GetLength();
	Real L2 = L * L;
	Real L3 = L2 * L;
	return Vector4D({ 12. / L3,
					 6. / L2,
					 -12. / L3,
					 6. / L2 });
}



//! map element coordinates (position or veloctiy level) given by nodal vectors q0 and q1 onto compressed shape function vector to compute position, etc.
Vector2D CObjectANCFCable2DBase::MapCoordinates(const Vector4D& SV, const LinkedDataVector& q0, const LinkedDataVector& q1)
{
	Vector2D v(0.);
	v[0] += SV[0] * q0[0];
	v[1] += SV[0] * q0[1];
	v[0] += SV[1] * q0[2];
	v[1] += SV[1] * q0[3];

	v[0] += SV[2] * q1[0];
	v[1] += SV[2] * q1[1];
	v[0] += SV[3] * q1[2];
	v[1] += SV[3] * q1[3];

	return v;
}

void CObjectANCFCable2DBase::ComputeCurrentNodeCoordinates(ConstSizeVector<4>& qNode0, ConstSizeVector<4>& qNode1) const
{
	qNode0.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector()); //displacement coordinates node 0
	qNode1.CopyFrom(((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector()); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
}

void CObjectANCFCable2DBase::ComputeCurrentNodeVelocities(ConstSizeVector<4>& qNode0, ConstSizeVector<4>& qNode1) const
{
	qNode0.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t()); //velocity coordinates node 0
	qNode1.CopyFrom(((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t()); //velocity coordinates node 1
}

template<Index ancfSize>
void CObjectANCFCable2DBase::ComputeCurrentObjectCoordinates(ConstSizeVector<ancfSize>& qANCF) const
{
	const int ns = 4; //number of shape functions
	LinkedDataVector qNode0(qANCF, 0, ns);		//link node values to element vector
	LinkedDataVector qNode1(qANCF, ns, ns);		//link node values to element vector

	qNode0 = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector(); //displacement coordinates node 0
	qNode1 = ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector(); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();

	if (ancfSize > ns * 2) //for ALE-ANCF
	{
		CHECKandTHROW(ancfSize == ns * 2 + 1, "CObjectANCFCable2DBase::ComputeCurrentObjectCoordinates: invalid size");
		LinkedDataVector qALE(qANCF, 2*ns, 1);
		((CNodeODE2*)GetCNode(2))->GetCurrentAndReferenceODE2CoordinateVector(qALE); 
	}
}

template<Index ancfSize>
void CObjectANCFCable2DBase::ComputeCurrentObjectVelocities(ConstSizeVector<ancfSize>& qANCF_t) const
{
	const int ns = 4; //number of shape functions
	LinkedDataVector qNode0(qANCF_t, 0, ns);		//link node values to element vector
	LinkedDataVector qNode1(qANCF_t, ns, ns);		//link node values to element vector

	qNode0 = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(); //displacement coordinates node 0
	qNode1 = ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t(); //displacement coordinates node 1

	if (ancfSize > ns * 2) //for ALE-ANCF
	{
		qANCF_t[ancfSize-1] = ((CNodeODE2*)GetCNode(2))->GetCurrentCoordinate_t(0);
	}
}

//! Computational function: compute mass matrix
void CObjectANCFCable2DBase::PreComputeMassTerms() const
{
	if (!massMatrixComputed)
	{
		precomputedMassMatrix.SetScalarMatrix(nODE2coordinates, 0.); //set 8x8 matrix
		Real L = GetLength();
		Real rhoA = GetMassPerLength();
		const Index ns = 4;   //number of shape functions

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;
		for (auto item : EXUmath::gaussRuleOrder7Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			Vector4D SV = ComputeShapeFunctions(x, L);
			Vector4D SVint = SV;
			SVint *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder7Weights[cnt++]);

			for (Index i = 0; i < ns; i++)
			{
				for (Index j = 0; j < ns; j++)
				{
					precomputedMassMatrix(i * 2, j * 2) += SV[i] * SVint[j];
					precomputedMassMatrix(i * 2 + 1, j * 2 + 1) += SV[i] * SVint[j];
				}
			}
		}
		massMatrixComputed = true;
	}
}

//! Computational function: compute mass matrix
void CObjectANCFCable2DBase::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	PreComputeMassTerms();
	massMatrix.CopyFrom(precomputedMassMatrix); //copy
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectANCFCable2DBase::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	const Index ns = 4;   //number of shape functions
	//pout << "GetNumberOfNodes() =" << GetNumberOfNodes() << "\n";
	if (GetNumberOfNodes() == 2)
	{
		ConstSizeVector<2 * ns> qANCF;
		ConstSizeVector<2 * ns> qANCF_t;
		ComputeCurrentObjectCoordinates(qANCF);
		ComputeCurrentObjectVelocities(qANCF_t);
		ComputeODE2LHStemplate<Real>(ode2Lhs, qANCF, qANCF_t);
	}
	else //ALE
	{
		ConstSizeVector<2 * ns+1> qANCF;
		ConstSizeVector<2 * ns+1> qANCF_t;
		ComputeCurrentObjectCoordinates(qANCF);
		ComputeCurrentObjectVelocities(qANCF_t);
		ComputeODE2LHStemplate<Real>(ode2Lhs, qANCF, qANCF_t);

	}
}

////does not resolve problem in general; find other ways!
//inline void AxialStrainNumericallyStable(const DReal16& rxNorm, const SlimVectorBase<DReal16, 2>& rx, DReal16& axialStrain)
//{
//	axialStrain = rxNorm - 1.;
//	//axialStrain = ((rx[0] * rx[0] - 1.) + rx[1] * rx[1]) / (rxNorm + 1);
//}
//
//inline void AxialStrainNumericallyStable(const Real& rxNorm, const Vector2D& rx, Real& axialStrain)
//{
//	if (rx[0] > rx[1])
//	{
//		axialStrain = ((rx[0] * rx[0] - 1.) + rx[1] * rx[1]) / (rxNorm+1);
//	}
//	else
//	{
//		axialStrain = ((rx[1] * rx[1] - 1.) + rx[0] * rx[0]) / (rxNorm+1);
//	}
//
//}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
template<class TReal, Index ancfSize>
void CObjectANCFCable2DBase::ComputeODE2LHStemplate(VectorBase<TReal>& ode2Lhs, 
	const ConstSizeVectorBase<TReal, ancfSize>& qANCF, const ConstSizeVectorBase<TReal, ancfSize>& qANCF_t) const
{
	ode2Lhs.SetNumberOfItems(ancfSize); //works both for ANCF and ALE-ANCF
	ode2Lhs.SetAll(0.);
	//compute work of elastic forces:

	const Index dim = 2;  //2D finite element
	const Index ns = 4;   //number of shape functions

	bool isALE = (ancfSize == nODE2coordinates+1); //simple check to see, if ale terms shall be added

	Real L = GetLength();
	Real EA, EI, axialStrain0, curvature0, bendingDamping, axialDamping, physicsMovingMassFactor;
	GetMaterialParameters(EI, EA, bendingDamping, axialDamping, axialStrain0, curvature0, physicsMovingMassFactor);

	Index cnt;
	Real a = 0; //integration interval [a,b]
	Real b = L;

	ConstSizeVector<2 * ns> qANCFref;
	if (StrainIsRelativeToReference() != 0.)
	{
		LinkedDataVector qNode0ref(qANCFref, 0, ns);		//link node values to element vector
		LinkedDataVector qNode1ref(qANCFref, ns, ns);		//link node values to element vector
		qNode0ref = ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector();
		qNode1ref = ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
	}

	ConstSizeVectorBase<TReal, ancfSize> elasticForces;

	//numerical integration:
	//accurate integration: axialStrain = order9, curvature = order5
	//reduced order 1: axialStrain = order7, curvature = order3 (lower Gauss order not possible, becomes unstable or very inaccurate ...
	//reduced order 2: axialStrain = order4, curvature = order3 (less oscillations in axial strains, if evaluated at [0,0.5L,L]
	//reduced order 3: axialStrain = order6, curvature = order5 
	//reduced order 4: axialStrain = order5, curvature = order6 

	const Index maxIntegrationPoints = 5;
	ConstSizeVector<maxIntegrationPoints> integrationPoints;
	ConstSizeVector<maxIntegrationPoints> integrationWeights;

	if (UseReducedOrderIntegration() == 0) //A9-B5 (max. integration axial order 9, bending order 5)
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder9Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder9Weights);
	}
	else if (UseReducedOrderIntegration() == 1) //A7-B3
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder7Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder7Weights);
	}
	else if (UseReducedOrderIntegration() == 2) //A4-B3 ; gives excellent axial strain at 0, L/2 and L !!
	{
		integrationPoints.CopyFrom(EXUmath::lobattoRuleOrder3Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::lobattoRuleOrder3Weights);
	}
	else { CHECKandTHROWstring("ObjectANCFCable2DBase::ComputeODE2LHS: useReducedOrderIntegration must be between 0 and 2"); }

	//axial strain:
	cnt = 0;
	for (auto item : integrationPoints)
	{
		Real x = 0.5*(b - a)*item + 0.5*(b + a);
		Vector4D SVx = ComputeShapeFunctions_x(x, L);
		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);

		SlimVectorBase<TReal, dim> rx = MapCoordinates<TReal>(SVx, qANCF);

		TReal rxNorm2 = rx.GetL2NormSquared();
		TReal rxNorm = sqrt(rxNorm2);

		TReal axialStrain = rxNorm - 1.; // axial strain
		TReal axialStrain_t = 0.; //rate of axial strain

		Real axialStrainRef = axialStrain0;
		if (StrainIsRelativeToReference() != 0.)
		{
			SlimVector<dim> rxRef = MapCoordinates<Real>(SVx, qANCFref);
			axialStrainRef += StrainIsRelativeToReference()*(rxRef.GetL2Norm() - 1.);
		}

		if (axialDamping != 0.)
		{
			SlimVectorBase<TReal, dim> rx_t = MapCoordinates<TReal>(SVx, qANCF_t);
			if (!isALE || physicsMovingMassFactor != 1.)
			{
				axialStrain_t = (rx * rx_t) / rxNorm; //rate of axial strain
			}
			else
			{
				Vector4D SVxx = ComputeShapeFunctions_xx(x, L);
				SlimVectorBase<TReal, dim> rxx = MapCoordinates<TReal>(SVxx, qANCF);
				TReal vALE = qANCF_t[ancfSize - 1];
				axialStrain_t = (rx * (vALE * rxx + rx_t) ) / rxNorm;
			}
		}

		//term due to variation of axialStrain
		for (Index i = 0; i < dim; i++)
		{
			for (Index j = 0; j < ns; j++)
			{
				elasticForces[j*dim + i] = 1. / rxNorm * SVx[j] * rx[i];
			}
		}

		if (isALE)
		{
			if (AddALEvariation())
			{
				Vector4D SVxx = ComputeShapeFunctions_xx(x, L);
				SlimVectorBase<TReal, dim> rxx = MapCoordinates<TReal>(SVxx, qANCF);

				elasticForces[ancfSize - 1] = (rx * rxx) / rxNorm;
			}
			else
			{
				elasticForces[ancfSize - 1] = 0.; //must be set to zero!
			}
		}

		//elasticForces *= integrationFactor * GetParameters().physicsAxialStiffness * (axialStrain - GetParameters().physicsReferenceAxialStrain);
		elasticForces *= integrationFactor * (EA * (axialStrain - axialStrainRef) + axialDamping * axialStrain_t);

		ode2Lhs += elasticForces;  //add to element elastic forces
	}

	//++++++++++++++++++++++++++++++
	//curvature:

	if (UseReducedOrderIntegration() == 0) //A9-B5 (max. integration axial order 9, bending order 5)
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder5Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder5Weights);
	}
	else if (UseReducedOrderIntegration() == 1) //A7-B3
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points); 
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
	}
	else if (UseReducedOrderIntegration() == 2) //A4-B3 ; gives excellent axial strain at 0, L/2 and L !!
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points); 
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
	}
	//else if (UseReducedOrderIntegration() == 3) //A6-B5
	//{
	//	integrationPoints.CopyFrom(EXUmath::gaussRuleOrder5Points); 
	//	integrationWeights.CopyFrom(EXUmath::gaussRuleOrder5Weights);
	//}
	//else if (UseReducedOrderIntegration() == 4) //A5-B6
	//{
	//	integrationPoints.CopyFrom(EXUmath::lobattoRuleOrder5Points);  
	//	integrationWeights.CopyFrom(EXUmath::lobattoRuleOrder5Weights);
	//}
	else { CHECKandTHROWstring("ObjectANCFCable2DBase::ComputeODE2LHS: useReducedOrderIntegration must be between 0 and 2"); }

	cnt = 0;
	for (auto item : integrationPoints)
	{
		Real x = 0.5*(b - a)*item + 0.5*(b + a);
		Vector4D SVx = ComputeShapeFunctions_x(x, L);
		Vector4D SVxx = ComputeShapeFunctions_xx(x, L);
		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);

		//Vector2D rx = MapCoordinates(SVx, q0, q1);
		//Vector2D rxx = MapCoordinates(SVxx, q0, q1);
		SlimVectorBase<TReal, dim> rx = MapCoordinates<TReal>(SVx, qANCF);
		SlimVectorBase<TReal, dim> rxx = MapCoordinates<TReal>(SVxx, qANCF);

		TReal rxNorm2 = rx.GetL2NormSquared();				//g
		//TReal rxNorm = sqrt(rxNorm2);				
		TReal rxCrossRxx = rx.CrossProduct2D(rxx);			//f
		TReal curvature = rxCrossRxx / rxNorm2;				//kappa = (rx x rxx)/rx^2       //material measure of curvature

		Real curvatureRef = curvature0;
		if (StrainIsRelativeToReference() != 0.)
		{
			SlimVector<dim> rxRef = MapCoordinates<Real>(SVx, qANCFref);
			SlimVector<dim> rxxRef = MapCoordinates<Real>(SVxx, qANCFref);

			Real rxNorm2ref = rxRef.GetL2NormSquared();
			Real rxCrossRxxRef = rxRef.CrossProduct2D(rxxRef);
			curvatureRef += StrainIsRelativeToReference()*(rxCrossRxxRef / rxNorm2ref);
		}

		TReal inv2RxNorm2 = 1. / (rxNorm2*rxNorm2);			//g2inv
		TReal tempF = 2. * rxCrossRxx*inv2RxNorm2;			//fn; f ... fraction numerator
		TReal tempG = rxNorm2 * inv2RxNorm2;				//gn; g ... fraction denominator
		TReal df;

		TReal curvature_t = 0.; //rate of curvature
		if (bendingDamping != 0.)
		{
			//Vector2D rx_t = MapCoordinates(SVx, q0_t, q1_t);
			//Vector2D rxx_t = MapCoordinates(SVxx, q0_t, q1_t);
			SlimVectorBase<TReal, dim> rx_t = MapCoordinates<TReal>(SVx, qANCF_t);
			SlimVectorBase<TReal, dim> rxx_t = MapCoordinates<TReal>(SVxx, qANCF_t);

			TReal rxCrossRxx_t = rx_t.CrossProduct2D(rxx) + rx.CrossProduct2D(rxx_t);	//f_t
			TReal rxNorm2_t = 2.*(rx*rx_t);												//g_t

			if (!isALE || physicsMovingMassFactor != 1.)
			{
				curvature_t = (rxCrossRxx_t * rxNorm2 - rxCrossRxx * rxNorm2_t) / EXUstd::Square(rxNorm2); //rate of bending strain; (f_t*g - f*g_t)/g^2
			}
			else
			{
				TReal vALE = qANCF_t[ancfSize - 1];
				SlimVectorBase<TReal, dim> vx = vALE * rxx + rx_t;

				Vector4D SVxxx = ComputeShapeFunctions_xxx(x, L);
				SlimVectorBase<TReal, dim> rxxx = MapCoordinates<TReal>(SVxxx, qANCF);

				SlimVectorBase<TReal, dim> vxx = vALE * rxxx + rxx_t;

				TReal rxCrossVxx = vx.CrossProduct2D(rxx) + rx.CrossProduct2D(vxx); //this substitutes rxCrossRxx_t in curvature_t of ANCF

				TReal rxvx = 2.*(rx*vx);  //this substitutes rxNorm2_t

				curvature_t = (rxCrossVxx * rxNorm2 - rxCrossRxx * rxvx) / EXUstd::Square(rxNorm2);
			}
		}

		for (Index i = 0; i < dim; i++)
		{
			for (Index j = 0; j < ns; j++)
			{
				switch (i) {
				case 0:
				{
					df = SVx[j] * rxx.Y() - SVxx[j] * rx.Y(); break;
				}
				case 1:
				{
					df = -SVx[j] * rxx.X() + SVxx[j] * rx.X(); break;
				}
				default:;
				}
				TReal dg = rx[i] * SVx[j]; //derivative of denominator
				elasticForces[j*dim + i] = df * tempG - tempF * dg;
			}
		}
		if (isALE)
		{
			if (AddALEvariation())
			{
				Vector4D SVxxx = ComputeShapeFunctions_xxx(x, L);
				SlimVectorBase<TReal, dim> rxxx = MapCoordinates<TReal>(SVxxx, qANCF);

				elasticForces[ancfSize - 1] = inv2RxNorm2 * (rxNorm2*rx.CrossProduct2D(rxxx) - 2.*rxCrossRxx*(rx*rxx));
			}
			else
			{
				elasticForces[ancfSize - 1] = 0.; //must be set to zero!
			}
		}


		//elasticForces *= integrationFactor * GetParameters().physicsBendingStiffness * (curvature - GetParameters().physicsReferenceCurvature);
		elasticForces *= integrationFactor * (EI * (curvature - curvatureRef) + bendingDamping * curvature_t);

		ode2Lhs += elasticForces;  //add to element elastic forces
	}

}

//! jacobian of LHS, w.r.t. position AND velocity level coordinates
//void CObjectANCFCable2DBase::ComputeJacobianODE2_ODE2(ResizableMatrix& jacobian, ResizableMatrix& jacobian_ODE2_t) const
void CObjectANCFCable2DBase::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp, 
	Real factorODE2, Real factorODE2_t,
	Index objectNumber, const ArrayIndex& ltg) const
{
	const Index ns = 4;   //number of shape functions
	ConstSizeVector<2*ns> qANCF0;
	ConstSizeVector<2*ns> qANCF0_t;
	ConstSizeVectorBase<DReal16, 2*ns> qANCF;
	ConstSizeVectorBase<DReal16, 2*ns> qANCF_t;
	ComputeCurrentObjectCoordinates(qANCF0);
	ComputeCurrentObjectVelocities(qANCF0_t);
	for (Index i = 0; i < 2 * ns; i++)
	{
		qANCF[i] = qANCF0[i];
		qANCF_t[i] = qANCF0_t[i];
		qANCF[i].DValue((int)i) = 1; //mark that this is the corresponding derivative
		qANCF_t[i].DValue((int)(i+2*ns)) = 1; //mark that this is the corresponding derivative; velocity derivatives are in second block
	}
	ConstSizeVectorBase<DReal16, 2 * ns> ode2Lhs;
	LinkedDataVectorBase<DReal16> linkedOde2Lhs(ode2Lhs); //added because of decoupling of ConstSizeVectorBase

	ComputeODE2LHStemplate<DReal16>(linkedOde2Lhs, qANCF, qANCF_t);

	jacobianODE2.SetUseDenseMatrix(true);
	ResizableMatrix& jac = jacobianODE2.GetInternalDenseMatrix();
	jac.SetNumberOfRowsAndColumns(2 * ns, 2 * ns);

	//now copy autodifferentiated result:
	for (Index i = 0; i < 2 * ns; i++)
	{
		for (Index j = 0; j < 2 * ns; j++)
		{
			jac(i, j) = factorODE2*ode2Lhs[i].DValue((int)j) + factorODE2_t*ode2Lhs[i].DValue((int)(j + 2 * ns));
		}
	}

	//jacobian.SetNumberOfRowsAndColumns(2 * ns, 2 * ns);
	//jacobian_ODE2_t.SetNumberOfRowsAndColumns(2 * ns, 2 * ns);

	////now copy autodifferentiated result:
	//for (Index i = 0; i < 2 * ns; i++)
	//{
	//	for (Index j = 0; j < 2 * ns; j++)
	//	{
	//		jacobian(i, j) = ode2Lhs[i].DValue((int)j);
	//		jacobian_ODE2_t(i, j) = ode2Lhs[i].DValue((int)(j+2*ns));
	//	}
	//}
}


//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectANCFCable2DBase::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt +
		//TODO: (Index)AccessFunctionType::JacobianTtimesVector_q +
		(Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
OutputVariableType CObjectANCFCable2DBase::GetOutputVariableTypes() const
{
	return (OutputVariableType)((Index)OutputVariableType::Position + (Index)OutputVariableType::Velocity);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectANCFCable2DBase::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	Real L = GetLength();

	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		const Index dim = 2;  //2D finite element
		const Index ns = 4;   //number of shape functions

		Real x = localPosition[0]; //only x-coordinate
		Vector4D SV = ComputeShapeFunctions(x, L);
		value.SetNumberOfRowsAndColumns(3, 8); //3D velocity, 8 coordinates qt
		//pout << "inside ..." << localPosition << "\n";

		if (localPosition[1] == 0)
		{
			value.SetAll(0.);
			value(0, 0) = SV[0];
			value(1, 1) = SV[0];
			value(0, 2) = SV[1];
			value(1, 3) = SV[1];
			value(0, 4) = SV[2];
			value(1, 5) = SV[2];
			value(0, 6) = SV[3];
			value(1, 7) = SV[3];
		}
		else
		{
			if (false)
			{
				//pout << "in\n";
				value.SetAll(0.);
				Real y = localPosition[1];
				Vector4D SV_x = ComputeShapeFunctions_x(x, L);
				Vector2D r_x = ComputeSlopeVector(x, ConfigurationType::Current);
				Real norm = r_x.GetL2Norm();
				Real normInv = 0;
				Vector2D n({ -r_x[1], r_x[0] });
				if (norm != 0.)
				{
					normInv = 1. / norm;
				}
				else
				{
					CHECKandTHROWstring("CObjectANCFCable2DBase::GetAccessFunctionBody(...): slope vector has length 0!");
				}
				n *= normInv;
				//p = r(localPosition[0]) + localPosition[1] * n; n=1/sqrt(rx^T*rx)*[-rx[1],rx[0]]
				//dp/dq = S + (ry^T*S_x)/(rx^T*rx) (3/2) * n + 1/sqrt(rx^T*rx) * S_x^perpendicular
				Real norm3 = norm * norm * norm; //could be SIMPLIFIED, because n also contains 1/norm ....

				//pout << "  slope=" << r_x << ", norm=" << norm << ", n=" << n << "\n";
				//
				for (Index i = 0; i < ns; i++)
				{
					Vector2D Svec[dim]; //SV_x
					Svec[0] = Vector2D({ SV_x[i],0 });
					Svec[1] = Vector2D({ 0, SV_x[i] });
					Vector2D SvecP[2];
					SvecP[0] = Vector2D({ 0., SV_x[i] });
					SvecP[1] = Vector2D({ -SV_x[i], 0. });

					for (Index j = 0; j < dim; j++)
					{
						Real u = -y * (r_x*Svec[j]) / norm3;
						value(0, i * dim + j) = u * n[0] + y * normInv * SvecP[j][0];
						value(1, i * dim + j) = u * n[1] + y * normInv * SvecP[j][1];

						value(j, i * dim + j) += SV[i];
					}

				}
			}
			else
			{
				//simpler version:
				Real y = localPosition[1];
				Vector4D SV_x = ComputeShapeFunctions_x(x, L);
				Vector2D r_x = ComputeSlopeVector(x, ConfigurationType::Current);
				Real norm = r_x.GetL2Norm();
				Real normInv = 0;
				Vector2D n({ -r_x[1], r_x[0] });
				if (norm != 0.)
				{
					normInv = 1. / norm;
				}
				else
				{
					CHECKandTHROWstring("CObjectANCFCable2DBase::GetAccessFunctionBody(...): slope vector has length 0!");
				}
				Vector2D t0 = normInv * r_x;

				//v = r_t + (-y*omega)*t0
				//omega = (n * r'_t)/(r')^2 = (-r'y*r'_xt + r'x*r'_yt)/(r')^2 //see CNodePoint2DSlope1::GetAngularVelocity
				//dv/dq_t = [S-y*diadic(t0, omega_qt)] = [S - y/(r')^2 * diadic(t0, n) * S')

				for (Index i = 0; i < ns; i++)
				{
					for (Index j = 0; j < dim; j++)
					{
						Real omega_qt = n[j] * SV_x[i] * (normInv*normInv);
						value(0, i * dim + j) = -y * omega_qt * t0[0];
						value(1, i * dim + j) = -y * omega_qt * t0[1];

						value(j, i * dim + j) += SV[i];
					}
				}
			}
		}

		break;
	}
	case AccessFunctionType::AngularVelocity_qt:
	{
		//const Index dim = 2;  //2D finite element
		const Index ns = 4;   //number of shape functions

		Real xLoc = localPosition[0]; //only x-coordinate
		Vector2D slope = ComputeSlopeVector(xLoc, ConfigurationType::Current);
		Real x = slope[0]; //x-slopex
		Real y = slope[1]; //y-slopex

		Vector4D SVx = ComputeShapeFunctions_x(xLoc, L);
		Real fact0 = -y / (x*x + y * y);
		Real fact1 = x / (x*x + y * y);

		value.SetNumberOfRowsAndColumns(3, 8);
		value.SetAll(0.); //last row not necessary to set to zero ... 
		for (Index i = 0; i < ns; i++)
		{
			value(2, i*2) = SVx[i] * fact0; //last row of jacobian
			value(2, i*2 + 1) = SVx[i] * fact1;
		}

		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		//const Index dim = 2;  //2D finite element
		//const Index ns = 4;   //number of shape functions

		value.SetNumberOfRowsAndColumns(3, 8); //3D velocity, 8 coordinates qt
		value.SetAll(0.);

		Real L = GetLength();
		Real rhoA = GetMassPerLength();

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;

		Vector4D SV({0.,0.,0.,0.});

		for (auto item : EXUmath::gaussRuleOrder3Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			Vector4D SVloc = ComputeShapeFunctions(x, L);
			SVloc *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder3Weights[cnt++]);
			SV += SVloc;
		}

		value(0, 0) = SV[0];
		value(1, 1) = SV[0];
		value(0, 2) = SV[1];
		value(1, 3) = SV[1];
		value(0, 4) = SV[2];
		value(1, 5) = SV[2];
		value(0, 6) = SV[3];
		value(1, 7) = SV[3];
		break;
	}
	default:
		SysError("CObjectANCFCable2D:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectANCFCable2DBase::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	//outputVariables = "{
	//'Position':'global position vector of local axis (1) and cross section (2) position', 
	//'Velocity':'global velocity vector of local axis (1) and cross section (2) position', 
	//'Director1':'(axial) slope vector of local axis position', 
	//'Strain':'axial strain (scalar)', 
	//'Curvature':'axial strain (scalar)', 
	//'Force':'(local) section normal force (scalar)', 
	//'Torque':'(local) bending moment (scalar)'}"
	Real x = localPosition[0];
	Real y = localPosition[1];
	bool isALE = (GetNumberOfNodes() != 2);

	switch (variableType)
	{
	case OutputVariableType::Position:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration)); break;
	}
	case OutputVariableType::Displacement:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	}
	case OutputVariableType::Velocity:
	{
		value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::VelocityLocal:
	{
		value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed() * 
			GetVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::Acceleration:
	{
		//only for ANCFCable, but not ALEANCF ==> not included in GetOutputVariableTypes(...)
		value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	}
	case OutputVariableType::AngularVelocity:
	{
		//independent of y, but correct
		value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::AngularVelocityLocal:
	{
		//independent of y, but correct
		value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::AngularAcceleration:
	{
		//only for ANCFCable, but not ALEANCF
		//independent of y, but correct
		value.CopyFrom(GetAngularAcceleration(localPosition, configuration)); break;
	}
	case OutputVariableType::Rotation:
	{
		Real x = localPosition[0]; //only x-coordinate
		Vector2D vRef = ComputeSlopeVector(x, configuration);

		Real phi = atan2(vRef[1], vRef[0]); //slope vector [1,0] is defined as zero angle (atan2(0,1) == 0.)
		value.CopyFrom(Vector1D(phi)); break;
	}
	case OutputVariableType::Director1: {
		//CHECKandTHROW(y == 0., "CObjectANCFCable2DBase::GetOutputVariableBody: Y-component of localPosition must be zero for Director1");
		Vector2D rx = ComputeSlopeVector(localPosition[0], configuration);
		value.SetVector({rx[0], rx[1], 0.});
		break; }
	case OutputVariableType::StrainLocal:	
	{
		//CHECKandTHROW(y == 0., "CObjectANCFCable2DBase::GetOutputVariableBody: Y-component of localPosition must be zero for StrainLocal");
		Real strain = ComputeAxialStrain(x, configuration);
		if (y != 0.)
		{
			strain -= y * ComputeCurvature(x, configuration);
		}

		value.SetVector({ strain }); 
		break;
	}
	case OutputVariableType::CurvatureLocal:	
	{
		//CHECKandTHROW(y == 0., "CObjectANCFCable2DBase::GetOutputVariableBody: Y-component of localPosition must be zero for CurvatureLocal");
		value.SetVector({ ComputeCurvature(x, configuration) });
		break;
	}
	case OutputVariableType::ForceLocal: {
		//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFCable2DBase::GetOutputVariableBody: Y-component of localPosition must be zero for ForceLocal");
		Real physicsBendingStiffness, physicsAxialStiffness, bendingDamping, axialDamping, physicsReferenceAxialStrain, physicsReferenceCurvature, physicsMovingMassFactor;
		GetMaterialParameters(physicsBendingStiffness, physicsAxialStiffness, bendingDamping, axialDamping, physicsReferenceAxialStrain, physicsReferenceCurvature, physicsMovingMassFactor);

		Real axialStrainRef = physicsReferenceAxialStrain;
		if (StrainIsRelativeToReference() != 0.)
		{
			Vector2D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
			axialStrainRef += StrainIsRelativeToReference()*(rxRef.GetL2Norm() - 1.);
		}

		Real force = physicsAxialStiffness * (ComputeAxialStrain(x, configuration) - axialStrainRef);
		if (axialDamping != 0) { force += axialDamping * ComputeAxialStrain_t(x, isALE, physicsMovingMassFactor, configuration); }

		value.SetVector({ force }); break;
	}
	case OutputVariableType::TorqueLocal: {
		//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFCable2DBase::GetOutputVariableBody: Y-component of localPosition must be zero for TorqueLocal");
		Real physicsBendingStiffness, physicsAxialStiffness, physicsReferenceAxialStrain, physicsReferenceCurvature, bendingDamping, axialDamping, physicsMovingMassFactor;
		GetMaterialParameters(physicsBendingStiffness, physicsAxialStiffness, bendingDamping, axialDamping, physicsReferenceAxialStrain, physicsReferenceCurvature, physicsMovingMassFactor);

		Real curvatureRef = physicsReferenceCurvature;
		if (StrainIsRelativeToReference() != 0.)
		{
			Vector2D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
			Vector2D rxxRef = ComputeSlopeVector_x(x, ConfigurationType::Reference);

			Real rxNorm2ref = rxRef.GetL2NormSquared();
			Real rxCrossRxxRef = rxRef.CrossProduct2D(rxxRef);
			curvatureRef += StrainIsRelativeToReference()*(rxCrossRxxRef / rxNorm2ref);
		}

		Real torque = physicsBendingStiffness * (ComputeCurvature(x, configuration) - curvatureRef);
		if (bendingDamping != 0) { torque += bendingDamping * ComputeCurvature_t(x, isALE, physicsMovingMassFactor, configuration); }
		value.SetVector({ torque }); break;
	}
	default:
		SysError("CObjectANCFCable2D::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFCable2DBase::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0]; //only x-coordinate
	Vector4D SV = ComputeShapeFunctions(x, GetLength());
	
	Vector2D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference)
	{
		v += MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}
	//include off-axis position:
	if (localPosition[1] != 0.)
	{
		Vector2D r_x = ComputeSlopeVector(x, configuration);
		Real norm = r_x.GetL2Norm();
		if (norm != 0.)
		{
			r_x *= 1. / norm;
			Vector2D n({ -r_x[1], r_x[0] });
			v += localPosition[1] * n;
		} else
		{ CHECKandTHROWstring("CObjectANCFCable2DBase::GetPosition(...): slope vector has length 0!"); }

	}

	return Vector3D({v[0],v[1],0.});

}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectANCFCable2DBase::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0]; 
	Real y = localPosition[1]; 
	Vector4D SV = ComputeShapeFunctions(x, GetLength());

	Vector2D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	//Vector2D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(), ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t());

	if (y != 0.)
	{
		Vector2D rx0 = ComputeSlopeVector(x, configuration);
		Real rxNorm = rx0.GetL2Norm();
		if (rxNorm != 0.) { rx0 *= 1. / rxNorm; }

		v += (-y * GetAngularVelocity(localPosition, configuration)[2]) * rx0;
		//Vector3D vOmega = GetAngularVelocity(localPosition, configuration)[2] * GetRotationMatrix(localPosition, configuration) * Vector3D({ -y, 0., 0. });
		//v += Vector2D({vOmega[0], vOmega[1]});
	}
	return Vector3D({ v[0],v[1],0. });
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectANCFCable2DBase::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	//???check accelerations and angular accelerations, etc.

	Real x = localPosition[0];
	Real y = localPosition[1];
	Vector4D SV = ComputeShapeFunctions(x, GetLength());

	//Vector2D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	Vector2D a = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_tt(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_tt(configuration));

	if (y != 0.)
	{
		Vector2D rx = ComputeSlopeVector(x, configuration);
		Real rxNorm = rx.GetL2Norm();
		Real invRxNorm = 0.;
		if (rxNorm != 0.) { invRxNorm = 1. / rxNorm; }

		//rx0 = rx/norm(rx) ==> rx0_t = (rx_t*norm(rx) - rx*norm(rx)_t)/norm(rx)^2
		Vector2D rx_t = ComputeSlopeVector_t(x, configuration);
		Real normRx_t = invRxNorm * rx*rx_t;
		Vector2D rx0_t = (rxNorm*rx_t - rx*(normRx_t))*invRxNorm*invRxNorm;

		Vector2D rx0 = invRxNorm*rx;
		a += (-y * GetAngularAcceleration(localPosition, configuration)[2]) * rx0 + (-y * GetAngularVelocity(localPosition, configuration)[2]) * rx0_t;
	}
	return Vector3D({ a[0],a[1],0. });
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFCable2DBase::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	if (localPosition[1] != 0.)
	{
		Real x = localPosition[0]; //only x-coordinate
		Vector4D SV = ComputeShapeFunctions(x, GetLength());

		Vector2D v(0.);
		if (configuration != ConfigurationType::Reference)
		{
			v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
		}
		return Vector3D({ v[0],v[1],0. });
	}
	else
	{
		//slower, but includes off-axis part
		return GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference);
	}
}

Matrix3D CObjectANCFCable2DBase::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	//return ((CNodeODE2*)GetCNode(0))->GetRotationMatrix(configuration);

	//compute slope vector:
	Real x = localPosition[0]; //only x-coordinate
	Vector2D vRef = ComputeSlopeVector(x, configuration);

	//compute angle from slope vector
	Real phi = atan2(vRef[1], vRef[0]); //slope vector [1,0] is defined as zero angle (atan2(0,1) == 0.)
	return Matrix3D(3, 3, { cos(phi),-sin(phi),0.,  sin(phi),cos(phi),0., 0.,0.,1. });
}

//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CObjectANCFCable2DBase::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	//for details see GetAngularVelocity in Point2DSlope1

	Real xLoc = localPosition[0]; //only x-coordinate
	Vector2D slope = ComputeSlopeVector(xLoc, configuration);
	Real x = slope[0]; //x-slopex
	Real y = slope[1]; //y-slopex

	Vector4D SVx = ComputeShapeFunctions_x(xLoc, GetLength());
	Vector2D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	//Vector2D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(), ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t());

	//compare this function to GetRotationMatrix(...)
	return Vector3D({ 0., 0., (-y * slope_t[0] + x * slope_t[1]) / (x*x + y * y) });
}

//! return configuration dependent angular acceleration of node; returns always a 3D Vector
Vector3D CObjectANCFCable2DBase::GetAngularAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real xLoc = localPosition[0]; //only x-coordinate
	Vector2D slope = ComputeSlopeVector(xLoc, configuration);
	Real x = slope[0]; //x-slopex
	Real y = slope[1]; //y-slopex

	Vector4D SVx = ComputeShapeFunctions_x(xLoc, GetLength());
	Vector2D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	Vector2D slope_tt = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_tt(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_tt(configuration));

	Real x_t = slope_t[0];
	Real y_t = slope_t[1];
	Real x_tt = slope_tt[0];
	Real y_tt = slope_tt[1];

	Real f = (-y * x_t + x * y_t);
	Real g = (x * x + y * y);
	Real f_t = (-y_t * x_t + x_t * y_t) + (-y * x_tt + x * y_tt);
	Real g_t = (2*x_t*x + 2*y_t * y);

	return Vector3D({ 0., 0., (f_t*g - f*g_t)/(g*g) });
}

Vector2D CObjectANCFCable2DBase::ComputeSlopeVector(Real x, ConfigurationType configuration) const
{
	Vector4D SVx = ComputeShapeFunctions_x(x, GetLength());

	Vector2D slope = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
	{
		slope += MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return slope;

}

Vector2D CObjectANCFCable2DBase::ComputeSlopeVector_x(Real x, ConfigurationType configuration) const
{
	Vector4D SVxx = ComputeShapeFunctions_xx(x, GetLength());

	Vector2D slope_x = MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
	{
		slope_x += MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return slope_x;

}

//!  compute the axial strain at a certain axial position, for given configuration
Real CObjectANCFCable2DBase::ComputeAxialStrain(Real x, ConfigurationType configuration) const 
{
	Vector2D rx = ComputeSlopeVector(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared();
	Real rxNorm = sqrt(rxNorm2);
	return rxNorm - 1.; // axial strain
}

//!  compute the (bending) curvature at a certain axial position, for given configuration
Real CObjectANCFCable2DBase::ComputeCurvature(Real x, ConfigurationType configuration) const
{
	Vector2D rx = ComputeSlopeVector(x, configuration);
	Vector2D rxx = ComputeSlopeVector_x(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared(); //computation see ComputeODE2LHS(...)
	//Real rxNorm = sqrt(rxNorm2);
	Real rxCrossRxx = rx.CrossProduct2D(rxx);
	return rxCrossRxx / rxNorm2; //curvature
}

Vector2D CObjectANCFCable2DBase::ComputeSlopeVector_t(Real x, ConfigurationType configuration) const
{
	Vector4D SVx = ComputeShapeFunctions_x(x, GetLength());

	return MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}

Vector2D CObjectANCFCable2DBase::ComputeSlopeVector_xt(Real x, ConfigurationType configuration) const
{
	Vector4D SVxx = ComputeShapeFunctions_xx(x, GetLength());

	return MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}

//!  compute the axial strain at a certain axial position, for given configuration
Real CObjectANCFCable2DBase::ComputeAxialStrain_t(Real x, bool isALE, Real physicsMovingMassFactor, ConfigurationType configuration) const
{
	CHECKandTHROW(!(isALE && physicsMovingMassFactor == 1), "ANCFCable2d:ComputeAxialStrain_t not implemented for ALE case with physicsMovingMassFactor=1");

	Vector2D rx = ComputeSlopeVector(x, configuration);
	Vector2D rx_t = ComputeSlopeVector_t(x, configuration);
	Real rxNorm2 = rx.GetL2NormSquared();
	Real rxNorm = sqrt(rxNorm2);

	return (rx * rx_t) / rxNorm; //rate of axial strain
}


//!  compute the (bending) curvature at a certain axial position, for given configuration
Real CObjectANCFCable2DBase::ComputeCurvature_t(Real x, bool isALE, Real physicsMovingMassFactor, ConfigurationType configuration) const
{
	CHECKandTHROW(!(isALE && physicsMovingMassFactor == 1), "ANCFCable2d:ComputeCurvature_t not implemented for ALE case with physicsMovingMassFactor=1");

	Vector2D rx = ComputeSlopeVector(x, configuration);
	Vector2D rxx = ComputeSlopeVector_x(x, configuration);

	Vector2D rx_t = ComputeSlopeVector_t(x, configuration);
	Vector2D rxx_t = ComputeSlopeVector_xt(x, configuration);

	//apply differentiation formula: (f/g)' = (f'g - fg') / g^2
	Real g = rx.GetL2NormSquared();				//g
	Real f = rx.CrossProduct2D(rxx);			//f
	Real f_t = rx_t.CrossProduct2D(rxx) + rx.CrossProduct2D(rxx_t);
	Real g_t = 2 * (rx_t * rx);

	return (f_t*g - f * g_t) / EXUstd::Square(g);
}



//delete:
////++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
////ANCFCable2D MAIN part
//py::object MainObjectANCFCable2D::CallFunction(STDstring functionName, py::dict args) const
//{
//	PyError(STDstring("MainObjectMassPoint::CallFunction called with invalid functionName '" + functionName + "'"));
//	return py::int_(EXUstd::InvalidIndex);
//}



//OLD AUTODIFF:
////! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//template<class TReal>
//void CObjectANCFCable2DBase::ComputeODE2LHStemplate(VectorBase<TReal>& ode2Lhs, const ConstSizeVectorBase<TReal, nODE2coordinates>& qANCF, const ConstSizeVectorBase<TReal, nODE2coordinates>& qANCF_t) const
//{
//	ode2Lhs.SetNumberOfItems(nODE2coordinates);
//	ode2Lhs.SetAll(0.);
//	//compute work of elastic forces:
//
//	const Index dim = 2;  //2D finite element
//	const Index ns = 4;   //number of shape functions
//
//	Real L = GetLength();
//	Real EA, EI, axialStrain0, curvature0, bendingDamping, axialDamping;
//	GetMaterialParameters(EI, EA, bendingDamping, axialDamping, axialStrain0, curvature0);
//
//	Index cnt;
//	Real a = 0; //integration interval [a,b]
//	Real b = L;
//
//
//	ConstSizeVectorBase<TReal, ns*dim> elasticForces;
//
//	//numerical integration:
//	//high accuracy: axialStrain = order9, curvature = order5
//	//low accuracy : axialStrain = order7, curvature = order3 (lower order not possible, becomes unstable or very inaccurate ...
//
//	const Index maxIntegrationPoints = 5;
//	ConstSizeVector<maxIntegrationPoints> integrationPoints;
//	ConstSizeVector<maxIntegrationPoints> integrationWeights;
//
//	if (UseReducedOrderIntegration())
//	{
//		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder7Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
//		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder7Weights);
//	}
//	else
//	{
//		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder9Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
//		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder9Weights);
//	}
//
//	//axial strain:
//	cnt = 0;
//	for (auto item : integrationPoints)
//	{
//		Real x = 0.5*(b - a)*item + 0.5*(b + a);
//		Vector4D SVx = ComputeShapeFunctions_x(x, L);
//		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);
//
//		SlimVectorBase<TReal, 2> rx = MapCoordinates<TReal>(SVx, qANCF);
//
//		TReal rxNorm2 = rx.GetL2NormSquared();
//		TReal rxNorm = sqrt(rxNorm2);
//		TReal axialStrain = rxNorm - 1.; // axial strain
//		TReal axialStrain_t = 0.; //rate of axial strain
//
//		if (axialDamping != 0.)
//		{
//			SlimVectorBase<TReal, 2> rx_t = MapCoordinates<TReal>(SVx, qANCF_t);
//			axialStrain_t = (rx * rx_t) / rxNorm; //rate of axial strain
//		}
//
//		for (Index i = 0; i < dim; i++)
//		{
//			for (Index j = 0; j < ns; j++)
//			{
//				elasticForces[j*dim + i] = 1. / rxNorm * SVx[j] * rx[i];
//			}
//		}
//		//elasticForces *= integrationFactor * GetParameters().physicsAxialStiffness * (axialStrain - GetParameters().physicsReferenceAxialStrain);
//		elasticForces *= integrationFactor * (EA * (axialStrain - axialStrain0) + axialDamping * axialStrain_t);
//
//		ode2Lhs += elasticForces;  //add to element elastic forces
//	}
//
//	//++++++++++++++++++++++++++++++
//	//curvature:
//	if (UseReducedOrderIntegration())
//	{
//		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points);
//		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
//	}
//	else
//	{
//		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder5Points);
//		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder5Weights);
//	}
//
//	cnt = 0;
//	for (auto item : integrationPoints)
//	{
//		Real x = 0.5*(b - a)*item + 0.5*(b + a);
//		Vector4D SVx = ComputeShapeFunctions_x(x, L);
//		Vector4D SVxx = ComputeShapeFunctions_xx(x, L);
//		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);
//
//		SlimVectorBase<TReal, 2> rx = MapCoordinates<TReal>(SVx, qANCF);
//		SlimVectorBase<TReal, 2> rxx = MapCoordinates<TReal>(SVxx, qANCF);
//
//		TReal rxNorm2 = rx.GetL2NormSquared();				//g
//		//TReal rxNorm = sqrt(rxNorm2);
//		TReal rxCrossRxx = rx.CrossProduct2D(rxx);			//f
//		TReal curvature = rxCrossRxx / rxNorm2;				//kappa = (rx x rxx)/rx^2       //WRONG (Andreas/Matlab?): kappa = sqrt(cross2d(rp, rpp) ^ 2) / (rp'*rp);        // material measure of curvature
//
//		TReal inv2RxNorm2 = 1. / (rxNorm2*rxNorm2);			//g2inv
//		TReal tempF = 2. * rxCrossRxx*inv2RxNorm2;			//fn; f ... fraction numerator
//		TReal tempG = rxNorm2 * inv2RxNorm2;					//gn; g ... fraction denominator
//		TReal df;
//
//		TReal curvature_t = 0.; //rate of curvature
//		if (bendingDamping != 0.)
//		{
//			SlimVectorBase<TReal, 2> rx_t = MapCoordinates<TReal>(SVx, qANCF_t);
//			SlimVectorBase<TReal, 2> rxx_t = MapCoordinates<TReal>(SVxx, qANCF_t);
//
//			TReal rxCrossRxx_t = rx_t.CrossProduct2D(rxx) + rx.CrossProduct2D(rxx_t);	//f_t
//			TReal rxNorm2_t = 2.*(rx*rx_t);												//g_t
//
//			curvature_t = (rxCrossRxx_t * rxNorm2 - rxCrossRxx * rxNorm2_t) / EXUstd::Square(rxNorm2); //rate of bending strain; (f_t*g - f*g_t)/g^2
//		}
//
//		for (Index i = 0; i < dim; i++)
//		{
//			for (Index j = 0; j < ns; j++)
//			{
//				switch (i) {
//				case 0:
//				{
//					df = SVx[j] * rxx.Y() - SVxx[j] * rx.Y(); break;
//				}
//				case 1:
//				{
//					df = -SVx[j] * rxx.X() + SVxx[j] * rx.X(); break;
//				}
//				default:;
//				}
//				TReal dg = rx[i] * SVx[j]; //derivative of denominator
//				elasticForces[j*dim + i] = df * tempG - tempF * dg;
//			}
//		}
//		//elasticForces *= integrationFactor * GetParameters().physicsBendingStiffness * (curvature - GetParameters().physicsReferenceCurvature);
//		elasticForces *= integrationFactor * (EI * (curvature - curvature0) + bendingDamping * curvature_t);
//
//		ode2Lhs += elasticForces;  //add to element elastic forces
//	}
//}
//

