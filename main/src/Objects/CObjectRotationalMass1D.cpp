/** ***********************************************************************************************
* @brief        CObjectRotationalMass1D implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectRotationalMass1D.h"
#include "Linalg/RigidBodyMath.h"


//! Computational function: compute mass matrix
void CObjectRotationalMass1D::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	massMatrix.SetScalarMatrix(1, parameters.physicsInertia);
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectRotationalMass1D::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	ode2Lhs.SetNumberOfItems(1);
	ode2Lhs.SetAll(0.);
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectRotationalMass1D::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt+
		(Index)AccessFunctionType::JacobianTtimesVector_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectRotationalMass1D::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		CHECKandTHROW((localPosition[0] == 0) && (localPosition[1] == 0), "ObjectRotationalMass1D::GetAccessFunctionBody: BodyMarkers and Loads to ObjectRotationalMass1D can only act at localPosition[0]==0 and localPosition[1]==0; otherwise use ObjectRigidBody2D");
		//would require to compute action on axis: similar to ObjectRigidBody2D, then depends on coordinates (sin/cos)?
		//v = GetRotationMatrix(...) * (Vector3D({ 0.,0.,omegaLocal }) x localPosition)
		//dv/dq_t = ...
		value.SetMatrix(3, 1, { 0.,0.,0. }); //a ForceVector has no action on RotationalMass1D
		break;
	}
	case AccessFunctionType::AngularVelocity_qt:
	{
		//this function relates a 3D angular velocity to the time derivative of all coordinates: omega = Jac*q_dot
		Vector3D v = parameters.referenceRotation * Vector3D({ 0.,0.,1. }); //local angular velocity is around z-axis!
		value.SetMatrix(3, 1, {v[0], v[1], v[2]}); //the 3D torque vector (only z-component) acts on the 3rd coordinate phi_t
		break;
	}
	case AccessFunctionType::JacobianTtimesVector_q: //jacobian w.r.t. global position and global orientation; HACK: Matrix value(0,0:6) contains 3D force + 3D torque
	{
		CHECKandTHROW((localPosition[0] == 0) && (localPosition[1] == 0), "ObjectRotationalMass1D::GetAccessFunctionBody [JacobianTtimesVector_q]: BodyMarkers and Loads to ObjectRotationalMass1D can only act at localPosition[0]==0 and localPosition[1]==0; otherwise use ObjectRigidBody2D");
		value.SetNumberOfRowsAndColumns(0, 0); //indicates that all entries are zero
		break;
	}
	//case AccessFunctionType::DisplacementMassIntegral_q:
	//{
	//	value.SetMatrix(3, 1, { 0.,0.,0. }); //no action of gravity!
	//	break;
	//}
	default:
		SysError("CObjectRotationalMass1D:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectRotationalMass1D::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::Rotation: value.CopyFrom(Vector1D( GetRotationAngle(configuration))); break;
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(localPosition, configuration);
		value.SetVector(rot.NumberOfColumns()*rot.NumberOfRows(), rot.GetDataPointer()); 
		break;
	}
	default:
		SysError("CObjectRotationalMass1D::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! return the rotation angle (reference+current) according to configuration type
Real CObjectRotationalMass1D::GetRotationAngle(ConfigurationType configuration) const
{
	Real phiRef = ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector()[0];
	if (configuration == ConfigurationType::Reference) { return phiRef; }
	return phiRef + ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration)[0];
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRotationalMass1D::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return GetRotationMatrix(localPosition, configuration) * localPosition + parameters.referencePosition;
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRotationalMass1D::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return GetRotationMatrix(localPosition, configuration) * GetAngularVelocityLocal(localPosition, configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRotationalMass1D::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return GetPosition(localPosition,configuration) - GetPosition(localPosition, ConfigurationType::Reference); //this also works for NodePointGround
}

Matrix3D CObjectRotationalMass1D::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real phi = GetRotationAngle(configuration);
	return parameters.referenceRotation * RigidBodyMath::RotationMatrix3(phi); //rotation around local z-axis
}

//! return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CObjectRotationalMass1D::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real omega = ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration)[0];
	return parameters.referenceRotation * Vector3D({ 0.,0.,omega }); //rotation around local z-axis
}

//! return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CObjectRotationalMass1D::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real omega = ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration)[0];
	return Vector3D({ 0.,0.,omega });//rotation around local z-axis
}

