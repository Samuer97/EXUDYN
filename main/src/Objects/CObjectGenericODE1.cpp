/** ***********************************************************************************************
* @brief        CObjectGenericODE1 implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"

#include "Main/CSystemData.h"
#include "Linalg/RigidBodyMath.h"

#include "Autogenerated/CObjectGenericODE1.h"
#include "Pymodules/PybindUtilities.h"


void CObjectGenericODE1::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE1Size());
	coordinates_t.SetNumberOfItems(GetODE1Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE1Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE1*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}

}

void CObjectGenericODE1::ComputeObjectCoordinates(Vector& coordinates, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE1Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE1Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
		}
		cnt += nc;
	}

}

//! Computational function: compute right-hand-side (RHS) of first order ordinary differential equations (ODE) to "ODE1Rhs"
//in fact, this is the LHS function!
void CObjectGenericODE1::ComputeODE1RHS(Vector& ODE1Rhs, Index objectNumber) const
{
	Index nODE1 = GetODE1Size();
	ODE1Rhs.SetNumberOfItems(nODE1);
	ODE1Rhs.SetAll(0.);

	//Vector coordinates(nODE1); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	//Vector coordinates_t(nODE1);
	tempCoordinates.SetNumberOfItems(nODE1);
	ComputeObjectCoordinates(tempCoordinates);

	if (parameters.systemMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.systemMatrix, tempCoordinates, ODE1Rhs);
	}

	if (parameters.rhsVector.NumberOfItems() != 0)
	{
		ODE1Rhs += parameters.rhsVector;
	}

	if (parameters.rhsUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce;

		EvaluateUserFunctionRHS(userForce, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates);
		CHECKandTHROW(userForce.NumberOfItems() == nODE1, "CObjectGenericODE1: forceUserFunction return a vector with different size from ObjectGenericODE1 system size");

		ODE1Rhs += userForce;
	}

}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectGenericODE1::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::_None); //currently no access possible (no markers, no loads; apply input only to nodes)
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectGenericODE1::GetAccessFunction(AccessFunctionType accessType, Matrix& value) const
{
	SysError("CObjectGenericODE1:GetAccessFunction not available");
}

//! provide according output variable in "value"
void CObjectGenericODE1::GetOutputVariable(OutputVariableType variableType, Vector& value, ConfigurationType configuration, Index objectNumber) const
{
	Index nODE1 = GetODE1Size();
	tempCoordinates.SetNumberOfItems(nODE1);
	tempCoordinates_t.SetNumberOfItems(nODE1);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(tempCoordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(tempCoordinates_t);	break;
	default:
		SysError("CObjectGenericODE1::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}


Index CObjectGenericODE1::GetODE1Size() const
{
	//faster version, does not require iterations:
	Index nn = parameters.nodeNumbers.NumberOfItems();
	if (nn) { return parameters.coordinateIndexPerNode.Last() + GetCNode(nn - 1)->GetNumberOfODE1Coordinates(); }
	else { return 0; }
}

void CObjectGenericODE1::InitializeCoordinateIndices()
{
	parameters.coordinateIndexPerNode.SetNumberOfItems(parameters.nodeNumbers.NumberOfItems());

	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		parameters.coordinateIndexPerNode[i] = s;
		if (!EXUstd::IndexIsInRange(parameters.nodeNumbers[i], 0, cSystemData->GetCNodes().NumberOfItems()))
		{
			PyError("ObjectGenericODE1: invalid node number detected; all nodes used in ObjectGenericODE1 must already exist");
		}
		else
		{
			s += GetCNode(i)->GetNumberOfODE1Coordinates();
		}
	}
}




