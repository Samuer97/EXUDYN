/** ***********************************************************************************************
* @brief        Implementation for VisualizationNodePoint
*
* @author       Gerstmayr Johannes
* @date         2018-04-18 (generated)
* @date         2019-05-27 (last modfied)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include <ostream>
//#include <array>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h" //includes stdoutput.h
#include "Utilities/BasicFunctions.h"	//includes stdoutput.h


#include "Linalg/BasicLinalg.h"		//includes Vector.h
#include "Linalg/Geometry.h"		//for reeving system

//#include "Main/MainSystem.h" //do not include pybind here!

#include "Graphics/VisualizationSystemContainer.h"
#include "Graphics/VisualizationPrimitives.h"
//#include "Pymodules/PybindUtilities.h" //do not include pybind here!
#include "Linalg/KinematicsBasics.h" //for geometrically exact beams

//++++++++++++++++++++++++++
//should not be needed, appropriate functions added to visualization objects
#include "Autogenerated/CNodePoint.h"
#include "Autogenerated/CNodePointGround.h"
#include "Autogenerated/CNodePoint2D.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CNodeRigidBodyRxyz.h"
#include "Autogenerated/CNodeRigidBodyRotVecLG.h"
#include "Autogenerated/CNodeRigidBodyRotVecDataLG.h"
#include "Autogenerated/CNodeRigidBody2D.h"
#include "Autogenerated/CNodePoint2DSlope1.h"
#include "Autogenerated/CNodePoint3DSlope1.h"
#include "Autogenerated/CNodePoint3DSlope23.h"

#include "Autogenerated/CObjectMassPoint.h"
#include "Autogenerated/CObjectMassPoint2D.h"
#include "Autogenerated/CObjectMass1D.h"
#include "Autogenerated/CObjectRotationalMass1D.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Autogenerated/CObjectRigidBody2D.h"
#include "Autogenerated/CObjectGenericODE2.h"
#include "Autogenerated/CObjectKinematicTree.h"
#include "Autogenerated/CObjectFFRF.h"
#include "Autogenerated/CObjectGround.h"

#include "Autogenerated/CObjectANCFCable2D.h"
#include "Autogenerated/CObjectALEANCFCable2D.h"
#include "Autogenerated/CObjectANCFBeam.h"
#include "Autogenerated/CObjectBeamGeometricallyExact2D.h"
#include "Autogenerated/CObjectBeamGeometricallyExact.h"

#include "Autogenerated/CObjectConnectorSpringDamper.h"
#include "Autogenerated/CObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/CObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/CObjectConnectorLinearSpringDamper.h"
#include "Autogenerated/CObjectConnectorTorsionalSpringDamper.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/CObjectConnectorHydraulicActuatorSimple.h"
#include "Autogenerated/CObjectConnectorReevingSystemSprings.h"
#include "Autogenerated/CObjectConnectorDistance.h"
#include "Autogenerated/CObjectConnectorCoordinate.h"
#include "Autogenerated/CObjectConnectorRollingDiscPenalty.h"
#include "Autogenerated/CObjectContactConvexRoll.h"
#include "Autogenerated/CObjectContactCoordinate.h"
#include "Autogenerated/CObjectContactCircleCable2D.h"
#include "Autogenerated/CObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/CObjectContactFrictionCircleCable2DOld.h"
#include "Autogenerated/CObjectJointGeneric.h"
#include "Autogenerated/CObjectJointRevoluteZ.h"
#include "Autogenerated/CObjectJointPrismaticX.h"
#include "Autogenerated/CObjectJointSpherical.h"
#include "Autogenerated/CObjectJointRollingDisc.h"
#include "Autogenerated/CObjectJointRevolute2D.h"
#include "Autogenerated/CObjectJointPrismatic2D.h"
#include "Autogenerated/CObjectJointSliding2D.h"
#include "Autogenerated/CObjectJointALEMoving2D.h"

#include "Autogenerated/CMarkerBodyPosition.h"
#include "Autogenerated/CMarkerBodyRigid.h"
#include "Autogenerated/CMarkerBodyMass.h"
#include "Autogenerated/CMarkerNodePosition.h"
#include "Autogenerated/CMarkerNodeRigid.h"
#include "Autogenerated/CMarkerSuperElementPosition.h"
#include "Autogenerated/CMarkerSuperElementRigid.h"
#include "Autogenerated/CMarkerKinematicTreeRigid.h"
#include "Autogenerated/CMarkerBodyCable2DShape.h"
#include "Autogenerated/CMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/CLoadForceVector.h"
#include "Autogenerated/CLoadTorqueVector.h"
#include "Autogenerated/CLoadMassProportional.h"

//#include "Autogenerated/CSensorNode.h" //unused
#include "Autogenerated/CSensorObject.h"
#include "Autogenerated/CSensorBody.h"
#include "Autogenerated/CSensorSuperElement.h"
#include "Autogenerated/CSensorKinematicTree.h"


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include "Autogenerated/VisuNodePoint.h"
#include "Autogenerated/VisuNodePointGround.h"
#include "Autogenerated/VisuNodePoint2D.h"
#include "Autogenerated/VisuNodeRigidBodyEP.h"
#include "Autogenerated/VisuNodeRigidBodyRxyz.h"
#include "Autogenerated/VisuNodeRigidBodyRotVecLG.h"
#include "Autogenerated/VisuNodeRigidBodyRotVecDataLG.h"
#include "Autogenerated/VisuNodeRigidBody2D.h"
#include "Autogenerated/VisuNodePoint2DSlope1.h"
#include "Autogenerated/VisuNodePoint3DSlope1.h"
#include "Autogenerated/VisuNodePoint3DSlope23.h"

#include "Autogenerated/VisuObjectMassPoint.h"
#include "Autogenerated/VisuObjectMassPoint2D.h"
#include "Autogenerated/VisuObjectMass1D.h"
#include "Autogenerated/VisuObjectRotationalMass1D.h"
#include "Autogenerated/VisuObjectRigidBody.h"
#include "Autogenerated/VisuObjectRigidBody2D.h"
#include "Autogenerated/VisuObjectGenericODE2.h"
#include "Autogenerated/VisuObjectKinematicTree.h"
#include "Autogenerated/VisuObjectFFRF.h"
#include "Autogenerated/VisuObjectGround.h"

#include "Autogenerated/VisuObjectANCFCable2D.h"
#include "Autogenerated/VisuObjectALEANCFCable2D.h"
#include "Autogenerated/VisuObjectANCFBeam.h"
#include "Autogenerated/VisuObjectBeamGeometricallyExact2D.h"
#include "Autogenerated/VisuObjectBeamGeometricallyExact.h"

#include "Autogenerated/VisuObjectConnectorSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/VisuObjectConnectorLinearSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorTorsionalSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorHydraulicActuatorSimple.h"
#include "Autogenerated/VisuObjectConnectorReevingSystemSprings.h"
#include "Autogenerated/VisuObjectConnectorDistance.h"
#include "Autogenerated/VisuObjectConnectorCoordinate.h"
#include "Autogenerated/VisuObjectConnectorRollingDiscPenalty.h"
#include "Autogenerated/VisuObjectContactConvexRoll.h"
#include "Autogenerated/VisuObjectContactCoordinate.h"
#include "Autogenerated/VisuObjectContactCircleCable2D.h"
#include "Autogenerated/VisuObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/VisuObjectContactFrictionCircleCable2DOld.h"
#include "Autogenerated/VisuObjectJointGeneric.h"
#include "Autogenerated/VisuObjectJointRevoluteZ.h"
#include "Autogenerated/VisuObjectJointPrismaticX.h"
#include "Autogenerated/VisuObjectJointSpherical.h"
#include "Autogenerated/VisuObjectJointRollingDisc.h"
#include "Autogenerated/VisuObjectJointRevolute2D.h"
#include "Autogenerated/VisuObjectJointPrismatic2D.h"
#include "Autogenerated/VisuObjectJointSliding2D.h"
#include "Autogenerated/VisuObjectJointALEMoving2D.h"

#include "Autogenerated/VisuMarkerBodyPosition.h"
#include "Autogenerated/VisuMarkerBodyRigid.h"
#include "Autogenerated/VisuMarkerBodyMass.h"
#include "Autogenerated/VisuMarkerNodePosition.h"
#include "Autogenerated/VisuMarkerNodeRigid.h"
#include "Autogenerated/VisuMarkerSuperElementPosition.h"
#include "Autogenerated/VisuMarkerSuperElementRigid.h"
#include "Autogenerated/VisuMarkerKinematicTreeRigid.h"
#include "Autogenerated/VisuMarkerBodyCable2DShape.h"
#include "Autogenerated/VisuMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/VisuLoadForceVector.h"
#include "Autogenerated/VisuLoadTorqueVector.h"
#include "Autogenerated/VisuLoadMassProportional.h"

#include "Autogenerated/VisuSensorNode.h"
#include "Autogenerated/VisuSensorObject.h"
#include "Autogenerated/VisuSensorBody.h"
#include "Autogenerated/VisuSensorSuperElement.h"
#include "Autogenerated/VisuSensorKinematicTree.h"
#include "Autogenerated/VisuSensorMarker.h"


#include <pybind11/stl.h> 
#include <pybind11/stl_bind.h>
#include <pybind11/numpy.h> //accept numpy arrays: numpy array automatically converted to std::vector<Real,...> ==> accepts np.array([1,0,0]) and [1,0,0] as return value!



//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint* cNode = (CNodePoint*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}


	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	//Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.general.sphereTiling : visualizationSettings.general.circleTiling;
	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePointGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePointGround* cNode = (CNodePointGround*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2D* cNode = (CNodePoint2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}
	if (visualizationSettings.nodes.drawNodesAsPoint) { vSystem->graphicsData.AddSphere(pos, currentColor, itemID); }
	else { vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 2 * visualizationSettings.nodes.tiling, itemID); }

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyEP::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyEP* cNode = (CNodeRigidBodyEP*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}


	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint, 
			visualizationSettings.general.axesTiling, 2.5, nn, "N");
	}
	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRxyz::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRxyz* cNode = (CNodeRigidBodyRxyz*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint,
			visualizationSettings.general.axesTiling, 2.5, nn, "N");
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRotVecLG::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRotVecLG* cNode = (CNodeRigidBodyRotVecLG*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint,
			visualizationSettings.general.axesTiling, 2.5, nn, "N");
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRotVecDataLG::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRotVecDataLG* cNode = (CNodeRigidBodyRotVecDataLG*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint,
			visualizationSettings.general.axesTiling, 2.5, nn, "N");
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBody2D* cNode = (CNodeRigidBody2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}


	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint,
			visualizationSettings.general.axesTiling, 2.5, nn, "N");
	}
	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2DSlope1::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2DSlope1* cNode = (CNodePoint2DSlope1*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 2 * visualizationSettings.nodes.tiling, itemID);

	if (visualizationSettings.nodes.showNodalSlopes)
	{
		Vector3D vec;
		//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
		vec = A * Vector3D({ 8 * radius, 0., 0. }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor, itemID);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint3DSlope1::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint3DSlope1* cNode = (CNodePoint3DSlope1*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showNodalSlopes)
	{
		Vector3D vec;
		//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
		vec = A * Vector3D({ 8 * radius,  0., 0. }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor, itemID);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint3DSlope23::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Node, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint3DSlope23* cNode = (CNodePoint3DSlope23*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) {
		radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if (((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes()) && visualizationSettings.contour.nodesColored)
	{
		Vector& value = vSystem->tempVector;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, currentColor);
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showNodalSlopes)
	{
		Vector3D vec;
		//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
		vec = A * Vector3D({ 0., 8 * radius,  0. }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor, itemID);
		vec = A * Vector3D({ 0., 0., 8 * radius }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor, itemID);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "N", visualizationSettings.nodes.defaultColor); }
}






//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//BODIES


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectMassPoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint* cObject = (CObjectMassPoint*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF;
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization));
	bool useContourColor = ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes()) && visualizationSettings.contour.rigidBodiesColored;
	if (useContourColor)
	{
		Float3 refPos3DF;
		refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));

		Float3 vel3DF;		//global
		Float3 angVel3DF(0.f);	//global
		if (visualizationSettings.contour.outputVariable == OutputVariableType::Velocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::VelocityLocal)
		{
			vel3DF.CopyFrom(cObject->GetVelocity(Vector3D(0.), ConfigurationType::Visualization));
		}
		//transform graphics data with rigid body transformation (includes lines, triangles, points, ...) AND set contour color
		EXUvis::AddBodyGraphicsDataColored(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, refPos3DF, EXUmath::unitMatrix3DF, 
			vel3DF, angVel3DF, itemID, visualizationSettings, useContourColor);
	}
	else //fast track
	{
		EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, itemID);
	}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }
	 
}

void VisualizationObjectMassPoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint2D* cObject = (CObjectMassPoint2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF;
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization));
	Float3 refPos3DF;
	refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));
	bool useContourColor = ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes()) && visualizationSettings.contour.rigidBodiesColored;
	if (useContourColor)
	{
		Float3 refPos3DF;
		refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));

		Float3 vel3DF;		//global
		Float3 angVel3DF(0.f);	//global
		if (visualizationSettings.contour.outputVariable == OutputVariableType::Velocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::VelocityLocal)
		{
			vel3DF.CopyFrom(cObject->GetVelocity(Vector3D(0.), ConfigurationType::Visualization));
		}
		//transform graphics data with rigid body transformation (includes lines, triangles, points, ...) AND set contour color
		EXUvis::AddBodyGraphicsDataColored(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, refPos3DF, EXUmath::unitMatrix3DF,
			vel3DF, angVel3DF, itemID, visualizationSettings, useContourColor);
	}
	else //fast track
	{
		EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, itemID);
	}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }
}

void VisualizationObjectMass1D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMass1D* cObject = (CObjectMass1D*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF;
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization));
	Float3 refPos3DF;
	refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));
	bool useContourColor = ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes()) && visualizationSettings.contour.rigidBodiesColored;
	if (useContourColor)
	{
		Float3 refPos3DF;
		refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));

		Float3 vel3DF;		//global
		Float3 angVel3DF(0.f);	//global
		if (visualizationSettings.contour.outputVariable == OutputVariableType::Velocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::VelocityLocal)
		{
			vel3DF.CopyFrom(cObject->GetVelocity(Vector3D(0.), ConfigurationType::Visualization));
			//angVel3DF.CopyFrom(cObject->GetAngularVelocity(Vector3D(0.), ConfigurationType::Visualization));
		}
		//transform graphics data with rigid body transformation (includes lines, triangles, points, ...) AND set contour color
		EXUvis::AddBodyGraphicsDataColored(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, refPos3DF, EXUmath::unitMatrix3DF,
			vel3DF, angVel3DF, itemID, visualizationSettings, useContourColor);
	}
	else //fast track
	{
		EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, itemID);
	}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }
}

void VisualizationObjectRotationalMass1D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRotationalMass1D* cObject = (CObjectRotationalMass1D*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF; //=refPos3DF in CObjectRotationalMass1D!
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization));
	Float3 refPos3DF;
	refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));
	Matrix3DF Rot3DF;
	Rot3DF.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));
	Matrix3DF RefRot3DF;
	RefRot3DF.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Reference));

	bool useContourColor = ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes()) && visualizationSettings.contour.rigidBodiesColored;
	if (useContourColor)
	{
		Float3 refPos3DF;
		refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));

		Float3 vel3DF(0.f);		//global
		Float3 angVel3DF;	//global
		if (visualizationSettings.contour.outputVariable == OutputVariableType::AngularVelocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::AngularVelocityLocal)
		{
			angVel3DF.CopyFrom(cObject->GetAngularVelocity(Vector3D(0.), ConfigurationType::Visualization));
		}
		//transform graphics data with rigid body transformation (includes lines, triangles, points, ...) AND set contour color
		EXUvis::AddBodyGraphicsDataColored(graphicsData, vSystem->graphicsData, pos3DF, Rot3DF, refPos3DF, RefRot3DF,
			vel3DF, angVel3DF, itemID, visualizationSettings, useContourColor);
	}
	else //fast track
	{
		EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, Rot3DF, itemID);
	}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody* cObject = (CObjectRigidBody*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF;
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization));
	Float3 refPos3DF;
	refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));
	Matrix3DF Rot3DF;
	Rot3DF.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));
	Matrix3DF RefRot3DF;
	RefRot3DF.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Reference));

	bool useContourColor = ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes()) && visualizationSettings.contour.rigidBodiesColored;
	if (useContourColor)
	{
		Float3 refPos3DF;
		refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));

		Float3 vel3DF;		//global
		Float3 angVel3DF;	//global
		if (visualizationSettings.contour.outputVariable == OutputVariableType::Velocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::VelocityLocal ||
			visualizationSettings.contour.outputVariable == OutputVariableType::AngularVelocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::AngularVelocityLocal)
		{
			vel3DF.CopyFrom(cObject->GetVelocity(Vector3D(0.), ConfigurationType::Visualization));
			angVel3DF.CopyFrom(cObject->GetAngularVelocity(Vector3D(0.), ConfigurationType::Visualization));
		}
		//transform graphics data with rigid body transformation (includes lines, triangles, points, ...) AND set contour color
		EXUvis::AddBodyGraphicsDataColored(graphicsData, vSystem->graphicsData, pos3DF, Rot3DF, refPos3DF, RefRot3DF,
			vel3DF, angVel3DF, itemID, visualizationSettings, useContourColor);
	}
	else //fast track
	{
		EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, Rot3DF, itemID);
	}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody2D* cObject = (CObjectRigidBody2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF;
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization));
	Float3 refPos3DF;
	refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));
	Matrix3DF Rot3DF;
	Rot3DF.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));
	Matrix3DF RefRot3DF;
	RefRot3DF.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Reference));

	bool useContourColor = ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes()) && visualizationSettings.contour.rigidBodiesColored;
	if (useContourColor)
	{
		Float3 refPos3DF;
		refPos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Reference));

		Float3 vel3DF;		//global
		Float3 angVel3DF;	//global
		if (visualizationSettings.contour.outputVariable == OutputVariableType::Velocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::VelocityLocal ||
			visualizationSettings.contour.outputVariable == OutputVariableType::AngularVelocity ||
			visualizationSettings.contour.outputVariable == OutputVariableType::AngularVelocityLocal)
		{
			vel3DF.CopyFrom(cObject->GetVelocity(Vector3D(0.), ConfigurationType::Visualization));
			angVel3DF.CopyFrom(cObject->GetAngularVelocity(Vector3D(0.), ConfigurationType::Visualization));
		}
		//transform graphics data with rigid body transformation (includes lines, triangles, points, ...) AND set contour color
		EXUvis::AddBodyGraphicsDataColored(graphicsData, vSystem->graphicsData, pos3DF, Rot3DF, refPos3DF, RefRot3DF,
			vel3DF, angVel3DF, itemID, visualizationSettings, useContourColor);
	}
	else //fast track
	{
		EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, Rot3DF, itemID);
	}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }

}


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectSuperElement::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;
	if (GetColor()[0] != -1.f) { currentColor = GetColor(); }

	CObjectSuperElement* cObject = (CObjectSuperElement*)vSystem->systemData->GetCObjects()[itemNumber];

	Index localRigidBodyNodeNumber; //local number in body!
	bool hasReferenceFrame = cObject->HasReferenceFrame(localRigidBodyNodeNumber);

	Matrix3D refRot = EXUmath::unitMatrix3D;
	Vector3D refPos({ 0,0,0 });

	if (hasReferenceFrame)
	{
		refRot = ((const CNodeRigidBody*)cObject->GetCNode(localRigidBodyNodeNumber))->GetRotationMatrix(ConfigurationType::Visualization); //cObject->GetCNode(...) takes local number
		refPos = ((const CNodeRigidBody*)cObject->GetCNode(localRigidBodyNodeNumber))->GetPosition(ConfigurationType::Visualization);
	}

	Real scaleFactor = visualizationSettings.bodies.deformationScaleFactor;

	if (GetShowNodes() && visualizationSettings.nodes.show) //show nodes with correct reference frame
	{
		//node size only defined globally
		float radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }

		//Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
		Vector3D nodePos;
		//Index mbsNumber = vSystem->GetSystemID();
		for (Index i = 0; i < cObject->GetNumberOfMeshNodes(); i++)
		{
			if (scaleFactor == 1.)
			{
				nodePos = cObject->GetMeshNodePosition(i, ConfigurationType::Visualization);
			}
			else
			{
				nodePos = cObject->GetMeshNodeLocalPosition(i, ConfigurationType::Visualization);
				Vector3D nodeRefPos = cObject->GetMeshNodeLocalPosition(i, ConfigurationType::Reference);
				nodePos = scaleFactor * (nodePos - nodeRefPos) + nodeRefPos;
				nodePos = refPos + refRot * nodePos;
			}

			Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
			if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
			EXUvis::DrawNode(nodePos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling); //itemID of SuperElement object!!!

			if (visualizationSettings.nodes.showNumbers) 
			{ 
				EXUvis::DrawItemNumber(nodePos, vSystem, Index2ItemID(i, ItemType::_None, vSystem->GetSystemID()), "NF", EXUvis::grey1); //use ItemType::_None, because should not be identified as node ...
			}
		}
	}

	if (GetTriangleMesh().NumberOfRows() != 0)
	{

		//process triangles of mesh to draw
		std::array<Float4, 3> colors;
		colors[0] = currentColor;
		colors[1] = currentColor;
		colors[2] = currentColor;
		//Vector contourValue; //memory allocation only in case of contour plot, but only once for whole mesh ...!
		Vector& contourValue = vSystem->tempVector;

		std::array<Vector3D, 3> nodes;
		std::array<Vector3D, 3> normals;
		//V, V, useFirstNodeAsReferenceFrame, , , bool, "false", , IO, "set true, if first node ($n_0$) is used as floating reference frame; all other nodes are interpreted relative to the reference frame; used to implement FFRF (floating frame of reference formulation); NOTE that in this case, nodes $[n_1,\,\ldots,\,n_n]\tp$ are still drawn without the reference frame"
		//	V, V, showNodes, , , bool, "false", , IO, "set true, nodes are drawn uniquely via the mesh, eventually using the floating reference frame, even in the visualization of the node is show=False"

		for (Index i = 0; i < GetTriangleMesh().NumberOfRows(); i++)
		{
			for (Index j = 0; j < 3; j++)
			{
				colors[j] = currentColor; //set back to default if some values are invalid
				Index meshNodeIndex = (Index)GetTriangleMesh()(i, j);
				if (scaleFactor == 1.)
				{
					nodes[j] = cObject->GetMeshNodePosition(meshNodeIndex, ConfigurationType::Visualization);
				}
				else
				{
					nodes[j] = cObject->GetMeshNodeLocalPosition(meshNodeIndex, ConfigurationType::Visualization);
					Vector3D nodeRefPos = cObject->GetMeshNodeLocalPosition(meshNodeIndex, ConfigurationType::Reference);
					nodes[j] = scaleFactor * (nodes[j] - nodeRefPos) + nodeRefPos;
					nodes[j] = refPos + refRot * nodes[j];
				}

				//add contour plot values to color; may NOT be called if contour.outputVariable == None (GetOutputVariable(...) fails!)
				if (EXUstd::IsOfTypeAndNotNone(cObject->GetOutputVariableTypesSuperElement(meshNodeIndex), visualizationSettings.contour.outputVariable))
				{
					cObject->GetOutputVariableSuperElement(visualizationSettings.contour.outputVariable, meshNodeIndex, ConfigurationType::Visualization, contourValue); //memory allocation!
					EXUvis::ComputeContourColor< Vector>(contourValue, visualizationSettings.contour.outputVariable, 
						visualizationSettings.contour.outputVariableComponent, colors[j]);
				}

			}
			//compute normals:
			Vector3D v0 = nodes[1] - nodes[0];
			Vector3D v1 = nodes[2] - nodes[0];
			Vector3D n = v0.CrossProduct(v1);
			Real len = n.GetL2Norm();
			if (len != 0) { n *= 1. / len; }
			normals[0] = n;
			normals[1] = n;
			normals[2] = n;

			vSystem->graphicsData.AddTriangle(nodes, normals, colors, itemID, true);
		}
	}


	//draw body number at reference frame node position
	if (visualizationSettings.bodies.showNumbers)
	{
		Vector3D refPos3D = cObject->GetPosition(Vector3D({ 0,0,0 }), ConfigurationType::Visualization);
		EXUvis::DrawItemNumber(refPos3D, vSystem, itemID, "RF", currentColor);
	}

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectKinematicTree::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;
	if (GetColor()[0] != -1.f) { currentColor = GetColor(); }
	
	CObjectKinematicTree* cObject = (CObjectKinematicTree*)vSystem->systemData->GetCObjects()[itemNumber];

	Matrix3D refRot = EXUmath::unitMatrix3D;
	Vector3D refPos({ 0,0,0 });

	////node size only defined globally
	//float radius = 0.5f*visualizationSettings.nodes.defaultSize;
	//if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->renderState.maxSceneSize * 0.002f; }

	Transformation66List Xup; //temporary list, needs new
	Vector6DList V; //temporary list, needs new
	Vector6DList Avp; //temporary list, needs new
	Vector3D pos3D;
	Matrix3D rot3D;

	Real frameSize = visualizationSettings.bodies.kinematicTree.frameSize;
	Real frameRadius = frameSize * 0.025;
	Real cylRadius = frameSize * 0.1;
	Vector3D prevPos3D;
	Matrix3D prevRot3D;

	bool hasBodyGraphicsData = false;

	if (this->graphicsDataList.NumberOfItems() != 0)
	{
		hasBodyGraphicsData = true;
	}

	cObject->ComputeTreeTransformations(ConfigurationType::Visualization, false, false, Xup, V, Avp); //Xup is the inverse transformation

	Transformation66 baseTransform = RigidBodyMath::RotationTranslation2T66Inverse(EXUmath::unitMatrix3D,
		cObject->GetParameters().baseOffset);

	//std::cout << "Xup=" << Xup << "\n";
	for (Index i = 0; i < cObject->GetNumberOfMeshNodes(); i++)
	{
		if (cObject->GetParameters().linkParents[i] != CObjectKinematicTree::noParent)
		{
			Xup[i] = Xup[i] * Xup[cObject->GetParameters().linkParents[i]];

			RigidBodyMath::T66toRotationTranslationInverse(Xup[cObject->GetParameters().linkParents[i]], prevRot3D, prevPos3D);
		}
		else
		{
			Xup[i] = Xup[i] * baseTransform;
			RigidBodyMath::T66toRotationTranslationInverse(baseTransform, prevRot3D, prevPos3D);
			//prevRot3D = EXUmath::unitMatrix3D;
			//prevPos3D = cObject->GetParameters().baseOffset;
		}

		RigidBodyMath::T66toRotationTranslationInverse(Xup[i], rot3D, pos3D);
		//if (cObject->GetParameters().linkParents[i] != CObjectKinematicTree::noParent && showLinks)

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//draw frames first, then they will be visible with transparency!
		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		bool zeroCOMcase = false; //case where both frames would be equivalent!
		if (cObject->GetParameters().linkCOMs[i] == 0. && visualizationSettings.bodies.kinematicTree.showCOMframes
			&& visualizationSettings.bodies.kinematicTree.showJointFrames) {
			zeroCOMcase = true;
		}

		if (visualizationSettings.bodies.kinematicTree.showJointFrames)
		{
			Index nn = EXUstd::InvalidIndex;
			const Index siceChar = 24;
			char preText[siceChar];
			preText[0] = char(0);
			if (visualizationSettings.bodies.kinematicTree.showFramesNumbers)
			{
				nn = itemNumber;
				if (zeroCOMcase) { snprintf(preText, siceChar, "O%iJ%i,COM%i", nn, i, i); }
				else { snprintf(preText, siceChar, "O%iJ%i", nn, i); }
			}
			EXUvis::DrawOrthonormalBasis(pos3D, rot3D, frameSize, frameRadius, vSystem->graphicsData, itemID, 1.0f, true, 12, 2.5, -1, preText);
		}
		if (visualizationSettings.bodies.kinematicTree.showCOMframes &&
			!zeroCOMcase) //in this case, only show joint frame!
		{
			Index nn = EXUstd::InvalidIndex;
			const Index siceChar = 24;
			char preText[siceChar];
			preText[0] = char(0);
			if (visualizationSettings.bodies.kinematicTree.showFramesNumbers)
			{
				nn = itemNumber;
				snprintf(preText, siceChar, "O%iCOM%i", nn, i);
			}

			EXUvis::DrawOrthonormalBasis(pos3D, rot3D, frameSize, frameRadius, vSystem->graphicsData, itemID, 1.0f, true, 12, 2.5, -1, preText);
		}

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		if (!hasBodyGraphicsData)
		{
			//draw joints first?, then they will be visible with transparency settings!
			if (showJoints)
			{
				Vector3D vAxis(0.); //initialize with zeros, only axis is filled!
				Joint::Type jointType = cObject->GetParameters().jointTypes[i];
				//only draw for revolute joints:
				Index vIndex = -1;
				if (jointType == Joint::RevoluteX) { vIndex = 0; }
				else if (jointType == Joint::RevoluteY) { vIndex = 1; }
				else if (jointType == Joint::RevoluteZ) { vIndex = 2; }
				if (vIndex != -1)
				{
					vAxis[vIndex] = cylRadius * 1.25; //this is the half axis length
					vAxis = rot3D * vAxis;
					EXUvis::DrawCylinder(pos3D - vAxis, 2.*vAxis, cylRadius*0.8, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, itemID,
						visualizationSettings.general.cylinderTiling);
				}
			}
			if (showLinks)
			{
				EXUvis::DrawCylinder(prevPos3D, (pos3D - prevPos3D), cylRadius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);
			}

		}
		else
		{
			Float3 pos3DF;
			Matrix3DF rot3DF;
			pos3DF.CopyFrom(pos3D);
			rot3DF.CopyFrom(rot3D);

			
			EXUvis::AddBodyGraphicsData(this->graphicsDataList[i],vSystem->graphicsData, pos3DF, rot3DF, itemID);
		}





	}


	//Vector3D nodePos;
	////iterate over tree and show links, COM, etc.
	//for (Index i = 0; i < cObject->GetNumberOfMeshNodes(); i++)
	//{
	//	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 2 * visualizationSettings.nodes.tiling;
	//	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	//	EXUvis::DrawNode(nodePos, radius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.openGL.showFaces, tiling); //itemID of SuperElement object!!!

	//	if (visualizationSettings.nodes.showNumbers)
	//	{
	//		EXUvis::DrawItemNumber(nodePos, vSystem, Index2ItemID(i, ItemType::_None, vSystem->GetSystemID()), "NF", EXUvis::grey1); //use ItemType::_None, because should not be identified as node ...
	//	}
	//}


	////draw body number at reference frame node position
	//if (visualizationSettings.bodies.showNumbers)
	//{
	//	Vector3D refPos3D = cObject->GetPosition(Vector3D({ 0,0,0 }), ConfigurationType::Visualization);
	//	EXUvis::DrawItemNumber(refPos3D, vSystem, itemID, "RF", currentColor);
	//}

}


////! Update visualizationSystem -> graphicsData for item
//void VisualizationObjectFFRF::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
//{
//	VisualizationObjectSuperElement::UpdateGraphics(visualizationSettings, vSystem, itemNumber);
//}


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectGround* cObject = (CObjectGround*)vSystem->systemData->GetCObjects()[itemNumber];

	Float3 pos3DF;
	pos3DF.CopyFrom(cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization)); 

	EXUvis::AddBodyGraphicsData(graphicsData, vSystem->graphicsData, pos3DF, EXUmath::unitMatrix3DF, itemID);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3DF, vSystem, itemID, "", currentColor); }
}


void VisualizationObjectANCFCable2DBaseUpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber, const Float4& color, float drawHeight)
{
	bool drawWithTriangles = visualizationSettings.bodies.beams.crossSectionFilled;
	//const bool interpolateLinear = true;
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;
	bool drawVertical = visualizationSettings.bodies.beams.drawVertical;
	float verticalOffset = visualizationSettings.bodies.beams.drawVerticalOffset; //additional offset
	
	CObjectANCFCable2DBase* cObject = (CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[itemNumber];

	Index tiling = EXUstd::Maximum(2, visualizationSettings.bodies.beams.axialTiling);

	GLLine item;
	GLLine itemVertical;
	item.itemID = itemID;
	if (color[0] != -1.f) { currentColor = color; }

	Real L = cObject->GetLength();
	item.color1 = currentColor;
	item.color2 = currentColor;

	bool contourPlot = false;
	float interpValues[4] = {0,0,0,0}; //values for linear interpolation

	//ConstSizeVector<9> value; //cable elements have no more than 9 cooordinates ...
	Vector& value = vSystem->tempVector;
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes())
	{
		cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ 0.,0.,0. }), ConfigurationType::Visualization, value, itemNumber);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			if (drawHeight == 0. || drawVertical)
			{
				EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color1);
				interpValues[0] = item.color1[0]; //store this contour plot value

				cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,0.,0. }), ConfigurationType::Visualization, value, itemNumber);
				EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color2);
				interpValues[1] = item.color2[0]; //store this contour plot value
			}
			else
			{
				cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ 0.,-0.5*drawHeight,0. }), ConfigurationType::Visualization, value, itemNumber);
				EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color1);
				interpValues[0] = item.color1[0]; //store this contour plot value

				cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,-0.5*drawHeight,0. }), ConfigurationType::Visualization, value, itemNumber);
				EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color2);
				interpValues[1] = item.color2[0]; //store this contour plot value

				cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ 0.,0.5*drawHeight,0. }), ConfigurationType::Visualization, value, itemNumber);
				EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color1);
				interpValues[2] = item.color1[0]; //store this contour plot value

				cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,0.5*drawHeight,0. }), ConfigurationType::Visualization, value, itemNumber);
				EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color2);
				interpValues[3] = item.color2[0]; //store this contour plot value

			}

			contourPlot = true;
		}

	}
	float factVertical = 1;
	if (drawVertical)
	{
		itemVertical.itemID = itemID;
		itemVertical.color1 = visualizationSettings.bodies.beams.drawVerticalColor;
		itemVertical.color2 = visualizationSettings.bodies.beams.drawVerticalColor;
		factVertical = visualizationSettings.bodies.beams.drawVerticalFactor;
		drawHeight = 0.;
	}

	//for now, bending stresses/strains are not computed/plotted off-axis!
	Float3 p0[2]; //mid line or bottom line
	Float3 p1[2]; //top line (if drawHeight!=0.)
	p0[0].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(-drawHeight * 0.5),0. }), ConfigurationType::Visualization));
	p0[1].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(drawHeight * 0.5),0. }), ConfigurationType::Visualization));

	Real deltaX = L / (Real)tiling;
	Index n = 1; //no height
	if (drawHeight != 0. && !drawWithTriangles && !drawVertical)
	{ 
		n = 2;
		//first cross section
		item.point1 = p0[0];
		item.point2 = p0[1];
		item.color1[0] = interpValues[0];
		item.color2[0] = interpValues[0];
		vSystem->graphicsData.glLines.Append(item);
	}

	for (Index j = 0; j < n; j++)
	{
		if (drawHeight == 0. || !drawWithTriangles || drawVertical) //draw as line
		{
			Real y = drawHeight * (-0.5 + (Real)j);
			for (Index i = 1; i <= tiling; i++)
			{
				Real x = (Real)i / (Real)tiling*L;

				Vector3D pLoc0({ x - deltaX, y, 0. });
				Vector3D pLoc1({ x, y, 0. });
				p1[j].CopyFrom(cObject->GetPosition(pLoc1, ConfigurationType::Visualization));

				float val1, val2;
				if (contourPlot)
				{
					if (visualizationSettings.bodies.beams.reducedAxialInterploation)
					{
						val1 = (float)EXUstd::LinearInterpolate(interpValues[0], interpValues[1], 0, (float)L, (float)(x - deltaX));
						val2 = (float)EXUstd::LinearInterpolate(interpValues[0], interpValues[1], 0, (float)L, (float)x);
						//outputBuffer.WriteVisualization("val1=" + EXUstd::ToString(val1) + "\n");
						//outputBuffer.WriteVisualization("val2=" + EXUstd::ToString(val2) + "\n");
						item.color1[0] = val1;
						item.color2[0] = val2;
					}
					else
					{
						cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, pLoc0, ConfigurationType::Visualization, value, itemNumber);
						EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color1);
						cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, pLoc1, ConfigurationType::Visualization, value, itemNumber);
						EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color2);
						val1 = item.color1[0];
						val2 = item.color2[0];
					}

					if (drawVertical) //draw contour value vertically (in cross section direction)
					{
						val1 += verticalOffset;
						val2 += verticalOffset;
						//if used, we do not get values in colorbar
						//item.color1 = currentColor;
						//item.color2 = currentColor;
						Vector2D ry[2];
						ry[0] = cObject->ComputeSlopeVector(x - deltaX, ConfigurationType::Visualization);
						ry[1] = cObject->ComputeSlopeVector(x, ConfigurationType::Visualization);
						Float2 n0[2];
						n0[0] = Float2({ -(float)ry[0][1], (float)ry[0][0] });
						n0[1] = Float2({ -(float)ry[1][1], (float)ry[1][0] });
						n0[0].Normalize();
						n0[1].Normalize();
						//val1 = drawHeight;
						//val2 = 0.5*drawHeight;
						itemVertical.point1 = p0[j] + Float3({ factVertical*val1*n0[0][0], factVertical*val1*n0[0][1], (float)0. });
						itemVertical.point2 = p1[j] + Float3({ factVertical*val2*n0[1][0], factVertical*val2*n0[1][1], (float)0. });
						vSystem->graphicsData.glLines.Append(itemVertical);

						if (visualizationSettings.bodies.beams.drawVerticalLines)
						{
							itemVertical.point1 = p0[j];
							itemVertical.point2 = p0[j] + Float3({ factVertical*val1*n0[0][0], factVertical*val1*n0[0][1], (float)0. });
							//itemVertical.point2 = p1[j] + Float3({ factVertical*val2*n0[1][0], factVertical*val2*n0[1][1], (float)0. });
							//itemVertical.point2 = p1[j] + Float3({ factVertical*val2*n0[1][0], factVertical*val2*n0[1][1], (float)0. });
							vSystem->graphicsData.glLines.Append(itemVertical);
						}
						if (visualizationSettings.bodies.beams.drawVerticalValues)
						{
							float showValue = (float)EXUstd::LinearInterpolate(interpValues[0], interpValues[1], 0, (float)L, (float)(x - deltaX));
							Vector3D posValue({ 1.1*(Real)(factVertical*val1*n0[0][0]) + (Real)p0[j][0],
								1.1*(Real)(factVertical*val1*n0[0][1]) + (Real)p0[j][1], 
								(Real)p0[j][2] });
							vSystem->graphicsData.AddText(posValue, currentColor,
								EXUstd::Num2String(showValue, visualizationSettings.general.rendererPrecision), 0.f, 0.f, 0.f, itemID);

						}
					}
				}

				item.point1 = p0[j];
				item.point2 = p1[j];
				vSystem->graphicsData.glLines.Append(item);
				p0[j] = p1[j]; //for next line segment
			}
		}
		else //draw 2D with triangles/quads
		{
			Index csTiling = visualizationSettings.bodies.beams.crossSectionTiling;
			//draw with triangles
			std::array<Float4, 3> colorsTrig;
			std::array<Float3, 3> nodes;
			std::array<Float3, 3> normals;
			normals[0] = Float3({ 0.f,0.f,1.f });
			normals[1] = Float3({ 0.f,0.f,1.f });
			normals[2] = Float3({ 0.f,0.f,1.f });
			//for contour plot
			Float4 colors[4];
			colors[0] = item.color1; //includes contourPlotFlag
			colors[1] = item.color2; //includes contourPlotFlag
			colors[2] = item.color1; //includes contourPlotFlag
			colors[3] = item.color2; //includes contourPlotFlag

			if ((interpValues[0] == interpValues[2] && interpValues[1] == interpValues[3]) || csTiling < 2 )
			{ csTiling=2; }

			float interpValues2[4]; //values for linear interpolation of sub-quads

			Real invCStiling = 1. / (Real)csTiling;
			Real invAxialTiling = 1./(Real)tiling;
			for (Index j = 0; j < csTiling; j++)
			{
				Real height0 = ((Real)j*invCStiling - 0.5)*(Real)drawHeight;
				Real height1 = ((Real)(j+1)*invCStiling - 0.5)*(Real)drawHeight;
				p0[0].CopyFrom(cObject->GetPosition(Vector3D({ 0., height0,0. }), ConfigurationType::Visualization));
				p0[1].CopyFrom(cObject->GetPosition(Vector3D({ 0., height1,0. }), ConfigurationType::Visualization));

				interpValues2[0] = EXUstd::LinearInterpolate(interpValues[0], interpValues[2], (float)0, (float)csTiling, (float)j);
				interpValues2[1] = EXUstd::LinearInterpolate(interpValues[1], interpValues[3], (float)0, (float)csTiling, (float)j);
				interpValues2[2] = EXUstd::LinearInterpolate(interpValues[0], interpValues[2], (float)0, (float)csTiling, (float)j+1);
				interpValues2[3] = EXUstd::LinearInterpolate(interpValues[1], interpValues[3], (float)0, (float)csTiling, (float)j+1);

				for (Index i = 1; i <= tiling; i++)
				{
					Real x = (Real)i *invAxialTiling*L;

					p1[0].CopyFrom(cObject->GetPosition(Vector3D({ x, height0, 0.}), ConfigurationType::Visualization));
					p1[1].CopyFrom(cObject->GetPosition(Vector3D({ x, height1, 0.}), ConfigurationType::Visualization));
					if (contourPlot)
					{
						colors[0][0] = EXUstd::LinearInterpolate(interpValues2[0], interpValues2[1], 0, (float)L, (float)(x - deltaX));
						colors[1][0] = EXUstd::LinearInterpolate(interpValues2[0], interpValues2[1], 0, (float)L, (float)x);
						colors[2][0] = EXUstd::LinearInterpolate(interpValues2[2], interpValues2[3], 0, (float)L, (float)(x - deltaX));
						colors[3][0] = EXUstd::LinearInterpolate(interpValues2[2], interpValues2[3], 0, (float)L, (float)x);
					}
					nodes[0] = p0[0];
					nodes[1] = p1[0];
					nodes[2] = p1[1];
					colorsTrig[0] = colors[0];
					colorsTrig[1] = colors[1];
					colorsTrig[2] = colors[3];
					vSystem->graphicsData.AddTriangle(nodes, normals, colorsTrig, itemID);
					nodes[0] = p0[0];
					nodes[1] = p1[1];
					nodes[2] = p0[1];
					//colorsTrig[0] = colors[0];
					colorsTrig[1] = colors[3];
					colorsTrig[2] = colors[2];

					vSystem->graphicsData.AddTriangle(nodes, normals, colorsTrig, itemID);

					p0[0] = p1[0]; //for next line segment
					p0[1] = p1[1]; //for next line segment
				}
			}

		}
	}
	if (drawHeight != 0. && !drawWithTriangles && !drawVertical)
	{
		//last cross section
		item.point1 = p1[0];
		item.point2 = p1[1];
		item.color1[0] = interpValues[1];
		item.color2[0] = interpValues[1];
		vSystem->graphicsData.glLines.Append(item);
	}

	Vector3D pos3D = cObject->GetPosition(Vector3D({ L*0.5,0.,0. }), ConfigurationType::Visualization);
	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3D, vSystem, itemID, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectALEANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

void VisualizationObjectBeamGeometricallyExact2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectBeamGeometricallyExact2D* cObject = (CObjectBeamGeometricallyExact2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Index tiling = 2;// visualizationSettings.bodies.beams.axialTiling; //not needed for linear beam

	GLLine item;
	item.itemID = itemID;
	if (color[0] != -1.f) { currentColor = color; }

	Real L = cObject->GetParameters().physicsLength;
	item.color1 = currentColor;
	item.color2 = currentColor;

	bool drawWithTriangles = visualizationSettings.bodies.beams.crossSectionFilled;
	bool contourPlot = false;
	float value1 = 0; //values for linear interpolation
	float value2 = 0; //values for linear interpolation
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes())
	{
		//ConstSizeVector<9> value; //cable elements have no more than 9 cooordinates ...
		Vector& value = vSystem->tempVector;
		cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ -0.5*L,0.,0. }), ConfigurationType::Visualization, value, itemNumber);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color1);
			//std::cout << "item.color1=" << item.color1 << "\n";
			value1 = item.color1[0];

			cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ 0.5*L,0.,0. }), ConfigurationType::Visualization, value, itemNumber);
			EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color2);
			//std::cout << "item.color2=" << item.color2 << "\n";

			value2 = item.color2[0];
			contourPlot = true;
		}
	}

	//for now, bending stresses/strains are not computed/plotted off-axis!
	Float3 p0[2];
	Float3 p1[2];
	p0[0].CopyFrom(cObject->GetPosition(Vector3D({ -0.5*L, (Real)(-drawHeight * 0.5),0. }), ConfigurationType::Visualization));
	p0[1].CopyFrom(cObject->GetPosition(Vector3D({ -0.5*L, (Real)(drawHeight * 0.5),0. }), ConfigurationType::Visualization));

	Real deltaX = L / (Real)tiling;
	Index n = 1; //no height
	if (drawHeight != 0. && !drawWithTriangles)
	{
		n = 2;
		//first cross section
		item.point1 = p0[0];
		item.point2 = p0[1];
		item.color1[0] = value1;
		item.color2[0] = value1;
		vSystem->graphicsData.glLines.Append(item);
	}

	if (!drawWithTriangles)
	{
		for (Index j = 0; j < n; j++)
		{
			Real y = drawHeight * (-0.5 + (Real)j);
			for (Index i = 1; i <= tiling; i++)
			{
				Real x = (Real)i / (Real)tiling*L - 0.5*L;

				Vector3D pLoc({ x, y, 0. });
				p1[j].CopyFrom(cObject->GetPosition(pLoc, ConfigurationType::Visualization));

				if (contourPlot)
				{
					item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)(x - deltaX));
					item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)x);
				}
				item.point1 = p0[j];
				item.point2 = p1[j];
				vSystem->graphicsData.glLines.Append(item);
				p0[j] = p1[j]; //for next line segment
			}
		}

	}
	else
	{
		std::array<Float4, 3> colorsTrig;
		std::array<Float3, 3> nodes;
		std::array<Float3, 3> normals;
		normals[0] = Float3({ 0.f,0.f,1.f });
		normals[1] = Float3({ 0.f,0.f,1.f });
		normals[2] = Float3({ 0.f,0.f,1.f });

		for (Index i = 1; i <= tiling; i++)
		{
			Real x = (Real)i / (Real)tiling*L - 0.5*L;

			p1[0].CopyFrom(cObject->GetPosition(Vector3D({ x, (Real)drawHeight * (-0.5), 0. }), ConfigurationType::Visualization));
			p1[1].CopyFrom(cObject->GetPosition(Vector3D({ x, (Real)drawHeight * ( 0.5), 0. }), ConfigurationType::Visualization));

			if (contourPlot)
			{
				item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, (float)(-0.5*L), (float)(0.5*L), (float)(x - deltaX));
				item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, (float)(-0.5*L), (float)(0.5*L), (float)x);
			}

			nodes[0] = p0[0];
			nodes[1] = p1[0];
			nodes[2] = p1[1];
			colorsTrig[0] = item.color1;
			colorsTrig[1] = item.color2;
			colorsTrig[2] = item.color2;
			vSystem->graphicsData.AddTriangle(nodes, normals, colorsTrig, itemID);
			nodes[0] = p0[0];
			nodes[1] = p1[1];
			nodes[2] = p0[1];
			//colorsTrig[0] = item.color1;
			//colorsTrig[1] = item.color2;
			colorsTrig[2] = item.color1;

			vSystem->graphicsData.AddTriangle(nodes, normals, colorsTrig, itemID);

			p0[0] = p1[0]; //for next quad
			p0[1] = p1[1]; //for next quad
		}

	}

	if (drawHeight != 0. && !drawWithTriangles)
	{
		//last cross section
		item.point1 = p1[0];
		item.point2 = p1[1];
		item.color1[0] = value2;
		item.color2[0] = value2;
		vSystem->graphicsData.glLines.Append(item);
	}

	Vector3D pos3D = cObject->GetPosition(Vector3D({ 0.,0.,0. }), ConfigurationType::Visualization);
	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3D, vSystem, itemID, "", currentColor); }

}

template<class TCObject, class TVisuObject>
void UpdateGraphicsBeam3D(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber,
	TCObject* cObject, TVisuObject* vObject)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.bodies.defaultColor;
	Index tiling = visualizationSettings.bodies.beams.axialTiling;

	//float drawHeight = 0.1f;
	bool hasGeometry = vObject->GetSectionGeometry().polygonalPoints.NumberOfItems() != 0; //without geometry, drawn as line!

	GLLine item;
	item.itemID = itemID;
	if (vObject->GetColor()[0] != -1.f) { currentColor = vObject->GetColor(); }

	Real L = cObject->GetParameters().physicsLength;
	item.color1 = currentColor;
	item.color2 = currentColor;

	bool contourPlot = false;
	float value1 = 0; //values for linear interpolation
	float value2 = 0; //values for linear interpolation
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes())
	{
		Vector& value = vSystem->tempVector;
		cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ 0.,0.,0. }), ConfigurationType::Visualization, value, itemNumber);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color1);
			value1 = item.color1[0]; 
			//item.color1 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!

			cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,0.,0. }), ConfigurationType::Visualization, value, itemNumber);
			EXUvis::ComputeContourColor<Vector>(value, visualizationSettings.contour.outputVariable, visualizationSettings.contour.outputVariableComponent, item.color2);
			value2 = item.color2[0];

			//item.color2 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			contourPlot = true;
		}
	}

	//for now, bending stresses/strains are not computed/plotted off-axis!

	Real deltaX = L / (Real)tiling;

	if (!hasGeometry)
	{
		Float3 p0;
		Float3 p1;
		//drawn as line:
		for (Index i = 0; i <= tiling; i++)
		{
			Real x = (Real)i *deltaX - 0.5*L;
			Vector3D pLoc({ x, 0., 0. });
			HomogeneousTransformation HT1 = cObject->GetLocalPositionFrame(pLoc, ConfigurationType::Visualization);

			p1.CopyFrom(HT1.GetTranslation());

			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//temporary!
			//Matrix3D A = cObject->GetRotationMatrix(pLoc, ConfigurationType::Visualization);
			//Vector3D pos = cObject->GetPosition(pLoc, ConfigurationType::Visualization);
			//pout << "pos" << i << "=" << pos << "\n";
			EXUvis::DrawOrthonormalBasis(HT1.GetTranslation(), HT1.GetRotation(), visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
				vSystem->graphicsData, itemID, 1.f, true,
				visualizationSettings.general.axesTiling, 2.5, itemNumber, "B");
			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

			if (i != 0)
			{
				if (contourPlot)
				{
					item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)(x - deltaX));
					item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)x);
				}
				item.point1 = p0;
				item.point2 = p1;
				vSystem->graphicsData.glLines.Append(item);
			}
			p0 = p1; //for next line segment
		}
	}
	else
	{
		std::array<Float4, 4> colorsQuad;
		std::array<Vector3D, 4> nodes;
		//std::array<Vector3D, 4> normals;
		colorsQuad[0] = currentColor;
		colorsQuad[1] = currentColor;
		colorsQuad[2] = currentColor;
		colorsQuad[3] = currentColor;

		const Vector2DList& pg = vObject->GetSectionGeometry().polygonalPoints;
		HomogeneousTransformation HT0;
		//pout << "pg=" << pg << "\n";
		for (Index i = 0; i <= tiling; i++)
		{
			Real x = (Real)i *deltaX - 0.5*L;
			Vector3D pLoc({ x, 0., 0. });
			HomogeneousTransformation HT1 = cObject->GetLocalPositionFrame(pLoc, ConfigurationType::Visualization);


			if (i != 0)
			{
				Vector3D p0loc({ 0.,pg.Last().X(), pg.Last().Y() });
				for (Index j = 0; j < pg.NumberOfItems(); j++)
				{
					Vector3D p1loc({ 0.,pg[j].X(), pg[j].Y() });
					nodes[0] = HT0.GetTranslation() + HT0.GetRotation() * p0loc;
					nodes[1] = HT1.GetTranslation() + HT1.GetRotation() * p0loc;
					nodes[3] = HT0.GetTranslation() + HT0.GetRotation() * p1loc;
					nodes[2] = HT1.GetTranslation() + HT1.GetRotation() * p1loc;

					vSystem->graphicsData.AddQuad(nodes, colorsQuad, itemID);
					p0loc = p1loc;
				}
			}
			HT0 = HT1; //save for next segment

			//??
			//if (i != 0)
			//{
			//	if (contourPlot)
			//	{
			//		item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)(x - deltaX));
			//		item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)x);
			//	}
			//	item.point1 = p0;
			//	item.point2 = p1;
			//	vSystem->graphicsData.glLines.Append(item);
			//}
			//p0 = p1; //for next line segment
		}

	}

	Vector3D pos3D = cObject->GetPosition(Vector3D({ 0.,0.,0. }), ConfigurationType::Visualization);
	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3D, vSystem, itemID, "", currentColor); }

}



void VisualizationObjectBeamGeometricallyExact::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	CObjectBeamGeometricallyExact* cObject = (CObjectBeamGeometricallyExact*)vSystem->systemData->GetCObjects()[itemNumber];

	UpdateGraphicsBeam3D(visualizationSettings, vSystem, itemNumber,
		cObject, this);
}

void VisualizationObjectANCFBeam::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	CObjectANCFBeam* cObject = (CObjectANCFBeam*)vSystem->systemData->GetCObjects()[itemNumber];

	UpdateGraphicsBeam3D(visualizationSettings, vSystem, itemNumber,
		cObject, this);
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//CONNECTORS

void VisualizationObjectConnectorSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorSpringDamper* cItem = (CObjectConnectorSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//Index2 markers = Index2({ cItem->GetMarkerNumbers()[0], cItem->GetMarkerNumbers()[1] });
	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }
	//if (!cItem->GetParameters().activeConnector) //if inactive, make the constraint much lighter; or turn to RED?
	//{ currentColor = Float4({ 0.75f+0.25f*currentColor[0],0.75f + 0.25f*currentColor[1],0.75f + 0.25f*currentColor[2],currentColor[3] }); }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1
	//Vector3D vN({ -v0[1], v0[0], v0[2] });
	//Real Ln = vN.GetL2Norm(); //length of normal vector
	//if (Ln != 0.f) { vN /= Ln; }
	//const Index numberOfPoints = 12;
	//EXUvis::DrawSpring2D(pos[0], pos[1], vN, numberOfPoints, r, currentColor, vSystem->graphicsData);
	Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
	const Index nTildePerWinding = visualizationSettings.general.circleTiling;
	EXUvis::DrawSpring(pos[0], pos[1], numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectConnectorCartesianSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCartesianSpringDamper* cItem = (CObjectConnectorCartesianSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1

	Vector3D p0, p1;// , vN, vRel;

	if (cItem->GetParameters().activeConnector) //does not work in visualization ...
	{
		//draw 3 orthogonal springs
		Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
		const Index nTildePerWinding = visualizationSettings.general.circleTiling;
		p0 = pos[0]; p1 = pos[0] + Vector3D({ v0[0],0,0 });		//x-direction
		EXUvis::DrawSpring(p0, p1, numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData, itemID);
		p0 = p1; p1 = pos[0] + Vector3D({ v0[0],v0[1],0 });		//y-direction
		EXUvis::DrawSpring(p0, p1, numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData, itemID);
		p0 = p1; p1 = pos[0] + v0;								//z-direction
		EXUvis::DrawSpring(p0, p1, numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData, itemID);

		//const Index numberOfPoints = 12;
		//p0 = pos[0]; p1 = pos[0] + Vector3D({ v0[0],0,0 });		//x-direction
		//EXUvis::DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		//p0 = p1; p1 = pos[0] + Vector3D({ v0[0],v0[1],0 });		//y-direction
		//EXUvis::DrawSpring2D(p0, p1, Vector3D({ 1,0,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		//p0 = p1; p1 = pos[0] + v0;								//z-direction
		//EXUvis::DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectConnectorRigidBodySpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorRigidBodySpringDamper* cItem = (CObjectConnectorRigidBodySpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }
	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//draw as sphere with drawSize ...
	EXUvis::DrawSphere(pos[0], r, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.sphereTiling);
	EXUvis::DrawSphere(pos[1], r, EXUvis::ModifyColor(currentColor, EXUvis::modifyColorFactor), vSystem->graphicsData, itemID, visualizationSettings.general.sphereTiling);
	EXUvis::DrawCylinder(pos[0], pos[1]-pos[0], 0.8*r, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showJointAxes)
	{
		Matrix3D rot[2];
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

		//add marker rotation here!
		rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
		rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, 
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, 
			vSystem->graphicsData, itemID, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}


void VisualizationObjectConnectorLinearSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorLinearSpringDamper* cItem = (CObjectConnectorLinearSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Matrix3D rot0;
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot0, ConfigurationType::Visualization);

	EXUvis::DrawSphere(pos[0], r, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.sphereTiling);
	EXUvis::DrawSphere(pos[1], r, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.sphereTiling);

	Vector3D v = pos[1] - pos[0];
	Vector3D pMid = 0.5*(pos[0] + pos[1]);
	Vector3D vSD = rot0 * cItem->GetParameters().axisMarker0; //this is the fixed (normalized) axis of the spring-damper

	//drawing will show some strange position of the spring-damper, if it is not attached to a prismatic joint!
	vSD = (vSD * v) * vSD; //this is the direction of the spring-damper
	pos[0] = pMid - 0.5*vSD;
	pos[1] = pMid + 0.5*vSD;

	if (drawAsCylinder)
	{
		EXUvis::DrawCylinder(pos[0], pos[1]-pos[0], r, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);
	}
	else
	{
		Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
		const Index nTildePerWinding = visualizationSettings.general.circleTiling;
		EXUvis::DrawSpring(pos[0], pos[1], numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData, itemID);
	}


	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pMid, vSystem, itemID, "", currentColor); }
}

void VisualizationObjectConnectorTorsionalSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorTorsionalSpringDamper* cItem = (CObjectConnectorTorsionalSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }
	float d = drawSize; //length of axis vector
	if (drawSize == -1.f) { d = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Matrix3D rot[2];

	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	//add marker rotation here!
	rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
	rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

	for (Index i = 0; i < 2; i++)
	{
		Vector3D rotAxis({ rot[i](0,2), rot[i](1,2), rot[i](2,2) });

		//draw double arrow and cylinder
		Float4 modColor = EXUvis::ModifyColor(currentColor, 1.f - 0.5f*i);
		EXUvis::DrawArrow(pos[i], d*rotAxis, d*0.025, modColor, vSystem->graphicsData, itemID, visualizationSettings.general.axesTiling, true, true);
		EXUvis::DrawCylinder(pos[i], d*0.25*rotAxis, d*0.5, modColor, vSystem->graphicsData, itemID, 2 * visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectConnectorCoordinateSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinateSpringDamper* cItem = (CObjectConnectorCoordinateSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//Vector3D n({ 0,0,1 }); //normal defining the plane in which the 2D spring is drawn
	//Vector3D v = pos[1] - pos[0];
	//if (fabs(v[2]) > fabs(v[0]) + fabs(v[1])) { n = Vector3D({1.,0.,0.}); }
	//const Index numberOfPoints = 12;	
	//EXUvis::DrawSpring2D(pos[0], pos[1], n, numberOfPoints, r, currentColor, vSystem->graphicsData);
	Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
	const Index nTildePerWinding = visualizationSettings.general.circleTiling;
	EXUvis::DrawSpring(pos[0], pos[1], numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}


void VisualizationObjectConnectorHydraulicActuatorSimple::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorHydraulicActuatorSimple* cItem = (CObjectConnectorHydraulicActuatorSimple*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Vector3D vAxis = pos[1] - pos[0];
	Real L = vAxis.GetL2Norm();
	if (L != 0.) { vAxis *= 1./L; }

	Real lCyl = cItem->GetParameters().offsetLength;
	Real lRod = rodMountRadius + cItem->GetParameters().strokeLength + pistonLength;
	Index TF = 2; //increase tiling for nicer cylinders ...

	//draw inner parts first for transparency view
	EXUvis::DrawCylinder(pos[1], -lRod*vAxis, rodRadius, colorPiston, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling*TF);
	if (pistonLength != 0) { EXUvis::DrawCylinder(pos[1] - lRod * vAxis, (-pistonLength)*vAxis, pistonRadius, colorPiston, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling*TF); }

	EXUvis::DrawCylinder(pos[0] + vAxis * baseMountLength, vAxis*(lCyl - baseMountLength - rodMountRadius), cylinderRadius, colorCylinder, vSystem->graphicsData, itemID, 
		visualizationSettings.general.cylinderTiling*TF); // , pistonRadius, Vector2D({ -0.5*EXUstd::pi,0.5*EXUstd::pi }));
	if (baseMountLength != 0) { EXUvis::DrawCylinder(pos[0], vAxis*baseMountLength, baseMountRadius, colorCylinder, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling*TF); }

	if (baseMountRadius != 0) { EXUvis::DrawSphere(pos[0], baseMountRadius, colorCylinder, vSystem->graphicsData, itemID, visualizationSettings.general.sphereTiling*TF); }
	if (rodMountRadius != 0) { EXUvis::DrawSphere(pos[1], rodMountRadius, colorPiston, vSystem->graphicsData, itemID, visualizationSettings.general.sphereTiling*TF); }

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectConnectorReevingSystemSprings::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorReevingSystemSprings* cItem = (CObjectConnectorReevingSystemSprings*)vSystem->systemData->GetCObjects()[itemNumber];

	Index nRigidBodyMarkers = cItem->GetParameters().markerNumbers.NumberOfItems() - 2 * (Index)cItem->GetParameters().hasCoordinateMarkers;
	Matrix3D rotA, rotB;
	Vector3D lastRB;

	for (Index i = 0; i < nRigidBodyMarkers-1; i++)
	{
		Vector3D pA, pB;
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[i+0]]->GetPosition(*vSystem->systemData, pA, ConfigurationType::Visualization);
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[i+1]]->GetPosition(*vSystem->systemData, pB, ConfigurationType::Visualization);

		//EXUvis::DrawCylinder(pA, pB-pA, ropeRadius, EXUvis::red, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);

		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[i + 0]]->GetRotationMatrix(*vSystem->systemData, rotA, ConfigurationType::Visualization);
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[i + 1]]->GetRotationMatrix(*vSystem->systemData, rotB, ConfigurationType::Visualization);

		Vector3D aA = rotA*cItem->GetParameters().sheavesAxes[i];
		Vector3D aB = rotB*cItem->GetParameters().sheavesAxes[i+1];

		//pout << "rotA=" << rotA*rotA.GetTransposed() << ",rotB=" << rotB*rotB.GetTransposed() << "\n";

		Real RA = cItem->GetParameters().sheavesRadii[i];
		Real RB = cItem->GetParameters().sheavesRadii[i+1];
		Vector3D rA;
		Vector3D rB(0.);
		bool rv = HGeometry::CommonTangentOf2Circles(pA, pB, aA, aB, RA, RB, rA, rB, 1,1, false); //, Real& phiA, Real& phiB)

		if (rv)
		{
			EXUvis::DrawCylinder(rA + pA, pB + rB - pA - rA, ropeRadius, color, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);

			if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(rA + rB), vSystem, itemID, "", currentColor); }

			if (i > 0 && RA != 0.)
			{
				//compute contact angle
				Vector3D lastRB0 = (1. / RA) * lastRB;
				Vector3D lastNB0 = aA.CrossProduct(lastRB0);

				Vector3D rA0 = (1. / RA) * rA;
				Real phi = atan2(lastNB0*rA0, lastRB0*rA0);
				if (phi < 0) { phi += 2.*EXUstd::pi; }
				//pout << "phi=" << phi << "\n";
				//pout << "lastRB0norm=" << lastRB0.GetL2Norm() << "\n";
				//pout << "lastNB0norm=" << lastNB0.GetL2Norm() << "\n";

				Index nTile = visualizationSettings.general.cylinderTiling;
				Vector3D v0 = lastRB;
				for (Index j = 1; j <= nTile; j++)
				{
					Real phi1 = (j * phi) / (Real)nTile;
					Vector3D v1 = RA * (lastRB0 * cos(phi1) + lastNB0 * sin(phi1));
					//pout << "j" << j << ":" << v1 << "\n";
					EXUvis::DrawCylinder(pA + v0, v1 - v0, ropeRadius, color, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);

					v0 = v1;
				}

			}
		}
		lastRB = rB;
	}

}



void VisualizationObjectConnectorDistance::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorDistance* cItem = (CObjectConnectorDistance*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	//float r = 0.5f*drawSize; //radius of spring
	//if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectConnectorCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinate* cItem = (CObjectConnectorCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }), 0, itemID);
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor, 0, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }

}

void VisualizationObjectConnectorRollingDiscPenalty::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorRollingDiscPenalty* cItem = (CObjectConnectorRollingDiscPenalty*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	Real discRadius = cItem->GetParameters().discRadius;
	Vector3D vAxis = rot[1] * cItem->GetParameters().discAxis;

	//add drawing for disc
	EXUvis::DrawCylinder(pos[1] - 0.5*discWidth*vAxis, discWidth*vAxis, discRadius, currentColor, vSystem->graphicsData, itemID,
		4 * visualizationSettings.general.cylinderTiling);
	EXUvis::DrawCylinder(pos[1] - discWidth * vAxis, 2.*discWidth*vAxis, 0.1*discRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, 
		itemID, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemID, "", currentColor); }
}

void VisualizationObjectContactConvexRoll::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber) {
	//draw contact sphere 
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	CObjectContactConvexRoll* cItem = (CObjectContactConvexRoll*)vSystem->systemData->GetCObjects()[itemNumber];
	Vector3D pContact = cItem->GetPContact(); 
	Float4 colorContact = visualizationSettings.connectors.defaultColor;
	Index nTiles = 12; 
	//Real R = (cItem->GetRBoundingSphere())*1e-2; // in relation to bounding sphere for better visability
	if (pContact[2] <= 0) { // only draw contact point if roll is in contact
		EXUvis::DrawSphere(pContact, 1e-3, colorContact,  vSystem->graphicsData, itemID, nTiles); 
	}
	return; 
}

void VisualizationObjectContactCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCoordinate* cItem = (CObjectContactCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius ContactCoordinate
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.contact.contactPointsDefaultSize; } //use default size

		//draw the two according points; change color to red, if contact:
		if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[0] < 0) //this is the gap at the end of the discontinuous iteration
		{
			currentColor = Float4({ 1.,0.,0.,1. }); //red color means contact ...
		}
		vSystem->graphicsData.AddCircleXY(pos[0], r, currentColor, 0, itemID);
		vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor, 0, itemID);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectContactCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCircleCable2D* cItem = (CObjectContactCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//V, showContactForces, , , bool, false, , P, "if True, contact forces are drawn for certain contact models"
	//	V, contactForcesFactor, , , float, "0.001f", , P, "factor used for scaling of contact forces is showContactForces=True"

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.contact.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		if (showContactCircle)
		{
			vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, visualizationSettings.general.circleTiling*4, itemID);
		}
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		//Vector3D contactForceLast;
		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor, 0, itemID);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });//red color means contact ...
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor, itemID);

					//test and adapt
					//if (visualizationSettings.contact.showContactForces)
					//{
					//	Vector3D pMid = 0.5*(pContact + pContactLast); //segment midpoint
					//	Vector3D n = pMid - pos[0];
					//	Real norm = n.GetL2Norm();
					//	if (norm != 0.) { n *= 1. / norm; }
					//
					//	Real val = -visualizationSettings.contact.contactForcesFactor * cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1];
					//	const Float4 forceColor = Float4({ 1.,0.,0.,1. });
					//	vSystem->graphicsData.AddLine(pMid, pMid + n*val, forceColor, forceColor, itemID);
					//
					//	if (i > 1)
					//	{
					//		vSystem->graphicsData.AddLine(contactForceLast, pMid + n * val, forceColor, forceColor, itemID);
					//	}
					//	contactForceLast = pMid + n * val;
					//
					//}
				} 

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemID, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectContactFrictionCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactFrictionCircleCable2D* cItem = (CObjectContactFrictionCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.contact.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		if (showContactCircle)
		{
			vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 
				visualizationSettings.general.circleTiling * 4, itemID);
		}
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		//Real lCable = ((const CObjectANCFCable2D&)vSystem->systemData->GetCObjectBody(objectNum)).GetParameters().physicsLength;
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		LinkedDataVector visualizationState = cItem->GetCNode(0)->GetVisualizationCoordinateVector();
		Vector3D contactForceLast;

		bool previousForceExists = false; //true, if a previous force exists, thus allowing a linear continuation
		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor, 0, itemID);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (visualizationState[i - 1] <= 0) //this is the gap at the end of the discontinuous iteration
				{
					float valGreen = 0; //stick = red, orange=-slip, yellow=+slip
					if (visualizationState[i - 1 + nSeg] == -CObjectContactFrictionCircleCable2D::absValueSlipCase) { valGreen = 0.75f; }
					else if (visualizationState[i - 1 + nSeg] == CObjectContactFrictionCircleCable2D::absValueSlipCase) { valGreen = 1.f; }
					contactColor = Float4({ 1.,valGreen,0.,1. }); //red color means contact + stick
					if (visualizationState[i - 1 + nSeg] == CObjectContactFrictionCircleCable2D::isUndefinedCase) 
						{ contactColor[2] = 1.f; contactColor[1] = 0; }
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor, itemID);

					if (visualizationSettings.contact.showContactForces)
					{
						Vector3D pMid = 0.5*(pContact + pContactLast); //segment midpoint
						Vector3D n = pMid - pos[0];
						Real norm = n.GetL2Norm();
						if (norm != 0.) { n *= 1. / norm; }
						const Float4 forceColor = Float4({ 1.,0.,0.,1. });
						
						//computes force purely depending on stiffness; damping NEGLECTED!
						Real force = cItem->GetParameters().contactStiffness * visualizationState[i - 1];
						Real val = -force * visualizationSettings.contact.contactForcesFactor;
						if (visualizationSettings.contact.showContactForcesValues && i == nSeg/2+1)
						{
							//const Index siceChar = 24;
							//char temp[siceChar];
							//snprintf(temp, siceChar, "%0.*g", visualizationSettings.general.rendererPrecision, force);
							vSystem->graphicsData.AddText(pMid + n * val*1.1, currentColor, 
								EXUstd::Num2String(force, visualizationSettings.general.rendererPrecision), 0.f, 0.f, 0.f, itemID);
						}
						vSystem->graphicsData.AddLine(pMid, pMid + n * val, forceColor, forceColor, itemID);

						if (previousForceExists)
						{
							vSystem->graphicsData.AddLine(contactForceLast, pMid + n * val, forceColor, forceColor, itemID);
						}

						contactForceLast = pMid + n * val;
						previousForceExists = true;
					}

				} 
				else
				{
					if (visualizationState[i - 1 + nSeg] == CObjectContactFrictionCircleCable2D::isUndefinedCase)
					{
						contactColor = Float4({ 0.,1.,1.,1. }); //undefined state
					}
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor, itemID);
					previousForceExists = false;
				}
				
			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemID, "", currentColor); } //midpoint of ANCF element

}


void VisualizationObjectContactFrictionCircleCable2DOld::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactFrictionCircleCable2DOld* cItem = (CObjectContactFrictionCircleCable2DOld*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.contact.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64, itemID);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		//Real lCable = ((const CObjectANCFCable2D&)vSystem->systemData->GetCObjectBody(objectNum)).GetParameters().physicsLength;
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor, 0, itemID);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor, itemID);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemID, "", currentColor); } //midpoint of ANCF element

}



void VisualizationObjectJointGeneric::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointGeneric* cItem = (CObjectJointGeneric*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
	rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

	if (color[0] != -1.f) { currentColor = color; }

	Index axesConstrained = cItem->GetParameters().constrainedAxes[3] + cItem->GetParameters().constrainedAxes[4] + cItem->GetParameters().constrainedAxes[5];

	//... add drawings for translational joints ...

	if (axesConstrained == 3) //rigid configuration, draw as sphere
	{
		EXUvis::DrawSphere(pos[0], 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData,
			itemID, visualizationSettings.general.sphereTiling);
		EXUvis::DrawSphere(pos[1], 0.5*axesRadius, currentColor, vSystem->graphicsData, itemID,
			visualizationSettings.general.sphereTiling);
	}
	else if (axesConstrained == 2) //revolute or cylindrical joint
	{
		for (Index i = 0; i < 3; i++)
		{
			if (cItem->GetParameters().constrainedAxes[3 + i] == 0)
			{
				Vector3D v = rot[0].GetColumnVector<3>(i);
				EXUvis::DrawCylinder(pos[0] - 0.6*axesLength*v, 1.2*axesLength*v, 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 0.25), 
					vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling); //axis attached to marker0
				EXUvis::DrawCylinder(pos[1] - 0.5*axesLength*v, axesLength*v, axesRadius, currentColor, 
					vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling, 0.75*axesRadius); //hinge attached to marker1
			}
		}
	}
	else if (axesConstrained == 1) //revolute or cylindrical joint
	{
		Index offset = 0; //for second body
		for (Index i = 0; i < 3; i++)
		{
			if (cItem->GetParameters().constrainedAxes[3 + i] == 0)
			{
				Vector3D v = rot[offset].GetColumnVector<3>(i);
				EXUvis::DrawCylinder(pos[offset] - 0.6*axesLength*v, 1.2*axesLength*v, 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 1.f-0.75f*offset), 
					vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling); //axis attached to marker0
				offset++;
			}
		}
	}
	if (visualizationSettings.connectors.showJointAxes)
	{
		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, 
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, 
			vSystem->graphicsData, itemID, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectJointRevoluteZ::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRevoluteZ* cItem = (CObjectJointRevoluteZ*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	rot[0] = rot[0] * cItem->GetParameters().rotationMarker0; 
	rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

	if (color[0] != -1.f) { currentColor = color; }

	const Index freeAxis = 2;
	Vector3D v = rot[0].GetColumnVector<3>(freeAxis);
	EXUvis::DrawCylinder(pos[0] - 0.6*axisLength*v, 1.2*axisLength*v, 0.5*axisRadius, EXUvis::ModifyColor(currentColor, 0.25),
		vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling); //axis attached to marker0
	EXUvis::DrawCylinder(pos[1] - 0.5*axisLength*v, axisLength*v, axisRadius, currentColor,
		vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling, 0.75*axisRadius); //hinge attached to marker1

	if (visualizationSettings.connectors.showJointAxes)
	{
		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius,
			vSystem->graphicsData, itemID, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}


void VisualizationObjectJointPrismaticX::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointPrismaticX* cItem = (CObjectJointPrismaticX*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
	rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

	if (color[0] != -1.f) { currentColor = color; }

	//... prismatic joint drawing as cylinders: joint axis = local x-axis
	Vector3D vAxis[2];
	vAxis[0] = 1.5*axisLength * Vector3D({ rot[0](0,0), rot[0](1,0), rot[0](2,0) }); //first column of rotation matrix = x-axis
	vAxis[1] = axisLength * Vector3D({ rot[1](0,0), rot[1](1,0), rot[1](2,0) }); //first column of rotation matrix = x-axis

	Real innerRadius = axisRadius * 0.5;
	EXUvis::DrawCylinder(pos[0] - 0.5*vAxis[0], vAxis[0], innerRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling);
	EXUvis::DrawCylinder(pos[1] - 0.5*vAxis[1], vAxis[1], axisRadius, currentColor, vSystem->graphicsData, itemID, visualizationSettings.general.cylinderTiling, innerRadius);

	if (visualizationSettings.connectors.showJointAxes)
	{
		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius,
			vSystem->graphicsData, itemID, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius,
			vSystem->graphicsData, itemID, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}



void VisualizationObjectJointSpherical::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointSpherical* cItem = (CObjectJointSpherical*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	Index axesConstrained = cItem->GetParameters().constrainedAxes[0] + cItem->GetParameters().constrainedAxes[1] + cItem->GetParameters().constrainedAxes[2];

	if (axesConstrained < 3) //draw relative vector as cylinder
	{
		EXUvis::DrawCylinder(pos[0], pos[1] - pos[0], 0.5*jointRadius, EXUvis::ModifyColor(currentColor, 0.5), vSystem->graphicsData,
			itemID, visualizationSettings.general.cylinderTiling); //axis attached to marker0
	}

	EXUvis::DrawSphere(pos[0], jointRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, itemID,
		visualizationSettings.general.sphereTiling);
	EXUvis::DrawSphere(pos[1], jointRadius, currentColor, vSystem->graphicsData, itemID,
		visualizationSettings.general.sphereTiling);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectJointRollingDisc::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRollingDisc* cItem = (CObjectJointRollingDisc*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	Real discRadius = cItem->GetParameters().discRadius;
	Vector3D vAxis({ rot[1](0,0), rot[1](1,0), rot[1](2,0) }); //x-axis is disc axis ==> vAxis = A*[1,0,0]

	//add drawing for disc
	EXUvis::DrawCylinder(pos[1] - 0.5*discWidth*vAxis, discWidth*vAxis, discRadius, currentColor, vSystem->graphicsData,
		itemID, 4 * visualizationSettings.general.cylinderTiling);
	EXUvis::DrawCylinder(pos[1] - discWidth * vAxis, 2.*discWidth*vAxis, 0.1*discRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, 
		itemID, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemID, "", currentColor); }
}


void VisualizationObjectJointRevolute2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRevolute2D* cItem = (CObjectJointRevolute2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }), 0, itemID);
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor, 0, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectJointPrismatic2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointPrismatic2D* cItem = (CObjectJointPrismatic2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }), 0, itemID);
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor, 0, itemID);
	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectJointSliding2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointSliding2D* cItem = (CObjectJointSliding2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }), 0, itemID);
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor, 0, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}

void VisualizationObjectJointALEMoving2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Object, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointALEMoving2D* cItem = (CObjectJointALEMoving2D*)vSystem->systemData->GetCObjects()[itemNumber];
	
	//const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	//moving body position:
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	
	//marker1 (ANCF) does not provide current positino, but only ANCF coordinates ...
	//vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Index nALEANCF = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
	const CObjectALEANCFCable2D& cable = (const CObjectALEANCFCable2D&)vSystem->systemData->GetCObjectBody(nALEANCF);

	//compute ANCF coordinates:
	const Index ns = 4;
	ConstSizeVector<ns> qNode0;
	ConstSizeVector<ns> qNode1;

	qNode0.CopyFrom(cable.GetCNode(0)->GetCoordinateVector(ConfigurationType::Visualization)); //displacement coordinates node 0
	qNode1.CopyFrom(cable.GetCNode(1)->GetCoordinateVector(ConfigurationType::Visualization)); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)cable.GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)cable.GetCNode(1))->GetReferenceCoordinateVector();

	//compute sliding position:
	Real L = cable.GetParameters().physicsLength;

	//compute sliding coordinate
	Real slidingCoordinate = cItem->GetCNode(1)->GetCoordinateVector(ConfigurationType::Visualization)[0]
		+ cItem->GetParameters().slidingOffset; //this is the global (Eulerian) sliding position

	Index slidingMarkerIndex = (Index)cItem->GetCNode(0)->GetCoordinateVector(ConfigurationType::Visualization)[0]; //this contains the current index in the cable marker list; slidingMarkerIndex will always be in valid range!

	slidingCoordinate -= cItem->GetParameters().slidingMarkerOffsets[slidingMarkerIndex]; //slidingPos now ranges from 0 to L in current cable element

	//draw sliding position:
	Vector4D SV = CObjectANCFCable2D::ComputeShapeFunctions(slidingCoordinate, L);
	Vector2D slidingPosition = CObjectANCFCable2D::MapCoordinates(SV, qNode0, qNode1);
	pos[1] = { slidingPosition[0],slidingPosition[1],0 };
	//std::cout << "pos1=" << pos[1] << ",pos0=" << pos[0] << "\n";

	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; 
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D vy({ 0,r,0 });
	Vector3D vx({ r,0,0 });
	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }), 0, itemID);

	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor, 0, itemID);
	vSystem->graphicsData.AddLine(pos[1] - vx, pos[1] + vx, currentColor, currentColor, itemID);
	vSystem->graphicsData.AddLine(pos[1] - vy, pos[1] + vy, currentColor, currentColor, itemID);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemID, "", currentColor); }
}






//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerBodyPosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyPosition* cMarker = (CMarkerBodyPosition*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

void VisualizationMarkerBodyMass::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyMass* cMarker = (CMarkerBodyMass*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); 
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); //bodymass-marker has double circle
	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

void VisualizationMarkerBodyRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyRigid* cMarker = (CMarkerBodyRigid*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({  radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({  radius,  radius, 0. }), pos + Vector3D({-radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({-radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

void VisualizationMarkerNodePosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodePosition* cMarker = (CMarkerNodePosition*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

void VisualizationMarkerNodeRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodeRigid* cMarker = (CMarkerNodeRigid*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius,  radius, 0. }), pos + Vector3D({ -radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({ -radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerSuperElementPosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerSuperElementPosition* cMarker = (CMarkerSuperElementPosition*)vSystem->systemData->GetCMarkers()[itemNumber];
	const CObjectSuperElement* cSuperElement = (const CObjectSuperElement*)vSystem->systemData->GetCObjects()[cMarker->GetObjectNumber()];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	//show marker position
	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	if (showMarkerNodes)
	{
		Float4 alternativeColor = EXUvis::ModifyColor(currentColor, 0.25f);
		for (Index node : cMarker->GetParameters().meshNodeNumbers)
		{
			Vector3D p = cSuperElement->GetMeshNodePosition(node, ConfigurationType::Visualization);
			EXUvis::DrawMarker(p, radius, alternativeColor, vSystem->graphicsData, itemID,
				!visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
		}
	}

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerSuperElementRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerSuperElementRigid* cMarker = (CMarkerSuperElementRigid*)vSystem->systemData->GetCMarkers()[itemNumber];
	const CObjectSuperElement* cSuperElement = (const CObjectSuperElement*)vSystem->systemData->GetCObjects()[cMarker->GetObjectNumber()];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	//show marker position
	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	Matrix3D A;
	cMarker->GetRotationMatrix(*vSystem->systemData, A, ConfigurationType::Visualization);
	
	//show marker orientation ==> only for rigid marker
	EXUvis::DrawOrthonormalBasis(pos, A, radius*4, 0.1*radius,
		vSystem->graphicsData, itemID, 1.f, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces,
		visualizationSettings.general.axesTiling, 2.5, -1, "M");

	if (showMarkerNodes)
	{
		Float4 alternativeColor = EXUvis::ModifyColor(currentColor, 0.25f);
		for (Index node : cMarker->GetParameters().meshNodeNumbers)
		{
			Vector3D p = cSuperElement->GetMeshNodePosition(node, ConfigurationType::Visualization);
			EXUvis::DrawMarker(p, radius, alternativeColor, vSystem->graphicsData, itemID,
				!visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
		}
	}

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

void VisualizationMarkerKinematicTreeRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerKinematicTreeRigid* cMarker = (CMarkerKinematicTreeRigid*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}



void VisualizationMarkerBodyCable2DShape::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DShape* cMarker = (CMarkerBodyCable2DShape*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 0, itemID);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor, itemID);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor, itemID);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DCoordinates::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Marker, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DCoordinates* cMarker = (CMarkerBodyCable2DCoordinates*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 0, itemID);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor, itemID);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor, itemID);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "M", currentColor); }
}





//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++  LOADS  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void VisualizationLoadForceVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Load, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadForceVector* cLoad = (CLoadForceVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::Position) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;

		if (cLoad->IsBodyFixed()) //transform load from local to global coordinates for drawing
		{
			Matrix3D rot;
			cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);
			loadVector = rot * loadVector;
		}

		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, 
			vSystem->graphicsData, itemID, visualizationSettings.general.axesTiling, false, !visualizationSettings.loads.drawSimplified && visualizationSettings.openGL.showFaces);

		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos+loadVector, vSystem, itemID, "L", currentColor); }
	}
}

void VisualizationLoadMassProportional::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Load, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadMassProportional* cLoad = (CLoadMassProportional*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::BodyMass) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		//always draw massproportional loads with fixed size
		Real L = loadVector.GetL2Norm();
		if (L > 0.) { loadVector *= 1. / L; }
		loadVector *= size;

		EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor,
			vSystem->graphicsData, itemID, visualizationSettings.general.axesTiling, false,
			!visualizationSettings.loads.drawSimplified && visualizationSettings.openGL.showFaces);

		//if (visualizationSettings.openGL.showFaces) //show in 3D
		//{
		//	EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.axesTiling);
		//}
		//else
		//{
		//	Vector3D n1; //resulting normal vector to loadVector ==> for drawing of arrow
		//	Vector3D n2;
		//	EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);

		//	//Vector3D hatOffset({ -0.1*loadVector[1], 0.1*loadVector[0], 0. });
		//	Vector3D hatOffset = (0.1*(Real)size)*n1;

		//	vSystem->graphicsData.AddLine(pos, pos + loadVector, currentColor, currentColor);
		//	vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector + hatOffset, currentColor, currentColor);
		//	vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector - hatOffset, currentColor, currentColor);
		//}
		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "L", currentColor); }
	}
}

void VisualizationLoadTorqueVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Load, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadTorqueVector* cLoad = (CLoadTorqueVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	if ((cMarker->GetType() & Marker::Position) && (cMarker->GetType() & Marker::Orientation)) //marker must be able to measure position and orientation
	{
		Vector3D pos; //global marker position
		Matrix3D rot; //global marker rotation
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);
		cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		if (cLoad->IsBodyFixed()) //transform load from local to global coordinates for drawing
		{
			Matrix3D rot;
			cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);
			loadVector = rot * loadVector;
		}

		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor,
			vSystem->graphicsData, itemID, visualizationSettings.general.axesTiling, true, !visualizationSettings.loads.drawSimplified && visualizationSettings.openGL.showFaces);

		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "L", currentColor); }
	}
}





//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++    SENSORS    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void VisualizationSensorNode::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Sensor, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	Index nodeNumber = vSystem->systemData->GetCSensors()[itemNumber]->GetNodeNumber();
	CNode* cNode = vSystem->systemData->GetCNodes()[nodeNumber];
	if (cNode->GetNodeGroup() == CNodeGroup::ODE2variables)
	{

		float radius = 0.5f*visualizationSettings.sensors.defaultSize;
		if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

		Vector3D pos(((CNodeODE2*)cNode)->GetPosition(ConfigurationType::Visualization));
		EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

		if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "S", currentColor); }
	}
}

void VisualizationSensorObject::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Sensor, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorObject* cSensor = (CSensorObject*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObject& cObject = *(vSystem->systemData->GetCObjects()[objectNumber]);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	//can only be drawn, if position exists
	if ((Index)cObject.GetType() & (Index)CObjectType::Connector)
	{
		const CObjectConnector& cConnector = (const CObjectConnector&)cObject;

		if (cConnector.GetMarkerNumbers().NumberOfItems() == 2)
		{
			const CMarker& cMarker0 = vSystem->systemData->GetCMarker(cConnector.GetMarkerNumbers()[0]);
			const CMarker& cMarker1 = vSystem->systemData->GetCMarker(cConnector.GetMarkerNumbers()[1]);

			Vector3D pos0, pos1;
			cMarker0.GetPosition(*(vSystem->systemData), pos0, ConfigurationType::Visualization);
			cMarker1.GetPosition(*(vSystem->systemData), pos1, ConfigurationType::Visualization);

			Vector3D pos = 0.5*(pos0 + pos1);
			EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);
			if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "S", currentColor); }
		}

	}


}

void VisualizationSensorBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Sensor, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorBody* cSensor = (CSensorBody*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObjectBody& cObject = vSystem->systemData->GetCObjectBody(objectNumber);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	Vector3D pos(cObject.GetPosition(cSensor->GetBodyLocalPosition(), ConfigurationType::Visualization));
	EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "S", currentColor); }

}

void VisualizationSensorSuperElement::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Sensor, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorSuperElement* cSensor = (CSensorSuperElement*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObjectSuperElement* cObject = (const CObjectSuperElement*)(vSystem->systemData->GetCObjects()[objectNumber]);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	Vector3D pos(cObject->GetMeshNodePosition(cSensor->GetMeshNodeNumber(), ConfigurationType::Visualization));
	EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "S", currentColor); }

}

void VisualizationSensorKinematicTree::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Sensor, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorKinematicTree* cSensor = (CSensorKinematicTree*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();

	const CObjectKinematicTree& cObject = (const CObjectKinematicTree&)vSystem->systemData->GetCObjectBody(objectNumber);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }


	Index n = cSensor->GetParameters().linkNumber;
	//GetPositionLinkLocalPosition needs to be implemented as well as other output variables in KinematicTree
	Vector3D pos = cObject.GetPositionKinematicTree(cSensor->GetBodyLocalPosition(), n, ConfigurationType::Visualization);
	EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "S", currentColor); }

}

void VisualizationSensorMarker::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Index itemID = Index2ItemID(itemNumber, ItemType::Sensor, vSystem->GetSystemID());
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	Index markerNumber = vSystem->systemData->GetCSensors()[itemNumber]->GetMarkerNumber();

	const CMarker& cMarker = vSystem->systemData->GetCMarker(markerNumber);

	Vector3D pos; //global marker position
	cMarker.GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, itemID, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemID, "S", currentColor); }
}



