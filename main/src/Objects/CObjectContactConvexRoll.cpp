/** ***********************************************************************************************
* @brief        Implementation of CObjectContactConvexRoll
*
* @author       Peter Manzl, Johannes Gerstmayr
* @date         2021-07-16 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectContactConvexRoll.h"
#include "Linalg/RigidBodyMath.h"
#include "Utilities/AdvancedMath.h"
#include "Utilities/Physics.h"

bool CObjectContactConvexRollRootOfPolynomialWarned = false;

/* PolynomialRollXOFAngle: calculate the x-Value of the polynomial matching the slope of the contact
*   poly:       coefficients of the polynomial describing the generatrix of the roller
*   dpoly:      coefficients of the derivative of the polynomial
*   n:          number of coefficients of the polynomial (=order+1)
*   lRoller:    length of the roller 
*   angy:       angle which the slope of the contact point should match
*/ 
Real CObjectContactConvexRoll::PolynomialRollXOfAngle(const Vector& poly, const Vector& dpoly, Real lRoller, Real angy) const
{
    Real k = tan(angy); // the tangent should be equal to k, therefore it is the offset for the desired Root
    Real x_0 = 0; // toDo: Starting Value of the Newton method using a second order polynomioal to decrease the number of steps
    Real xBoundary[2] = {-lRoller/2, lRoller/2}; 
    Real kBoundary[2];   // as only strictly convex bodies of revolution are covered in the formulation, the gradient can only increase monotoniously
    kBoundary[0] = -ExuMath::Polyval(poly, -lRoller/2);
    kBoundary[1] = -ExuMath::Polyval(poly, lRoller/2);
	Real x = 0; 
    if ((k > kBoundary[0]) and (k < kBoundary[1])) 
    { // if y is in the valid range calculate the root of the polynomial 
		Index iterations;
		x = ExuMath::RootOfPolynomial(poly, dpoly, x_0, k, xBoundary, 1e-14, CObjectContactConvexRollMaxIterationsContact, lRoller, iterations);
		if ((iterations >= CObjectContactConvexRollMaxIterationsContact) && not(CObjectContactConvexRollRootOfPolynomialWarned))
		{
			pout << "WARNING: ContactConvexRoll: maximum number of iterations " << EXUstd::ToString(CObjectContactConvexRollMaxIterationsContact) << " was surpassed. Further warnings will be suppressed!\n" << std::endl;
			CObjectContactConvexRollRootOfPolynomialWarned = true;
		}
	}
    else if (k > kBoundary[1])
    { // if the gradient lies out of the valid range it is projected back to the edge of the polynomial
        x = xBoundary[1];        
    } 
    else if( k < kBoundary[0])
    {
        x = xBoundary[0]; 
    }
    return x; 
}

// Check if a given polynomial is convex in the range of +/- lRoller/2 
bool CObjectContactConvexRoll::CheckConvexityOfPolynomial(const CObjectContactConvexRollParameters& parameters)
{
	const Vector& dpoly = GetCoefficientsHullDerivative(); //only reference to internal Vector

	Real lRoller = parameters.rollLength;
	int n_eval = CObjectContactConvexRollNEvalConvexityCheck;  
	ConstSizeVector<CObjectContactConvexRollNEvalConvexityCheck> eval_dpoly;
	Real x;
	Real ddpoly;
	bool convexity = true;
	for (int i = 0; i < n_eval; i++)
	{
		x = lRoller * (((double)i - n_eval / 2) / n_eval);
		eval_dpoly[i] = ExuMath::Polyval(dpoly, x);
		if (i > 0)
		{
			ddpoly = eval_dpoly[i] - eval_dpoly[i - 1];  // numerical divided difference, d/dx (dpoly) ~ (dpoly[x[i]] - dpoly[x[i-1]])/ (x[i] - x[i-1])
			if (ddpoly >= 0) {
				convexity = false; // not strictly convex 
			}
		}
	}
	return convexity;
}


/* findContactRoller: returns the point of a roller closest to the ground
*   Rotm:       rotation matrix from the ground to the local frame of the roller
*   poly:       coefficients of a strictly convex polynomial describing the surface of the roller
*   dpoly:      coefficients of the derivative of the polynomial poly
*   n:          order of the polynomial poly
*   lRoller:    length of the roller, so that the surface lies between +/- lRoller/2
*/
Vector3D CObjectContactConvexRoll::FindContactPoint(const Matrix3D& Rotm, const Vector& poly, Real lRoller) const 
{
	Vector3D pContact = Vector3D({ 0,0,0 }); // initialize 
	// calculate euler angles for z-y-x rotation
	Real angy = atan2(-Rotm[2][0], sqrt(fabs(1 - Rotm(2,0) * Rotm(2,0))));
	Real angx = atan2(Rotm[2][1], Rotm[2][2]);
	Real xContact = PolynomialRollXOfAngle(GetCoefficientsHullDerivative(), GetCoefficientsHullDDerivative(), lRoller, angy);
	Real rContact = ExuMath::Polyval(poly, xContact);
	pContact[0] = xContact;
	pContact[1] = rContact * sin(-angx); // geometrical considerations of local frame 
	pContact[2] = -rContact * cos(-angx);
	return pContact;  // returns the point closest to the ground, therefore pContact[2] < 0 => contact occures
}

//// sign template 
//template <typename T> int sign(T val) {
//	return (T(0) < val) - (val < T(0));
//}

// Initialize derivative of given polynomial for Roll form and check for convexity 
void CObjectContactConvexRoll::InitializeObject(const CObjectContactConvexRollParameters& parameters) 
{
	if (parameters.coefficientsHull.NumberOfItems() > CObjectContactConvexRollMaxPolynomialCoefficients) {
		PyError("The maximum number of " + EXUstd::ToString(CObjectContactConvexRollMaxPolynomialCoefficients) + " coefficients for the polynomial of the ContactConvexRoll was exceeded. Please reduce the number of coefficients. ");
	}
	Vector dpoly; //just called once, new is no problem!
	Vector ddpoly; 
	ExuMath::ComputePolynomialDerivative(parameters.coefficientsHull, dpoly);
	SetCoefficientsHullDerivative(dpoly); // constant vector because of performance
	ExuMath::ComputePolynomialDerivative(GetCoefficientsHullDerivative(), ddpoly);
	SetCoefficientsHullDDerivative(ddpoly);

	if (not(CObjectContactConvexRoll::CheckConvexityOfPolynomial(parameters))) {
		PyWarning("The given polynomial of ContactConvexRoll seems not to be convex. Check the coefficients of the Hull.");
	}
	SetRBoundingSphere(ExuMath::Polyval(parameters.coefficientsHull, 0));
	/*
	Vector3D p1; // position of roller in ground frame
	Vector3D pC; // global position of contact point
	Matrix3D Rotm; 
	Real& dataGap= ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[2];
	GetCSystemData()->GetCMarker(0).GetRotationMatrix(*this->GetCSystemData(), Rotm, ConfigurationType::Initial); 
	GetCSystemData()->GetCMarker(1).GetPosition(*this->GetCSystemData(), p1, ConfigurationType::Initial); 
	Vector3D pContactLocal = FindContactPoint(Rotm, parameters.coefficientsHull, parameters.rollLength);
	pC = Rotm * pContactLocal + p1;
	dataGap = pC[2]; 
	pout << "Initialized DataGap =" << EXUstd::ToString(dataGap) << std::endl; 
	*/

	objectIsInitialized = true;
}

/* PreContactCheckRoller: check if one of the bounding spheres at the ends of the rollers are in contact with the ground.
*  Rotm:            current rotation matrix of the roller in the ground frame
*  displacement:    position of the roller in the ground frame
*  lRoller:         length of the roller
*  R:               maximum radius of the roller / radius of the bounding sphere
*/
bool CObjectContactConvexRoll::PreContactCheckRoller(const Matrix3D& Rotm, const Vector3D& displacement, Real lRoller, Real R, Vector3D& pC) const
{
	//bool contact = true; // init possible contact
	Vector3D rx = Rotm * EXUmath::unitVecX * (lRoller / 2); // Get local x-Axis and go to the end of the Roller
	Vector3D rx1 = displacement + rx;
	Vector3D rx2 = displacement - rx;
	if ((rx1[2] < R) or (rx2[2] < R))
	{  // ground is inside the bounding sphere, so contact may occure
		return true;
	}
	else
	{ // ground outside bounding sphere, no contact possible
		if (rx1[2] < rx2[2]){
			pC = rx1;  // return point closest to ground for possible postNewtonStep
		}
		else if (rx2[2] < rx1[2])
		{
			pC = rx2; 
		}
		else
		{
			pC = rx; // in the center
		}
		return false;
	}

}


//! compute contact force helper function; vectors pC, vC provide position and velocity of contact point in global coordinate system; allowSwitching set false for Newton
//  vectors wLateral,
//  contact force fContact is given in local joint J1 coordinates
//  computeCurrent: if true, the contact forces are computed for current values, but for the data/history variables
void CObjectContactConvexRoll::ComputeContactForces(const MarkerDataStructure& markerData, const CObjectContactConvexRollParameters& parameters,
	Vector3D& pC, Vector3D& vC, Vector3D& fContact, Vector3D& mContact, bool allowSwitching) const {
	
	const Vector3D& p1 = markerData.GetMarkerData(1).position; // global position of contact marker 
	const Matrix3D& Rotm = markerData.GetMarkerData(1).orientation;	// Rotation matrix from ground to roller
	const Vector3D& v1 = markerData.GetMarkerData(1).velocity;		// global velocity of the roller


	//const Vector& poly = GetCoefficientsHullDerivative();
	//const Vector& dpoly = GetCoefficientsHullDDerivative();
	const Real& dataGap = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[0]; 

	//contact only considered, if switched in PostNewton
	if ((allowSwitching || dataGap < 0) && CObjectContactConvexRoll::PreContactCheckRoller(Rotm, p1, parameters.rollLength, GetRBoundingSphere(), pC))
		{
		Vector3D pContactLocal = FindContactPoint(Rotm, parameters.coefficientsHull, parameters.rollLength);
		pC = Rotm * pContactLocal + p1;
		//if ((pC[2] > 0) or (dataGap > 0)){ // do not change contact while in newton method
		//	fContact = Vector3D({ 0,0,0 });
		//	mContact = Vector3D({ 0,0,0 });
		//	vC = Vector3D({ 0,0,0 });
		//	return; 
		//}
		Vector3D wLocal = markerData.GetMarkerData(1).angularVelocityLocal;
		vC = Rotm * (wLocal.CrossProduct(pContactLocal));
		Vector3D vNormal = EXUmath::unitVecZ * (EXUmath::unitVecZ * v1);
		Vector3D vCNormal = EXUmath::unitVecZ * (EXUmath::unitVecZ * vC);
		Vector3D vTangential = v1 - vNormal;
		Vector3D vCTangential = vC - vCNormal; // tangential component of contact velocity
		Vector3D vDiff = vCTangential - (-vTangential); // difference of tangential velocities of contact point and Roller
		Real FNormal = parameters.contactStiffness * pC[2] + parameters.contactDamping * v1[2];  // spring-damper model for normal force
		Real normVDiff = vDiff.GetL2Norm();
		Vector3D rt; // direction vector of tangential velocity difference vDiff 
		if (normVDiff == 0)
		{
			rt = vDiff; // avoid diff0
		}
		else
		{
			rt = (1 / normVDiff) * vDiff;
		}
		Real dFric = ExuPhysics::StribeckFunction(vDiff.GetL2Norm(), parameters.dynamicFriction, parameters.staticFrictionOffset,
			parameters.viscousFriction, parameters.exponentialDecayStatic, parameters.frictionProportionalZone);  // Friction coefficients
		fContact = dFric * fabs(FNormal) * rt;
		fContact[2] += FNormal;
		mContact = (Rotm * pContactLocal).CrossProduct(fContact);
		// pout << std::endl << "friction coeff dFric " << dFric << "\t vector rt = "<< rt << std::endl;
		// pout << "normVDiff = " << normVDiff <<  "vDiff = "  << vDiff << std::endl;
	}
	else
	{
		fContact = Vector3D({ 0,0,0 });
		mContact = Vector3D({ 0,0,0 });
		vC = Vector3D({ 0,0,0 });
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectContactConvexRoll::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectContactConvexRoll::ComputeODE2LHS: marker do not provide velocityLevel information");

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	//pout << "test\n";
	if (parameters.activeConnector)
	{
		Vector3D pC; //deviation of contact conditions
		Vector3D vC; //deviation of velocity at contact point
		Vector3D fContact; //contact force (0=lateral, 1=longitudinal, 2=normal direction), local coordinates
		Vector3D mContact;  // torque in the contact point
		
		ComputeContactForces(markerData, parameters, pC, vC, fContact, mContact, false);
		// pout << "pC=" << pC << "\t fContact" << fContact << std::endl; 
		
		
		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			//positionJacobian.NumberOfColumns() == rotationJacobian.NumberOfColumns()
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(), markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fContact, ldv1);
			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, mContact, ldv1);
		}

		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{ 
			fContact *= -1.; // on marker 0 (ground) the sign is flipped 
			mContact *= -1.;
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, fContact, ldv0);
			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, mContact, ldv0);
		}
		// pout << "fContact" << fContact <<"\tode2Lhs=" << ode2Lhs << "\n";
	}

}

//! provide according output variable in "value"
void CObjectContactConvexRoll::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	//const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	//const Vector3D& v1 = markerData.GetMarkerData(1).velocity;
	//Vector3D omega1 = A1 * markerData.GetMarkerData(1).angularVelocityLocal;

	Vector3D pC; //deviation of contact conditions
	Vector3D vC; //deviation of velocity at contact point
	Vector3D fContact; //contact force (0=lateral, 1=longitudinal, 2=normal direction)
	Vector3D mContact;
	ComputeContactForces(markerData, parameters,pC, vC, fContact, mContact, false);

	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(pC); break;
	case OutputVariableType::Velocity: value.CopyFrom(vC); break;
	case OutputVariableType::Force:
	{
		value.CopyFrom(fContact);
		break;
	}
	case OutputVariableType::Torque:
	{
		value.CopyFrom(mContact);
		break;
	}
	default:
		SysError("CObjectContactConvexRoll::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}

//! function called after Newton method; returns a residual error (force)
Real CObjectContactConvexRoll::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
	Real discontinuousError = 0;
	flags = PostNewtonFlags::_None;

	Vector3D pC; // global contact position
	Vector3D vC; // velocity of the contact point
	Vector3D fContact; // contact force, global coordinates
	Vector3D mContact; // contact force, global coordinates
	ComputeContactForces(markerDataCurrent, parameters, pC, vC, fContact, mContact, true);
	Real& dataGap = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[0]; // the current gap to be modified
	Real dataGapStart = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep)[0]; // the Gap from the start of step 

	SetPContact(pC); 	//REMOVE!!!!!
	Real currentGap = pC[2]; //  z-coordinate as ground is flat in x-y plane; negative z-coord is contact!
	if ((currentGap > 0 && dataGapStart <= 0) || (currentGap <= 0 && dataGapStart > 0)) { //action: state1=dataGapState, error = |currentGap*k|
		discontinuousError += fabs(currentGap * parameters.contactStiffness); // error because of wrong assumption of contact#
		// ToDo: only print if Verbosemode >= 1 
		pout << "PostNewton Connector " << EXUstd::ToString(itemIndex) << ": " << markerDataCurrent.GetTime() << ": changed from gap " << dataGapStart << " to " << currentGap << "\n";
		recommendedStepSize = fabs(pC[2]/vC[2]);  // moment in which contact should switch 
	}
	else if (currentGap < 0) { //both states are the same, only interesting if gap is negative
		// error due to changing slip velocity slip velocity ?? 
		// ComputeSlipForce()

	}

	/*
	if ((currentGap > 0 && dataGapState <= 0) || (currentGap <= 0 && dataGapState > 0)) //action: state1=dataGapState, error = |currentGap*k|
	else if (currentGap < 0 ) //both states are the same, only interesting if gap is negative
	{
		//old and new state have contact ==> check if right slipping condition has been assumed:
		Vector2D dataSlipForce = ComputeSlipForce(parameters, localSlipVelocity, dataLocalSlipVelocity, fContact[2]);
		Vector2D slipForce = ComputeSlipForce(parameters, localSlipVelocity, localSlipVelocity, fContact[2]);

		discontinuousError += (slipForce - dataSlipForce).GetL2Norm(); //always there is an error because slip direction is updated slowly
	}
	*/ 
	//store new contact gap and slip velocities:
	dataGap = currentGap; 
	// ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[1] = vC[0];
	// ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[2] = vC[1];
	return discontinuousError;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CObjectContactConvexRoll::PostDiscontinuousIterationStep()
{

}


