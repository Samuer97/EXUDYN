/** ***********************************************************************************************
* @brief		Implementation for NodeRigidBody2D
*
* @author		Gerstmayr Johannes
* @date			2019-06-15 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeRigidBody2D.h"				//includes ReleaseAssert.h, BasicDefinitions.h, ResizeableArray.h, LinkedDataVector.h
#include "Utilities/RigidBodyMath.h"

////for CallFunction(...)
//#include "Main/MainSystem.h"
//#include "Pymodules/PybindUtilities.h"
//#include "Autogenerated/MainNodeRigidBody2D.h"


Vector3D CNodeRigidBody2D::GetPosition(ConfigurationType configuration) const
{
	LinkedDataVector pRef2D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef2D[0], pRef2D[1], 0. });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	LinkedDataVector u2D = GetCoordinateVector(configuration);
	Vector3D displacement({ u2D[0], u2D[1], 0. });
	return pRef + displacement;
}

Vector3D CNodeRigidBody2D::GetVelocity(ConfigurationType configuration) const
{
	LinkedDataVector u2D_t = GetCoordinateVector_t(configuration);
	return Vector3D({ u2D_t[0], u2D_t[1], 0. }); //rotation ignored
}

Vector3D CNodeRigidBody2D::GetAcceleration(ConfigurationType configuration) const
{
	LinkedDataVector u2D_tt = GetCoordinateVector_tt(configuration);
	return Vector3D({ u2D_tt[0], u2D_tt[1], 0. }); //rotation ignored
}

Matrix3D CNodeRigidBody2D::GetRotationMatrix(ConfigurationType configuration) const
{
	Real phi = GetReferenceCoordinateVector()[2];
	if (configuration != ConfigurationType::Reference)
	{
		phi += GetCoordinateVector(configuration)[2];
	}
	return Matrix3D(3,3,{ cos(phi),-sin(phi),0.,  sin(phi),cos(phi),0., 0.,0.,1.});
}

//! AUTO:  return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CNodeRigidBody2D::GetAngularVelocity(ConfigurationType configuration) const
{
	return Vector3D({ 0., 0., GetCoordinateVector_t(configuration)[2] }); 
}

//! AUTO:  return configuration dependent angular acceleration of node; returns always a 3D Vector
Vector3D CNodeRigidBody2D::GetAngularAcceleration(ConfigurationType configuration) const
{
	return Vector3D({ 0., 0., GetCoordinateVector_tt(configuration)[2] }); 
}



////! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
//OutputVariableType CNodeRigidBody2D::GetOutputVariableTypes() const
//{
//	return (OutputVariableType)((Index)OutputVariableType::Position + (Index)OutputVariableType::Velocity +
//		(Index)OutputVariableType::Coordinates + (Index)OutputVariableType::Coordinates_t);
//}

//! provide according output variable in "value"
void CNodeRigidBody2D::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
	case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(configuration)); break;
	case OutputVariableType::AngularAcceleration: value.CopyFrom(GetAngularAcceleration(configuration)); break;
	case OutputVariableType::Coordinates:
	{
		if (IsConfigurationInitialCurrentReferenceVisualization(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodeRigidBody2D::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsConfigurationInitialCurrentVisualization(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodeRigidBody2D::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_tt:
	{
		if (IsConfigurationInitialCurrentVisualization(configuration)) 
		{
			value = GetCoordinateVector_tt(configuration);
		}
		else
		{
			PyError("CNodeRigidBody2D::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(configuration)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetAngularVelocityLocal(configuration)); break;
	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(configuration);
		value.SetVector(9, rot.GetDataPointer());
		break;
	}
	case OutputVariableType::Rotation: 
	{
		//old, does not reveal infinite rotations:
		//Matrix3D rotMat = GetRotationMatrix(configuration);
		//Vector3D rot = RigidBodyMath::RotationMatrix2RotXYZ(rotMat);

		Real phi = GetCoordinateVector(configuration)[2];
		if (configuration != ConfigurationType::Reference) {
			phi += GetCoordinateVector(ConfigurationType::Reference)[2];
		}
		Vector3D rot({0.,0.,phi});

		value.SetVector(3, rot.GetDataPointer());
		break;
	}
	default:
		SysError("CNodeRigidBody2D::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}

//delete:
////! call a certain function of object (autogenerated in future!)
//py::object MainNodeRigidBody2D::CallFunction(STDstring functionName, py::dict args) const
//{
//	//these calls should be automated by python script ...
//	if (functionName == "GetTypeName")
//	{
//		return py::str(GetTypeName());
//	}
//	else if (functionName == "GetNodeType")
//	{
//		return py::cast(GetCNodeRigidBody2D()->GetType());
//	}
//	else if (functionName == "GetNodeGroup")
//	{
//		return py::cast(GetCNodeRigidBody2D()->GetNodeGroup());
//	}
//	else if (functionName == "GetNumberOfODE2Coordinates")
//	{
//		return py::int_(GetCNodeRigidBody2D()->GetNumberOfODE2Coordinates());
//	}
//	else if (functionName == "GetGlobalODE2CoordinateIndex")
//	{
//		return py::int_(GetCNodeRigidBody2D()->GetGlobalODE2CoordinateIndex());
//	}
//	else if (functionName == "GetCurrentCoordinateVector")
//	{
//		LinkedDataVector v(GetCNodeRigidBody2D()->GetCurrentCoordinateVector());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetInitialCoordinateVector")
//	{
//		LinkedDataVector v(GetCNodeRigidBody2D()->GetInitialCoordinateVector());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetCurrentCoordinateVector_t")
//	{
//		LinkedDataVector v(GetCNodeRigidBody2D()->GetCurrentCoordinateVector_t());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetInitialCoordinateVector_t")
//	{
//		LinkedDataVector v(GetCNodeRigidBody2D()->GetInitialCoordinateVector_t());
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	else if (functionName == "GetCurrentPosition")
//	{
//		Vector3D v = GetCNodeRigidBody2D()->GetPosition(ConfigurationType::Current);
//		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
//	}
//	//before doing so, use : https://pybind11.readthedocs.io/en/master/advanced/pycpp/numpy.html?highlight=numpy#f
//	// and matrix example : https://github.com/pybind/pybind11/blob/master/tests/test_buffers.cpp
//	//else if (functionName == "GetCurrentRotationMatrix")
//	//{
//	//	Matrix3D m = GetCNodeRigidBody2D()->GetRotationMatrix(ConfigurationType::Current);
//	//	return py::array_t<Real>(m.NumberOfItems(), m.GetDataPointer());
//	//}
//
//	PyError(STDstring("MainNodeRigidBody2D::CallFunction called with invalid functionName '" + functionName + "'"));
//	return py::int_(EXUstd::InvalidIndex);
//}
