/** ***********************************************************************************************
* @brief        CObjectJointPrismaticX implementation; follows mostly the CObjectJointGeneric.cpp implementation
*
* @author       Gerstmayr Johannes
* @date         2018-06-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"
#include "Autogenerated/CObjectJointPrismaticX.h"
#include "Linalg/RigidBodyMath.h"

#include <pybind11/stl.h> 
#include <pybind11/stl_bind.h>
#include <pybind11/numpy.h> //accept numpy arrays: numpy array automatically converted to std::vector<Real,...> ==> accepts np.array([1,0,0]) and [1,0,0] as return value!

//! Computational function: compute algebraic equations and write residual into "algebraicEquations"
void CObjectJointPrismaticX::ComputeAlgebraicEquations(Vector& algebraicEquations, const MarkerDataStructure& markerData, Real t, Index itemIndex, bool velocityLevel) const
{
	if (parameters.activeConnector)
	{

		algebraicEquations.SetNumberOfItems(nConstraints);
		//const LinkedDataVector& lambda = markerData.GetLagrangeMultipliers();

		const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
		const Matrix3D& A0off = parameters.rotationMarker0;
		Matrix3D A0all = (A0*A0off);

		if (!velocityLevel)
		{
			//use difference of positions in local coordinates
			Vector3D vPos = A0all.GetTransposed()*(markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position); //local equations (marker0-fixed)

			algebraicEquations[0] = vPos[1]; //J0 y-axis; local constraint
			algebraicEquations[1] = vPos[2]; //J0 z-axis; local constraint

			//++++++++++++++++++++++++++++++++
			//rotation constraints:
			const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
			const Matrix3D& A1off = parameters.rotationMarker1;
			Matrix3D A1all = (A1*A1off);

			Vector3D vx0 = A0all.GetColumnVector<3>(0);
			//Vector3D vy0 = A0all.GetColumnVector<3>(1);
			Vector3D vz0 = A0all.GetColumnVector<3>(2);

			Vector3D vx1 = A1all.GetColumnVector<3>(0);
			Vector3D vy1 = A1all.GetColumnVector<3>(1);
			//Vector3D vz1 = A1all.GetColumnVector<3>(2);

			algebraicEquations[2] = vz0 * vy1;
			algebraicEquations[3] = vz0 * vx1;
			algebraicEquations[4] = vx0 * vy1;
		}
		else //index2
		{
			//CHECKandTHROWstring("CObjectJointPrismaticX: velocity level not implemented"); 
			CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable, "CObjectJointPrismaticX::ComputeAlgebraicEquations: marker do not provide velocityLevel information");

			const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
			const Matrix3D& A1off = parameters.rotationMarker1;
			Matrix3D A1all = (A1*A1off);

			Matrix3D A0_t = markerData.GetMarkerData(0).orientation * RigidBodyMath::Vector2SkewMatrix(markerData.GetMarkerData(0).angularVelocityLocal);
			Matrix3D A1_t = markerData.GetMarkerData(1).orientation * RigidBodyMath::Vector2SkewMatrix(markerData.GetMarkerData(1).angularVelocityLocal);
			Matrix3D A0all_t = (A0_t*A0off);
			Matrix3D A1all_t = (A1_t*A1off);

			//use difference of velocities in local coordinates
			Vector3D vVel = A0all.GetTransposed()*(markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity)
				+ A0all_t.GetTransposed()*(markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
			//the term A0all_t is needed for prismatic joints, because then the positions are not any more identical ...; 
			//==> causes divergence of index2 solver after short time!


			algebraicEquations[0] = vVel[1]; //J0 y-axis; local constraint
			algebraicEquations[1] = vVel[2]; //J0 z-axis; local constraint

			//++++++++++++++++++++++++++++++++
			//rotation constraints:
			Vector3D vx0 = A0all.GetColumnVector<3>(0);
			//Vector3D vy0 = A0all.GetColumnVector<3>(1);
			Vector3D vz0 = A0all.GetColumnVector<3>(2);

			Vector3D vx1 = A1all.GetColumnVector<3>(0);
			Vector3D vy1 = A1all.GetColumnVector<3>(1);
			//Vector3D vz1 = A1all.GetColumnVector<3>(2);

			Vector3D vx0_t = A0all_t.GetColumnVector<3>(0);
			//Vector3D vy0_t = A0all_t.GetColumnVector<3>(1);
			Vector3D vz0_t = A0all_t.GetColumnVector<3>(2);

			Vector3D vx1_t = A1all_t.GetColumnVector<3>(0);
			Vector3D vy1_t = A1all_t.GetColumnVector<3>(1);
			//Vector3D vz1_t = A1all_t.GetColumnVector<3>(2);

			algebraicEquations[2] = vz0_t * vy1 + vz0 * vy1_t;
			algebraicEquations[3] = vz0_t * vx1 + vz0 * vx1_t;
			algebraicEquations[4] = vx0_t * vy1 + vx0 * vy1_t;

			////alternative approach:
			//Vector3D dOmega = A0all * markerData.GetMarkerData(0).angularVelocityLocal - A1all * markerData.GetMarkerData(1).angularVelocityLocal;
			//
			//algebraicEquations[2] = dOmega[0];
			//algebraicEquations[3] = dOmega[1];
			//algebraicEquations[4] = dOmega[2];
		}
	}
	else
	{
		algebraicEquations.CopyFrom(markerData.GetLagrangeMultipliers()); //equation [lambda0,lambda1]^T = [0,0]^T, means that the current values need to be copied
	}
}


void CObjectJointPrismaticX::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, ResizableMatrix& jacobian_ODE1, 
	ResizableMatrix& jacobian_AE, const MarkerDataStructure& markerData, Real t, Index itemIndex) const
{
	if (parameters.activeConnector)
	{
		//markerData contains already the correct jacobians ==> transformed to constraint jacobian
		Index nColumnsJac0 = markerData.GetMarkerData(0).positionJacobian.NumberOfColumns();
		Index nColumnsJac1 = markerData.GetMarkerData(1).positionJacobian.NumberOfColumns();
		jacobian_ODE2.SetNumberOfRowsAndColumns(nConstraints, nColumnsJac0 + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());

		const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
		const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
		//const Matrix3D& A0off = EXUmath::unitMatrix3D; //parameters.rotationMarker0;
		//const Matrix3D& A1off = EXUmath::unitMatrix3D; //parameters.rotationMarker1;
		const Matrix3D& A0off = parameters.rotationMarker0;
		const Matrix3D& A1off = parameters.rotationMarker1;
		Matrix3D A0all = (A0*A0off);
		Matrix3D A1all = (A1*A1off);

		Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
		Matrix3D A0allT = A0all.GetTransposed();
		Matrix3D vPosTilde = RigidBodyMath::Vector2SkewMatrix(vPos);

		//vPos = A0allT*(markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position); //local equations (marker0-fixed)
		// A0allT_q0*vPos - A0allT * posJac0
		// A0allT * posJac1
		for (Index i = 0; i < nColumnsJac0; i++)
		{
			Vector3D Gvec0 = markerData.GetMarkerData(0).rotationJacobian.GetColumnVector<3>(i);
			Vector3D jacPos0 = markerData.GetMarkerData(0).positionJacobian.GetColumnVector<3>(i);
			Vector3D v = A0allT * (vPosTilde*Gvec0 - jacPos0);  //A0allT*vPosTilde*Gvec0  - A0allT * jacPos0;
			jacobian_ODE2(0, i) = v[1]; //y
			jacobian_ODE2(1, i) = v[2]; //z
		}
		for (Index i = 0; i < nColumnsJac1; i++)
		{
			Vector3D jacPos1 = markerData.GetMarkerData(1).positionJacobian.GetColumnVector<3>(i);
			Vector3D v = A0allT * jacPos1;
			jacobian_ODE2(0, i + nColumnsJac0) = v[1];
			jacobian_ODE2(1, i + nColumnsJac0) = v[2];
		}

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		Vector3D vx0 = A0all.GetColumnVector<3>(0);
		//Vector3D vy0 = A0all.GetColumnVector<3>(1);
		Vector3D vz0 = A0all.GetColumnVector<3>(2);

		Vector3D vx1 = A1all.GetColumnVector<3>(0);
		Vector3D vy1 = A1all.GetColumnVector<3>(1);
		//Vector3D vz1 = A1all.GetColumnVector<3>(2);

		//algebraicEquations[2] = vz0 * vy1;
		//algebraicEquations[3] = vz0 * vx1;
		//algebraicEquations[4] = vx0 * vy1;

		for (Index i = 0; i < nColumnsJac0; i++)
		{
			Vector3D Gvec0 = -1.*markerData.GetMarkerData(0).rotationJacobian.GetColumnVector<3>(i);
			jacobian_ODE2(2, i) = vy1 * (RigidBodyMath::Vector2SkewMatrix(vz0) * Gvec0);
			jacobian_ODE2(3, i) = vx1 * (RigidBodyMath::Vector2SkewMatrix(vz0) * Gvec0);
			jacobian_ODE2(4, i) = vy1 * (RigidBodyMath::Vector2SkewMatrix(vx0) * Gvec0);
		}
		for (Index i = 0; i < nColumnsJac1; i++)
		{
			Vector3D Gvec1 = -1.*markerData.GetMarkerData(1).rotationJacobian.GetColumnVector<3>(i);
			jacobian_ODE2(2, i + nColumnsJac0) = vz0 * (RigidBodyMath::Vector2SkewMatrix(vy1) * Gvec1);
			jacobian_ODE2(3, i + nColumnsJac0) = vz0 * (RigidBodyMath::Vector2SkewMatrix(vx1) * Gvec1);
			jacobian_ODE2(4, i + nColumnsJac0) = vx0 * (RigidBodyMath::Vector2SkewMatrix(vy1) * Gvec1);
		}

		//jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); 
		//jacobian_AE.SetNumberOfRowsAndColumns(0, 0);
	}
	else
	{
		jacobian_AE.SetScalarMatrix(nConstraints, 1.); //represents derivative of algebraic equation '[lambda0,lambda1]^T = [0,0]^T'
	}
}

JacobianType::Type CObjectJointPrismaticX::GetAvailableJacobians() const
{
	if (parameters.activeConnector)
	{
		return (JacobianType::Type)(JacobianType::AE_ODE2 + JacobianType::AE_ODE2_function ); 
	}
	else //deactivated constraint means that only the lagrange multiplier needs to be set to zero
	{
		return (JacobianType::Type)(JacobianType::AE_AE + JacobianType::AE_AE_function);
	}
}

//! provide according output variable in "value"
void CObjectJointPrismaticX::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	//const LinkedDataVector& lambda = markerData.GetLagrangeMultipliers();

	const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
	const Matrix3D& A0off = parameters.rotationMarker0;
	Matrix3D A0all = (A0*A0off);

	const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	const Matrix3D& A1off = parameters.rotationMarker1;
	Matrix3D A1all = (A1*A1off);

	//use difference of positions in local joint J0 coordinates
	Vector3D vPosLocal = A0all.GetTransposed()*(markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position); 
	Vector3D vVelLocal = A0all.GetTransposed()*(markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);

	Vector3D angVelLocal = A0all.GetTransposed()*(A1*markerData.GetMarkerData(1).angularVelocityLocal - A0 * markerData.GetMarkerData(0).angularVelocityLocal); //difference of global angular velocities, projected into J0

	//compute relative rotation, J0-fixed:
	Matrix3D relRot = A0all.GetTransposed() * A1all;
	Vector3D vLocRot = RigidBodyMath::RotationMatrix2RotXYZ(relRot);

	if (vLocRot[0] > EXUstd::pi) { vLocRot[0] -= 2.*EXUstd::pi; }
	if (vLocRot[1] > EXUstd::pi) { vLocRot[1] -= 2.*EXUstd::pi; }
	if (vLocRot[2] > EXUstd::pi) { vLocRot[2] -= 2.*EXUstd::pi; }

	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(markerData.GetMarkerData(0).position); break;
	case OutputVariableType::Velocity: value.CopyFrom(markerData.GetMarkerData(0).velocity); break;
	case OutputVariableType::DisplacementLocal: value.CopyFrom(vPosLocal); break;
	case OutputVariableType::Rotation: value.CopyFrom(vLocRot); break;
	case OutputVariableType::VelocityLocal: value.CopyFrom(vVelLocal); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(angVelLocal); break;
	case OutputVariableType::ForceLocal:
	{
		//force is local in Prismatic joint
		Vector3D force({ 0., GetCurrentAEcoordinate(0), GetCurrentAEcoordinate(1) }); //x, y, z in J0 joint coordinates
		value.CopyFrom(force);
		break;
	}
	case OutputVariableType::TorqueLocal:
	{
		Vector3D torque({ GetCurrentAEcoordinate(2), GetCurrentAEcoordinate(3), GetCurrentAEcoordinate(4) });
		value.CopyFrom(torque);
		break;
	}
	default:
		SysError("CObjectJointPrismaticX::GetOutputVariable failed"); //error should not occur, because types are checked!
	}

}



