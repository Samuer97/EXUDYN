/** ***********************************************************************************************
* @brief        CObjectJointRevolute2D implementation
*
* @author       Gerstmayr Johannes
* @date         2018-06-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectJointRevolute2D.h"


//! Computational function: compute algebraic equations and write residual into "algebraicEquations"
void CObjectJointRevolute2D::ComputeAlgebraicEquations(Vector& algebraicEquations, const MarkerDataStructure& markerData, Real t, Index itemIndex, bool velocityLevel) const
{
	if (parameters.activeConnector)
	{
		if (!velocityLevel)
		{
			Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);

			algebraicEquations.SetNumberOfItems(2);
			algebraicEquations[0] = vPos[0];
			algebraicEquations[1] = vPos[1];
		}
		else
		{
			CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable, "CObjectJointRevolute2D::ComputeAlgebraicEquations: marker do not provide velocityLevel information");
			Vector3D vVel = (markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);

			algebraicEquations.SetNumberOfItems(2);
			algebraicEquations[0] = vVel[0];
			algebraicEquations[1] = vVel[1];

		}
	}
	else
	{
		algebraicEquations.CopyFrom(markerData.GetLagrangeMultipliers()); //equation [lambda0,lambda1]^T = [0,0]^T, means that the current values need to be copied
	}
}


void CObjectJointRevolute2D::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, ResizableMatrix& jacobian_ODE1, 
	ResizableMatrix& jacobian_AE, const MarkerDataStructure& markerData, Real t, Index itemIndex) const
{
	if (parameters.activeConnector)
	{
		//markerData contains already the correct jacobians ==> transformed to constraint jacobian
		Index columnsOffset = markerData.GetMarkerData(0).positionJacobian.NumberOfColumns();
		jacobian_ODE2.SetNumberOfRowsAndColumns(2, columnsOffset + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());

		for (Index i = 0; i < columnsOffset; i++)
		{
			jacobian_ODE2(0, i) = -markerData.GetMarkerData(0).positionJacobian(0, i);
			jacobian_ODE2(1, i) = -markerData.GetMarkerData(0).positionJacobian(1, i);
		}
		for (Index i = 0; i < markerData.GetMarkerData(1).positionJacobian.NumberOfColumns(); i++)
		{
			jacobian_ODE2(0, i + columnsOffset) = markerData.GetMarkerData(1).positionJacobian(0, i);
			jacobian_ODE2(1, i + columnsOffset) = markerData.GetMarkerData(1).positionJacobian(1, i);
		}
		//jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); 
		//jacobian_AE.SetNumberOfRowsAndColumns(0, 0);
	}
	else
	{
		jacobian_AE.SetScalarMatrix(2, 1.); //represents derivative of algebraic equation '[lambda0,lambda1]^T = [0,0]^T'
	}
}

JacobianType::Type CObjectJointRevolute2D::GetAvailableJacobians() const
{
	if (parameters.activeConnector)
	{
		return (JacobianType::Type)(JacobianType::AE_ODE2 + JacobianType::AE_ODE2_function);
	}
	else //deactivated constraint means that only the lagrange multiplier needs to be set to zero
	{
		return (JacobianType::Type)(JacobianType::AE_AE + JacobianType::AE_AE_function);
	}
}


//! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
OutputVariableType CObjectJointRevolute2D::GetOutputVariableTypes() const
{
	return (OutputVariableType)((Index)OutputVariableType::Displacement + (Index)OutputVariableType::Rotation); //Displacement represents drift in index2 case
}

//! provide according output variable in "value"
void CObjectJointRevolute2D::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	SysError("CObjectJointRevolute2D::GetOutputVariableConnector not implemented");
}



