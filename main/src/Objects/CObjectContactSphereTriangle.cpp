/** ***********************************************************************************************
* @brief        Implementation of CObjectContactSphereTriangle
*
* @author       Gerstmayr Johannes
* @date         2025-05-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Linalg/Geometry.h"
#include "Autogenerated/CNodeGenericData.h"
#include "Autogenerated/CObjectContactSphereTriangle.h"

// compute the contact force acting on sphere 1; n0 points from center of spehere 0 to center of sphere 1
// gap is the distance between the two speheres (negative in case of contact)
// n0 is the vector pointing from center of spehere 0 to spehere 1
// deltaVnormal is the separation (gap) velocity (for sphere 1 positive in the case that the particles separate)
template<typename TReal>
TReal CObjectContactSphereTriangle::ComputeContactForces(TReal gap, const SlimVectorBase<TReal, 3>& n0,
	TReal deltaVnormal, const SlimVectorBase<TReal, 3>& deltaVji, TReal dryFriction, bool frictionRegularizedRegion,
	SlimVectorBase<TReal, 3>& fVec, SlimVectorBase<TReal, 3>& fFriction, bool forceFrictionMode) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Real k1 = parameters.contactStiffness;
	Real d1 = parameters.contactDamping;
	Real n = parameters.contactStiffnessExponent;
	TReal deltaExp = -gap; // overwrite this in case that n != 1 holds (see following line)
	if (n != 1) { deltaExp = EXUstd::SignReal(deltaExp) * pow(fabs(deltaExp), n); } // also respect sign
	// at first, just use the easierst spring damper model (damping acts against n0 for sphere 1 if deltaVnormal is positive)
	TReal fDamp = -d1 * deltaVnormal;
	TReal contactForce = k1 * deltaExp + fDamp;

	if (parameters.impactModel != 0)
	{
		// if impactModel != 0  treat the contact force with restitution model
		// for resititution coefficient < 1, lambda must be negative as component acting in direction of damping is added
		TReal minImpactVel = EXUstd::Maximum(parameters.minimumImpactVelocity, data[dataIndexImpactVel]);
		if (minImpactVel > 0)
		{
			TReal lambda = k1 / minImpactVel;
			const Real& ee = parameters.restitutionCoefficient;
			if (parameters.impactModel == 1) // Hunt-Crossley
			{
				lambda *= 3. / 2. * (ee - 1.);
			}
			else if (parameters.impactModel == 2) // mixed Gonthier/EtAl-Carvalho/Martins
			{
				if (ee > 1. / 3.)
				{
					lambda *= 3. / 2. * (ee - 1.) * (11. - ee) / (1. + 9. * ee);
				}
				else if (ee > 0)
				{
					lambda *= (ee * ee - 1.) / ee;
				}
				else {
					CHECKandTHROWstring("CObjectContactSphereTriangle: coefficient of restitution must be > 0");
				}
			}
			contactForce += lambda * deltaExp * deltaVnormal;
		}
	}
	contactForce *= (-1); // this is the contact force acting on sphere (and moved to the LHS of the ODE2)
	fVec = contactForce * n0; //fVec = f_m1
	////////////////////////// add tangential component for the force vector if friction should be added
	// note that for coulomb friction we need fR acting against the velocity
	// fR = - fN * deltaVtangent
	// since fN is already moved to LHS of ODE2, the negative sign is not necessary: fR = fN * deltaVtangent
	// since we then must also move fR to LHS of ODE2, the computation again gets a negative sign
	if (dryFriction != 0.)
	{
		// global tangent velocity of spehere 1 relative to spehere 0
		SlimVectorBase<TReal, 3> deltaVtangent = deltaVji - deltaVnormal * n0;	// tangent velocity
		TReal relVel = deltaVtangent.GetL2Norm();
		if (!forceFrictionMode) // if mode is not enforced, then we have to compute it (this is wrong in GeneralContact!)
		{
			frictionRegularizedRegion = (relVel < parameters.frictionProportionalZone);
		}
		if (frictionRegularizedRegion && parameters.frictionProportionalZone != 0)
		{
			//Warning: in the adhesive model, contactForce could become positive (=tension) and cause unphysical friction behavior
			// as long as relVel < frictionProportionalZone, friction force is computed linearily with deltaVtangent
			fFriction = (-dryFriction * contactForce / parameters.frictionProportionalZone) * deltaVtangent;
		}
		else
		{
			if (relVel != 0.) //in case that frictionProportionalZone=0, this could happen!
			{
				// this is to scale the friction force with the relative velocity
				// the friction force is decreased for high relative velocities
				fFriction = (-dryFriction * contactForce / relVel) * deltaVtangent; //this should be put into the nonlinear iteration for better Newton convergence ...
			}
			else { fFriction.SetAll(0.); }
		}
		fVec += fFriction;
	}
	return contactForce;
}

//compute the properties which are needed for computation of LHS and needed for OutputVariables
void CObjectContactSphereTriangle::ComputeConnectorProperties(const MarkerDataStructure& markerData, Index itemIndex, const LinkedDataVector& data,
	Real& frictionCoeff, Real& gap, Vector3D& deltaP, Vector3D& deltaV, 
	Vector3D& fVec, Vector3D& fFriction, Vector3D& n0, bool contactFromData) const
{
	//0=Sphere, 1=Triangle
	const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	const Vector3D& p1 = markerData.GetMarkerData(1).position;
	const Vector3D& v1 = markerData.GetMarkerData(1).velocity;
	const Vector3D& omega1 = markerData.GetMarkerData(1).angularVelocityLocal;

	const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
	const Vector3D& p0 = markerData.GetMarkerData(0).position;
	const Vector3D& v0 = markerData.GetMarkerData(0).velocity;
	const Vector3D& omega0 = markerData.GetMarkerData(0).angularVelocityLocal;

	Vector3D trigPP;
	Index inside, onEdge;
	//Vector3D t0, t1, t2;
	
	EGeometry::MinDistTrigEdges(A1 * parameters.trianglePoints[0] + p1,
								A1 * parameters.trianglePoints[1] + p1,
								A1 * parameters.trianglePoints[2] + p1,
		p0, trigPP, inside, onEdge);
	
	deltaP = (trigPP - p0); //points from sphereI to trigJ!!!
	//==>trigPP = p0 + deltaP = p0 + n0*(radius+gap); //for torque

	Real dist = deltaP.GetL2Norm();
	if (!contactFromData && onEdge && !(onEdge & parameters.includeEdges)) 
	{ 
		dist += parameters.radiusSphere; //in this case, we need to signal PostNewtonStep that there is no contact
	}

	Real invDist = 1.;
	if (dist != 0) { invDist = 1. / dist; }
	//compute contact forces
	n0 = invDist * deltaP;

	//compute velocities
	//global trig velocity at contact point
	Vector3D vTrigJ = (A1 * omega1).CrossProduct(trigPP - p1) + v1;
	//global sphere velocity at contact point:
	Vector3D vSphereI = (A0 * omega0).CrossProduct(trigPP - p0) + v0;
	deltaV = vTrigJ - vSphereI;
	Real deltaVnormal = n0 * deltaV;

	gap = dist - parameters.radiusSphere; //gap is negative

	frictionCoeff = parameters.dynamicFriction; //this has to be computed depending on velocity, using Stribeck function ...

	bool hasContact;
	if (contactFromData) { hasContact = (data[dataIndexGap] < 0); }
	else { hasContact = (gap < 0 && (!onEdge || (onEdge & parameters.includeEdges)) ); }

	if (hasContact)
	{
		Real deltaVnormal = n0 * deltaV; //relative velocity in normal direction

		//frictionRegularizedRegion is only used in case that contactFromData=true
		bool frictionRegularizedRegion = data[dataIndexVtangent] < parameters.frictionProportionalZone;

		//Real contactForce = 
		ComputeContactForces<Real>(gap, n0, deltaVnormal, deltaV,
			frictionCoeff, frictionRegularizedRegion, fVec, fFriction, contactFromData);
		//pout << "** fVec=" << fVec << ", gap=" << gap << ",ff=" << fFriction <<	"\n";
	}
	else //no contact
	{
		fVec.SetAll(0.);
		fFriction.SetAll(0.);
	}
	//in case that it is inactive, we only compute kinematical quantities, but no forces
	if (!parameters.activeConnector)
	{
		fVec *= 0;
		fFriction *= 0;
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectContactSphereTriangle::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectContactSphereTriangle::ComputeAlgebraicEquations: marker do not provide velocityLevel information");

	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Vector3D deltaP;
	Vector3D deltaV;
	//Vector3D contactPoint;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real gap;

	ComputeConnectorProperties(markerData, objectNumber, data,
		frictionCoeff, gap, deltaP, deltaV, fVec, fFriction, n0);

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	if (parameters.activeConnector)
	{
		//marker 1 / triangle / J (positive):    (according to computation of relative position)
		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			//positionJacobian.NumberOfColumns() == rotationJacobian.NumberOfColumns()
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(), markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fVec, ldv1); //fVec = f_m1
			if (frictionCoeff != 0)
			{
				//==>trigPP = p0 + deltaP = p0 + n0*(radius+gap); //for torque use gap*0.5
				Vector3D contactPoint = markerData.GetMarkerData(0).position + (parameters.radiusSphere + 0.5 * gap) * n0;

				Vector3D torque = (contactPoint - markerData.GetMarkerData(1).position).CrossProduct(fVec); //fVec = f_m1
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, torque, ldv1);
			}
		}


		////marker 0 / sphere / I (negative):
		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, -fVec, ldv0); //fVec = f_m1
			if (frictionCoeff != 0)
			{
				Vector3D torque = (-(parameters.radiusSphere + 0.5 * gap) * n0).CrossProduct(fVec); //fVec = f_m1
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, torque, ldv0);
			}
		}
	}
}


//! provide according output variable in "value"
void CObjectContactSphereTriangle::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real gap;

	ComputeConnectorProperties(markerData, itemIndex, data,
		frictionCoeff, gap, deltaP, deltaV, fVec, fFriction, n0);

	switch (variableType)
	{
	case OutputVariableType::Position: {
		Vector3D contactPoint = markerData.GetMarkerData(0).position + (parameters.radiusSphere + 0.5 * gap) * n0;
		value.CopyFrom(contactPoint); break;
	}
	case OutputVariableType::Displacement: value.CopyFrom(deltaP); break;
	case OutputVariableType::DisplacementLocal: value.CopyFrom(Vector1D({gap})); break;
	case OutputVariableType::Velocity: value.CopyFrom(deltaV); break;
	case OutputVariableType::Director1: value.CopyFrom(n0); break;
	case OutputVariableType::Force: value.CopyFrom(fVec); break;
	case OutputVariableType::Torque: value.CopyFrom((-(parameters.radiusSphere + 0.5 * gap) * n0).CrossProduct(fVec)); break;
	default:
		SysError("CObjectContactSphereTriangle::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}
}


//! function called after Newton method; returns a residual error (force); 
//! done for two different computation states in order to estimate the correct time of contact
Real CObjectContactSphereTriangle::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
	//return force-type error in case of contact: in case that the assumed contact state has been wrong, 
	//  the contact force (also negative) is returned as measure of the error
	Real discontinuousError = 0;
	flags = PostNewtonFlags::_None;


	LinkedDataVector dataStartofStepState = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep);	//state0
	LinkedDataVector data = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current);			//state1

	//Real tStartOfStep = ((CNodeData*)GetCNode(0))->GetCData()->startOfStepState.GetTime();

	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real currentGap;

	ComputeConnectorProperties(markerDataCurrent, itemIndex, data, frictionCoeff, currentGap, deltaP, deltaV, fVec, fFriction, n0, false);

	Real vGap = n0 * deltaV; //required for Hunt-Crossley and similar models

	Real lastGap = data[dataIndexGap];
	Real startofStepGap = dataStartofStepState[dataIndexGap];

	Real lastVtangent = data[dataIndexVtangent];

	data[dataIndexGap] = currentGap;
	data[dataIndexVtangent] = (deltaV - (vGap)*n0).GetL2Norm(); //tangent velocity norm

	Real deltaPlastic = 0; //unused
	data[dataIndexDeltaPlastic] = deltaPlastic;

	//pout << "curGap=" << currentGap << ", fVec=" << fVec << ", vGap=" << vGap << "\n";

	//compute error for gap:
	if ((currentGap > 0 && lastGap <= 0) || (currentGap <= 0 && lastGap > 0)) //action: state1=currentGapState, error = |currentGap*k|
	{
		discontinuousError = fabs(currentGap * parameters.contactStiffness);

		//in fact it is (0-startofStepState) which is the part of time to go in these steps!
		//startofStepGap<=0 caused in case of inappropriate initialization => no step recommendation, but try to re-iterate
		if (vGap != 0 && startofStepGap > 0) { recommendedStepSize = fabs(startofStepGap / vGap); }

		//pout << "curGap=" << currentGap << ", sosGap=" << startofStepGap << ", discErr=" << discontinuousError << ", recStep=" << recommendedStepSize << ", vGap=" << vGap << "\n";
		flags = PostNewtonFlags::UpdateJacobian;
	}

	//compute error for friction:
	if (currentGap < 0 && parameters.frictionProportionalZone != 0.)
	{
		if ( (data[dataIndexVtangent] < parameters.frictionProportionalZone && lastVtangent > parameters.frictionProportionalZone) ||
			(data[dataIndexVtangent] > parameters.frictionProportionalZone && lastVtangent < parameters.frictionProportionalZone) )
		{
			//we have switching between stick and slip => so estimate some force error
			//we use the erroneous change in the tangent velocity and estimate the error in the friction force
			discontinuousError += fabs((parameters.dynamicFriction * (fVec * n0) / parameters.frictionProportionalZone) * (data[dataIndexVtangent] - parameters.frictionProportionalZone));

			//here we do not use a recommendedStepSize!
		}
	}

	//update impact velocity, if impact occured:
	if (startofStepGap > 0 && currentGap <= 0)
	{
		data[dataIndexImpactVel] = -vGap;
		//pout << "Impact vel=" << -vGap << "\n";
	}
	else //else set back to start-of-step, as we shall not change this value during discontinuous iterations!
	{
		data[dataIndexImpactVel] = dataStartofStepState[dataIndexImpactVel];
	}

	//pout << "PNS: currentGap=" << currentGap << ", previousState=" << previousState << ", currentState=" << currentState << ", error=" << discontinuousError << "\n";
	return discontinuousError;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CObjectContactSphereTriangle::PostDiscontinuousIterationStep() 
{

}





