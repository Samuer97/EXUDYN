/** ***********************************************************************************************
* @brief        CObjectMassPoint2D implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectMassPoint2D.h"


//! Computational function: compute mass matrix
void CObjectMassPoint2D::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	//Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	//massMatrix.SetScalarMatrix(nODE2coordinates, parameters.physicsMass);

	massMatrixC.SetUseDenseMatrix(false);
	SparseTripletVector& triplets = massMatrixC.GetInternalSparseTripletMatrix().GetTriplets();
	if (parameters.physicsMass != 0.)
	{
		triplets.AppendPure(EXUmath::Triplet(ltg[0], ltg[0], parameters.physicsMass));
		triplets.AppendPure(EXUmath::Triplet(ltg[1], ltg[1], parameters.physicsMass));
	}
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectMassPoint2D::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	ode2Lhs.SetNumberOfItems(nODE2coordinates);
	ode2Lhs.SetAll(0.);
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectMassPoint2D::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::JacobianTtimesVector_q +
		(Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectMassPoint2D::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		value.SetMatrix(3, 2, { 1.,0.,0.,1.,0.,0. }); //a 3D Vector (e.g. 3D ForceVector) acts on two coordinates (x,y)
		break;
	}
	case AccessFunctionType::JacobianTtimesVector_q: //jacobian w.r.t. global position and global orientation!!!
	{
		value.SetNumberOfRowsAndColumns(0, 0); //indicates that all entries are zero
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetMatrix(3, 2, { parameters.physicsMass,0.,0.,parameters.physicsMass,0.,0. }); //a 3D Vector (e.g. 3D ForceVector) acts on two coordinates (x,y)
		break;
	}
	default:
		SysError("CObjectMassPoint2D:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectMassPoint2D::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	default:
		SysError("CObjectMassPoint2D::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectMassPoint2D::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + localPosition;

}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectMassPoint2D::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration);
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectMassPoint2D::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetAcceleration(configuration);
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectMassPoint2D::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

