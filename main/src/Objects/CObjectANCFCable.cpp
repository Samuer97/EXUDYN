/** ***********************************************************************************************
* @brief        CObjectANCFCable implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectANCFCable.h"

#include "Utilities/AutomaticDifferentiation.h"
typedef EXUmath::AutoDiff<24, Real> DReal24;

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//ANCFCable BASE class

//! get compressed shape function vector
//MATLAB: [(2 * x ^ 3) / L ^ 3 - (3 * x ^ 2) / L ^ 2 + 1, x - (2 * x ^ 2) / L + x ^ 3 / L ^ 2, (3 * x ^ 2) / L ^ 2 - (2 * x ^ 3) / L ^ 3, x ^ 3 / L ^ 2 - x ^ 2 / L]
Vector4D CObjectANCFCable::ComputeShapeFunctions(Real x, Real L)
{
	//Real L = GetLength();
	Real x0 = x / L;
	return Vector4D({ 1. - 3. * EXUstd::Square(x0) + 2. * EXUstd::Cube(x0),
					 x - 2. * EXUstd::Square(x) / L + x * EXUstd::Square(x0),
					 3. * EXUstd::Square(x0) - 2. * EXUstd::Cube(x0),
					 -x * (x0) + x * EXUstd::Square(x0) });
}

//! get derivative of compressed shape function vector for slopes
//MATLAB: [(6 * x ^ 2) / L ^ 3 - (6 * x) / L ^ 2, (3 * x ^ 2) / L ^ 2 - (4 * x) / L + 1, (6 * x) / L ^ 2 - (6 * x ^ 2) / L ^ 3, (3 * x ^ 2) / L ^ 2 - (2 * x) / L]
Vector4D CObjectANCFCable::ComputeShapeFunctions_x(Real x, Real L)
{
	//Real L = GetLength();
	Real L2 = L*L;
	Real L3 = L2*L;
	return Vector4D({ - 6. * x / L2+ 6. * EXUstd::Square(x)/L3,
					 1 - 4. * x / L + 3.* EXUstd::Square(x)/L2,
					 6. * x / L2 - 6. * EXUstd::Square(x)/L3,
					 -2.*x / L + 3.*EXUstd::Square(x)/L2 });
}

//! get second derivative of compressed shape function vector for slopes
//MATLAB: [(12 * x) / L ^ 3 - 6 / L ^ 2, (6 * x) / L ^ 2 - 4 / L, 6 / L ^ 2 - (12 * x) / L ^ 3, (6 * x) / L ^ 2 - 2 / L]
Vector4D CObjectANCFCable::ComputeShapeFunctions_xx(Real x, Real L)
{
	//Real L = GetLength();
	Real L2 = L * L;
	Real L3 = L2 * L;
	return Vector4D({ (12. * x) / L3 - 6. / L2,
					 (6. * x) / L2 - 4. / L,
					 6. / L2 - (12. * x) / L3,
					 (6. * x) / L2 - 2. / L });
}

//! get third derivative of compressed shape function vector for slopes
Vector4D CObjectANCFCable::ComputeShapeFunctions_xxx(Real x, Real L)
{
	//Real L = GetLength();
	Real L2 = L * L;
	Real L3 = L2 * L;
	return Vector4D({ 12. / L3,
					 6. / L2,
					 -12. / L3,
					 6. / L2 });
}


//! map element coordinates (position or veloctiy level) given by nodal vectors q0 and q1 onto compressed shape function vector to compute position, etc.
Vector3D CObjectANCFCable::MapCoordinates(const Vector4D& SV, const LinkedDataVector& q0, const LinkedDataVector& q1)
{
	Vector3D v(0.);
	v[0] += SV[0] * q0[0];
	v[1] += SV[0] * q0[1];
	v[2] += SV[0] * q0[2];
	v[0] += SV[1] * q0[3];
	v[1] += SV[1] * q0[4];
	v[2] += SV[1] * q0[5];

	v[0] += SV[2] * q1[0];
	v[1] += SV[2] * q1[1];
	v[2] += SV[2] * q1[2];
	v[0] += SV[3] * q1[3];
	v[1] += SV[3] * q1[4];
	v[2] += SV[3] * q1[5];

	return v;
}

//! locally defined template: map element coordinates (position or veloctiy level) given by nodal vectors q0 and q1 onto compressed shape function vector to compute position, etc.
template<class TReal, Index ancfSize>
SlimVectorBase<TReal, 3> MapCoordinatesElement(const Vector4D& SV, const ConstSizeVectorBase<TReal, ancfSize>& qANCF)
{
	const Index dim = 3;		//3D finite element
	SlimVectorBase<TReal, dim> v;
	v[0] = 0;
	v[1] = 0;
	v[2] = 0;
	for (Index i = 0; i < SV.NumberOfItems(); i++)
	{
		v[0] += SV[i] * qANCF[dim * i];
		v[1] += SV[i] * qANCF[dim * i + 1];
		v[2] += SV[i] * qANCF[dim * i + 2];
	}
	return v;
}

void CObjectANCFCable::ComputeCurrentNodeCoordinates(ConstSizeVector<6>& qNode0, ConstSizeVector<6>& qNode1) const
{
	qNode0.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector()); //displacement coordinates node 0
	qNode1.CopyFrom(((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector()); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
}

void CObjectANCFCable::ComputeCurrentNodeVelocities(ConstSizeVector<6>& qNode0, ConstSizeVector<6>& qNode1) const
{
	qNode0.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t()); //velocity coordinates node 0
	qNode1.CopyFrom(((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t()); //velocity coordinates node 1
}

void CObjectANCFCable::ComputeCurrentObjectCoordinates(ConstSizeVector<nODE2coordinates>& qANCF) const
{
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	const Index nnc = dim * 2;  //number of node coordinates
	LinkedDataVector qNode0(qANCF, 0, nnc);		//link node values to element vector
	LinkedDataVector qNode1(qANCF, nnc, nnc);		//link node values to element vector

	qNode0 = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector(); //displacement coordinates node 0
	qNode1 = ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector(); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
}

void CObjectANCFCable::ComputeCurrentObjectVelocities(ConstSizeVector<nODE2coordinates>& qANCF_t) const
{
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	const Index nnc = dim * 2;  //number of node coordinates

	LinkedDataVector qNode0(qANCF_t, 0, nnc);		//link node values to element vector
	LinkedDataVector qNode1(qANCF_t, nnc, nnc);		//link node values to element vector

	qNode0 = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(); //displacement coordinates node 0
	qNode1 = ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t(); //displacement coordinates node 1
}

//! Computational function: compute mass matrix
void CObjectANCFCable::PreComputeMassTerms() const
{
	if (!massMatrixComputed)
	{
		precomputedMassMatrix.SetScalarMatrix(nODE2coordinates, 0.); //set 8x8 matrix
		Real L = parameters.physicsLength;
		Real rhoA = parameters.physicsMassPerLength;
		const Index dim = 3;		//3D finite element
		const Index ns = 4;			//number of shape functions

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;
		for (auto item : EXUmath::gaussRuleOrder7Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			Vector4D SV = ComputeShapeFunctions(x, L);
			Vector4D SVint = SV;
			SVint *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder7Weights[cnt++]);

			for (Index i = 0; i < ns; i++)
			{
				for (Index j = 0; j < ns; j++)
				{
					precomputedMassMatrix(i * dim,     j * dim) += SV[i] * SVint[j];
					precomputedMassMatrix(i * dim + 1, j * dim + 1) += SV[i] * SVint[j];
					precomputedMassMatrix(i * dim + 2, j * dim + 2) += SV[i] * SVint[j];
				}
			}
		}
		massMatrixComputed = true;
	}
}

//! Computational function: compute mass matrix
void CObjectANCFCable::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber, bool computeInverse) const
{
	CHECKandTHROW(!computeInverse, "CObjectANCFCable::ComputeMassMatrix: computeMassMatrixInversePerBody=True is not possible for this type of element; change solver settings");

	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	PreComputeMassTerms();
	massMatrix.CopyFrom(precomputedMassMatrix); //copy
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectANCFCable::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	//pout << "GetNumberOfNodes() =" << GetNumberOfNodes() << "\n";

	ConstSizeVector<dim * ns> qANCF;
	ConstSizeVector<dim * ns> qANCF_t;
	ComputeCurrentObjectCoordinates(qANCF);
	ComputeCurrentObjectVelocities(qANCF_t);
	ComputeODE2LHStemplate<Real>(ode2Lhs, qANCF, qANCF_t);
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
template<class TReal, Index ancfSize>
void CObjectANCFCable::ComputeODE2LHStemplate(VectorBase<TReal>& ode2Lhs, 
	const ConstSizeVectorBase<TReal, ancfSize>& qANCF, const ConstSizeVectorBase<TReal, ancfSize>& qANCF_t) const
{
	ode2Lhs.SetNumberOfItems(ancfSize); //works both for ANCF and ALE-ANCF
	ode2Lhs.SetAll(0.);

	//compute work of elastic forces:
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	const Index nnc = dim * 2;  //number of node coordinates

	Real L = parameters.physicsLength;
	Real EA = parameters.physicsAxialStiffness;
	Real EI = parameters.physicsBendingStiffness;
	Real axialStrain0 = parameters.physicsReferenceAxialStrain;
	Real bendingDamping = parameters.physicsBendingDamping;
	Real axialDamping = parameters.physicsAxialDamping;

	Index cnt;
	Real a = 0; //integration interval [a,b]
	Real b = L;

	ConstSizeVector<2 * nnc> qANCFref;
	if (parameters.strainIsRelativeToReference != 0.)
	{
		LinkedDataVector qNode0ref(qANCFref, 0, nnc);		//link node values to element vector
		LinkedDataVector qNode1ref(qANCFref, nnc, nnc);		//link node values to element vector
		qNode0ref = ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector();
		qNode1ref = ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
	}

	ConstSizeVectorBase<TReal, ancfSize> elasticForces;

	//numerical integration:
	//accurate integration: axialStrain = order9, curvature = order5
	//reduced order 1: axialStrain = order7, curvature = order3 (lower Gauss order not possible, becomes unstable or very inaccurate ...
	//reduced order 2: axialStrain = order4, curvature = order3 (less oscillations in axial strains, if evaluated at [0,0.5L,L]
	//reduced order 3: axialStrain = order6, curvature = order5 
	//reduced order 4: axialStrain = order5, curvature = order6 

	const Index maxIntegrationPoints = 5;
	ConstSizeVector<maxIntegrationPoints> integrationPoints;
	ConstSizeVector<maxIntegrationPoints> integrationWeights;

	if (parameters.useReducedOrderIntegration == 0) //A9-B5 (max. integration axial order 9, bending order 5)
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder9Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder9Weights);
	}
	else if (parameters.useReducedOrderIntegration == 1) //A7-B3
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder7Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder7Weights);
	}
	else if (parameters.useReducedOrderIntegration == 2) //A4-B3 ; gives excellent axial strain at 0, L/2 and L !!
	{
		integrationPoints.CopyFrom(EXUmath::lobattoRuleOrder3Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::lobattoRuleOrder3Weights);
	}
	else { CHECKandTHROWstring("ObjectANCFCable::ComputeODE2LHS: useReducedOrderIntegration must be between 0 and 2"); }

	//axial strain:
	cnt = 0;
	for (auto item : integrationPoints)
	{
		Real x = 0.5*(b - a)*item + 0.5*(b + a);
		Vector4D SVx = ComputeShapeFunctions_x(x, L);
		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);

		SlimVectorBase<TReal, dim> rx = MapCoordinatesElement<TReal, dim * ns>(SVx, qANCF);

		TReal rxNorm2 = rx.GetL2NormSquared();
		TReal rxNorm = sqrt(rxNorm2);

		TReal axialStrain = rxNorm - 1.; // axial strain
		TReal axialStrain_t = 0.; //rate of axial strain

		Real axialStrainRef = axialStrain0;
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = MapCoordinatesElement<Real, dim * ns>(SVx, qANCFref);
			axialStrainRef += parameters.strainIsRelativeToReference * (rxRef.GetL2Norm() - 1.);
		}

		if (axialDamping != 0.)
		{
			SlimVectorBase<TReal, dim> rx_t = MapCoordinatesElement<TReal, dim* ns>(SVx, qANCF_t);
			axialStrain_t = (rx * rx_t) / rxNorm; //rate of axial strain
		}

		//term due to variation of axialStrain
		for (Index i = 0; i < dim; i++)
		{
			for (Index j = 0; j < ns; j++)
			{
				elasticForces[j*dim + i] = 1. / rxNorm * SVx[j] * rx[i];
			}
		}

		//elasticForces *= integrationFactor * GetParameters().physicsAxialStiffness * (axialStrain - GetParameters().physicsReferenceAxialStrain);
		elasticForces *= integrationFactor * (EA * (axialStrain - axialStrainRef) + axialDamping * axialStrain_t);

		ode2Lhs += elasticForces;  //add to element elastic forces
	}

	//++++++++++++++++++++++++++++++
	//curvature:

	if (parameters.useReducedOrderIntegration == 0) //A9-B5 (max. integration axial order 9, bending order 5)
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder5Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder5Weights);
	}
	else if (parameters.useReducedOrderIntegration == 1) //A7-B3
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points); 
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
	}
	else if (parameters.useReducedOrderIntegration == 2) //A4-B3 ; gives excellent axial strain at 0, L/2 and L !!
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points); 
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
	}
	else { CHECKandTHROWstring("ObjectANCFCable::ComputeODE2LHS: useReducedOrderIntegration must be between 0 and 2"); }

	cnt = 0;
	for (auto item : integrationPoints)
	{
		Real x = 0.5*(b - a)*item + 0.5*(b + a);
		Vector4D SVx = ComputeShapeFunctions_x(x, L);
		Vector4D SVxx = ComputeShapeFunctions_xx(x, L);
		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);

		//Vector3D rx = MapCoordinates(SVx, q0, q1);
		//Vector3D rxx = MapCoordinates(SVxx, q0, q1);
		SlimVectorBase<TReal, dim> rx = MapCoordinatesElement<TReal, dim* ns>(SVx, qANCF);
		SlimVectorBase<TReal, dim> rxx = MapCoordinatesElement<TReal, dim* ns>(SVxx, qANCF);

		TReal rxNorm2 = rx.GetL2NormSquared();				//g
		//TReal rxNorm = sqrt(rxNorm2);				
		SlimVectorBase<TReal, dim> rxCrossRxx = rx.CrossProduct(rxx);			//f
		SlimVectorBase<TReal, dim> curvature = rxCrossRxx * (1. / rxNorm2);				//kappa = (rx x rxx)/rx^2       //material measure of curvature

		Vector3D curvatureRef(0.);
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = MapCoordinatesElement<Real, dim * ns>(SVx, qANCFref);
			Vector3D rxxRef = MapCoordinatesElement<Real, dim * ns>(SVxx, qANCFref);

			Real rxNorm2ref = rxRef.GetL2NormSquared();
			Vector3D rxCrossRxxRef = rxRef.CrossProduct(rxxRef);
			curvatureRef += parameters.strainIsRelativeToReference*(rxCrossRxxRef * (1. / rxNorm2ref) );
		}

		TReal inv2RxNorm2 = 1. / (rxNorm2*rxNorm2);			//g2inv
		SlimVectorBase<TReal, dim> tempF = 2. * rxCrossRxx*inv2RxNorm2;			//fn; f ... fraction numerator
		TReal tempG = rxNorm2 * inv2RxNorm2;				//gn; g ... fraction denominator
		SlimVectorBase<TReal, dim> df;

		SlimVectorBase<TReal, dim> curvature_t(0.); //rate of curvature
		if (bendingDamping != 0.)
		{
			//Vector3D rx_t = MapCoordinates(SVx, q0_t, q1_t);
			//Vector3D rxx_t = MapCoordinates(SVxx, q0_t, q1_t);
			SlimVectorBase<TReal, dim> rx_t = MapCoordinatesElement<TReal, dim* ns>(SVx, qANCF_t);
			SlimVectorBase<TReal, dim> rxx_t = MapCoordinatesElement<TReal, dim* ns>(SVxx, qANCF_t);

			SlimVectorBase<TReal, dim> rxCrossRxx_t = rx_t.CrossProduct(rxx) + rx.CrossProduct(rxx_t);	//f_t
			TReal rxNorm2_t = 2.*(rx*rx_t);												//g_t

			curvature_t = (rxCrossRxx_t * rxNorm2 - rxCrossRxx * rxNorm2_t) * (1. / EXUstd::Square(rxNorm2) ); //rate of bending strain; (f_t*g - f*g_t)/g^2
		}

		//precompute 3D torque times integration factor
		curvature[0] -= curvatureRef[0]; //needs to be done component-wise as it is Real and TReal
		curvature[1] -= curvatureRef[1];
		curvature[2] -= curvatureRef[2];
		SlimVectorBase<TReal, dim> curvatureFactor = integrationFactor * (EI * (curvature) + bendingDamping * curvature_t);

		for (Index i = 0; i < dim; i++)
		{
			for (Index j = 0; j < ns; j++)
			{
				switch (i) {
				case 0:
				{
					df[0] = 0.;
					df[1] = -SVx[j] * rxx.Z() + SVxx[j] * rx.Z();
					df[2] = SVx[j] * rxx.Y() - SVxx[j] * rx.Y();
					break;
				}
				case 1:
				{
					df[0] = SVx[j] * rxx.Z() - SVxx[j] * rx.Z();
					df[1] = 0;
					df[2] = -SVx[j] * rxx.X() + SVxx[j] * rx.X(); 
					break;
				}
				case 2:
				{
					df[0] = -SVx[j] * rxx.Y() + SVxx[j] * rx.Y();
					df[1] = +SVx[j] * rxx.X() - SVxx[j] * rx.X();
					df[2] = 0; 
					break;
				}
				default:;
				}
				TReal dg = rx[i] * SVx[j]; //derivative of denominator
				elasticForces[j*dim + i] = (df * tempG - tempF * dg) * curvatureFactor;
			}
		}

		ode2Lhs += elasticForces;  //add to element elastic forces
	}

}

//! jacobian of LHS, w.r.t. position AND velocity level coordinates
//void CObjectANCFCable::ComputeJacobianODE2_ODE2(ResizableMatrix& jacobian, ResizableMatrix& jacobian_ODE2_t) const
void CObjectANCFCable::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp, 
	Real factorODE2, Real factorODE2_t,
	Index objectNumber, const ArrayIndex& ltg) const
{
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	//const Index nnc = dim * 2;  //number of node coordinates

	ConstSizeVector<dim * ns> qANCF0;
	ConstSizeVector<dim * ns> qANCF0_t;
	ConstSizeVectorBase<DReal24, dim * ns> qANCF;
	ConstSizeVectorBase<DReal24, dim * ns> qANCF_t;
	ComputeCurrentObjectCoordinates(qANCF0);
	ComputeCurrentObjectVelocities(qANCF0_t);
	for (Index i = 0; i < dim * ns; i++)
	{
		qANCF[i] = qANCF0[i];
		qANCF_t[i] = qANCF0_t[i];
		qANCF[i].DValue((int)i) = 1; //mark that this is the corresponding derivative
		qANCF_t[i].DValue((int)(i + dim * ns)) = 1; //mark that this is the corresponding derivative; velocity derivatives are in second block
	}
	ConstSizeVectorBase<DReal24, dim * ns> ode2Lhs;
	LinkedDataVectorBase<DReal24> linkedOde2Lhs(ode2Lhs); //added because of decoupling of ConstSizeVectorBase

	ComputeODE2LHStemplate<DReal24>(linkedOde2Lhs, qANCF, qANCF_t);

	jacobianODE2.SetUseDenseMatrix(true);
	ResizableMatrix& jac = jacobianODE2.GetInternalDenseMatrix();
	jac.SetNumberOfRowsAndColumns(dim * ns, dim * ns);

	//now copy autodifferentiated result:
	for (Index i = 0; i < dim * ns; i++)
	{
		for (Index j = 0; j < dim * ns; j++)
		{
			jac(i, j) = factorODE2*ode2Lhs[i].DValue((int)j) + factorODE2_t*ode2Lhs[i].DValue((int)(j + dim * ns));
		}
	}
}


//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectANCFCable::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt +
		//TODO: (Index)AccessFunctionType::JacobianTtimesVector_q +
		(Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectANCFCable::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	Real L = GetLength();

	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		const Index dim = 3;		//3D finite element
		const Index ns = 4;			//number of shape functions

		Real x = localPosition[0]; //only x-coordinate
		Vector4D SV = ComputeShapeFunctions(x, L);
		value.SetNumberOfRowsAndColumns(dim, dim * ns); //3D velocity, 12 coordinates qt
		//pout << "inside ..." << localPosition << "\n";

		CHECKandTHROW(localPosition[1] == 0 && localPosition[2] == 0,
			"CObjectANCFCable: markers, forces and constraints can only act at the beam centerline at Y=Z=0; check your code");

		value.SetAll(0.);
		value(0, 0) = SV[0];
		value(1, 1) = SV[0];
		value(2, 2) = SV[0];
		value(0, 3) = SV[1];
		value(1, 4) = SV[1];
		value(2, 5) = SV[1];
		value(0, 6) = SV[2];
		value(1, 7) = SV[2];
		value(2, 8) = SV[2];
		value(0, 9) = SV[3];
		value(1,10) = SV[3];
		value(2,11) = SV[3];

		break;
	}
	//thin ancf 3D cable: torque cannot be applied in such a way: 
	//case AccessFunctionType::AngularVelocity_qt: 
	//{
	//	//const Index dim = 3;		//3D finite element
	//	const Index ns = 4;			//number of shape functions
	//	//const Index nnc = dim * 2;  //number of node coordinates

	//	Real xLoc = localPosition[0]; //only x-coordinate
	//	Vector3D slope = ComputeSlopeVector(xLoc, ConfigurationType::Current);
	//	Real x = slope[0]; //x-slopex
	//	Real y = slope[1]; //y-slopex

	//	Vector4D SVx = ComputeShapeFunctions_x(xLoc, L);
	//	Real fact0 = -y / (x*x + y * y);
	//	Real fact1 = x / (x*x + y * y);

	//	value.SetNumberOfRowsAndColumns(3, 8);
	//	value.SetAll(0.); //last row not necessary to set to zero ... 
	//	for (Index i = 0; i < ns; i++)
	//	{
	//		value(2, i*2) = SVx[i] * fact0; //last row of jacobian
	//		value(2, i * 2 + 1) = SVx[i] * fact1;
	//		value(2, i * 2 + 1) = SVx[i] * fact1;
	//	}

	//	break;
	//}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		const Index dim = 3;		//3D finite element
		const Index ns = 4;			//number of shape functions

		value.SetNumberOfRowsAndColumns(dim, dim * ns); //3D velocity, 12 coordinates qt
		value.SetAll(0.);

		Real L = parameters.physicsLength;
		Real rhoA = parameters.physicsMassPerLength;

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;

		Vector4D SV({0.,0.,0.,0.});

		for (auto item : EXUmath::gaussRuleOrder3Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			Vector4D SVloc = ComputeShapeFunctions(x, L);
			SVloc *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder3Weights[cnt++]);
			SV += SVloc;
		}

		value(0, 0) = SV[0];
		value(1, 1) = SV[0];
		value(2, 2) = SV[0];
		value(0, 3) = SV[1];
		value(1, 4) = SV[1];
		value(2, 5) = SV[1];
		value(0, 6) = SV[2];
		value(1, 7) = SV[2];
		value(2, 8) = SV[2];
		value(0, 9) = SV[3];
		value(1,10) = SV[3];
		value(2,11) = SV[3];
		break;
	}
	default:
		SysError("CObjectANCFCable:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectANCFCable::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	//outputVariables = "{
	//'Position':'global position vector of local axis (1) and cross section (2) position', 
	//'Velocity':'global velocity vector of local axis (1) and cross section (2) position', 
	//'Director1':'(axial) slope vector of local axis position', 
	//'Strain':'axial strain (scalar)', 
	//'Curvature':'axial strain (scalar)', 
	//'Force':'(local) section normal force (scalar)', 
	//'Torque':'(local) bending moment (scalar)'}"
	Real x = localPosition[0];

	switch (variableType)
	{
	case OutputVariableType::Position:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration)); break;
	}
	case OutputVariableType::Displacement:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	}
	case OutputVariableType::Velocity:
	{
		value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::Acceleration:
	{
		//only for ANCFCable, but not ALEANCF ==> not included in GetOutputVariableTypes(...)
		value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	}
	//case OutputVariableType::AngularVelocity:
	//{
	//	//independent of y, but correct
	//	value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	//}
	case OutputVariableType::Director1: {
		//CHECKandTHROW(y == 0., "CObjectANCFCable::GetOutputVariableBody: Y-component of localPosition must be zero for Director1");
		Vector3D rx = ComputeSlopeVector(localPosition[0], configuration);
		value.SetVector({rx[0], rx[1] , rx[2]});
		break; }
	case OutputVariableType::StrainLocal:	
	{
		//CHECKandTHROW(y == 0., "CObjectANCFCable::GetOutputVariableBody: Y-component of localPosition must be zero for StrainLocal");
		Real strain = ComputeAxialStrain(x, configuration);

		value.SetVector({ strain }); 
		break;
	}
	case OutputVariableType::CurvatureLocal:	
	{
		//CHECKandTHROW(y == 0., "CObjectANCFCable::GetOutputVariableBody: Y-component of localPosition must be zero for CurvatureLocal");
		value.CopyFrom( ComputeCurvature(x, configuration) );
		break;
	}
	case OutputVariableType::ForceLocal: {
		//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFCable::GetOutputVariableBody: Y-component of localPosition must be zero for ForceLocal");

		Real axialStrainRef = parameters.physicsReferenceAxialStrain;
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
			axialStrainRef += parameters.strainIsRelativeToReference*(rxRef.GetL2Norm() - 1.);
		}

		Real force = parameters.physicsAxialStiffness * (ComputeAxialStrain(x, configuration) - axialStrainRef);
		if (parameters.physicsAxialDamping != 0) { force += parameters.physicsAxialDamping * ComputeAxialStrain_t(x, configuration); }

		value.SetVector({ force }); break;
	}
	case OutputVariableType::TorqueLocal: {
		//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFCable::GetOutputVariableBody: Y-component of localPosition must be zero for TorqueLocal");

		Vector3D curvatureRef(0.);
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
			Vector3D rxxRef = ComputeSlopeVector_x(x, ConfigurationType::Reference);

			Real rxNorm2ref = rxRef.GetL2NormSquared();
			Vector3D rxCrossRxxRef = rxRef.CrossProduct(rxxRef);
			curvatureRef += parameters.strainIsRelativeToReference*(rxCrossRxxRef * (1. / rxNorm2ref) );
		}

		Vector3D torque = parameters.physicsBendingStiffness * (ComputeCurvature(x, configuration) - curvatureRef);
		if (parameters.physicsBendingDamping != 0) 
		{ 
			torque += parameters.physicsBendingDamping * ComputeCurvature_t(x, configuration); 
		}
		value.CopyFrom(torque); 
		break;
	}
	default:
		SysError("CObjectANCFCable::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFCable::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0]; //only x-coordinate
	Vector4D SV = ComputeShapeFunctions(x, GetLength());
	
	Vector3D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference)
	{
		v += MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return v;
}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectANCFCable::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0]; 
	Vector4D SV = ComputeShapeFunctions(x, GetLength());

	Vector3D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));

	return v;
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectANCFCable::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0];
	Vector4D SV = ComputeShapeFunctions(x, GetLength());

	//Vector3D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	Vector3D a = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_tt(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_tt(configuration));

	return a;
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFCable::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	if (localPosition[1] != 0.)
	{
		Real x = localPosition[0]; //only x-coordinate
		Vector4D SV = ComputeShapeFunctions(x, GetLength());

		Vector3D v(0.);
		if (configuration != ConfigurationType::Reference)
		{
			v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
		}
		return v;
	}
	else
	{
		//slower, but includes off-axis part
		return GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference);
	}
}

//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CObjectANCFCable::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectANCFCable::GetAngularVelocity: not implemented!!!");
	//for details see GetAngularVelocity in Point2DSlope1

	Real xLoc = localPosition[0]; //only x-coordinate
	Vector3D slope = ComputeSlopeVector(xLoc, configuration);
	Real x = slope[0]; //x-slopex
	Real y = slope[1]; //y-slopex
	//REQUIRES SOME 3D FORMULA!!!!!!!!!!!!!!!!!!

	Vector4D SVx = ComputeShapeFunctions_x(xLoc, GetLength());
	Vector3D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	//Vector3D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(), ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t());

	//compare this function to GetRotationMatrix(...)
	return Vector3D({ 0., 0., (-y * slope_t[0] + x * slope_t[1]) / (x*x + y * y) }); //!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

Vector3D CObjectANCFCable::ComputeSlopeVector(Real x, ConfigurationType configuration) const
{
	Vector4D SVx = ComputeShapeFunctions_x(x, GetLength());

	Vector3D slope = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
	{
		slope += MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return slope;

}

Vector3D CObjectANCFCable::ComputeSlopeVector_x(Real x, ConfigurationType configuration) const
{
	Vector4D SVxx = ComputeShapeFunctions_xx(x, GetLength());

	Vector3D slope_x = MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
	{
		slope_x += MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return slope_x;

}

//!  compute the axial strain at a certain axial position, for given configuration
Real CObjectANCFCable::ComputeAxialStrain(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared();
	Real rxNorm = sqrt(rxNorm2);
	return rxNorm - 1.; // axial strain
}

//!  compute the axial strain at a certain axial position, for given configuration
Real CObjectANCFCable::ComputeAxialStrain_t(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);
	Vector3D rx_t = ComputeSlopeVector_t(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared();
	Real rxNorm = sqrt(rxNorm2);

	return (rx * rx_t) / rxNorm; //rate of axial strain
}


//!  compute the (bending) curvature at a certain axial position, for given configuration
Vector3D CObjectANCFCable::ComputeCurvature(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);
	Vector3D rxx = ComputeSlopeVector_x(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared(); //computation see ComputeODE2LHS(...)

	Vector3D rxCrossRxx = rx.CrossProduct(rxx);
	return rxCrossRxx * (1. / rxNorm2); //curvature
}

//!  compute the (bending) curvature at a certain axial position, for given configuration
Vector3D CObjectANCFCable::ComputeCurvature_t(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);
	Vector3D rxx = ComputeSlopeVector_x(x, configuration);

	Vector3D rx_t = ComputeSlopeVector_t(x, configuration);
	Vector3D rxx_t = ComputeSlopeVector_xt(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared(); //computation see ComputeODE2LHS(...)

	Vector3D rxCrossRxx = rx.CrossProduct(rxx);

	//apply differentiation formula: (f/g)' = (f'g - fg') / g^2
	Real g = rx.GetL2NormSquared();				//g
	Vector3D f = rx.CrossProduct(rxx);			//f
	Vector3D f_t = rx_t.CrossProduct(rxx) + rx.CrossProduct(rxx_t);
	Real g_t = 2. * (rx_t * rx);

	return (f_t * g - f * g_t) * (1. / EXUstd::Square(g));
}

Vector3D CObjectANCFCable::ComputeSlopeVector_t(Real x, ConfigurationType configuration) const
{
	Vector4D SVx = ComputeShapeFunctions_x(x, GetLength());

	return MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}

Vector3D CObjectANCFCable::ComputeSlopeVector_xt(Real x, ConfigurationType configuration) const
{
	Vector4D SVxx = ComputeShapeFunctions_xx(x, GetLength());

	return MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}



