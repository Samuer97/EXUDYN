/** ***********************************************************************************************
* @brief        implementation of all MainObject CheckPreAssembleConsistency functions, 
*				to reduce dependencies on pybind
*
* @author       Gerstmayr Johannes
* @date         2020-12-09 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

//++++++++++++++++++++++++++++++++++++++++
//really needed? 2020-12-09
#include <pybind11/pybind11.h>      //! include pybind for dictionary access
#include <pybind11/stl.h>           //! needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
//from CObjectFFRF; some of these includes are necessary, as the objects are Main... .h headers are included from here; if not included, no compilation error but may fail
#include <pybind11/stl_bind.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>       //interface to numpy
#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
#include <pybind11/embed.h>       //scoped interpreter
//#include <pybind11/cast.h> //for arguments
#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)
//namespace py = pybind11;            //! "py" used throughout in code
//++++++++++++++++++++++++++++++++++++++++

#include "Linalg/RigidBodyMath.h"
#include "Main/CSystemData.h"
#include "Autogenerated/CNodeGenericData.h"
#include "System/ItemIndices.h"

//for consistency checks:
#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Pymodules/PyMatrixVector.h"

//+++++++++++++++++++++++++++++
//specific markers to include:
//#include "Autogenerated/CMarkerNodeCoordinate.h"
#include "Autogenerated/MainMarkerNodeCoordinate.h"
#include "Autogenerated/MainMarkerNodeCoordinates.h"
#include "Autogenerated/MainMarkerNodeODE1Coordinate.h"
#include "Autogenerated/MainMarkerNodeRotationCoordinate.h"
#include "Autogenerated/MainMarkerObjectODE2Coordinates.h"
#include "Autogenerated/MainMarkerSuperElementPosition.h"
#include "Autogenerated/CObjectGenericODE2.h" //for "Autogenerated/MainMarkerSuperElementPosition.h", "Autogenerated/MainMarkerSuperElementRigid.h"
#include "Autogenerated/MainMarkerSuperElementRigid.h"

//+++++++++++++++++++++++++++++
//specific nodes to include:
#include "Autogenerated/MainNodeGenericData.h"
#include "Autogenerated/MainNodeGenericODE2.h"
#include "Autogenerated/MainNodeGenericODE1.h"
#include "Autogenerated/MainNodeGenericAE.h"
#include "Autogenerated/MainNodeRigidBodyEP.h"

//+++++++++++++++++++++++++++++
//specific objects to include:
#include "Autogenerated/MainObjectALEANCFCable2D.h"
#include "Autogenerated/MainObjectANCFCable2D.h"
#include "Autogenerated/CNodeGenericODE2.h" //for "Autogenerated/MainObjectALEANCFCable2D.h"
//#include "Autogenerated/CNodeGenericODE1.h"
#include "Autogenerated/MainObjectConnectorCoordinateVector.h"
#include "Autogenerated/MainObjectConnectorRollingDiscPenalty.h"
#include "Autogenerated/MainObjectContactCircleCable2D.h"
#include "Autogenerated/MainObjectContactConvexRoll.h"
#include "Autogenerated/MainObjectContactCoordinate.h"
#include "Autogenerated/MainObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/MainObjectContactFrictionCircleCable2DOld.h"
#include "Autogenerated/CNodeGenericData.h" //for "Autogenerated/MainObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/MainObjectFFRF.h"
#include "Autogenerated/MainObjectFFRFreducedOrder.h"
#include "Autogenerated/MainObjectGenericODE2.h"
#include "Autogenerated/MainObjectGenericODE1.h"
#include "Autogenerated/MainObjectKinematicTree.h"
#include "Autogenerated/MainObjectJointALEMoving2D.h"
#include "Autogenerated/MainObjectJointRollingDisc.h"
#include "Autogenerated/CMarkerBodyRigid.h" //for "Autogenerated/MainObjectJointRollingDisc.h"
#include "Autogenerated/MainObjectJointSliding2D.h"

//+++++++++++++++++++++++++++++
//specific sensors to include:
#include "Autogenerated/MainSensorNode.h"
#include "Autogenerated/MainSensorObject.h"
#include "Autogenerated/MainSensorBody.h"
#include "Autogenerated/MainSensorSuperElement.h"
#include "Autogenerated/MainSensorKinematicTree.h"
#include "Autogenerated/MainSensorMarker.h"
//#include "Autogenerated/MainSensorLoad.h"
#include "Autogenerated/MainSensorUserFunction.h"


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//MARKERS
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bool MainMarkerNodeCoordinate::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CMarkerNodeCoordinate* cMarker = (CMarkerNodeCoordinate*)GetCMarker();

	Index coordinate = cMarker->GetCoordinateNumber();
	Index nodeNumber = cMarker->GetNodeNumber();
	Index nodeCoordinates = mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).GetNumberOfAccessibleCoordinates();

	//nodenumber has been checked already at this point!
	if (coordinate >= nodeCoordinates && !mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).IsGroundNode())
	{
		errorString = "MarkerNodeCoordinate: coordinate index (=" + EXUstd::ToString(coordinate) + ") out of range of number of nodal coordinates (0 .." + EXUstd::ToString(nodeCoordinates - 1) + ")";
		return false;
	}


	return true;
}

bool MainMarkerNodeCoordinates::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	//CMarkerNodeCoordinates* cMarker = (CMarkerNodeCoordinates*)GetCMarker();

	//Index nodeNumber = cMarker->GetNodeNumber();
	//Index nodeCoordinates0 = mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).GetNumberOfAccessibleCoordinates();

	//nothing to check here, function could be erased

	////nodenumber has been checked already at this point!
	//if (coordinate >= nodeNumberOfCoordinates && !mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).IsGroundNode())
	//{
	//	errorString = "MarkerNodeCoordinates: coordinate index (=" + EXUstd::ToString(coordinate) + ") out of range of number of nodal coordinates (0 .." + EXUstd::ToString(coordinate - 1) + ")";
	//	return false;
	//}


	return true;
}

bool MainMarkerNodeODE1Coordinate::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CMarkerNodeODE1Coordinate* cMarker = (CMarkerNodeODE1Coordinate*)GetCMarker();

	Index coordinate = cMarker->GetCoordinateNumber();
	Index nodeNumber = cMarker->GetNodeNumber();
	Index nodeNumberOfCoordinates = mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).GetNumberOfAccessibleCoordinates();

	//nodenumber has been checked already at this point!
	if (coordinate >= nodeNumberOfCoordinates && !mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).IsGroundNode())
	{
		errorString = "MarkerNodeODE1Coordinate: coordinate index (=" + EXUstd::ToString(coordinate) + ") out of range of number of nodal coordinates (0 .." + EXUstd::ToString(coordinate - 1) + ")";
		return false;
	}


	return true;
}

bool MainMarkerNodeRotationCoordinate::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CMarkerNodeRotationCoordinate* cMarker = (CMarkerNodeRotationCoordinate*)GetCMarker();

	Index coordinate = cMarker->GetRotationCoordinateNumber();
	Index nodeNumber = cMarker->GetNodeNumber();
	//Index nodeNumberOfCoordinates = mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber).GetNumberOfAccessibleCoordinates();

	//check if coordinate < 3 and if is rigid body!
	//nodenumber already checked in CSystem
	if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainNodes()[nodeNumber]->GetCNode()->GetType(), Node::Orientation))
	{
		errorString = "MarkerNodeRotationCoordinate: Node must be of type Orientation (or RigidBody)";
		return false;
	}

	if (((Index)mainSystem.GetMainSystemData().GetMainNodes()[nodeNumber]->GetCNode()->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
	{
		errorString = "MarkerNodeRotationCoordinate: Node must be of NodeGroup::ODE2variables";
		return false;
	}

	//nodenumber has been checked already at this point!
	if (coordinate >= 3)
	{
		errorString = "MarkerNodeRotationCoordinate: coordinate index must be in range(0 .. 2)";
		return false;
	}


	return true;
}

bool MainMarkerObjectODE2Coordinates::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	const CMarkerObjectODE2Coordinates* cMarker = GetCMarkerObjectODE2Coordinates();

	//Check: object=body, all nodes are ODE2?

	//valid object number has been already checked in CSystem::CheckSystemIntegrity
	Index objectNumber = cMarker->GetObjectNumber();
	const CObject* cObjectPtr = mainSystem.GetMainSystemData().GetMainObjects()[objectNumber]->GetCObject();

	if (((Index)cObjectPtr->GetType() & (Index)CObjectType::Body) == 0)
	{
		errorString = "MarkerObjectODE2Coordinates: object must be a body!";
		return false;
	}

	for (Index j = 0; j < cObjectPtr->GetNumberOfNodes(); j++)
	{
		if (((Index)cObjectPtr->GetCNode(j)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "MarkerObjectODE2Coordinates: all nodes of marker object must have ODE2 coordinates!";
			return false;
		}
	}

	return true;
}

bool MainMarkerSuperElementPosition::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	const CMarkerSuperElementPosition* cMarker = GetCMarkerSuperElementPosition();
	const ArrayIndex& meshNodeNumbers = cMarker->GetParameters().meshNodeNumbers;
	const Vector& weightingFactors = cMarker->GetParameters().weightingFactors;

	//Check: meshNodeNumbers, weightingFactors;

	//valid object number has been already checked in CSystem::CheckSystemIntegrity
	Index bodyNumber = cMarker->GetObjectNumber();
	const CObject* cObjectPtr = mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetCObject();

	if (((Index)cObjectPtr->GetType() & (Index)CObjectType::SuperElement) == 0)
	{
		errorString = "MarkerSuperElementPosition: can only be applied to a body object of type 'SuperElement'";
		return false;
	}

	const CObjectSuperElement& cObjectSuperElement = (const CObjectSuperElement&)(*cObjectPtr); //now possible
	//Index localRigidBodyNodeNumber;
	//bool useFirstNodeAsReferenceFrame = cObjectSuperElement.HasReferenceFrame(localRigidBodyNodeNumber);

	//there must be at least one node
	if (meshNodeNumbers.NumberOfItems() == 0)
	{
		errorString = "MarkerSuperElementPosition: number of nodes must be larger than zero";
		return false;
	}

	//check weightingFactors
	Real sumWF = weightingFactors.Sum();
	if (fabs(sumWF - 1.) > 1e-10)
	{
		PyWarning("MainMarkerSuperElementPosition: Sum of weightingFactors should be 1, but received" + EXUstd::ToString(sumWF) + ", weightingFactors=" + EXUstd::ToString(weightingFactors));
	}

	//weighting factors and number of nodes must be equal
	if (cMarker->GetParameters().weightingFactors.NumberOfItems() != meshNodeNumbers.NumberOfItems())
	{
		errorString = "MarkerSuperElementPosition: number of nodes (" + EXUstd::ToString(meshNodeNumbers.NumberOfItems())
			+ ") and number of weighting factors (" + EXUstd::ToString(cMarker->GetParameters().weightingFactors.NumberOfItems()) + ") must be same";
		return false;
	}

	Index nn = cObjectSuperElement.GetNumberOfMeshNodes();
	for (Index i : meshNodeNumbers)
	{
		if (i >= nn)
		{
			errorString = "MarkerSuperElementPosition: mesh node index " + EXUstd::ToString(i) +
				" is larger than the number of nodes in the generic body " + mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetName() +
				" (number of nodes = " + EXUstd::ToString(nn) + ")";
			return false;
		}
		else
		{
			CNodeODE2* cNode = cObjectSuperElement.GetMeshNode(i);
			if (cNode != nullptr)
			{
				if (cNode->GetNumberOfODE2Coordinates() != 3)
				{
					errorString = "MarkerSuperElementPosition: mesh node " + EXUstd::ToString(i) +
						" should have 3 coordinates but has " + EXUstd::ToString(cNode->GetNumberOfODE2Coordinates()) + " coordinates";
					return false;
				}
			}
		}
	}

	return true;
}

bool MainMarkerSuperElementRigid::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	const CMarkerSuperElementRigid* cMarker = GetCMarkerSuperElementRigid();
	const ArrayIndex& meshNodeNumbers = cMarker->GetParameters().meshNodeNumbers;
	const Vector& weightingFactors = cMarker->GetParameters().weightingFactors;

	//Check: meshNodeNumbers, weightingFactors;

	//valid object number has been already checked in CSystem::CheckSystemIntegrity
	Index bodyNumber = cMarker->GetObjectNumber();
	const CObject* cObjectPtr = mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetCObject();

	if (((Index)cObjectPtr->GetType() & (Index)CObjectType::SuperElement) == 0)
	{
		errorString = "MarkerSuperElementRigid: can only be applied to a body object of type 'SuperElement'";
		return false;
	}

	const CObjectSuperElement& cObjectSuperElement = (const CObjectSuperElement&)(*cObjectPtr); //now possible
	//Index localRigidBodyNodeNumber;
	//bool useFirstNodeAsReferenceFrame = cObjectSuperElement.HasReferenceFrame(localRigidBodyNodeNumber);

	//there must be at least one node
	if (meshNodeNumbers.NumberOfItems() == 0)
	{
		errorString = "MarkerSuperElementRigid: number of nodes must be larger than zero";
		return false;
	}

	//check weightingFactors
	Real sumWF = weightingFactors.Sum();
	if (fabs(sumWF - 1.) > 1e-10)
	{
		PyWarning("MainMarkerSuperElementRigid " + this->GetName() + ": Sum of weightingFactors should be 1, but received" + EXUstd::ToString(sumWF) + ", weightingFactors=" + EXUstd::ToString(weightingFactors));
	}

	//weighting factors and number of nodes must be equal
	if (cMarker->GetParameters().weightingFactors.NumberOfItems() != meshNodeNumbers.NumberOfItems())
	{
		errorString = "MarkerSuperElementRigid: number of nodes (" + EXUstd::ToString(meshNodeNumbers.NumberOfItems())
			+ ") and number of weighting factors (" + EXUstd::ToString(cMarker->GetParameters().weightingFactors.NumberOfItems()) + ") must be same";
		return false;
	}

	Index nn = cObjectSuperElement.GetNumberOfMeshNodes();
	for (Index i : meshNodeNumbers)
	{
		if (i >= nn)
		{
			errorString = "MarkerSuperElementRigid: mesh node index " + EXUstd::ToString(i) +
				" is larger than the number of nodes in the generic body " + mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetName() +
				" (number of nodes = " + EXUstd::ToString(nn) + ")";
			return false;
		}
		else
		{
			CNodeODE2* cNode = cObjectSuperElement.GetMeshNode(i);
			if (cNode != nullptr)
			{
				if (cNode->GetNumberOfODE2Coordinates() != 3)
				{
					errorString = "MarkerSuperElementRigid: mesh node " + EXUstd::ToString(i) +
						" should have 3 coordinates but has " + EXUstd::ToString(cNode->GetNumberOfODE2Coordinates()) + " coordinates";
					return false;
				}
			}
		}
	}

	if (true) //additional check for regularity of nodes providing rigid body motion
	{
		const ArrayIndex& nodeNumbers = cMarker->GetParameters().meshNodeNumbers;
		Real factor = 0; //sum w_i * |pRef_i|^2

		Matrix3D factorMatrix(3, 3, 0.); //W in docu

		Vector3D pRef; //mesh node local reference position
		
		Vector3D pRef0 = cMarker->GetParameters().offset; //this is a correction, if the midpoint is not at the desired center of the marker

		for (Index i = 0; i < nodeNumbers.NumberOfItems(); i++)
		{
			pRef0 += cMarker->GetParameters().weightingFactors[i] * cObjectSuperElement.GetMeshNodeLocalPosition(nodeNumbers[i], ConfigurationType::Reference);
		}

		for (Index i = 0; i < nodeNumbers.NumberOfItems(); i++)
		{
			pRef = cObjectSuperElement.GetMeshNodeLocalPosition(nodeNumbers[i], ConfigurationType::Reference);
			pRef -= pRef0;

			if (cMarker->GetParameters().useAlternativeApproach) //check if nodes provide a regular rotation matrix
			{
				factorMatrix -= cMarker->GetParameters().weightingFactors[i] * RigidBodyMath::Vector2SkewMatrix(pRef) * RigidBodyMath::Vector2SkewMatrix(pRef);
			}
			else
			{
				factor += cMarker->GetParameters().weightingFactors[i] * pRef.GetL2NormSquared();
			}
		}

		if (cMarker->GetParameters().useAlternativeApproach) //check if nodes provide a regular rotation matrix
		{
			bool rv = true;
			//factorMatrix.GetInverse();
			try
			{
				factorMatrix.GetInverse(); //raises exception, if singular
			}
			catch (...) //any exception
			{
				errorString = "MarkerSuperElementRigid: W=" + EXUstd::ToString(factorMatrix) + "\nmeshNodes must be able to represent a rigid body motion; check node reference positions and weighting factors; a minimum requirement is to have 2 nodes, which are not lying at [0,0,0] and not lying on a line which goes trough [0,0,0]\n";
				rv = false;
			}
			if (!rv) { return false; }
		}
		else
		{
			if (factor == 0) //leads to division by zero
			{
				errorString = "MarkerSuperElementRigid: meshNodes must be able to represent a rigid body motion; check node reference positions and weighting factors; a minimum requirement is to have 2 nodes, which are not lying at [0,0,0]\n";
				return false;
			}
		}
	}

	return true;
}








//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//NODES
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool MainNodeGenericData::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CNodeGenericData* cNode = (CNodeGenericData*)GetCNode();
	//Index dataNodeNumber = cNode->GetNodeNumber(0);

	Index len = cNode->GetParameters().numberOfDataCoordinates;
	if (len != GetInitialVector().NumberOfItems())
	{
		errorString = "MainNodeGenericData: numberOfDataCoordinates (size=" + EXUstd::ToString(len) + ") must have same size as initialCoordinates (size=" +
			EXUstd::ToString(GetInitialVector().NumberOfItems()) + ")";
		return false;
	}

	return true;
}

bool MainNodeGenericODE2::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CNodeGenericODE2* cNode = (CNodeGenericODE2*)GetCNode();
	//Index dataNodeNumber = cNode->GetNodeNumber(0);

	Index len = cNode->GetParameters().numberOfODE2Coordinates;
	if (len != GetInitialVector().NumberOfItems())
	{
		errorString = "MainNodeGenericODE2: numberOfODE2Coordinates (size=" + EXUstd::ToString(len) + ") must have same size as initialCoordinates (size=" +
			EXUstd::ToString(GetInitialVector().NumberOfItems()) + ")";
		return false;
	}

	if (len != GetInitialVector_t().NumberOfItems())
	{
		errorString = "MainNodeGenericODE2: numberOfODE2Coordinates (size=" + EXUstd::ToString(len) + ") must have same size as initialCoordinates_t (size=" +
			EXUstd::ToString(GetInitialVector_t().NumberOfItems()) + ")";
		return false;
	}

	if (len != cNode->GetReferenceCoordinateVector().NumberOfItems())
	{
		errorString = "MainNodeGenericODE2: numberOfODE2Coordinates (size=" + EXUstd::ToString(len) + ") must have same size as referenceCoordinates (size=" +
			EXUstd::ToString(cNode->GetReferenceCoordinateVector().NumberOfItems()) + ")";
		return false;
	}

	return true;
}

bool MainNodeGenericODE1::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CNodeGenericODE1* cNode = (CNodeGenericODE1*)GetCNode();

	Index len = cNode->GetParameters().numberOfODE1Coordinates;
	if (len != GetInitialVector().NumberOfItems())
	{
		errorString = "MainNodeGenericODE1: numberOfODE1Coordinates (size=" + EXUstd::ToString(len) + ") must have same size as initialCoordinates (size=" +
			EXUstd::ToString(GetInitialVector().NumberOfItems()) + ")";
		return false;
	}

	if (len != cNode->GetReferenceCoordinateVector().NumberOfItems())
	{
		errorString = "MainNodeGenericODE1: numberOfODE1Coordinates (size=" + EXUstd::ToString(len) + ") must have same size as referenceCoordinates (size=" +
			EXUstd::ToString(cNode->GetReferenceCoordinateVector().NumberOfItems()) + ")";
		return false;
	}

	return true;
}

bool MainNodeGenericAE::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CNodeGenericAE* cNode = (CNodeGenericAE*)GetCNode();

	Index len = cNode->GetParameters().numberOfAECoordinates;
	if (len != GetInitialVector().NumberOfItems())
	{
		errorString = "MainNodeGenericAE: numberOfAECoordinates (size=" + EXUstd::ToString(len) + ") must have same size as initialCoordinates (size=" +
			EXUstd::ToString(GetInitialVector().NumberOfItems()) + ")";
		return false;
	}

	if (len != cNode->GetReferenceCoordinateVector().NumberOfItems())
	{
		errorString = "MainNodeGenericAE: numberOfAECoordinates (size=" + EXUstd::ToString(len) + ") must have same size as referenceCoordinates (size=" +
			EXUstd::ToString(cNode->GetReferenceCoordinateVector().NumberOfItems()) + ")";
		return false;
	}

	return true;
}

bool MainNodeRigidBodyEP::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CNodeRigidBodyEP* cNode = (CNodeRigidBodyEP*)GetCNode();

	LinkedDataVector ep(cNode->GetReferenceCoordinateVector(), 3, 4); //only euler parameters
	if (fabs(ep.GetL2Norm() - 1.) > 1e-10) //[1,0,0,1e-5] gives an error of 5e-11
	{
		errorString = "MainNodeRigidBodyEP: reference values for Euler Parameters have a norm which differs considerable from unity (" +
			EXUstd::ToString(ep.GetL2Norm()) + ")";
		return false;
	}

	return true;
}







//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//OBJECTS
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bool MainObjectALEANCFCable2D::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectALEANCFCable2D* cObject = (CObjectALEANCFCable2D*)GetCObject();
	const Index eulerianVelocityNodeLocalIndex = 2;
	Index eulerianVelocityNodeNumber = cObject->GetNodeNumber(eulerianVelocityNodeLocalIndex);


	//const MainNode& dataNode = mainSystem.GetMainSystemData().GetMainNode(eulerianVelocityNodeNumber);

	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(eulerianVelocityNodeNumber).GetTypeName(), "GenericODE2") != 0)
	{
		errorString = "ObjectALEANCFCable2D: node 2 must be of type 'GenericODE2'";
		return false;
	}

	for (Index i = 0; i < 2; i++) {
		if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(cObject->GetNodeNumber(i)).GetTypeName(), "Point2DSlope1") != 0)
		{
			errorString = "ObjectALEANCFCable2D: node " + EXUstd::ToString(i) + " must be of type 'Point2DSlope1', but found type '" +
				mainSystem.GetMainSystemData().GetMainNode(cObject->GetNodeNumber(i)).GetTypeName() + "'";
			return false;
		}
	}


	Index nc = ((const CNodeGenericODE2&)(cObject->GetCSystemData()->GetCNode(eulerianVelocityNodeNumber))).GetNumberOfODE2Coordinates();
	if (nc != 1)
	{
		errorString = STDstring("ObjectALEANCFCable2D: NodeGenericODE2 (Node ") + EXUstd::ToString(eulerianVelocityNodeNumber) +
			") must have 1 coordinate (found: " + EXUstd::ToString(nc) + ")";
		return false;
	}

	return true;
}

bool MainObjectANCFCable2D::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectANCFCable2D* cObject = (CObjectANCFCable2D*)GetCObject();

	for (Index i = 0; i < 2; i++) {
		if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(cObject->GetNodeNumber(i)).GetTypeName(), "Point2DSlope1") != 0)
		{
			errorString = "ObjectANCFCable2D: node " + EXUstd::ToString(i) + " must be of type 'Point2DSlope1'";
			return false;
		}
	}
	return true;
}

bool MainObjectConnectorCoordinateVector::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectConnectorCoordinateVector* cObject = (CObjectConnectorCoordinateVector*)GetCObject();

	Index m0Columns = cObject->GetParameters().scalingMarker0.NumberOfColumns();
	Index m0Rows = cObject->GetParameters().scalingMarker0.NumberOfRows();

	Index m1Columns = cObject->GetParameters().scalingMarker1.NumberOfColumns();
	Index m1Rows = cObject->GetParameters().scalingMarker1.NumberOfRows();
	Index offsetLength = cObject->GetParameters().offset.NumberOfItems();

	//quadratic terms:
	Index mQ0Columns = cObject->GetParameters().quadraticTermMarker0.NumberOfColumns();
	Index mQ0Rows = cObject->GetParameters().quadraticTermMarker0.NumberOfRows();

	Index mQ1Columns = cObject->GetParameters().quadraticTermMarker1.NumberOfColumns();
	Index mQ1Rows = cObject->GetParameters().quadraticTermMarker1.NumberOfRows();

	Index maxRows = EXUstd::Maximum(EXUstd::Maximum(EXUstd::Maximum(m0Rows, m1Rows), mQ0Rows), mQ1Rows);
	//Index maxRows = EXUstd::Maximum(m0Rows, m1Rows);


	if (cObject->GetAlgebraicEquationsSize() == 0)
	{
		errorString = "ObjectConnectorCoordinateVector: number of algebraic equations is zero, which is forbidden; define number of algebraic equations by number of rows of scaling matrices or quadratic term matrices";
		return false;
	}
	if ((cObject->GetParameters().constraintUserFunction != 0 && cObject->GetParameters().jacobianUserFunction == 0) ||
		(cObject->GetParameters().constraintUserFunction == 0 && cObject->GetParameters().jacobianUserFunction != 0))
	{
		errorString = "ObjectConnectorCoordinateVector: if constraintUserFunction is provided, a jacobianUserFunction is also needed!";
		return false;
	}

	if (m0Rows != maxRows && m0Rows != 0)
	{
		errorString = "ObjectConnectorCoordinateVector: number of rows in scalingMarker0 must be identical to all other matrices or have zero rows";
		return false;
	}

	if (m1Rows != maxRows && m1Rows != 0)
	{
		errorString = "ObjectConnectorCoordinateVector: number of rows in scalingMarker1 must be identical to all other matrices or have zero rows";
		return false;
	}

	if (mQ0Rows != maxRows && mQ0Rows != 0)
	{
		errorString = "ObjectConnectorCoordinateVector: number of rows in quadraticTermMarker0 must be identical to all other matrices or have zero rows";
		return false;
	}

	if (mQ1Rows != maxRows && mQ1Rows != 0)
	{
		errorString = "ObjectConnectorCoordinateVector: number of rows in quadraticTermMarker1 must be identical to all other matrices or have zero rows";
		return false;
	}

	if (offsetLength != 0 && offsetLength != cObject->GetAlgebraicEquationsSize())
	{
		errorString = "ObjectConnectorCoordinateVector: length of offset vector must be either 0 or identical to number of rows of scaling matrices";
		return false;
	}

	//marker numbers have already been checked in CSystem::CheckSystemIntegrity
	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	const CMarker& marker0 = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]);
	const CMarker& marker1 = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[1]);

	if (!(marker0.GetType() & Marker::Coordinates))
	{
		errorString = STDstring("ObjectConnectorCoordinateVector: Marker 0 must be of type = 'Coordinates'");
		return false;
	}

	if (!(marker1.GetType() & Marker::Coordinates))
	{
		errorString = STDstring("ObjectConnectorCoordinateVector: Marker 1 must be of type = 'Coordinates'");
		return false;
	}

	//these checks are only needed, if not a user function
	if (cObject->GetParameters().constraintUserFunction == 0)
	{

		if (marker0.GetDimension(mainSystem.GetCSystem()->GetSystemData()) != m0Columns && m0Columns != 0)
		{
			errorString = STDstring("ObjectConnectorCoordinateVector: marker 0 must have number of (marker) coordinates same as the number of columns in scalingMarker0");
			return false;
		}

		if (marker1.GetDimension(mainSystem.GetCSystem()->GetSystemData()) != m1Columns && m0Columns != 0)
		{
			errorString = STDstring("ObjectConnectorCoordinateVector: marker 1 must have number of (marker) coordinates same as the number of columns in scalingMarker1");
			return false;
		}

		//check quadratic terms
		if (marker0.GetDimension(mainSystem.GetCSystem()->GetSystemData()) != mQ0Columns && mQ0Columns != 0)
		{
			errorString = STDstring("ObjectConnectorCoordinateVector: marker 0 must have number of (marker) coordinates same as the number of columns in quadraticTermMarker0");
			return false;
		}

		if (marker1.GetDimension(mainSystem.GetCSystem()->GetSystemData()) != mQ1Columns && mQ0Columns != 0)
		{
			errorString = STDstring("ObjectConnectorCoordinateVector: marker 1 must have number of (marker) coordinates same as the number of columns in quadraticTermMarker1");
			return false;
		}
	}
	return true;
}

bool MainObjectConnectorRollingDiscPenalty::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectConnectorRollingDiscPenalty* cObject = (CObjectConnectorRollingDiscPenalty*)GetCObject();

	if (cObject->GetParameters().discRadius <= 0)
	{
		errorString = "CObjectConnectorRollingDiscPenalty: discRadius must be > 0";
		return false;
	}
	if (cObject->GetParameters().dryFriction[0] < 0 || cObject->GetParameters().dryFriction[1] < 0)
	{
		errorString = "CObjectConnectorRollingDiscPenalty: dryFriction coefficients must be positive";
		return false;
	}
	//if (cObject->GetParameters().dryFrictionAngle != 0)
	//{
	//	errorString = "CObjectConnectorRollingDiscPenalty: dryFrictionAngle must be zero, because it is not yet implemented";
	//	return false;
	//}
	return true;
}


bool MainObjectContactCircleCable2D::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectContactCircleCable2D* cObject = (CObjectContactCircleCable2D*)GetCObject();
	Index node = cObject->GetNodeNumber(0);

	if (cObject->GetParameters().numberOfContactSegments > CObjectContactCircleCable2DmaxNumberOfSegments)
	{
		errorString = "ObjectContactCircleCable2D: numberOfContactSegments must be <= " + EXUstd::ToString(CObjectContactCircleCable2DmaxNumberOfSegments);
		return false;
	}

	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(node).GetTypeName(), "GenericData") != 0)
	{
		errorString = "ObjectContactCircleCable2D: node must be of type 'GenericData'";
		return false;
	}

	Index nc = ((const CNodeGenericData&)(cObject->GetCSystemData()->GetCNode(node))).GetNumberOfDataCoordinates();
	if (nc != cObject->GetParameters().numberOfContactSegments)
	{
		errorString = STDstring("ObjectContactCircleCable2D: NodeGenericData (Node ") + EXUstd::ToString(node) + ") must have " + EXUstd::ToString(cObject->GetParameters().numberOfContactSegments)
			+ " coordinates (found: " + EXUstd::ToString(nc) + ")";
		return false;
	}

	if (cObject->GetParameters().contactDamping != 0)
	{
		errorString = STDstring("ObjectContactCircleCable2D: contactDamping is not yet implemented; set parameter to zero");
		return false;
	}

	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	if (!(mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetType() & Marker::Position))
	{
		errorString = STDstring("ObjectContactCircleCable2D: Marker 0 must be of type = 'Position'");
		return false;
	}

	if (STDstring(mainSystem.GetMainSystemData().GetMainMarkers()[nMarkers[1]]->GetTypeName()) != STDstring("BodyCable2DShape"))
	{
		errorString = STDstring("ObjectContactCircleCable2D: Marker 1 must be of type = 'BodyCable2DShape'");
		return false;
	}

	return true;
}

bool MainObjectContactConvexRoll::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	// ToDo Peter! 
	
	return true; 
}

bool MainObjectContactCoordinate::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	//check for valid node number already done prior to this function
	CObjectContactCoordinate* cObject = (CObjectContactCoordinate*)GetCObject();
	Index node = cObject->GetNodeNumber(0);

	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(node).GetTypeName(), "GenericData") != 0)
	{
		errorString = "ObjectContactCoordinate: node must be of type 'GenericData'";
		return false;
	}

	Index nc = ((const CNodeGenericData&)(cObject->GetCSystemData()->GetCNode(node))).GetNumberOfDataCoordinates();
	if (nc != 1)
	{
		errorString = STDstring("ObjectContactCoordinate: NodeGenericData must have 1 coordinate (found: ") + EXUstd::ToString(nc) + ")";
		return false;
	}
	return true;
}

bool MainObjectContactFrictionCircleCable2D::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectContactFrictionCircleCable2D* cObject = (CObjectContactFrictionCircleCable2D*)GetCObject();
	Index node = cObject->GetNodeNumber(0);

	if (cObject->GetParameters().numberOfContactSegments > CObjectContactFrictionCircleCable2DmaxNumberOfSegments)
	{
		errorString = "ObjectContactFrictionCircleCable2D: numberOfContactSegments must be <= " + EXUstd::ToString(CObjectContactFrictionCircleCable2DmaxNumberOfSegments);
		return false;
	}

	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(node).GetTypeName(), "GenericData") != 0)
	{
		errorString = "ObjectContactFrictionCircleCable2D: node must be of type 'GenericData'";
		return false;
	}

	Index nc = ((const CNodeGenericData&)(cObject->GetCSystemData()->GetCNode(node))).GetNumberOfDataCoordinates();
	Index nGenericCoordinates = 3 * cObject->GetParameters().numberOfContactSegments; //per segment: contact gap, stick/slip (stick=1), last friction position (UNUSED)
	if (nc != nGenericCoordinates)
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2D: NodeGenericData (Node ") + EXUstd::ToString(node) + ") must have " + EXUstd::ToString(nGenericCoordinates)
			+ " coordinates (found: " + EXUstd::ToString(nc) + ")";
		return false;
	}

	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	Marker::Type mType = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetType();
	if (!((mType & Marker::Position) && (mType & Marker::Orientation)))
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2D: Marker 0 must be of type = 'Rigid' (Position + Orientation)");
		return false;
	}

	Index object0Index = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetObjectNumber();
	if (mainSystem.GetCSystem()->GetSystemData().GetCObjects()[object0Index]->GetNumberOfCoordinates() > CObjectContactFrictionCircleCable2DmaxObject0Coordinates)
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2D: Marker 0 must refer to an object which has no more than ") + EXUstd::ToString(CObjectContactFrictionCircleCable2DmaxObject0Coordinates) + " coordinates";
		return false;
	}


	if (STDstring(mainSystem.GetMainSystemData().GetMainMarkers()[nMarkers[1]]->GetTypeName()) != STDstring("BodyCable2DShape"))
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2D: Marker 1 must be of type = 'BodyCable2DShape'");
		return false;
	}

	return true;
}


bool MainObjectContactFrictionCircleCable2DOld::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectContactFrictionCircleCable2DOld* cObject = (CObjectContactFrictionCircleCable2DOld*)GetCObject();
	Index node = cObject->GetNodeNumber(0);

	if (cObject->GetParameters().numberOfContactSegments > CObjectContactFrictionCircleCable2DOldmaxNumberOfSegments)
	{
		errorString = "ObjectContactFrictionCircleCable2DOld: numberOfContactSegments must be <= " + EXUstd::ToString(CObjectContactFrictionCircleCable2DOldmaxNumberOfSegments);
		return false;
	}

	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(node).GetTypeName(), "GenericData") != 0)
	{
		errorString = "ObjectContactFrictionCircleCable2DOld: node must be of type 'GenericData'";
		return false;
	}

	Index nc = ((const CNodeGenericData&)(cObject->GetCSystemData()->GetCNode(node))).GetNumberOfDataCoordinates();
	Index nGenericCoordinates = 3 * cObject->GetParameters().numberOfContactSegments; //per segment: contact gap, stick/slip (stick=1), last friction position (UNUSED)
	if (nc != nGenericCoordinates)
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2DOld: NodeGenericData (Node ") + EXUstd::ToString(node) + ") must have " + EXUstd::ToString(nGenericCoordinates)
			+ " coordinates (found: " + EXUstd::ToString(nc) + ")";
		return false;
	}

	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	Marker::Type mType = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetType();
	if (!((mType & Marker::Position) && (mType & Marker::Orientation)))
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2DOld: Marker 0 must be of type = 'Rigid' (Position + Orientation)");
		return false;
	}

	Index object0Index = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetObjectNumber();
	if (mainSystem.GetCSystem()->GetSystemData().GetCObjects()[object0Index]->GetNumberOfCoordinates() > CObjectContactFrictionCircleCable2DOldmaxObject0Coordinates)
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2DOld: Marker 0 must refer to an object which has no more than ") + EXUstd::ToString(CObjectContactFrictionCircleCable2DOldmaxObject0Coordinates) + " coordinates";
		return false;
	}


	if (STDstring(mainSystem.GetMainSystemData().GetMainMarkers()[nMarkers[1]]->GetTypeName()) != STDstring("BodyCable2DShape"))
	{
		errorString = STDstring("ObjectContactFrictionCircleCable2DOld: Marker 1 must be of type = 'BodyCable2DShape'");
		return false;
	}

	return true;
}



bool MainObjectFFRF::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectFFRF* cObject = (CObjectFFRF*)GetCObject();

	Index numberOfNodes = cObject->GetNumberOfNodes();
	//Index numberOfMeshNodes = cObject->GetNumberOfMeshNodes();

	//Index nODE2test = cObject->GetODE2Size(); //NOT AVAILABLE YET
	Index nODE2 = 0; //total number of coordinates
	for (Index i = 0; i < cObject->GetParameters().nodeNumbers.NumberOfItems(); i++)
	{
		cObject->GetCoordinateIndexPerNode()[i] = nODE2;
		nODE2 += cObject->GetCNode(i)->GetNumberOfODE2Coordinates();
	}


	Index nR = cObject->GetCNode(cObject->rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nF = nODE2 - nR; //number of flexible coordinates

	if (numberOfNodes == 0)
	{
		errorString = "ObjectFFRF: has 0 nodes, but must have at least 1 node (rigid body node)";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < numberOfNodes; nn++)
	{
		if (((Index)cObject->GetCNode(nn)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "ObjectFFRF: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE2 node (node group ODE2variables)";
			return false;
		}
		if (nn > 0 && cObject->GetCNode(nn)->GetNumberOfODE2Coordinates() != CObjectFFRF::ffrfNodeDim)
		{
			errorString = "ObjectFFRF: local node " + EXUstd::ToString(nn) + " has " + EXUstd::ToString(cObject->GetCNode(nn)->GetNumberOfODE2Coordinates()) + " coordinates, but must have number of coordinates = 3";
			return false;
		}
	}

	if (!EXUstd::IsOfType(cObject->GetCNode(CObjectFFRF::rigidBodyNodeNumber)->GetType(), (Node::Type)(Node::RigidBody)))
	{
		errorString = "ObjectFFRF: local node 0 must be of type 'Node.RigidBody'";
		return false;
	}

	Index nForce = cObject->GetParameters().forceVector.NumberOfItems();
	if (nForce != nODE2 && nForce != 0)
	{
		errorString = "ObjectFFRF: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but forceVector has size " + EXUstd::ToString(nForce);
		return false;
	}

	Index rowsMass = cObject->GetParameters().massMatrixFF.NumberOfRows();
	Index columnsMass = cObject->GetParameters().massMatrixFF.NumberOfColumns();
	if (!(rowsMass == nF && columnsMass == nF))
	{
		if (rowsMass == 0 && columnsMass == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRF: massMatrixFF must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRF: number of flexible coordinates of object is " + EXUstd::ToString(nF) + ", but mass matrix has size (" + EXUstd::ToString(rowsMass) + " x " + EXUstd::ToString(columnsMass) + ")";
			return false;
		}
	}

	Index rowsStiffness = cObject->GetParameters().stiffnessMatrixFF.NumberOfRows();
	Index columnsStiffness = cObject->GetParameters().stiffnessMatrixFF.NumberOfColumns();
	if (!(rowsStiffness == nF && columnsStiffness == nF))
	{
		if (rowsStiffness == 0 && columnsStiffness == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRF: stiffnessMatrixFF must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRF: number of flexible coordinates of object is " + EXUstd::ToString(nF) + ", but stiffnessMatrixFF has size (" + EXUstd::ToString(rowsStiffness) + " x " + EXUstd::ToString(columnsStiffness) + ")";
			return false;
		}
	}

	Index rowsDamping = cObject->GetParameters().dampingMatrixFF.NumberOfRows();
	Index columnsDamping = cObject->GetParameters().dampingMatrixFF.NumberOfColumns();
	if (!(rowsDamping == nF && columnsDamping == nF) && !((rowsDamping == 0 && columnsDamping == 0)))
	{
		errorString = "ObjectFFRF: number of flexible coordinates of object is " + EXUstd::ToString(nF) + ", but dampingMatrixFF has size (" + EXUstd::ToString(rowsDamping) + " x " + EXUstd::ToString(columnsDamping) + ")";
		return false;
	}

	//check visualization
	VisualizationObjectFFRF* vObject = (VisualizationObjectFFRF*)GetVisualizationObject();
	if (vObject->GetTriangleMesh().NumberOfRows() != 0)
	{
		if (vObject->GetTriangleMesh().NumberOfColumns() != 3)
		{
			errorString = "ObjectFFRF: number of columns in triangleMesh must be 3";
			return false;
		}

		auto& trigs = vObject->GetTriangleMesh();
		for (Index i = 0; i < trigs.NumberOfRows(); i++)
		{
			for (Index j = 0; j < trigs.NumberOfColumns(); j++)
			{
				if (trigs(i, j) >= cObject->GetNumberOfMeshNodes())
				{
					errorString = "ObjectFFRF: node number in triangleMesh(" + EXUstd::ToString(i) + "," + EXUstd::ToString(j) + ") is invalid; valid node numbers: 0 .. " + EXUstd::ToString(cObject->GetNumberOfMeshNodes());
					return false;
				}
			}
		}
	}


	return true;
}

bool MainObjectFFRFreducedOrder::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectFFRFreducedOrder* cObject = (CObjectFFRFreducedOrder*)GetCObject();

	Index numberOfNodes = cObject->GetNumberOfNodes();
	Index numberOfMeshNodes = cObject->GetNumberOfMeshNodes();

	//Index nODE2test = cObject->GetODE2Size(); //NOT AVAILABLE YET

	//Index nODE2Rigid = cObject->GetCNode(cObject->rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = cObject->GetCNode(cObject->genericNodeNumber)->GetNumberOfODE2Coordinates(); //number of modal coordinates
	//Index nODE2 = nODE2Rigid+nODE2FF; //total number of coordinates

	if (numberOfNodes != 2)
	{
		errorString = "ObjectFFRFreducedOrder: has " + EXUstd::ToString(numberOfNodes) + " nodes, but must have 2 nodes (one rigid body node and one generic ODE2 node)";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < numberOfNodes; nn++)
	{
		//if (!EXUstd::IsOfType((Node::Type)(Node::GenericODE2 + Node::Position2D + Node::Orientation2D + Node::Point2DSlope1 + Node::Position + Node::Orientation + Node::RigidBody),
		//	cObject->GetCNode(nn)->GetType()))
		if (((Index)cObject->GetCNode(nn)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "ObjectFFRFreducedOrder: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE2 node (node group ODE2variables)";
			return false;
		}
	}

	if (!EXUstd::IsOfType(cObject->GetCNode(CObjectFFRFreducedOrder::rigidBodyNodeNumber)->GetType(), (Node::Type)(Node::RigidBody)))
	{
		errorString = "ObjectFFRFreducedOrder: local node 0 must be of type 'Node.RigidBody'";
		return false;
	}

	//GenericODE2 node may not have reference values! ==> is not considered in mode calculation
	LinkedDataVector genericODE2ref(cObject->GetCNode(1)->GetCoordinateVector(ConfigurationType::Reference));
	if (genericODE2ref.GetL2Norm() != 0 )
	{
		errorString = "ObjectFFRFreducedOrder: referenceCoordinates of GenericODE2 node must all be zero!";
		return false;
	}

	Index rowsMass = cObject->GetParameters().massMatrixReduced.NumberOfRows();
	Index columnsMass = cObject->GetParameters().massMatrixReduced.NumberOfColumns();
	if (!(rowsMass == nODE2FF && columnsMass == nODE2FF))
	{
		if (rowsMass == 0 && columnsMass == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRFreducedOrder: massMatrixReduced must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRFreducedOrder: number of flexible coordinates of object is " + EXUstd::ToString(nODE2FF) + ", but mass matrix has size (" + EXUstd::ToString(rowsMass) + " x " + EXUstd::ToString(columnsMass) + ")";
			return false;
		}
	}

	Index rowsStiffness = cObject->GetParameters().stiffnessMatrixReduced.NumberOfRows();
	Index columnsStiffness = cObject->GetParameters().stiffnessMatrixReduced.NumberOfColumns();
	if (!(rowsStiffness == nODE2FF && columnsStiffness == nODE2FF))
	{
		if (rowsStiffness == 0 && columnsStiffness == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRFreducedOrder: stiffnessMatrixReduced must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRFreducedOrder: number of flexible coordinates of object is " + EXUstd::ToString(nODE2FF) + ", but stiffnessMatrixFF has size (" + EXUstd::ToString(rowsStiffness) + " x " + EXUstd::ToString(columnsStiffness) + ")";
			return false;
		}
	}

	Index rowsDamping = cObject->GetParameters().dampingMatrixReduced.NumberOfRows();
	Index columnsDamping = cObject->GetParameters().dampingMatrixReduced.NumberOfColumns();
	if (!(rowsDamping == nODE2FF && columnsDamping == nODE2FF) && !((rowsDamping == 0 && columnsDamping == 0)))
	{
		errorString = "ObjectFFRFreducedOrder: number of flexible coordinates of object is " + EXUstd::ToString(nODE2FF) + ", but dampingMatrixReduced has size (" + EXUstd::ToString(rowsDamping) + " x " + EXUstd::ToString(columnsDamping) + ")";
		return false;
	}

	//check node reference positions and mode Basis
	Index modeRows = cObject->GetParameters().modeBasis.NumberOfRows();
	if (cObject->GetParameters().referencePositions.NumberOfItems() % 3 != 0)
	{
		errorString = "ObjectFFRFreducedOrder: referencePositions must have a length of mesh nodes * 3, but has length " + EXUstd::ToString(cObject->GetParameters().referencePositions.NumberOfItems());
		return false;
	}
	if (cObject->GetParameters().modeBasis.NumberOfColumns() != nODE2FF)
	{
		errorString = "ObjectFFRFreducedOrder: number of modal coordinates (NodeGenericODE2) " + EXUstd::ToString(nODE2FF) +
			", but number of columns in modeBasis = " + EXUstd::ToString(cObject->GetParameters().modeBasis.NumberOfColumns());
		return false;
	}
	if (modeRows != cObject->GetNumberOfMeshNodes() * 3)
	{
		errorString = "ObjectFFRFreducedOrder: number of full coordinates (rows in modeBasis) " + EXUstd::ToString(modeRows) +
			", but number of mesh nodes * 3 = " + EXUstd::ToString(cObject->GetNumberOfMeshNodes() * 3);
		return false;
	}

	//check visualization
	VisualizationObjectFFRFreducedOrder* vObject = (VisualizationObjectFFRFreducedOrder*)GetVisualizationObject();
	if (vObject->GetTriangleMesh().NumberOfRows() != 0)
	{
		if (vObject->GetTriangleMesh().NumberOfColumns() != 3)
		{
			errorString = "ObjectFFRFreducedOrder: number of columns in triangleMesh must be 3";
			return false;
		}

		auto& trigs = vObject->GetTriangleMesh();
		for (Index i = 0; i < trigs.NumberOfRows(); i++)
		{
			for (Index j = 0; j < trigs.NumberOfColumns(); j++)
			{
				if (trigs(i, j) >= cObject->GetNumberOfMeshNodes())
				{
					errorString = "ObjectFFRFreducedOrder: node number in triangleMesh(" + EXUstd::ToString(i) + "," + EXUstd::ToString(j) + ") is invalid; valid node numbers: 0 .. " + EXUstd::ToString(cObject->GetNumberOfMeshNodes());
					return false;
				}
			}
		}
	}

	if (cObject->GetParameters().outputVariableTypeModeBasis == OutputVariableType::StressLocal ||
		cObject->GetParameters().outputVariableTypeModeBasis == OutputVariableType::StrainLocal)
	{
		if (cObject->GetParameters().outputVariableModeBasis.NumberOfColumns() < nODE2FF * 6)
		{
			errorString = "ObjectFFRFreducedOrder: if outputVariableTypeModeBasis is set, the outputVariableModeBasis must have >= (6 * number of modal coordinates) columns; number of modal coordinates of object is " + EXUstd::ToString(nODE2FF);
			return false;

		}
		if (cObject->GetParameters().outputVariableModeBasis.NumberOfRows() != numberOfMeshNodes)
		{
			errorString = "ObjectFFRFreducedOrder: if outputVariableTypeModeBasis is set, the outputVariableModeBasis must have number of mesh nodes rows; number of mesh nodes is " + EXUstd::ToString(numberOfMeshNodes);
			return false;

		}
	}
	else if (cObject->GetParameters().outputVariableTypeModeBasis != OutputVariableType::_None)
	{
		errorString = "ObjectFFRFreducedOrder: if outputVariableTypeModeBasis may be of type Stress, Strain or _None";
		return false;
	}

	return true;
}

bool MainObjectGenericODE2::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectGenericODE2* cObject = (CObjectGenericODE2*)GetCObject();

	Index numberOfNodes = cObject->GetParameters().nodeNumbers.NumberOfItems();
	if (numberOfNodes == 0)
	{
		errorString = "ObjectGenericODE2: has 0 nodes, but must have at least 1 node";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < numberOfNodes; nn++)
		//for (auto item : cObject->GetParameters().nodeNumbers)
	{
		//if (!EXUstd::IsOfType((Node::Type)(Node::GenericODE2 + Node::Position2D + Node::Orientation2D + Node::Point2DSlope1 + Node::Position + Node::Orientation + Node::RigidBody),
		//	cObject->GetCNode(nn)->GetType()))
		if (((Index)cObject->GetCNode(nn)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "ObjectGenericODE2: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE2 node (node group ODE2variables)";
			return false;
		}
	}

	//if (cObject->GetParameters().useFirstNodeAsReferenceFrame)
	//{
	//	if (!EXUstd::IsOfType(cObject->GetCNode(0)->GetType(), (Node::Type)(Node::RigidBody)))
	//	{
	//		errorString = "ObjectGenericODE2: local node 0 must be of type 'Node.RigidBody' because useFirstNodeAsReferenceFrame = True";
	//		return false;
	//	}
	//}


	//now check size of vectors and matrices
	Index nODE2 = cObject->GetODE2Size();

	Index nForce = cObject->GetParameters().forceVector.NumberOfItems();
	if (nForce != nODE2 && nForce != 0)
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but forceVector has size " + EXUstd::ToString(nForce);
		return false;
	}

	Index rowsMass = cObject->GetParameters().massMatrix.NumberOfRows();
	Index columnsMass = cObject->GetParameters().massMatrix.NumberOfColumns();
	if (!(rowsMass == nODE2 && columnsMass == nODE2) && !((rowsMass == 0 && columnsMass == 0)))
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but mass matrix has size (" + EXUstd::ToString(rowsMass) + " x " + EXUstd::ToString(columnsMass) + ")";
		return false;
	}

	Index rowsStiffness = cObject->GetParameters().stiffnessMatrix.NumberOfRows();
	Index columnsStiffness = cObject->GetParameters().stiffnessMatrix.NumberOfColumns();
	Index rowsDamping = cObject->GetParameters().dampingMatrix.NumberOfRows();
	Index columnsDamping = cObject->GetParameters().dampingMatrix.NumberOfColumns();

	if (rowsStiffness && rowsDamping && (cObject->GetParameters().stiffnessMatrix.UseDenseMatrix() !=
		cObject->GetParameters().dampingMatrix.UseDenseMatrix()))
	{
		errorString = "ObjectGenericODE2: stiffnessMatrix and dampingMatrix must be both in dense or sparse mode";
		return false;
	}
	if (!(rowsStiffness == nODE2 && columnsStiffness == nODE2) && !((rowsStiffness == 0 && columnsStiffness == 0)))
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but stiffness matrix has size (" + EXUstd::ToString(rowsStiffness) + " x " + EXUstd::ToString(columnsStiffness) + ")";
		return false;
	}

	if (!(rowsDamping == nODE2 && columnsDamping == nODE2) && !((rowsDamping == 0 && columnsDamping == 0)))
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but damping matrix has size (" + EXUstd::ToString(rowsDamping) + " x " + EXUstd::ToString(columnsDamping) + ")";
		return false;
	}

	//check visualization
	VisualizationObjectGenericODE2* vObject = (VisualizationObjectGenericODE2*)GetVisualizationObject();
	if (vObject->GetTriangleMesh().NumberOfRows() != 0)
	{

		if (vObject->GetTriangleMesh().NumberOfColumns() != 3)
		{
			errorString = "ObjectGenericODE2: number of columns in triangleMesh must be 3";
			return false;
		}

		const MatrixI& trigs = vObject->GetTriangleMesh();
		for (Index i = 0; i < trigs.NumberOfRows(); i++)
		{
			for (Index j = 0; j < trigs.NumberOfColumns(); j++)
			{
				if (trigs(i, j) >= cObject->GetNumberOfNodes())
				{
					errorString = "ObjectGenericODE2: node number in triangleMesh(" + EXUstd::ToString(i) + "," + EXUstd::ToString(j) + ") is invalid; valid node numbers: 0 .. " + EXUstd::ToString(cObject->GetNumberOfNodes());
					return false;
				}
			}
		}
	}


	return true;
}

bool MainObjectGenericODE1::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectGenericODE1* cObject = (CObjectGenericODE1*)GetCObject();

	Index numberOfNodes = cObject->GetParameters().nodeNumbers.NumberOfItems();
	if (numberOfNodes == 0)
	{
		errorString = "ObjectGenericODE1: has 0 nodes, but must have at least 1 node";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < numberOfNodes; nn++)
	{
		if (EXUstd::IsOfType(cObject->GetCNode(nn)->GetNodeGroup(), CNodeGroup::ODE1variables) == 0)
		{
			errorString = "ObjectGenericODE1: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE1 node (node group ODE1variables)";
			return false;
		}
	}

	//now check size of vectors and matrices
	Index nODE1 = cObject->GetODE1Size();

	Index nRHS = cObject->GetParameters().rhsVector.NumberOfItems();
	if (nRHS != nODE1 && nRHS != 0)
	{
		errorString = "ObjectGenericODE1: total ODE1 coordinates of nodes is " + EXUstd::ToString(nODE1) + ", but rhsVector has size " + EXUstd::ToString(nRHS);
		return false;
	}

	Index rowsA = cObject->GetParameters().systemMatrix.NumberOfRows();
	Index columnsA = cObject->GetParameters().systemMatrix.NumberOfColumns();
	if (!(rowsA == nODE1 && columnsA == nODE1) && !((rowsA == 0 && columnsA == 0)))
	{
		errorString = "ObjectGenericODE1: total ODE1 coordinates of nodes is " + EXUstd::ToString(nODE1) + ", but system matrix has size (" + EXUstd::ToString(rowsA) + " x " + EXUstd::ToString(columnsA) + ")";
		return false;
	}

	return true;
}


bool MainObjectKinematicTree::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectKinematicTree* cObject = (CObjectKinematicTree*)GetCObject();

	//check specific node types
	//nodetype checked already in CSystem!

	//now check size of vectors and matrices
	Index nodeNumber = cObject->GetNodeNumber(0);
	const CNodeODE2* node = &(const CNodeODE2&)(mainSystem.GetCSystem()->GetSystemData().GetCNode(nodeNumber));

	//Index nODE2 = cObject->GetODE2Size();
	Index nLinks = node->GetNumberOfODE2Coordinates();

	//++++++++++++++++++++++++++++++++++++++++++++++++++
	//vectors/lists which must have size nLinks:
	Index jointTypesSize = (Index)(cObject->GetParameters().jointTypes.size());
	if (jointTypesSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointTypes has size " + EXUstd::ToString(jointTypesSize);
		return false;
	}

	const ArrayIndex& linkParents = cObject->GetParameters().linkParents;
	Index linkParentsSize = linkParents.NumberOfItems();
	if (linkParentsSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but linkParents has size " + EXUstd::ToString(linkParentsSize);
		return false;
	}

	Index jointTransformationsSize = cObject->GetParameters().jointTransformations.NumberOfItems();
	if (jointTransformationsSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointTransformations has size " + EXUstd::ToString(jointTransformationsSize);
		return false;
	}

	Index jointOffsetsSize = cObject->GetParameters().jointOffsets.NumberOfItems();
	if (jointOffsetsSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointOffsets has size " + EXUstd::ToString(jointOffsetsSize);
		return false;
	}

	Index linkInertiasSize = cObject->GetParameters().linkInertiasCOM.NumberOfItems();
	if (linkInertiasSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but linkInertiasCOM has size " + EXUstd::ToString(linkInertiasSize);
		return false;
	}

	Index linkCOMsSize = cObject->GetParameters().linkCOMs.NumberOfItems();
	if (linkCOMsSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but linkCOMs has size " + EXUstd::ToString(linkCOMsSize);
		return false;
	}

	Index linkMassesSize = cObject->GetParameters().linkMasses.NumberOfItems();
	if (linkMassesSize != nLinks)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but linkMasses has size " + EXUstd::ToString(linkMassesSize);
		return false;
	}

	//++++++++++++++++++++++++++++++++++++++++++++++++++
	//quantities that me have zero size or nLinks size
	Index linkForcesSize = cObject->GetParameters().linkForces.NumberOfItems();
	if (linkForcesSize != nLinks && linkForcesSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but linkForces has size " + EXUstd::ToString(linkForcesSize);
		return false;
	}

	Index linkTorquesSize = cObject->GetParameters().linkTorques.NumberOfItems();
	if (linkTorquesSize != nLinks && linkTorquesSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but linkTorques has size " + EXUstd::ToString(linkTorquesSize);
		return false;
	}


	//++++++++++++++++++++++++++++++++++++++++++++++++++
	//the following parameters may be empty:
	Index jointForceVectorSize = cObject->GetParameters().jointForceVector.NumberOfItems();
	if (jointForceVectorSize != nLinks && jointForceVectorSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointForceVector has size " + EXUstd::ToString(jointForceVectorSize);
		return false;
	}

	Index jointPositionOffsetVectorSize = cObject->GetParameters().jointPositionOffsetVector.NumberOfItems();
	if (jointPositionOffsetVectorSize != nLinks && jointPositionOffsetVectorSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointPositionOffsetVector has size " + EXUstd::ToString(jointPositionOffsetVectorSize);
		return false;
	}

	Index jointVelocityOffsetVectorSize = cObject->GetParameters().jointVelocityOffsetVector.NumberOfItems();
	if (jointVelocityOffsetVectorSize != nLinks && jointVelocityOffsetVectorSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointVelocityOffsetVector has size " + EXUstd::ToString(jointVelocityOffsetVectorSize);
		return false;
	}

	Index jointPControlVectorSize = cObject->GetParameters().jointPControlVector.NumberOfItems();
	if (jointPControlVectorSize != nLinks && jointPControlVectorSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointPControlVector has size " + EXUstd::ToString(jointPControlVectorSize);
		return false;
	}

	Index jointDControlVectorSize = cObject->GetParameters().jointDControlVector.NumberOfItems();
	if (jointDControlVectorSize != nLinks && jointDControlVectorSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but jointDControlVector has size " + EXUstd::ToString(jointDControlVectorSize);
		return false;
	}

	if (jointPositionOffsetVectorSize != jointPControlVectorSize)
	{
		errorString = "ObjectKinematicTree: jointPositionOffsetVector and jointPControlVector must have equal size!";
		return false;
	}

	if (jointDControlVectorSize != jointVelocityOffsetVectorSize)
	{
		errorString = "ObjectKinematicTree: jointDControlVector and jointVelocityOffsetVector must have equal size!";
		return false;
	}

	//++++++++++++++++++++++++++++++++++++++++++++++++++
	//check if parents are correct (must always have smaller, valid index
	for (Index i = 0; i < nLinks; i++)
	{
		if (linkParents[i] < CObjectKinematicTree::noParent || linkParents[i] >= i)
		{
			errorString = "ObjectKinematicTree: link " + EXUstd::ToString(i) + " has parent " + EXUstd::ToString(linkParents[i]) + "; link parents can either have no parent (" +
				EXUstd::ToString(CObjectKinematicTree::noParent) + ") or otherwise must be smaller than the link index itself";
			return false;
		}
	}

	//++++++++++++++++++++++++++++++++++++++++++++++++++

	//++++++++++++++++++++++++++++++++++++++++++++++++++

	////check visualization
	////BodyGraphicsData already merges data! Need to use lists of BodyGraphicsData or other way!
	VisualizationObjectKinematicTree* vObject = (VisualizationObjectKinematicTree*)GetVisualizationObject();
	Index graphicsDataListSize = vObject->GetGraphicsDataList().NumberOfItems();

	if (graphicsDataListSize != nLinks && graphicsDataListSize != 0)
	{
		errorString = "ObjectKinematicTree: number of links is " + EXUstd::ToString(nLinks) + ", but graphicsDataList has size " + EXUstd::ToString(graphicsDataListSize);
		return false;
	}


	return true;
}


bool MainObjectJointRollingDisc::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectJointRollingDisc* cObject = (CObjectJointRollingDisc*)GetCObject();

	if (cObject->GetParameters().discRadius <= 0)
	{
		errorString = "CObjectJointRollingDisc: discRadius must be > 0";
		return false;
	}
	//check that marker m0 is either ground body or rigid body with reference position = 0
	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	const CMarker& cMarker0 = mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]);

	if (EXUstd::IsOfType(cMarker0.GetType(), Marker::Body))
	{
		Index nBody = cMarker0.GetObjectNumber();
		const CObjectBody& body = mainSystem.GetCSystem()->GetSystemData().GetCObjectBody(nBody);
		if (!EXUstd::IsOfType(body.GetType(), CObjectType::Ground)) //for ground always ok
		{
			//only alternative: must be rigid body
			//now check, if reference position of RigidBody Marker is 0
			if (EXUstd::IsOfType(cMarker0.GetType(), (Marker::Type)((Index)Marker::Orientation + (Index)Marker::Position)))
			{
				CMarker* cMarker0Ptr = mainSystem.GetCSystem()->GetSystemData().GetCMarkers()[nMarkers[0]];
				if (dynamic_cast<CMarkerBodyRigid*>(cMarker0Ptr) != nullptr)
				{
					Vector3D p = dynamic_cast<CMarkerBodyRigid*>(cMarker0Ptr)->GetParameters().localPosition;
					if (p.GetL2Norm() != 0)
					{
						errorString = "CObjectJointRollingDisc: Marker 0: if it is of rigid body type, localPosition must be zero";
						return false;
					}
				}
				else
				{
					errorString = "CObjectJointRollingDisc: Marker 0: if it is of body type and no ground, it must be MarkerRigidBody";
					return false;
				}
			}
			else
			{
				errorString = "CObjectJointRollingDisc: Marker 0 must be rigid body, rigid node or ground";
				return false;
			}
		}
	}
	else if (!EXUstd::IsOfType(cMarker0.GetType(), Marker::Node)) //node is always ok, has no reference point
	{
		errorString = "CObjectJointRollingDisc: Marker 0 must be either body or node type";
		return false;
	}


	return true;
}

bool MainObjectJointSliding2D::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectJointSliding2D* cObject = (CObjectJointSliding2D*)GetCObject();
	Index dataNodeNumber = cObject->GetNodeNumber(0);

	const MainNode& dataNode = mainSystem.GetMainSystemData().GetMainNode(dataNodeNumber);
	SignedIndex initialMarker = (SignedIndex)dataNode.GetInitialVector()[0]; //length of initial vector already checked in Node-consistency checks

	Index slidingMarkerSize = cObject->GetParameters().slidingMarkerNumbers.NumberOfItems();
	Index slidingMarkerOffsetSize = cObject->GetParameters().slidingMarkerOffsets.NumberOfItems();

	if (slidingMarkerSize != slidingMarkerOffsetSize)
	{
		errorString = "ObjectJointSliding2D: the slidingMarkerNumbers list (size=" + EXUstd::ToString(slidingMarkerSize) + ") must have same size as the slidingMarkerOffsets list (size=" + EXUstd::ToString(slidingMarkerOffsetSize) + ")";
		return false;
	}

	if (initialMarker < 0 || (Index)initialMarker >= slidingMarkerSize)
	{
		errorString = "ObjectJointSliding2D: initial Data variable must be >= 0 and < " + EXUstd::ToString(slidingMarkerSize);
		return false;
	}

	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(dataNodeNumber).GetTypeName(), "GenericData") != 0)
	{
		errorString = "ObjectJointSliding2D: node must be of type 'GenericData'";
		return false;
	}

	Index nc = ((const CNodeGenericData&)(cObject->GetCSystemData()->GetCNode(dataNodeNumber))).GetNumberOfDataCoordinates();
	const Index nodeGenericDataSize = 2; //current cable in markerlist and the global sliding position
	if (nc != nodeGenericDataSize)
	{
		errorString = STDstring("ObjectJointSliding2D: NodeGenericData (Node ") + EXUstd::ToString(dataNodeNumber) + ") must have " +
			EXUstd::ToString(nodeGenericDataSize) + " coordinates (found: " + EXUstd::ToString(nc) + ")";
		return false;
	}

	if (cObject->GetParameters().axialForce != 0 && !cObject->GetParameters().classicalFormulation)
	{
		errorString = STDstring("ObjectJointSliding2D: in case of classicalFormulation == False, no axialForce may be applied; set axialForce=0 !");
		return false;
	}

	//Check indidual types:
	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	if (cObject->GetParameters().constrainRotation)
	{
		if (!EXUstd::IsOfType(mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetType(), (Marker::Type)((Index)Marker::Position + (Index)Marker::Orientation)))
		{
			errorString = STDstring("ObjectJointSliding2D: in case of constrainRotation == True, Marker 0 must be of type = 'Position' + 'Orientation'");
			return false;
		}
	}
	else if (!EXUstd::IsOfType(mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetType(), Marker::Position))
	{
		errorString = STDstring("ObjectJointSliding2D: Marker 0 must be of type = 'Position'");
		return false;
	}


	if (STDstring(mainSystem.GetMainSystemData().GetMainMarkers()[nMarkers[1]]->GetTypeName()) != STDstring("BodyCable2DCoordinates"))
	{
		errorString = STDstring("ObjectJointSliding2D: Marker 1 must be of type = 'BodyCable2DCoordinates'");
		return false;
	}

	return true;
}











bool MainObjectJointALEMoving2D::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectJointALEMoving2D* cObject = (CObjectJointALEMoving2D*)GetCObject();
	Index dataNodeNumber = cObject->GetNodeNumber(0);
	Index genericODE2NodeNumber = cObject->GetNodeNumber(1);

	const MainNode& dataNode = mainSystem.GetMainSystemData().GetMainNode(dataNodeNumber);
	SignedIndex initialMarker = (SignedIndex)dataNode.GetInitialVector()[0]; //length of initial vector already checked in Node-consistency checks

	Index slidingMarkerSize = cObject->GetParameters().slidingMarkerNumbers.NumberOfItems();
	Index slidingMarkerOffsetSize = cObject->GetParameters().slidingMarkerOffsets.NumberOfItems();

	if (slidingMarkerSize != slidingMarkerOffsetSize)
	{
		errorString = "ObjectJointALEMoving2D: the slidingMarkerNumbers list (size=" + EXUstd::ToString(slidingMarkerSize) + ") must have same size as the slidingMarkerOffsets list (size=" + EXUstd::ToString(slidingMarkerOffsetSize) + ")";
		return false;
	}

	if (initialMarker < 0 || (Index)initialMarker >= slidingMarkerSize)
	{
		errorString = "ObjectJointALEMoving2D: initial Data variable must be >= 0 and < " + EXUstd::ToString(slidingMarkerSize);
		return false;
	}

	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(dataNodeNumber).GetTypeName(), "GenericData") != 0)
	{
		errorString = "ObjectJointALEMoving2D: node must be of type 'GenericData'";
		return false;
	}
	//check for valid node number already done prior to this function
	if (std::strcmp(mainSystem.GetMainSystemData().GetMainNode(genericODE2NodeNumber).GetTypeName(), "GenericODE2") != 0)
	{
		errorString = "ObjectJointALEMoving2D: node must be of type 'GenericODE2'";
		return false;
	}
	

	Index nc = ((const CNodeGenericData&)(cObject->GetCSystemData()->GetCNode(dataNodeNumber))).GetNumberOfDataCoordinates();
	const Index nodeGenericDataSize = 1; //current cable in markerlist and the global sliding position
	if (nc != nodeGenericDataSize)
	{
		errorString = STDstring("ObjectJointALEMoving2D: NodeGenericData (Node ") + EXUstd::ToString(dataNodeNumber) + ") must have " + 
			EXUstd::ToString(nodeGenericDataSize) + " coordinates (found: " + EXUstd::ToString(nc) + ")";
		return false;
	}

	//Check indidual types:
	const ArrayIndex& nMarkers = cObject->GetMarkerNumbers();
	if (!(mainSystem.GetCSystem()->GetSystemData().GetCMarker(nMarkers[0]).GetType() & Marker::Position))
	{
		errorString = STDstring("ObjectJointALEMoving2D: Marker 0 must be of type = 'Position'");
		return false;
	}

	if (STDstring(mainSystem.GetMainSystemData().GetMainMarkers()[nMarkers[1]]->GetTypeName()) != STDstring("BodyCable2DCoordinates"))
	{
		errorString = STDstring("ObjectJointALEMoving2D: Marker 1 must be of type = 'BodyCable2DCoordinates'");
		return false;
	}

	return true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//SENSORS
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bool MainSensorNode::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CSensorNode* cSensor = (CSensorNode*)GetCSensor();

	Index n = GetCSensor()->GetNodeNumber();

	if (!EXUstd::IsOfTypeAndNotNone(mainSystem.GetMainSystemData().GetMainNode(n).GetCNode()->GetOutputVariableTypes(), cSensor->GetOutputVariableType()))
	{
		errorString = STDstring("SensorNode: OutputVariableType '") + GetOutputVariableTypeString(cSensor->GetOutputVariableType()) +
			"' is not available in node with node number " + EXUstd::ToString(n);
		return false;
	}

	return true;
}

bool MainSensorObject::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CSensorObject* cSensor = (CSensorObject*)GetCSensor();
	Index n = GetCSensor()->GetObjectNumber();

	if (EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::Body))
	{
		errorString = STDstring("SensorObject: OutputVariableType '") + GetOutputVariableTypeString(cSensor->GetOutputVariableType()) +
			"' cannot be attached to a body. Use SensorBody instead";
		return false;
	}
	if (!EXUstd::IsOfTypeAndNotNone(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetOutputVariableTypes(), 
		GetCSensor()->GetOutputVariableType()))
	{
		errorString = STDstring("SensorObject: OutputVariableType '") + GetOutputVariableTypeString(cSensor->GetOutputVariableType()) +
			"' is not available in object with object number " + EXUstd::ToString(n);
		return false;
	}

	return true;
}

bool MainSensorBody::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CSensorBody* cSensor = (CSensorBody*)GetCSensor();
	Index n = cSensor->GetObjectNumber();

	if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::Body))
	{
		errorString = STDstring("SensorBody: contains invalid object (ID=") + EXUstd::ToString(n) + ") which is not of ObjectType::Body. Use SensorObject instead";
		return false;
	}
	if (!EXUstd::IsOfTypeAndNotNone(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetOutputVariableTypes(),
		GetCSensor()->GetOutputVariableType()))
	{
		errorString = STDstring("SensorBody: OutputVariableType '") + GetOutputVariableTypeString(GetCSensor()->GetOutputVariableType()) + 
			"' is not available in object with object number " + EXUstd::ToString(n);
		return false;
	}

	return true;
}

bool MainSensorSuperElement::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CSensorSuperElement* cSensor = (CSensorSuperElement*)GetCSensor();
	Index n = GetCSensor()->GetObjectNumber();


	if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::SuperElement))
	{
		errorString = STDstring("SensorSuperElement: contains invalid object (ID=") + EXUstd::ToString(n) + ") which is not of ObjectType::SuperElement";
		return false;
	}
	const CObjectSuperElement* cObjectSuperElement = (const CObjectSuperElement*)(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject());

	if (!EXUstd::IndexIsInRange(cSensor->GetMeshNodeNumber(), 0, cObjectSuperElement->GetNumberOfMeshNodes()))
	{
		errorString = STDstring("SensorSuperElement: meshNodeNumber '") + EXUstd::ToString(cSensor->GetMeshNodeNumber()) + "' is out of valid range [0, " +
			EXUstd::ToString(cObjectSuperElement->GetNumberOfMeshNodes() - 1) + "]";
		return false;
	}

	if (!EXUstd::IsOfTypeAndNotNone(cObjectSuperElement->GetOutputVariableTypesSuperElement(cSensor->GetMeshNodeNumber()),
		cSensor->GetOutputVariableType()))
	{
		errorString = STDstring("SensorSuperElement: OutputVariableType '") + GetOutputVariableTypeString(GetCSensor()->GetOutputVariableType()) +
			"' is not available in mesh node " + EXUstd::ToString(n) + " of object " + EXUstd::ToString(cSensor->GetMeshNodeNumber());
		return false;
	}

	return true;
}

bool MainSensorKinematicTree::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CSensorKinematicTree* cSensor = (CSensorKinematicTree*)GetCSensor();
	Index n = GetCSensor()->GetObjectNumber();


	if (!EXUstd::IsOfType(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject()->GetType(), CObjectType::KinematicTree))
	{
		errorString = STDstring("SensorKinematicTree: contains invalid object (ID=") + EXUstd::ToString(n) + ") which is not of ObjectType::KinematicTree";
		return false;
	}
	const CObjectKinematicTree* cObjectKinematicTree = (const CObjectKinematicTree*)(mainSystem.GetMainSystemData().GetMainObjects()[n]->GetCObject());

	if (cSensor->GetParameters().linkNumber >= cObjectKinematicTree->GetODE2Size())
	{
		errorString = STDstring("SensorKinematicTree: contains invalid link number") + EXUstd::ToString(cSensor->GetParameters().linkNumber) + 
			" which exceeds the number of available links in KinematicTree";
		return false;
	}

	//meshnodenumber not available/used in KinematicTree
	if (!EXUstd::IsOfTypeAndNotNone(cObjectKinematicTree->GetOutputVariableTypesSuperElement(0),
		cSensor->GetOutputVariableType()))
	{
		errorString = STDstring("SensorKinematicTree: OutputVariableType '") + GetOutputVariableTypeString(GetCSensor()->GetOutputVariableType()) +
			"' is not available";
		return false;
	}



	return true;
}

bool MainSensorMarker::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CSensorMarker* cSensor = (CSensorMarker*)GetCSensor();
	Index n = cSensor->GetMarkerNumber();

	const CMarker& cMarker = *mainSystem.GetMainSystemData().GetMainMarkers()[n]->GetCMarker();

	if (!((EXUstd::IsOfType(cMarker.GetType(), Marker::Position) && (cSensor->GetOutputVariableType() == OutputVariableType::Position || cSensor->GetOutputVariableType() == OutputVariableType::Velocity)) ||
		(EXUstd::IsOfType(cMarker.GetType(), Marker::Orientation) && (cSensor->GetOutputVariableType() == OutputVariableType::Rotation || cSensor->GetOutputVariableType() == OutputVariableType::AngularVelocityLocal)) ||
		(EXUstd::IsOfType(cMarker.GetType(), Marker::Coordinate) && (cSensor->GetOutputVariableType() == OutputVariableType::Coordinates || cSensor->GetOutputVariableType() == OutputVariableType::Coordinates_t))))
	{
		errorString = STDstring("SensorMarker: OutputVariableType '") + GetOutputVariableTypeString(cSensor->GetOutputVariableType()) + 
			"' is not available in marker with marker number " + EXUstd::ToString(n);
		return false;
	}

	return true;
}

//bool MainSensorLoad::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
//{
//	return true;
//}

//bool MainSensorUserFunction::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
//{
//	return true;
//}



