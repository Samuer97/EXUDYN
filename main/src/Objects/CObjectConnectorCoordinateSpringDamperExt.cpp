/** ***********************************************************************************************
* @brief        Implementation of CObjectConnectorCoordinateSpringDamperExt
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamperExt.h"

#include "Utilities/Physics.h" //stribeck function

inline Real ComputeStickingForce(Real relPos, Real relVel, Real lastStickPos, Real stiffness, Real damping)
{
    return (relPos - lastStickPos)*stiffness + relVel * damping;
}

//! compute friction force and other values from current position, velocity, last sticking position and parameters
//! to compute current frictionForce for ODE2RHS, just use dummy values for Real& args and 
//!   set lastStickPos and lastStateFriction to current values in data variables
//! used both functions: in PostNewton step as well as in ODE2RHS
Real ComputeFrictionForce(Real relPos, Real relVel, Real lastStickPos, Real lastStateFriction,
    Real startOfStepStickPos, Real startOfStepState, const CObjectConnectorCoordinateSpringDamperExtParameters& parameters, bool isPostNewton,
    Real& newStateFriction, Real& newStickPos, Real& forceError) //these values are updated
{
    Real frictionForce;
    newStateFriction = lastStateFriction; //first assume to keep everything as is
    if (lastStateFriction == 0) // is/was stick
    {
        frictionForce = ComputeStickingForce(relPos, relVel, lastStickPos, parameters.stickingStiffness, parameters.stickingDamping);
        if (isPostNewton)
        {
            newStickPos = lastStickPos;
            if (fabs(frictionForce) > (parameters.fDynamicFriction + parameters.fStaticFrictionOffset))
            {   //was stick => switch to slide: friction force is larger than allowed sticking force
                Real stribeck = ExuPhysics::StribeckFunction(relVel, parameters.fDynamicFriction,
                    parameters.fStaticFrictionOffset, parameters.fViscousFriction,
                    parameters.exponentialDecayStatic, parameters.frictionProportionalZone);

                forceError += fabs(frictionForce) - fabs(stribeck);
                //newStateFriction = EXUstd::SignReal(relVel)*fabs(stribeck); //switch to slipping
                newStateFriction = stribeck; //switch to slipping
            }
            else //stay at stick
            {
                //pout << "case stick: force=" << frictionForce << "\n";
                newStateFriction = 0; //update in any case, to have correct value of friction in state variable
                //pout << "case stick: force=" << frictionForce << "\n";
            }
        }
    }
    else // is/was slip
    {
        frictionForce = ExuPhysics::StribeckFunction(relVel, parameters.fDynamicFriction,
            parameters.fStaticFrictionOffset, parameters.fViscousFriction,
            parameters.exponentialDecayStatic, parameters.frictionProportionalZone);
        if (!isPostNewton)
        {
            //improve convergence:
            frictionForce = EXUstd::SignReal(lastStateFriction)*fabs(frictionForce); //sign of slip force will not change during Newton
        }
        else
        {
            newStickPos = relPos;
            newStateFriction = frictionForce;
            //pout << "case slip: stbk=" << frictionForce << "\n";
            if (relVel * lastStateFriction < 0) //this means that assumption was slip, but sliding in wrong direction
            {   //switch to stick (before switching to other slipping direction)
                if (startOfStepState == 0) //initially step was with stick ==> go back to original values!
                {
                    newStickPos = startOfStepStickPos;
                    newStateFriction = 0; //try sticking again, before switching to other sign!

                    //error is difference when switching to sticking:
                    forceError += fabs(fabs(frictionForce) - fabs(ComputeStickingForce(relPos, relVel, lastStickPos, parameters.stickingStiffness, parameters.stickingDamping)));
                }
                else //start of step was sliding => sticking is new and thus should start with slipping force of start of step
                {
                    Real lastFrictionForce = startOfStepState;

                    //compute good start estimate for newStickPos, such that initial sticking force is approx. last sliding force
                    newStickPos = relPos - (lastFrictionForce - relVel * parameters.stickingDamping) / parameters.stickingStiffness;

                    //error is difference when switching to sticking:
                    forceError += fabs(lastFrictionForce - frictionForce); //error is due to different assumption of the previous step ...
                    newStateFriction = 0; //try sticking again, before switching to other sign!
                }
            }
        }
    }
    return frictionForce;
}

//! compute limit stop forces as well as updates for PostNewton
//! to only compute forces, set currentStateLS to current data variable and ignore newContactState and forceError
Real ComputeLimitStops(Real relPos, Real relVel, Real currentStateLS, const CObjectConnectorCoordinateSpringDamperExtParameters& parameters,
    Real& newContactState, Real& forceError)
{
    Real forceLS;
    newContactState = currentStateLS; //if nothing happens ... prolong current state
    if (currentStateLS < 0)
    {
        forceLS = (relPos - parameters.limitStopsLower)*parameters.limitStopsStiffness + relVel * parameters.limitStopsDamping;
        if (relPos > parameters.limitStopsLower)
        {
            newContactState = 0;
            forceError += fabs(currentStateLS * parameters.limitStopsStiffness);
        }
        else
        {
            newContactState = relPos - parameters.limitStopsLower;
        }
    }
    else if (currentStateLS > 0)
    {
        forceLS = (relPos - parameters.limitStopsUpper)*parameters.limitStopsStiffness + relVel * parameters.limitStopsDamping;
        if (relPos < parameters.limitStopsUpper)
        {
            newContactState = 0;
            forceError += fabs(currentStateLS * parameters.limitStopsStiffness);
        }
        else
        {
            newContactState = relPos - parameters.limitStopsUpper;
        }
    }
    else //last state was not in limit
    {
        forceLS = 0; //in compute case, the currentStateLS says so
        if (relPos > parameters.limitStopsUpper)
        {
            newContactState = relPos - parameters.limitStopsUpper;
            forceError += fabs(newContactState * parameters.limitStopsStiffness);
        }
        else if (relPos < parameters.limitStopsLower)
        {
            newContactState = relPos - parameters.limitStopsLower;
            forceError += fabs(newContactState * parameters.limitStopsStiffness);
        }
    }
    return forceLS;
}

inline void ComputePosVel(const MarkerDataStructure& markerData, const CObjectConnectorCoordinateSpringDamperExtParameters& parameters, 
	Real& relPos, Real& relVel)
{
	//relative position, spring length and inverse spring length
	relPos = (parameters.factor1 * markerData.GetMarkerData(1).vectorValue[0] - parameters.factor0 * markerData.GetMarkerData(0).vectorValue[0]);

	//relative velocity of spring-damper
	relVel = (parameters.factor1 * markerData.GetMarkerData(1).vectorValue_t[0] - parameters.factor0 * markerData.GetMarkerData(0).vectorValue_t[0]);
}

//! function provides the force, relative displacement and relative velocity of the connector
inline void CObjectConnectorCoordinateSpringDamperExt::ComputeSpringForce(const MarkerDataStructure& markerData, Index itemIndex,
	Real& relPos, Real& relVel, Real& force) const
{
	ComputePosVel(markerData, parameters, relPos, relVel);

	force = 0; //default; necessary, e.g. if computed in GetOutputVariable...
	if (parameters.activeConnector)
	{
		if (!parameters.springForceUserFunction)
		{   //compute resulting force vector:
			
            //spring-damper force:
			force = parameters.stiffness * (relPos - parameters.offset) + parameters.damping * relVel;

            //friction:
            if (parameters.frictionProportionalZone != 0)
            {
                force += ExuPhysics::StribeckFunction(relVel, parameters.fDynamicFriction, 
                    parameters.fStaticFrictionOffset, parameters.fViscousFriction, 
                    parameters.exponentialDecayStatic, parameters.frictionProportionalZone);  
            }
            else
            {
                if (parameters.fDynamicFriction != 0 || parameters.fStaticFrictionOffset != 0)
                {
                    CHECKandTHROW(parameters.nodeNumber != EXUstd::InvalidIndex, "CObjectConnectorCoordinateSpringDamperExt: needs valid data node for frictionProportionalZone != 0");
                    Real& currentStateFriction = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[0];
                    Real& currentStateLastStick = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[1];

                    Real newStateFriction;  //not used here
                    Real newStickPos;       //not used here
                    Real forceError;        //not used here
                    force += ComputeFrictionForce(relPos, relVel, currentStateLastStick, currentStateFriction,
                        currentStateLastStick, currentStateFriction, parameters, false,
                        newStateFriction, newStickPos, forceError); //these values are updated, only frictionForce used
                }
            }

            //limit stops:
            if (parameters.useLimitStops)
            {
                CHECKandTHROW(parameters.nodeNumber != EXUstd::InvalidIndex, "CObjectConnectorCoordinateSpringDamperExt: needs valid data node for useLimitStops=True");
                Real newContactState = 0; //unused
                Real discontinuousError = 0; //unused
                Real currentStateLS = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[2];
                force += ComputeLimitStops(relPos, relVel, currentStateLS, parameters, newContactState, discontinuousError);
            }
        }
		else
		{
			EvaluateUserFunctionForce(force, cSystemData->GetMainSystemBacklink(), markerData.GetTime(), 
                itemIndex, relPos, relVel);
		}
	}
}



//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectConnectorCoordinateSpringDamperExt::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectConnectorCoordinateSpringDamperExt::ComputeODE2LHS: marker do not provide velocityLevel information");

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).jacobian.NumberOfColumns() + markerData.GetMarkerData(1).jacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	if (parameters.activeConnector)
	{
		Real relPos;
		Real relVel;
		Real force;
		ComputeSpringForce(markerData, objectNumber, relPos, relVel, force);


		Vector1D fVec(force); //convert to vector to allow matrix-multiplication as usual ...

		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).jacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).jacobian.NumberOfColumns(), markerData.GetMarkerData(1).jacobian.NumberOfColumns());

			//factor added according to virtual work; gives e.g. larger torque on gear with slower angular velocity
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).jacobian, parameters.factor1*fVec, ldv1);
		}

		if (markerData.GetMarkerData(0).jacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).jacobian.NumberOfColumns());

			fVec *= -1.;
			//factor added according to virtual work; gives e.g. larger torque on gear with slower angular velocity
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).jacobian, parameters.factor0*fVec, ldv0);

		}
	}

}

//FUTURE: needed if MarkerNodeRotationCoordinate has jacDerivative: 
void CObjectConnectorCoordinateSpringDamperExt::ComputeJacobianForce6D(const MarkerDataStructure& markerData, Index objectNumber, Vector6D& force6D) const
{
	if (parameters.activeConnector)
	{
		Real relPos, relVel, force;
		ComputeSpringForce(markerData, objectNumber, relPos, relVel, force);
		force6D.SetVector({ force, 0., 0., 0., 0., 0. }); //for coordinate connectors, use only first coordinate
	}
	else { force6D.SetAll(0.); }
}

void CObjectConnectorCoordinateSpringDamperExt::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp,
	Real factorODE2, Real factorODE2_t,
	Index objectNumber, const ArrayIndex& ltg, const MarkerDataStructure& markerData) const
{
	if (parameters.activeConnector)
	{
		temp.localJacobian.SetNumberOfRowsAndColumns(1, 1);
		//compute inner jacobian: factorODE2 * d(F)/(dq) + factorODE2_t * d(F)/(dq_t)
		Real localJac = parameters.stiffness * factorODE2 + parameters.damping * factorODE2_t;

		temp.localJacobian(0, 0) = localJac;
		//pout << "inside, localJac=" << localJac << "\n";
	}
	//compute jacobianODE2 in dense mode; temp.localJacobian is modified!
	ComputeJacobianODE2_ODE2generic(temp.localJacobian, jacobianODE2, temp, factorODE2, factorODE2_t, objectNumber, markerData, 
		parameters.activeConnector, true, false);
}


JacobianType::Type CObjectConnectorCoordinateSpringDamperExt::GetAvailableJacobians() const
{
    bool hasNonlinearity = parameters.useLimitStops ||
        parameters.fDynamicFriction != 0 || parameters.fStaticFrictionOffset != 0 ||
        parameters.fViscousFriction != 0;

    if (!parameters.springForceUserFunction && !hasNonlinearity)
	{   //only in very simple case we can use analytical Jacobian
		return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t + JacobianType::ODE2_ODE2_function + JacobianType::ODE2_ODE2_t_function);
	}
	else 
	{   //numerical Jacobian
		return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t);
	}
}

//! provide according output variable in "value"
void CObjectConnectorCoordinateSpringDamperExt::GetOutputVariableConnector(OutputVariableType variableType, 
    const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	Real relPos;
	Real relVel;
	Real force;
	ComputeSpringForce(markerData, itemIndex, relPos, relVel, force);

	switch (variableType)
	{
	case OutputVariableType::Displacement: value = Vector({ relPos }); break;
	case OutputVariableType::Velocity: value = Vector({ relVel }); break;
	case OutputVariableType::Force: value = Vector({ force }); break;
	default:
		SysError("CObjectConnectorCoordinateSpringDamperExt::GetOutputVariable failed"); //error should not occur, because types are checked!
	}

}

//! function called after Newton method; returns a residual error (force)
Real CObjectConnectorCoordinateSpringDamperExt::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
    Real discontinuousError = 0;
    flags = PostNewtonFlags::_None;

    CHECKandTHROW(parameters.nodeNumber != EXUstd::InvalidIndex, "CObjectConnectorCoordinateSpringDamperExt::PostNewtonStep: invalid node number for PostNewton; report to Exudyn on github");

    Real startofStepStateFriction = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep)[0];
    Real& currentStateFriction = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[0];
    Real startofStepStateLastStick = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep)[1];
    Real& currentStateLastStick = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[1];
    //Real startofStepStateLS = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep)[2];
    Real& currentStateLS = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current)[2];

	Real relPos, relVel;
	ComputePosVel(markerDataCurrent, parameters, relPos, relVel);

    //this does not work as currentStateFriction contains +/forces: if (currentStateFriction == -2) { discontinuousError += parameters.stickingStiffness; } //to mark that iteration should be repeated!

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //friction:
    Real newStateFriction;
    Real newStickPos;
    ComputeFrictionForce(relPos, relVel, currentStateLastStick, currentStateFriction, startofStepStateLastStick, startofStepStateFriction, 
        parameters, true,
        newStateFriction, newStickPos, discontinuousError); //these values are updated

    currentStateLastStick = newStickPos;
    currentStateFriction = newStateFriction;

    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //limit stops:
    Real newContactState = 0; //current contact: 0=no contact, (<0)=contact with lower limit stop, (>0)=contact with upper limit stop
    if (parameters.useLimitStops)
    {
        ComputeLimitStops(relPos, relVel, currentStateLS, parameters, newContactState, discontinuousError);
    }
    currentStateLS = newContactState;
    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if (discontinuousError != 0) { flags = PostNewtonFlags::UpdateJacobian; }

    //pout << "PNS: t:" << markerDataCurrent.GetTime() << ", limit stop=" << currentStateLS << ", frictionState=" << newStateFriction <<
    //    ", stickPos=" << newStickPos << ", error=" << discontinuousError << "\n";
    return discontinuousError;

}

//! AUTO:  function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CObjectConnectorCoordinateSpringDamperExt::PostDiscontinuousIterationStep()
{

}
