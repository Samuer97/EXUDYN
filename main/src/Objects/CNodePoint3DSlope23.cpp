/** ***********************************************************************************************
* @brief		Implementation for NodePoint3DSlope23
*
* @author		Gerstmayr Johannes
* @date			2019-06-15 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Linalg/RigidBodyMath.h"
#include "Autogenerated/CNodePoint3DSlope23.h"				//includes ReleaseAssert.h, BasicDefinitions.h, ResizeableArray.h, LinkedDataVector.h
#include "Utilities/Differentiation.h"

Vector3D CNodePoint3DSlope23::GetPosition(ConfigurationType configuration) const
{
	//p = pRef + u = reference position + displacement
	LinkedDataVector pRef3D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef3D[0], pRef3D[1] , pRef3D[2] });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	LinkedDataVector u3D = GetCoordinateVector(configuration);
	Vector3D displacement({ u3D[0], u3D[1] , u3D[2] });
	return pRef + displacement;
}

Vector3D CNodePoint3DSlope23::GetVelocity(ConfigurationType configuration) const
{
	LinkedDataVector u3D_t = GetCoordinateVector_t(configuration);
	return Vector3D({ u3D_t[0], u3D_t[1] , u3D_t[2] });
}

//! provide position jacobian of node; derivative of 3D Position with respect to 9 coordinates ux,uy and x/y "displacements" of slopex
void CNodePoint3DSlope23::GetPositionJacobian(Matrix& value) const
{
	//derivative of position with respect to all coordinates
	value.SetMatrix(3, 9, {
		1.,0.,0.,0.,0.,0.,0.,0.,0.,
		0.,1.,0.,0.,0.,0.,0.,0.,0.,
		0.,0.,1.,0.,0.,0.,0.,0.,0. });
}

template <class TReal>
void fRotTest(const ConstSizeVectorBase<TReal, 6>& q, ConstSizeVectorBase<TReal, 9>& f)
{
	ConstSizeMatrixBase<TReal, 9> A;
	EXUmath::OrthogonalBasisFromVectorsZY(SlimVectorBase< TReal, 3>({ q[0],q[1],q[2] }), 
		SlimVectorBase< TReal, 3>({ q[3],q[4],q[5] }), A);
	f.CopyFrom(LinkedDataVectorBase<TReal>(A.GetDataPointer(), 9));
};


Matrix3D CNodePoint3DSlope23::GetRotationMatrix_t(ConfigurationType configuration) const
{
	//CHECKandTHROWstring("CNodePoint3DSlope23::GetRotationMatrix_t: not implemented!");
	const Index nqSlope = 6;
	const Index dimRot = 9; //number of entries in rotation matrix A
	ConstSizeVector<nODE2coordinates> q0;
	q0.CopyFrom(GetCoordinateVector(ConfigurationType::Reference));
	if (!(configuration == ConfigurationType::Reference))
	{
		q0 += GetCoordinateVector(configuration);
	}

	//LinkedDataVector q(&q0[3], nqSlope);
	//LinkedDataVector q_t(&GetCoordinateVector_t(configuration)[3], nqSlope);

	ConstSizeVector<nqSlope> q(LinkedDataVector(q0), 3);
	ConstSizeVector<nqSlope> q_t(GetCoordinateVector_t(configuration), 3);

	bool doNumDiff = false;
	if (doNumDiff)
	{
		auto fRot = [](const ConstSizeVector<6>& q, ConstSizeVector<9>& f) //-> void
		{
			Matrix3D A;
			EXUmath::OrthogonalBasisFromVectorsZY(Vector3D({ q[0],q[1],q[2] }), Vector3D({ q[3],q[4],q[5] }), A);
			f.CopyFrom(LinkedDataVector(A.GetDataPointer(), 9));
		};

		ConstSizeMatrix<nqSlope*dimRot> jacobian;
		ConstSizeVector<dimRot> tempF0;
		ConstSizeVector<dimRot> tempF1;
		//EXUmath::NumDiff(fRotTest, dimRot, q, tempF0, tempF1, jacobian);
		EXUmath::NumDiffVectors<CSVector6D, CSVector9D, ConstSizeMatrix<6 * 9>, dimRot>(fRot, q, tempF0, tempF1, jacobian);

		Matrix3D Ap(3, 3);
		LinkedDataVector result(Ap.GetDataPointer(), 9);
		EXUmath::MultMatrixVectorTemplate<ConstSizeMatrix<nqSlope*dimRot>, ConstSizeVector<nqSlope>, LinkedDataVector>(jacobian, q_t, result);

		return Ap;
	}
	else
	{
		//typedef EXUmath::AutoDiff<nqSlope, Real> DRealX;
		//void fRot = [](const ConstSizeVectorBase<DRealX, 6>& q, ConstSizeVectorBase<DRealX, 9>& f)
		//{
		//	ConstSizeMatrixBase<DRealX, 9> A;
		//	EXUmath::OrthogonalBasisFromVectorsZY(SlimVectorBase< DRealX,3>({ q[0],q[1],q[2] }), SlimVectorBase< DRealX, 3>({ q[3],q[4],q[5] }), A);
		//	f.CopyFrom(LinkedDataVectorBase<DRealX>(A.GetDataPointer(), 9));
		//};
		ConstSizeMatrix<nqSlope*dimRot> jacobian;
		EXUmath::AutoDiffVectors<dimRot, nqSlope>(fRotTest<EXUmath::AutoDiff<nqSlope, Real>>, q, jacobian);
		Matrix3D Ap(3, 3);
		LinkedDataVector result(Ap.GetDataPointer(), 9);
		EXUmath::MultMatrixVectorTemplate<ConstSizeMatrix<nqSlope*dimRot>, ConstSizeVector<nqSlope>, LinkedDataVector>(jacobian, q_t, result);

		return Ap;
	}

}

Matrix3D CNodePoint3DSlope23::GetRotationMatrix(ConfigurationType configuration) const
{
	//slope vector = pRef' + u'
	ConstSizeVector<nODE2coordinates> q;
	q.CopyFrom(GetCoordinateVector(ConfigurationType::Reference));
	if (!(configuration == ConfigurationType::Reference))
	{
		q += GetCoordinateVector(configuration);
	}
	////initialize matrix with 2 slope vectors in columns => compute rotation matrix
	//Matrix3D A(3, 3, {
	//	0.,q[3],q[6],
	//	0.,q[4],q[7],
	//	0.,q[5],q[8]
	//	});
	//EXUmath::OrthogonalBasisFromVectorsZY(A);
	Matrix3D A;
	EXUmath::OrthogonalBasisFromVectorsZY(Vector3D({ q[3],q[4],q[5] }), Vector3D({ q[6],q[7],q[8] }), A);

	return A;
}

//! AUTO:  return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CNodePoint3DSlope23::GetAngularVelocity(ConfigurationType configuration) const
{
	//CHECKandTHROWstring("CNodePoint3DSlope23::GetAngularVelocity: untested!");

	ConstSizeVector<nODE2coordinates> q;
	q.CopyFrom(GetCoordinateVector(ConfigurationType::Reference));
	if (!(configuration == ConfigurationType::Reference))
	{
		q += GetCoordinateVector(configuration);
	}
	LinkedDataVector q_t(GetCoordinateVector_t(configuration));

	Vector3D slopeY({ q[3], q[4], q[5] });
	Vector3D slopeZ({ q[6], q[7], q[8] });
	Vector3D slopeY_t({ q_t[3], q_t[4], q_t[5] });
	Vector3D slopeZ_t({ q_t[6], q_t[7], q_t[8] });

	//See MarkerSuperElementRigid
	//r_loc=slope, v_loc=slope_t
	//omega_loc_tilde * sum r_loc = sum v_loc = -sum r_loc_tilde * omega_loc
	//sum r_loc_tilde * v_loc = -sum r_loc_tilde * r_loc_tilde * omega_loc
	//==>omega = -sum r_loc_tilde * v_loc / (sum r_loc_tilde * r_loc_tilde)

	Matrix3D slopeYskew = RigidBodyMath::Vector2SkewMatrix(slopeY);
	Matrix3D slopeZskew = RigidBodyMath::Vector2SkewMatrix(slopeZ);

	Matrix3D W = -1.*(slopeYskew*slopeYskew + slopeZskew * slopeZskew);
	return W.GetInverse() * (slopeYskew*slopeY_t + slopeZskew * slopeZ_t);
}

//! AUTO:  return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CNodePoint3DSlope23::GetAngularVelocityLocal(ConfigurationType configuration) const
{
	//CHECKandTHROWstring("CNodePoint3DSlope23::GetAngularVelocityLocal: untested!");

	return GetRotationMatrix(configuration).GetTransposed() * GetAngularVelocity(configuration);
}

void CNodePoint3DSlope23::GetRotationJacobian(Matrix& value) const
{
	//CHECKandTHROWstring("CNodePoint3DSlope23::GetRotationJacobian: untested!");


	ConstSizeVector<nODE2coordinates> q;
	q.CopyFrom(GetReferenceCoordinateVector());
	q += GetCurrentCoordinateVector();
	
	LinkedDataVector q_t(GetCurrentCoordinateVector_t());

	Vector3D slopeY({ q[3], q[4], q[5] });
	Vector3D slopeZ({ q[6], q[7], q[8] });


	//See MarkerSuperElementRigid
	//r_loc=slope, v_loc=slope_t
	//omega_loc_tilde * sum r_loc = sum v_loc = -sum r_loc_tilde * omega_loc
	//sum r_loc_tilde * v_loc = -sum r_loc_tilde * r_loc_tilde * omega_loc
	//==>omega = -sum r_loc_tilde * v_loc / (sum r_loc_tilde * r_loc_tilde)
	//==>jacobian is d(omega)/d(q_t) which has simple structure!

	Matrix3D slopeYskew = RigidBodyMath::Vector2SkewMatrix(slopeY);
	Matrix3D slopeZskew = RigidBodyMath::Vector2SkewMatrix(slopeZ);

	Matrix3D Winv = -1.*(slopeYskew*slopeYskew + slopeZskew * slopeZskew);
	Winv.Invert();


	value.SetNumberOfRowsAndColumns(3, 9);
	value.SetAll(0.);

	value.SetSubmatrix(Winv*slopeYskew, 0, 3, 1.);
	value.SetSubmatrix(Winv*slopeZskew, 0, 6, 1.);

}

//! provide derivative w.r.t. coordinates of rotation Jacobian times vector; for current configuration
//! 4x4 matrix for all nodal coordinates
void CNodePoint3DSlope23::GetRotationJacobianTTimesVector_q(const Vector3D& vector, Matrix& jacobian_q) const 
{ 
	CHECKandTHROWstring("CNodePoint3DSlope23::GetRotationJacobianTTimesVector_q: not implemented!");

	////only in current configuration!
	//LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	//LinkedDataVector u = GetCurrentCoordinateVector();

	//Real x = u[2] + ref[2]; //x-slopex
	//Real y = u[3] + ref[3]; //y-slopex

	////{ 0.,0.,0.,
	////  0.,0.,0.,
	////	0.,0.,-y / (x*x + y * y), 
	////  0.,0., x / (x*x + y * y) }^T * v = 
	//// [0.                     ]
	//// [0.                     ]
	//// [v[2]*(-y / (x*x + y * y))]
	//// [v[2]*( x / (x*x + y * y))]
	////
	//// [ v[2]*(-u'[3] * (x*x + y*y) + y*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]   //(f'g-f*g')/g^2
	//// [ v[2]*(u'[2] * (x*x + y*y) - x*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]
	////
	//// g2 = (x*x + y*y)^2 //(f'g-f*g')/g^2
	//// d(J^T*v) / q =
	//// [0.,0.,0.,0.]
	//// [0.,0.,0.,0.]
	//// [0.,0.,               v[2]*(y*(2*x) ) / g2, v[2]*(-(x*x + y*y) + y*(2*y) ) / g2]   
	//// [0.,0., v[2]*((x*x + y*y) - x*(2*x) ) / g2, v[2]*( - x*(2*y) ) / g2            ]

	//jacobian_q.SetNumberOfRowsAndColumns(4, 4);
	//jacobian_q.SetAll(0.);
	//Real g2 = EXUstd::Square(x*x + y * y);
	//CHECKandTHROW(g2 != 0., "CNodePoint3DSlope23::GetRotationJacobianTTimesVector_q: slope vector has zero length; check initial values!");

	//Real divG2 = 1. / g2;
	//jacobian_q(2, 2) = vector[2] * (y*(2 * x)) * divG2;
	//jacobian_q(2, 3) = vector[2] * (-(x*x + y * y) + y * (2 * y)) * divG2;
	//jacobian_q(3, 2) = vector[2] * ((x*x + y * y) - x * (2 * x)) * divG2;
	//jacobian_q(3, 3) = vector[2] * (-x * (2 * y)) * divG2;
}


//! provide according output variable in "value"
void CNodePoint3DSlope23::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
	case OutputVariableType::Coordinates:
	{
		if (IsValidConfiguration(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodePoint3DSlope23::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodePoint3DSlope23::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_tt:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_tt(configuration);
		}
		else
		{
			PyError("CNodePoint3DSlope23::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodePoint3DSlope23::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}


