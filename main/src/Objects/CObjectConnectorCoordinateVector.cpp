/** ***********************************************************************************************
* @brief        CObjectConnectorCoordinateVector implementation
*
* @author       Gerstmayr Johannes
* @date         2018-06-14 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorCoordinateVector.h"


//! number of algebraic equations; independent of node/body coordinates
Index CObjectConnectorCoordinateVector::GetAlgebraicEquationsSize() const
{
	//one scaling matrix could have zero rows, but not both! checked in CheckPreAssembleConsistency
	//return EXUstd::Maximum(parameters.scalingMarker0.NumberOfRows(),
	//	parameters.scalingMarker1.NumberOfRows()); //number of algebraic equations
	return EXUstd::Maximum(EXUstd::Maximum(EXUstd::Maximum(parameters.scalingMarker0.NumberOfRows(),
		parameters.scalingMarker1.NumberOfRows()),
		parameters.quadraticTermMarker0.NumberOfRows()),
		parameters.quadraticTermMarker1.NumberOfRows()); //number of algebraic equations
}

//! Computational function: compute algebraic equations and write residual into "algebraicEquations"
void CObjectConnectorCoordinateVector::ComputeAlgebraicEquations(Vector& algebraicEquations, const MarkerDataStructure& markerData, Real t, Index itemIndex, bool velocityLevel) const
{
	if (parameters.activeConnector)
	{
		Index nAE = GetAlgebraicEquationsSize();
		algebraicEquations.SetNumberOfItems(nAE);
		if (!parameters.constraintUserFunction)
		{

			if (!velocityLevel && !parameters.velocityLevel)
			{
				//C(q,q_t,t) = scalingMarker1*qMarker1 - scalingMarker0*qMarker0 - quadraticTermMarker0*qMarker0^2 - quadraticTermMarker1*qMarker1^2 - offset = 0

				algebraicEquations.SetAll(0.);
				if (markerData.GetMarkerData(0).vectorValue.NumberOfItems() != 0)
				{
					if (parameters.scalingMarker0.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorAdd(parameters.scalingMarker0, markerData.GetMarkerData(0).vectorValue, algebraicEquations);
					}
					if (parameters.quadraticTermMarker0.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorSquaredAddTemplate<Matrix, ResizableVector, Vector>(parameters.quadraticTermMarker0, markerData.GetMarkerData(0).vectorValue, algebraicEquations);
					}
					algebraicEquations *= -1.;
				}
				if (markerData.GetMarkerData(1).vectorValue.NumberOfItems() != 0)
				{
					if (parameters.scalingMarker1.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorAdd(parameters.scalingMarker1, markerData.GetMarkerData(1).vectorValue, algebraicEquations);
					}
					if (parameters.quadraticTermMarker1.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorSquaredAddTemplate<Matrix, ResizableVector, Vector>(parameters.quadraticTermMarker1, markerData.GetMarkerData(1).vectorValue, algebraicEquations);
					}
				}
				{
					if (parameters.offset.NumberOfItems() != 0)
					{
						algebraicEquations -= parameters.offset;
					}
				}

			}
			else
			{
				CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
					"CObjectConnectorCoordinateVector::ComputeAlgebraicEquations: marker do not provide velocityLevel information");

				//C(q,q_t,t) = scalingMarker1*qMarker1_t - scalingMarker0*qMarker0_t = 0
				algebraicEquations.SetAll(0.);
				if (markerData.GetMarkerData(0).vectorValue_t.NumberOfItems() != 0)
				{
					if (parameters.scalingMarker0.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorAdd(parameters.scalingMarker0, markerData.GetMarkerData(0).vectorValue_t, algebraicEquations);
					}
					if (parameters.quadraticTermMarker0.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorSquaredAddTemplate<Matrix, ResizableVector, Vector>(parameters.quadraticTermMarker0, markerData.GetMarkerData(0).vectorValue_t, algebraicEquations);
					}
					algebraicEquations *= -1.;
				}
				if (markerData.GetMarkerData(1).vectorValue_t.NumberOfItems() != 0)
				{
					if (parameters.scalingMarker1.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorAdd(parameters.scalingMarker1, markerData.GetMarkerData(1).vectorValue_t, algebraicEquations);
					}
					if (parameters.quadraticTermMarker1.NumberOfColumns() != 0)
					{
						EXUmath::MultMatrixVectorSquaredAddTemplate<Matrix, ResizableVector, Vector>(parameters.quadraticTermMarker1, markerData.GetMarkerData(1).vectorValue_t, algebraicEquations);
					}
				}

				if (parameters.velocityLevel) 
				{ 
					if (parameters.offset.NumberOfItems() != 0)
					{
						algebraicEquations -= parameters.offset;
					}
				}
			}
		}
		else
		{
			EvaluateUserFunctionConstraint(algebraicEquations, cSystemData->GetMainSystemBacklink(), markerData.GetTime(), itemIndex,
				markerData.GetMarkerData(0).vectorValue, markerData.GetMarkerData(1).vectorValue,
				markerData.GetMarkerData(0).vectorValue_t, markerData.GetMarkerData(1).vectorValue_t, velocityLevel || parameters.velocityLevel);
			CHECKandTHROW(algebraicEquations.NumberOfItems() == nAE, "CObjectConnectorCoordinateVector::ComputeAlgebraicEquations with constraintUserFunction: size returned =" + EXUstd::ToString(algebraicEquations.NumberOfItems()) + " but expected size of algebraic equations =" + EXUstd::ToString(nAE));
		}
	}
	else
	{
		algebraicEquations.CopyFrom(markerData.GetLagrangeMultipliers()); //equation lambda = 0, means that the current values need to be copied
	}

}

void CObjectConnectorCoordinateVector::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, ResizableMatrix& jacobian_ODE1, 
	ResizableMatrix& jacobian_AE, const MarkerDataStructure& markerData, Real t, Index itemIndex) const
{
	Index nAE = GetAlgebraicEquationsSize();
	if (parameters.activeConnector)
	{
		ResizableMatrix* usedJac;
		if (parameters.velocityLevel) //in this case, always the jacobian_ODE2_t must be used
		{
			usedJac = &jacobian_ODE2_t;
			//jacobian_ODE2.SetNumberOfRowsAndColumns(0, 0); 
		}
		else
		{
			usedJac = &jacobian_ODE2;
			//jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); 
		}

		Index sizeOfCoordinates = markerData.GetMarkerData(0).jacobian.NumberOfColumns() + markerData.GetMarkerData(1).jacobian.NumberOfColumns();
		usedJac->SetNumberOfRowsAndColumns(nAE, sizeOfCoordinates);
		usedJac->SetAll(0.); //in case that no linear part exists

		if (!parameters.constraintUserFunction)
		{


			//needs memory allocation:
			ResizableMatrix temp;
			Index jacOffset = markerData.GetMarkerData(0).jacobian.NumberOfColumns();
			if (markerData.GetMarkerData(0).jacobian.NumberOfColumns() != 0)
			{
				if (parameters.scalingMarker0.NumberOfColumns() != 0)
				{
					EXUmath::MultMatrixMatrixTemplate<Matrix, ResizableMatrix, ResizableMatrix>(parameters.scalingMarker0, markerData.GetMarkerData(0).jacobian, temp);
					usedJac->SetSubmatrix(temp, 0, 0, -1.);
				}
				if (parameters.quadraticTermMarker0.NumberOfColumns() != 0)
				{
					ResizableMatrix temp2;
					temp2.CopyFrom(parameters.quadraticTermMarker0);
					for (Index i = 0; i < temp2.NumberOfColumns(); i++)
					{
						temp2.MultiplyColumn(i, -2.*markerData.GetMarkerData(0).vectorValue[i]); //'-' because of factor -1 for marker0
					}
					EXUmath::MultMatrixMatrixTemplate<Matrix, ResizableMatrix, ResizableMatrix>(temp2, markerData.GetMarkerData(0).jacobian, temp);
					usedJac->AddSubmatrix(temp, 0, 0);
				}
			}
			if (markerData.GetMarkerData(1).jacobian.NumberOfColumns() != 0)
			{
				if (parameters.scalingMarker1.NumberOfColumns() != 0)
				{
					//parameters.scalingMarker1 * eye(2*[v[0],2*v[1], ...) * GetMarkerData(1).jacobian
					EXUmath::MultMatrixMatrixTemplate<Matrix, ResizableMatrix, ResizableMatrix>(parameters.scalingMarker1, markerData.GetMarkerData(1).jacobian, temp);
					usedJac->SetSubmatrix(temp, 0, jacOffset);
				}
				if (parameters.quadraticTermMarker1.NumberOfColumns() != 0)
				{
					ResizableMatrix temp2;
					temp2.CopyFrom(parameters.quadraticTermMarker1);
					for (Index i = 0; i < temp2.NumberOfColumns(); i++)
					{
						temp2.MultiplyColumn(i, 2.*markerData.GetMarkerData(1).vectorValue[i]);
					}
					//pout << "temp2=" << temp2 << "\n";
					EXUmath::MultMatrixMatrixTemplate<Matrix, ResizableMatrix, ResizableMatrix>(temp2, markerData.GetMarkerData(1).jacobian, temp);
					usedJac->AddSubmatrix(temp, 0, jacOffset);
				}
			}
			//pout << "jac=" << *usedJac << "\n";
		}
		else
		{
			EXUmath::MatrixContainer MC;
			EvaluateUserFunctionJacobian(MC, cSystemData->GetMainSystemBacklink(), markerData.GetTime(), itemIndex,
				markerData.GetMarkerData(0).vectorValue, markerData.GetMarkerData(1).vectorValue,
				markerData.GetMarkerData(0).vectorValue_t, markerData.GetMarkerData(1).vectorValue_t, parameters.velocityLevel);

			CHECKandTHROW(MC.UseDenseMatrix(), "ObjectConnectorCoordinateVector::ComputeJacobianAE: jacobian currently only accepts dense matrices");
			usedJac->CopyFrom(MC.GetInternalDenseMatrix());

			CHECKandTHROW(usedJac->NumberOfRows() == nAE, 
				"CObjectConnectorCoordinateVector::ComputeJacobianAE with jacobianUserFunction: number of rows returned=" + 
				EXUstd::ToString(usedJac->NumberOfRows()) + " but expected nAE=" + EXUstd::ToString(nAE));
			CHECKandTHROW(usedJac->NumberOfColumns() == sizeOfCoordinates, 
				"CObjectConnectorCoordinateVector::ComputeJacobianAE with jacobianUserFunction: number of columns returned=" + 
				EXUstd::ToString(usedJac->NumberOfColumns()) + " but expected nAE=" + EXUstd::ToString(sizeOfCoordinates));
		}

	}
	else
	{
		jacobian_AE.SetScalarMatrix(nAE, 1.); //represents derivative of algebraic equation 'lambda = 0'
		//jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); //not necessary, because of CObjectConnectorCoordinateVector::GetAvailableJacobians()
		//jacobian_ODE2.SetNumberOfRowsAndColumns(0, 0);	  ////not necessary, because of CObjectConnectorCoordinateVector::GetAvailableJacobians()
	}

}

JacobianType::Type CObjectConnectorCoordinateVector::GetAvailableJacobians() const
{
	if (parameters.activeConnector)
	{
		if (parameters.velocityLevel)
		{
			return (JacobianType::Type)(JacobianType::AE_ODE2_t + JacobianType::AE_ODE2_t_function);
		}
		else
		{
			return (JacobianType::Type)(JacobianType::AE_ODE2 + JacobianType::AE_ODE2_function);
		}
	}
	else //deactivated constraint means that only the lagrange multiplier needs to be set to zero
	{
		return (JacobianType::Type)(JacobianType::AE_AE + JacobianType::AE_AE_function);
	}
}


//! provide according output variable in "value"
void CObjectConnectorCoordinateVector::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Displacement: 
	{
		if (markerData.GetMarkerData(1).vectorValue.NumberOfItems() != 0)
		{
			value.CopyFrom(markerData.GetMarkerData(1).vectorValue);

			if (markerData.GetMarkerData(0).vectorValue.NumberOfItems() != 0)
			{
				value -= markerData.GetMarkerData(0).vectorValue;
			}
		}
		else
			if (markerData.GetMarkerData(0).vectorValue.NumberOfItems() != 0)
			{
				value.CopyFrom(markerData.GetMarkerData(0).vectorValue);
				value *= -1;
			}
		break;
	}
	case OutputVariableType::Velocity: 
	{
		if (markerData.GetMarkerData(1).vectorValue_t.NumberOfItems() != 0)
		{
			value.CopyFrom(markerData.GetMarkerData(1).vectorValue_t);

			if (markerData.GetMarkerData(0).vectorValue_t.NumberOfItems() != 0)
			{
				value -= markerData.GetMarkerData(0).vectorValue_t;
			}
		}
		else
			if (markerData.GetMarkerData(0).vectorValue_t.NumberOfItems() != 0)
			{
				value.CopyFrom(markerData.GetMarkerData(0).vectorValue_t);
				value *= -1;
			}
		break;
	}
	case OutputVariableType::ConstraintEquation: 
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		bool velocityLevel = false;
		Vector algebraicEquations;
		ComputeAlgebraicEquations(algebraicEquations, markerData, t, velocityLevel);
		value.CopyFrom(algebraicEquations); 
		break;
	}
	case OutputVariableType::Force: value.CopyFrom(markerData.GetLagrangeMultipliers()); break;
	default:
		SysError("CObjectConnectorCoordinateVector::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}

}



