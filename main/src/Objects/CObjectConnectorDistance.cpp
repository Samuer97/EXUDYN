/** ***********************************************************************************************
* @brief        CObjectConnectorDistance implementation
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorDistance.h"


//! Computational function: compute algebraic equations and write residual into "algebraicEquations"
void CObjectConnectorDistance::ComputeAlgebraicEquations(Vector& algebraicEquations, const MarkerDataStructure& markerData, Real t, Index itemIndex, bool velocityLevel) const
{
	if (parameters.activeConnector)
	{
		if (!velocityLevel)
		{
			Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
			Real currentDistance = vPos.GetL2Norm();

			algebraicEquations.SetNumberOfItems(1);
			algebraicEquations[0] = currentDistance - parameters.distance;
		}
		else
		{
			CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
				"CObjectConnectorDistance::ComputeAlgebraicEquations: marker do not provide velocityLevel information");

			Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
			Vector3D vVel = (markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);
			Real currentDistance = vPos.GetL2Norm();
			Real currentDistanceInv;

			if (currentDistance != 0.) { currentDistanceInv = 1. / currentDistance; }
			else { currentDistanceInv = 1.; SysError("CObjectConnectorDistance::ComputeAlgebraicEquations_t: currentDistance = 0"); }

			algebraicEquations.SetNumberOfItems(1);
			algebraicEquations[0] = currentDistanceInv * (vPos * vVel);
		}
	}
	else
	{
		algebraicEquations.CopyFrom(markerData.GetLagrangeMultipliers()); //equation lambda = 0, means that the current values need to be copied
	}
}

void CObjectConnectorDistance::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, ResizableMatrix& jacobian_ODE1,
	ResizableMatrix& jacobian_AE, const MarkerDataStructure& markerData, Real t, Index itemIndex) const
{
	if (parameters.activeConnector)
	{
		//markerData contains already the correct jacobians ==> transformed to constraint jacobian_ODE2
		Index columnsOffset = markerData.GetMarkerData(0).positionJacobian.NumberOfColumns();
		jacobian_ODE2.SetNumberOfRowsAndColumns(1, columnsOffset + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());

		Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
		Real currentDistance = vPos.GetL2Norm();
		Real currentDistanceInv;

		if (currentDistance != 0.) { currentDistanceInv = 1. / currentDistance; }
		else { currentDistanceInv = 1.; SysError("CObjectConnectorDistance::ComputeAlgebraicEquationsJacobian: currentDistance = 0"); }


		for (Index i = 0; i < columnsOffset; i++)
		{
			Vector3D jacVec({ markerData.GetMarkerData(0).positionJacobian(0,i),
				markerData.GetMarkerData(0).positionJacobian(1,i),
				markerData.GetMarkerData(0).positionJacobian(2,i) });
			jacobian_ODE2(0, i) = -currentDistanceInv * (vPos * jacVec);
		}
		for (Index i = 0; i < markerData.GetMarkerData(1).positionJacobian.NumberOfColumns(); i++)
		{
			Vector3D jacVec({ markerData.GetMarkerData(1).positionJacobian(0,i),
				markerData.GetMarkerData(1).positionJacobian(1,i),
				markerData.GetMarkerData(1).positionJacobian(2,i) });
			jacobian_ODE2(0, i + columnsOffset) = currentDistanceInv * (vPos * jacVec);
		}
	}
	else
	{
		jacobian_AE.SetScalarMatrix(1, 1.); //represents derivative of algebraic equation '[lambda0]^T = [0]^T'
	}
}

JacobianType::Type CObjectConnectorDistance::GetAvailableJacobians() const
{
	if (parameters.activeConnector)
	{
		return (JacobianType::Type)(JacobianType::AE_ODE2 + JacobianType::AE_ODE2_function);
	}
	else //deactivated constraint means that only the lagrange multiplier needs to be set to zero
	{
		return (JacobianType::Type)(JacobianType::AE_AE + JacobianType::AE_AE_function);
	}
}

////! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
//OutputVariableType CObjectConnectorDistance::GetOutputVariableTypes() const
//{
//	return OutputVariableType::Distance;
//}

//! provide according output variable in "value"
void CObjectConnectorDistance::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
	Vector3D vVel = (markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);
	Real currentDistance = vPos.GetL2Norm();

	switch (variableType)
	{
		case OutputVariableType::Displacement: value.CopyFrom(vPos); break;
		case OutputVariableType::Velocity: value.CopyFrom(vVel); break;
		case OutputVariableType::Distance: value = Vector({ currentDistance }); break;
		case OutputVariableType::Force: value.CopyFrom(markerData.GetLagrangeMultipliers()); break;
		default:
			SysError("CObjectConnectorDistance::GetOutputVariable failed"); //error should not occur, because types are checked!
	}

}



