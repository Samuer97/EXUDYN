/** ***********************************************************************************************
* @brief        Implementation for MarkerNodeCoordinate
*
* @author       Gerstmayr Johannes
* @date         2019-06-13 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CMarkerNodeCoordinate.h"


void CMarkerNodeCoordinate::GetPosition(const CSystemData& cSystemData, Vector3D& position, ConfigurationType configuration) const
{
	if ((Index)cSystemData.GetCNodes()[parameters.nodeNumber]->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
	{
		position = ((CNodeODE2*)(cSystemData.GetCNodes()[parameters.nodeNumber]))->GetPosition(configuration);
	}
	else { position = Vector3D(0.); } //in other cases, GetPosition might not be implemented
}

//void CMarkerNodeCoordinate::GetVelocity(const CSystemData& cSystemData, Vector3D& velocity, ConfigurationType configuration) const
//{
//	velocity = ((CNodeODE2*)(cSystemData.GetCNodes()[parameters.nodeNumber]))->GetVelocity(configuration);
//}

void CMarkerNodeCoordinate::ComputeMarkerData(const CSystemData& cSystemData, bool computeJacobian, MarkerData& markerData) const
{
	//A marker 'NodeCoordinate' must be attached to the ODE2 part of a node
	//always markerData.value is written ... also for velocities
	
	Index n = cSystemData.GetCNodes()[parameters.nodeNumber]->GetNumberOfODE2Coordinates(); //works already for both cases
	if (n) //access to GetCurrentCoordinateVector only if not ground node (which has no real coordinates, but it is allows to constrain to a ground node 'coordinate' being always zero
	{
		if ((Index)cSystemData.GetCNodes()[parameters.nodeNumber]->GetNodeGroup() & (Index)CNodeGroup::ODE2variables)
		{
			//must be ODE2
			markerData.velocityAvailable = true;
			markerData.vectorValue_t.SetVector({ ((CNodeODE2*)(cSystemData.GetCNodes()[parameters.nodeNumber]))->GetCurrentCoordinateVector_t()[parameters.coordinate] }); //works for all coordinates
		}
		else
		{
			markerData.velocityAvailable = false;
		}
		markerData.vectorValue.SetVector({ cSystemData.GetCNodes()[parameters.nodeNumber]->GetCurrentCoordinateVector()[parameters.coordinate] }); //works for all coordinates

		if (computeJacobian)
		{
			//zero-vector with 1 at parameters.coordinate => this is also done for velocity markers; this might not work for non-holonomic constraints
			markerData.jacobian.SetNumberOfRowsAndColumns(1, n);
			markerData.jacobian.SetAll(0.);
			markerData.jacobian(0, parameters.coordinate) = 1; //action only to the specified coordinate
		}
	}
	else //ground node
	{
		markerData.velocityAvailable = true;
		//markerData.value = 0;
		//markerData.value_t = 0; //set this also for ground markers, because it could be asked for in connector!!!!
		markerData.vectorValue.SetVector({ 0. });   //indicates that value is zero
		markerData.vectorValue_t.SetVector({ 0. }); //set this also for ground markers, because it could be asked for in connector!!!!
		markerData.jacobian.SetNumberOfRowsAndColumns(0, 0); //this signals the connector/system not to apply any load or Lagrange multiplier
	}
}

//! compute markerdata: fill in according data for derivative of jacobian times vector v, e.g.: d(Jpos.T @ v)/dq
void CMarkerNodeCoordinate::ComputeMarkerDataJacobianDerivative(const CSystemData& cSystemData, const Vector6D& v6D, MarkerData& markerData) const
{
	markerData.jacobianDerivative.SetNumberOfRowsAndColumns(0, 0); //signals that there is no dependency!
}
