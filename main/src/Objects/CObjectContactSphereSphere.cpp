/** ***********************************************************************************************
* @brief        Implementation of CObjectContactSphereSphere
*
* @author       Gerstmayr Johannes and Weyrer Sebastian
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeGenericData.h"
#include "Autogenerated/CObjectContactSphereSphere.h"

// compute the contact force acting on sphere 1; n0 points from center of spehere 0 to center of sphere 1
// gap is the distance between the two speheres (negative in case of contact)
// n0 is the vector pointing from center of spehere 0 to spehere 1
// deltaVnormal is the separation (gap) velocity (for sphere 1 positive in the case that the particles separate)
template<typename TReal>
TReal CObjectContactSphereSphere::ComputeContactForces(TReal gap, const SlimVectorBase<TReal, 3>& n0,
	TReal deltaVnormal, const SlimVectorBase<TReal, 3>& deltaVji, TReal dryFriction, bool frictionRegularizedRegion, 
	SlimVectorBase<TReal, 3>& fVec, SlimVectorBase<TReal, 3>& fFriction, bool forceFrictionMode) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Real k1 = parameters.contactStiffness;
	Real d1 = parameters.contactDamping;
	Real n = parameters.contactStiffnessExponent;
	TReal deltaExp = -gap; // overwrite this in case that n != 1 holds (see following line)
	if (n != 1) { deltaExp = EXUstd::SignReal(deltaExp) * pow(fabs(deltaExp), n); } // also respect sign
	// at first, just use the easierst spring damper model (damping acts against n0 for sphere 1 if deltaVnormal is positive)
	TReal fDamp = - d1 * deltaVnormal;
	TReal contactForce = k1 * deltaExp + fDamp;
	////////////////////////// use Adhesive Elasto-Plastic model in the case that impactModel == 0
	if (parameters.impactModel == 0)
	{
		if (parameters.contactPlasticityRatio != 0.)
		{
			Real k2 = k1 * (1. / (1. - parameters.contactPlasticityRatio));
			Real f0 = parameters.constantPullOffForce;
			TReal deltaPlasticExp = data[dataIndexDeltaPlastic]; // overwrite this in case that n != 1 holds (see following line)
			if (n != 1) { deltaPlasticExp = EXUstd::SignReal(deltaPlasticExp) * pow(fabs(deltaPlasticExp), n); }  // also respect sign
			if ((k2 * (deltaExp - deltaPlasticExp)) >= (k1 * deltaExp))
			{
				contactForce = k1 * deltaExp; // loading process (overwrite primarily computed contactForce)
			}
			else
			{
				Real kAdh = parameters.adhesionCoefficient;
				Real x = parameters.adhesionExponent;
				Real deltaAdhExp = -gap; // overwrite this in case that x != 1 holds (see following line)
				if (n != 1) { deltaAdhExp = EXUstd::SignReal(deltaAdhExp) * pow(fabs(deltaAdhExp), x); }  // also respect sign
				if (((k1 * deltaExp) > (k2 * (deltaExp - deltaPlasticExp))) && ((k2 * (deltaExp - deltaPlasticExp)) > (-kAdh * deltaAdhExp)))
				{
					contactForce = k2 * (deltaExp - deltaPlasticExp); // unloading process (overwrite primarily computed contactForce)
				}
				if ((-kAdh * deltaAdhExp) > (k2 * (deltaExp - deltaPlasticExp)))
				{
					contactForce = -kAdh * deltaAdhExp; // unloading process with adhesion (overwrite primarily computed contactForce)
				}
			}
			contactForce += -f0 + fDamp; // add constant adhesion force (negative for spehere 1 since acting against n0) and damping
		}
	} 
	else 
	{
		// if impactModel != 0  treat the contact force with restitution model
		// for resititution coefficient < 1, lambda must be negative as component acting in direction of damping is added
		TReal minImpactVel = EXUstd::Maximum(parameters.minimumImpactVelocity, data[dataIndexImpactVel]); 
		if (minImpactVel > 0)
		{
			TReal lambda = k1 / minImpactVel;
			const Real& ee = parameters.restitutionCoefficient; 
			if (parameters.impactModel == 1) // Hunt-Crossley
			{
				lambda *= 3. / 2. * (ee - 1.);
			} else if (parameters.impactModel == 2) // mixed Gonthier/EtAl-Carvalho/Martins
			{
				if (ee > 1. / 3.)
				{
					lambda *= 3. / 2. * (ee - 1.) * (11. - ee)/(1. + 9. * ee);
				}
				else if (ee > 0)
				{
					lambda *= (ee * ee - 1.) / ee;
				} else {
					CHECKandTHROWstring("CObjectContactSphereSphere: coefficient of restitution must be > 0");
				}
			}
			contactForce += lambda * deltaExp * deltaVnormal;
		}
	}
	contactForce *= (-1); // this is the contact force acting on sphere 1 (and moved to the LHS of the ODE2)
	fVec = contactForce * n0;
	////////////////////////// add tangential component for the force vector if friction should be added
	// note that for coulomb friction we need fR acting against the velocity
	// fR = - fN * deltaVtangent
	// since fN is already moved to LHS of ODE2, the negative sign is not necessary: fR = fN * deltaVtangent
	// since we then must also move fR to LHS of ODE2, the computation again gets a negative sign
	if (dryFriction != 0.)
	{
		// global tangent velocity of spehere 1 relative to spehere 0
		SlimVectorBase<TReal, 3> deltaVtangent = deltaVji - deltaVnormal * n0;	// tangent velocity
		TReal relVel = deltaVtangent.GetL2Norm();
		if (!forceFrictionMode) // if mode is not enforced, then we have to compute it (this is wrong in GeneralContact!)
		{
			frictionRegularizedRegion = (relVel < parameters.frictionProportionalZone);
		}
		if (frictionRegularizedRegion && parameters.frictionProportionalZone != 0)
		{
			//Warning: in the adhesive model, contactForce could become positive (=tension) and cause unphysical friction behavior
			// as long as relVel < frictionProportionalZone, friction force is computed linearily with deltaVtangent
			fFriction = (-dryFriction * contactForce / parameters.frictionProportionalZone) * deltaVtangent;
		} else 
		{
			if (relVel != 0.) //in case that frictionProportionalZone=0, this could happen!
			{
				// this is to scale the friction force with the relative velocity
				// the friction force is decreased for high relative velocities
				fFriction = (-dryFriction * contactForce / relVel) * deltaVtangent; //this should be put into the nonlinear iteration for better Newton convergence ...
			}
			else { fFriction.SetAll(0.); }
		}
		fVec += fFriction;
	}
	return contactForce;
}

//compute the properties which are needed for computation of LHS and needed for OutputVariables
void CObjectContactSphereSphere::ComputeConnectorProperties(const MarkerDataStructure& markerData, Index itemIndex, const LinkedDataVector& data, 
	Real& frictionCoeff, Real& gap, Vector3D& deltaP, Vector3D& deltaV, 
	Vector3D& fVec, Vector3D& fFriction, Vector3D& n0, bool contactFromData) const
{
	deltaP = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
	Real dist = deltaP.GetL2Norm();
	gap = dist - (parameters.spheresRadii[0] + parameters.spheresRadii[1]); //gap = -penetration

	//unit direction and relative velocity of spring-damper
	n0 = deltaP;
	if (dist != 0.)
	{
		n0 *= (1. / dist);
	}
	Vector3D vSphereI = markerData.GetMarkerData(0).velocity;
	Vector3D vSphereJ = markerData.GetMarkerData(1).velocity;

	frictionCoeff = parameters.dynamicFriction; //this has to be computed depending on velocity, using Stribeck function ...

	if (!contactFromData)
	{
		//deltaV (only normal direction) is needed for PostNewtonStep in all cases
		deltaV = vSphereJ - vSphereI; //relative velocity in normal direction; to be consistent with jacobian
	}
	else
	{
		deltaV.SetAll(0.);
	}

	bool hasContact;
	if (contactFromData) { hasContact = (data[dataIndexGap] < 0);	}
	else { hasContact = (gap < 0); }

	if (hasContact)
	{
		if (frictionCoeff != 0.)
		{
			vSphereI += (markerData.GetMarkerData(0).orientation * markerData.GetMarkerData(0).angularVelocityLocal).CrossProduct((parameters.spheresRadii[0] + 0.5 * gap) * n0);
			vSphereJ += (markerData.GetMarkerData(1).orientation * markerData.GetMarkerData(1).angularVelocityLocal).CrossProduct((-parameters.spheresRadii[1] - 0.5 * gap) * n0); // use -n0; (-1) is put in the brackets here
		}
		deltaV = vSphereJ - vSphereI; //relative velocity in normal direction; to be consistent with jacobian
		Real deltaVnormal = n0 * deltaV; //relative velocity in normal direction; to be consistent with jacobian

		bool frictionRegularizedRegion = data[dataIndexVtangent]; //==> shall read out data variable

		//Real contactForce = 
		ComputeContactForces<Real>(gap, n0, deltaVnormal, deltaV,
			frictionCoeff, frictionRegularizedRegion, fVec, fFriction, contactFromData);
	}
	else //no contact
	{
		fVec.SetAll(0.);
		fFriction.SetAll(0.);
	}
	//in case that it is inactive, we only compute kinematical quantities, but no forces
	if (!parameters.activeConnector)
	{
		fVec *= 0;
		fFriction *= 0;
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectContactSphereSphere::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectContactSphereSphere::ComputeAlgebraicEquations: marker do not provide velocityLevel information");

	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real gap;

	ComputeConnectorProperties(markerData, objectNumber, data, 
		frictionCoeff, gap, deltaP, deltaV, fVec, fFriction, n0);

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	//pout << "test\n";
	if (parameters.activeConnector)
	{

		//marker 1 / J (positive):    (according to computation of relative position)
		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			//positionJacobian.NumberOfColumns() == rotationJacobian.NumberOfColumns()
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(), markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fVec, ldv1);
			if (frictionCoeff != 0)
			{
				Vector3D torque = ((-parameters.spheresRadii[1] - 0.5 * gap) * n0).CrossProduct(fVec);
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, torque, ldv1);
			}
		}


		////marker 0 / I (negative):
		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, -fVec, ldv0);
			if (frictionCoeff != 0)
			{
				Vector3D torque = ((-parameters.spheresRadii[0] - 0.5 * gap) * n0).CrossProduct(fVec);
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, torque, ldv0);
			}
		}
	}

}


//! provide according output variable in "value"
void CObjectContactSphereSphere::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real gap;

	ComputeConnectorProperties(markerData, itemIndex, data,
		frictionCoeff, gap, deltaP, deltaV, fVec, fFriction, n0);

	switch (variableType)
	{
	case OutputVariableType::Displacement: value.CopyFrom(deltaP); break;
	case OutputVariableType::DisplacementLocal: value.CopyFrom(Vector1D({gap})); break;
	case OutputVariableType::Velocity: value.CopyFrom(deltaV); break;
	case OutputVariableType::Director3: value.CopyFrom(n0); break;
	case OutputVariableType::Force: value.CopyFrom(fVec); break;
	case OutputVariableType::Torque: value.CopyFrom(((-parameters.spheresRadii[0] - 0.5 * gap) * n0).CrossProduct(fVec)); break;
	default:
		SysError("CObjectContactSphereSphere::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}
}


//! function called after Newton method; returns a residual error (force); 
//! done for two different computation states in order to estimate the correct time of contact
Real CObjectContactSphereSphere::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
	//return force-type error in case of contact: in case that the assumed contact state has been wrong, 
	//  the contact force (also negative) is returned as measure of the error
	Real discontinuousError = 0;
	flags = PostNewtonFlags::_None;


	LinkedDataVector dataStartofStepState = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep);	//state0
	LinkedDataVector data = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current);			//state1


	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real currentGap;

	ComputeConnectorProperties(markerDataCurrent, itemIndex, data, frictionCoeff, currentGap, deltaP, deltaV, fVec, fFriction, n0, false);

	Real vGap = n0 * deltaV; //required for Hunt-Crossley and similar models

	Real deltaPlastic = 0;
	if (currentGap < 0 && parameters.contactPlasticityRatio != 0.)
	{
		if (parameters.contactStiffnessExponent != 1.) { deltaPlastic = pow(parameters.contactPlasticityRatio, 1. / parameters.contactStiffnessExponent) * (-currentGap); }
		else { deltaPlastic = parameters.contactPlasticityRatio * (-currentGap); }

		deltaPlastic = EXUstd::Maximum(deltaPlastic, dataStartofStepState[dataIndexDeltaPlastic]); //here we need start of step, as we do not consider values of previous iterations!
	}

	Real lastGap = data[dataIndexGap];
	Real startofStepGap = dataStartofStepState[dataIndexGap];

	Real lastVtangent = data[dataIndexVtangent];

	data[dataIndexGap] = currentGap;
	data[dataIndexVtangent] = (deltaV - (vGap)*n0).GetL2Norm(); //tangent velocity norm
	data[dataIndexDeltaPlastic] = deltaPlastic; //plastic deformation

	////possible situations (state: C=contact, N=no contact); k=parameters.contactStiffness:
	////  assumption (because of convergence): gap0 and state0 are always consistent
	////state0	state1	gap1	action		error	
	////N			N		>0		no			0		
	////N			N		<=0		state1=C	|gap1*k|
	////N			C		>		state1=N	|gap1*k|
	////N			C		<=0		no			0
	////C			N		>0		no			0
	////C			N		<=0		state1=C	|gap1*k|
	////C			C		>		state1=N	|gap1*k|
	////C			C		<=		no			0

	//compute error for gap:
	if ((currentGap > 0 && lastGap <= 0) || (currentGap <= 0 && lastGap > 0)) //action: state1=currentGapState, error = |currentGap*k|
	{
		discontinuousError = fabs(currentGap * parameters.contactStiffness);

		//in fact it is (0-startofStepState) which is the part of time to go in these steps!
		//startofStepGap<=0 caused in case of inappropriate initialization => no step recommendation, but try to re-iterate
		if (vGap != 0 && startofStepGap > 0) { recommendedStepSize = fabs(startofStepGap / vGap); }

		//pout << "curGap=" << currentGap << ", sosGap=" << startofStepGap << ", discErr=" << discontinuousError << ", recStep=" << recommendedStepSize << ", vGap=" << vGap << "\n";
		flags = PostNewtonFlags::UpdateJacobian;
	}

	//compute error for friction:
	if (currentGap < 0 && parameters.frictionProportionalZone != 0.)
	{
		if ( (data[dataIndexVtangent] < parameters.frictionProportionalZone && lastVtangent > parameters.frictionProportionalZone) ||
			(data[dataIndexVtangent] > parameters.frictionProportionalZone && lastVtangent < parameters.frictionProportionalZone) )
		{
			//we have switching between stick and slip => so estimate some force error
			//we use the erroneous change in the tangent velocity and estimate the error in the friction force
			discontinuousError += fabs((parameters.dynamicFriction * (fVec * n0) / parameters.frictionProportionalZone) * (data[dataIndexVtangent] - parameters.frictionProportionalZone));

			//here we do not use a recommendedStepSize!
		}
	}

	//update impact velocity, if impact occured:
	if (startofStepGap > 0 && currentGap <= 0)
	{
		data[dataIndexImpactVel] = -vGap;
		//pout << "Impact vel=" << -vGap << "\n";
	}
	else //else set back to start-of-step, as we shall not change this value during discontinuous iterations!
	{
		data[dataIndexImpactVel] = dataStartofStepState[dataIndexImpactVel];
	}

	//pout << "PNS: currentGap=" << currentGap << ", previousState=" << previousState << ", currentState=" << currentState << ", error=" << discontinuousError << "\n";
	return discontinuousError;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CObjectContactSphereSphere::PostDiscontinuousIterationStep() 
{

}





