/** ***********************************************************************************************
* @brief        CObjectANCFThinPlate implementation; following SimpleThinPlate3D in HOTINT
*
* @author       Gerstmayr Johannes
* @date         2019-06-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

//#define USE_COBJECTANCFTHINPLATE
#ifdef USE_COBJECTANCFTHINPLATE

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectANCFThinPlate.h"

#include "Utilities/AutomaticDifferentiation.h"
//typedef EXUmath::AutoDiff<24, Real> DReal24;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//ANCFThinPlate BASE class
const Real size1 = 2; //? check if this is normalized?
const Real size2 = 2; //? check if this is normalized?

//! get compressed shape function vector, using unit coordinates xi and eta
void CObjectANCFThinPlate::ComputeShapeFunctions(Real xi, Real eta, Vector12D& sf)
{
	Real xieta = xi * eta;
	Real xi2 = xi * xi;
	Real xi3 = xi * xi;
	Real eta2 = eta * eta;
	Real eta3 = eta * eta2;

	sf.SetVector({ xieta * 0.5 - xi3 * eta * 0.125 - xi * eta3 * 0.125 + 0.25 + xi3 * 0.125 + eta2
			* eta * 0.125 - 0.375 * eta - 0.375 * xi,
		size1 * xi2 * eta 0.0625 + size1 * 0.0625 + size1 * xieta * 0.0625 - size1 * xi * 0.0625 - size1 * xi2 * 0.0625 - size1 *
			xi3 * eta * 0.0625 + size1 * xi3 * 0.0625 - size1 * eta * 0.0625,
		size2 * 0.0625 - size2 * xi * eta3 * 0.0625 - size2 * eta * 0.0625 - size2 * eta2 * 0.0625 + size2 * eta3 /
			16. - size2 * xi * 0.0625 + size2 * xieta * 0.0625 + size2 * xi * eta2 * 0.0625,
		-xieta * 0.5 + xi3 * eta * 0.125 + xi * eta3 * 0.125 + 0.25 - xi3 * 0.125 + eta *
			eta2 * 0.125 - 0.375 * eta + 0.375 * xi,
		-size1 * 0.0625 - size1 * xi * 0.0625 + size1 * xi2 * 0.0625 + size1 * xi3 * 0.0625 + size1 * eta * 0.0625 + size1 * xi *
			eta * 0.0625 - size1 * xi2 * eta * 0.0625 - size1 * xi3 * eta * 0.0625,
		size2 * 0.0625 - size2 * eta * 0.0625 + size2 * xi * 0.0625 - size2 * xieta * 0.0625 - size2 * eta2 * 0.0625 - size2 * xieta *
			eta * 0.0625 + size2 * eta3 * 0.0625 + size2 * xi * eta3 * 0.0625,
		xieta * 0.5 - xi3 * eta * 0.125 - xi * eta3 * 0.125 + 0.25 - xi3 * 0.125 - eta2
			* eta * 0.125 + 0.375 * eta + 0.375 * xi,
		-size1 * 0.0625 - size1 * eta * 0.0625 - size1 * xi * 0.0625 - size1 * xieta * 0.0625 + size1 * xi2 * 0.0625 + size1 * xi2 *
			eta * 0.0625 + size1 * xi3 * 0.0625 + size1 * xi3 * eta * 0.0625,
		-size2 * 0.0625 - size2 * eta * 0.0625 + size2 * eta2 * 0.0625 - size2 * xi * 0.0625 - size2 * xieta * 0.0625 + size2 * xieta *
			eta * 0.0625 + size2 * eta3 * 0.0625 + size2 * xi * eta3 * 0.0625,
		-xieta * 0.5 + xi3 * eta * 0.125 + xi * eta3 * 0.125 + 0.25 + xi3 * 0.125 - eta *
			eta2 * 0.125 + 0.375 * eta - 0.375 * xi,
		size1 * 0.0625 + size1 * eta * 0.0625 - size1 * xi * 0.0625 - size1 * xieta * 0.0625 - size1 * xi2 * 0.0625 - size1 * xi2 *
			eta * 0.0625 + size1 * xi3 * 0.0625 + size1 * xi3 * eta * 0.0625,
		-size2 * 0.0625 - size2 * eta * 0.0625 + size2 * eta2 * 0.0625 + size2 * eta3 * 0.0625 + size2 * xi * 0.0625 + size2 * xi *
			eta * 0.0625 - size2 * xi * eta2 * 0.0625 - size2 * xi * eta3 * 0.0625 } );
}

//! get derivative of compressed shape function vector for slopes
void CObjectANCFThinPlate::ComputeShapeFunctions_xy(Real xi, Real eta, Vector12D& sf_x, Vector12D& sf_y)
{
	Real xieta = xi * eta;
	Real xi2 = xi * xi;
	Real xi3 = xi * xi;
	Real eta2 = eta * eta;
	Real eta3 = eta * eta2;

	sf_x.SetVector({
			eta / 2.0 - 0.375 * xi2 * eta - eta3 * 0.125 + 0.375 * xi2 - 0.375,
			size1 * xi * eta * 0.125 + size1 * eta * 0.0625 - size1 * 0.0625 - size1 * xi * 0.125 - 3.0 * 0.0625 * size1 * xi2 * eta + 3.0 * 0.0625 * size1 * xi2,
			-size2 * eta3 * 0.0625 - size2 * 0.0625 + size2 * eta * 0.0625 + size2 * eta2 * 0.0625,
			-eta / 2.0 + 0.375 * xi2 * eta + eta3 * 0.125 - 0.375 * xi2 + 0.375,
			-size1 * 0.0625 + size1 * xi * 0.125 + 3.0 * 0.0625 * size1 * xi2 + size1 * eta * 0.0625 - size1 * xi * eta * 0.125 - 3.0 * 0.0625 * size1 * xi2 * eta,
			size2 * 0.0625 - size2 * eta * 0.0625 - size2 * eta2 * 0.0625 + size2 * eta3 * 0.0625,
			eta / 2.0 - 0.375 * xi2 * eta - eta3 * 0.125 - 0.375 * xi2 + 0.375,
			-size1 * 0.0625 - size1 * eta * 0.0625 + size1 * xi * 0.125 + size1 * xi * eta * 0.125 + 3.0 * 0.0625 * size1 * xi2 + 3.0 * 0.0625 * size1 * xi2 * eta,
			-size2 * 0.0625 - size2 * eta * 0.0625 + size2 * eta2 * 0.0625 + size2 * eta3 * 0.0625,
			-eta / 2.0 + 0.375 * xi2 * eta + eta3 * 0.125 + 0.375 * xi2 - 0.375,
			-size1 * 0.0625 - size1 * eta * 0.0625 - size1 * xi * 0.125 - size1 * xi * eta * 0.125 + 3.0 * 0.0625 * size1 * xi2 + 3.0 * 0.0625 * size1 * xi2 * eta,
			size2 * 0.0625 + size2 * eta * 0.0625 - size2 * eta2 * 0.0625 - size2 * eta3 * 0.0625,
		}),

	sf_y.SetVector({
			xi / 2.0 - xi3 * 0.125 - 0.375 * xi * eta2 + 0.375 * eta2 - 0.375,
			size1 * xi2 * 0.0625 + size1 * xi * 0.0625 - size1 * xi3 * 0.0625 - size1 * 0.0625,
			-3.0 * 0.0625 * size2 * xi * eta2 - size2 * 0.0625 - size2 * eta * 0.125 + 3.0 * 0.0625 * size2 * eta2 + size2 * xi * 0.0625 + size2 * xi * eta * 0.125,
			-xi / 2.0 + xi3 * 0.125 + 0.375 * xi * eta2 + 0.375 * eta2 - 0.375,
			size1 * 0.0625 + size1 * xi * 0.0625 - size1 * xi2 * 0.0625 - size1 * xi3 * 0.0625,
			-size2 * 0.0625 - size2 * xi * 0.0625 - size2 * eta * 0.125 - size2 * xi * eta * 0.125 + 3.0 * 0.0625 * size2 * eta2 + 3.0 * 0.0625 * size2 * xi * eta2,
			xi / 2.0 - xi3 * 0.125 - 0.375 * xi * eta2 - 0.375 * eta2 + 0.375,
			-size1 * 0.0625 - size1 * xi * 0.0625 + size1 * xi2 * 0.0625 + size1 * xi3 * 0.0625,
			-size2 * 0.0625 + size2 * eta * 0.125 - size2 * xi * 0.0625 + size2 * xi * eta * 0.125 + 3.0 * 0.0625 * size2 * eta2 + 3.0 * 0.0625 * size2 * xi * eta2,
			-xi / 2.0 + xi3 * 0.125 + 0.375 * xi * eta2 - 0.375 * eta2 + 0.375,
			size1 * 0.0625 - size1 * xi * 0.0625 - size1 * xi2 * 0.0625 + size1 * xi3 * 0.0625,
			-size2 * 0.0625 + size2 * eta * 0.125 + 3.0 * 0.0625 * size2 * eta2 + size2 * xi * 0.0625 - size2 * xi * eta * 0.125 - 3.0 * 0.0625 * size2 * xi * eta2,
		});
}

//! get second derivative of compressed shape function vector for slopes
void CObjectANCFThinPlate::ComputeShapeFunctions_xxyy(Real xi, Real eta, 
	Vector12D& sf_xx, Vector12D& sf_yy, Vector12D& sf_xy)
{
	Real xieta = xi * eta;
	Real xi2 = xi * xi;
	Real xi3 = xi * xi;
	Real eta2 = eta * eta;
	Real eta3 = eta * eta2;

	sf_xx.SetVector({
		 -0.75 * xi * eta + 0.75 * xi,
		 -0.375 * size1 * xi * eta + size1 * eta / 8.0 + 0.375 * size1 * xi - size1 / 8.0,
		 0.0,
		 0.75 * xi * eta - 0.75 * xi,
		 size1 / 8.0 + 0.375 * size1 * xi - size1 * eta / 8.0 - 0.375 * size1 * xi * eta,
		 0.0,
		 -0.75 * xi * eta - 0.75 * xi,
		 size1 / 8.0 + size1 * eta / 8.0 + 0.375 * size1 * xi + 0.375 * size1 * xi * eta,
		 0.0,
		 0.75 * xi * eta + 0.75 * xi,
		 -size1 / 8.0 - size1 * eta / 8.0 + 0.375 * size1 * xi + 0.375 * size1 * xi * eta,
		 0.0,
		});
	sf_yy.SetVector({
		0.5 - 0.375 * xi * xi - 0.375 * eta * eta,
		-0.1875 * size1 * xi * xi + size1 * xi / 8.0 + size1 / 16.0,
		size2 / 16.0 - 0.1875 * size2 * eta * eta + size2 * eta / 8.0,
		-0.5 + 0.375 * xi * xi + 0.375 * eta * eta,
		size1 / 16.0 - size1 * xi / 8.0 - 0.1875 * size1 * xi * xi,
		-size2 / 16.0 - size2 * eta / 8.0 + 0.1875 * size2 * eta * eta,
		0.5 - 0.375 * xi * xi - 0.375 * eta * eta,
		-size1 / 16.0 + size1 * xi / 8.0 + 0.1875 * size1 * xi * xi,
		-size2 / 16.0 + size2 * eta / 8.0 + 0.1875 * size2 * eta * eta,
		-0.5 + 0.375 * xi * xi + 0.375 * eta * eta,
		-size1 / 16.0 - size1 * xi / 8.0 + 0.1875 * size1 * xi * xi,
		size2 / 16.0 - size2 * eta / 8.0 - 0.1875 * size2 * eta * eta,
		});
	sf_xy.SetVector({
		-0.75 * xi * eta + 0.75 * eta,
		0.0,
		-0.375 * size2 * xi * eta + size2 * xi / 8.0 - size2 / 8.0 + 0.375 * size2 * eta,
		0.75 * xi * eta + 0.75 * eta,
		0.0,
		-size2 / 8.0 - size2 * xi / 8.0 + 0.375 * size2 * eta + 0.375 * size2 * xi * eta,
		-0.75 * xi * eta - 0.75 * eta,
		0.0,
		size2 / 8.0 + size2 * xi / 8.0 + 0.375 * size2 * eta + 0.375 * size2 * xi * eta,
		0.75 * xi * eta - 0.75 * eta,
		0.0,
		size2 / 8.0 + 0.375 * size2 * eta - size2 * xi / 8.0 - 0.375 * size2 * xi * eta,
		});

}


//! map element coordinates (position or veloctiy level) given by nodal vectors q0 ... q3 onto compressed shape function vector to compute position, etc.
Vector3D CObjectANCFThinPlate::MapCoordinates(const Vector12D& SV, 
	const LinkedDataVector& q0, const LinkedDataVector& q1, const LinkedDataVector& q2, const LinkedDataVector& q3)
{
	const Index dim = 3;		//3D finite element
	const Index nnv = 3; //number of vectors per node
	Vector3D v(0.);
	for (Index i = 0; i < dim; i++)
	{
		for (Index j = 0; j < nnv; j++)
		{
			v[i] += SV[j] * q0[i + j * dim];
			v[i] += SV[j + 1 * nnv] * q1[i + j * dim];
			v[i] += SV[j + 2 * nnv] * q2[i + j * dim];
			v[i] += SV[j + 3 * nnv] * q3[i + j * dim];

		}
	}
	return v;
}

//! locally defined template: map element coordinates (position or veloctiy level) given by nodal vectors q0 and q1 onto compressed shape function vector to compute position, etc.
template<class TReal, Index ancfSize>
SlimVectorBase<TReal, 3> MapCoordinatesElement(const Vector12D& SV, const ConstSizeVectorBase<TReal, ancfSize>& qANCF)
{
	const Index dim = 3;		//3D finite element
	SlimVectorBase<TReal, dim> v;
	v[0] = 0;
	v[1] = 0;
	v[2] = 0;
	for (Index i = 0; i < SV.NumberOfItems(); i++)
	{
		v[0] += SV[i] * qANCF[dim * i];
		v[1] += SV[i] * qANCF[dim * i + 1];
		v[2] += SV[i] * qANCF[dim * i + 2];
	}
	return v;
}

void CObjectANCFThinPlate::ComputeCurrentObjectCoordinates(ConstSizeVector<nODE2coordinates>& qANCF) const
{
	const Index dim = 3;		//3D finite element
	LinkedDataVector qNode[nNodes];		//link node values to element vector

	for (Index i = 0; i < nNodes; i++)
	{
		qNode[i].LinkDataTo(qANCF, nnc*i, nnc);
		qNode[i] = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector(); //displacement coordinates node 0
		qNode[i] += ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	}
}

void CObjectANCFThinPlate::ComputeCurrentObjectVelocities(ConstSizeVector<nODE2coordinates>& qANCF_t) const
{
	const Index dim = 3;		//3D finite element
	LinkedDataVector qNode[nNodes];		//link node values to element vector

	for (Index i = 0; i < nNodes; i++)
	{
		qNode[i].LinkDataTo(qANCF_t, nnc * i, nnc);
		qNode[i] = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(); //velocity coordinates node 0
	}
}

//! Computational function: compute mass matrix
void CObjectANCFThinPlate::PreComputeMassTerms() const
{
	if (!massMatrixComputed)
	{
		precomputedMassMatrix.SetScalarMatrix(nODE2coordinates, 0.); //set 8x8 matrix
		Real L = parameters.physicsLength;
		Real rhoA = parameters.physicsMassPerLength;
		const Index dim = 3;		//3D finite element
		const Index ns = 4;			//number of shape functions

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;
		for (auto item : EXUmath::gaussRuleOrder7Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			Vector4D SV = ComputeShapeFunctions(x, L);
			Vector4D SVint = SV;
			SVint *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder7Weights[cnt++]);

			for (Index i = 0; i < ns; i++)
			{
				for (Index j = 0; j < ns; j++)
				{
					precomputedMassMatrix(i * dim,     j * dim) += SV[i] * SVint[j];
					precomputedMassMatrix(i * dim + 1, j * dim + 1) += SV[i] * SVint[j];
					precomputedMassMatrix(i * dim + 2, j * dim + 2) += SV[i] * SVint[j];
				}
			}
		}
		massMatrixComputed = true;
	}
}

//! Computational function: compute mass matrix
void CObjectANCFThinPlate::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber, bool computeInverse) const
{
	CHECKandTHROW(!computeInverse, "CObjectANCFThinPlate::ComputeMassMatrix: computeMassMatrixInversePerBody=True is not possible for this type of element; change solver settings");

	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	PreComputeMassTerms();
	massMatrix.CopyFrom(precomputedMassMatrix); //copy
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectANCFThinPlate::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	//pout << "GetNumberOfNodes() =" << GetNumberOfNodes() << "\n";

	ConstSizeVector<dim * ns> qANCF;
	ConstSizeVector<dim * ns> qANCF_t;
	ComputeCurrentObjectCoordinates(qANCF);
	ComputeCurrentObjectVelocities(qANCF_t);
	ComputeODE2LHStemplate<Real>(ode2Lhs, qANCF, qANCF_t);
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
template<class TReal, Index ancfSize>
void CObjectANCFThinPlate::ComputeODE2LHStemplate(VectorBase<TReal>& ode2Lhs, 
	const ConstSizeVectorBase<TReal, ancfSize>& qANCF, const ConstSizeVectorBase<TReal, ancfSize>& qANCF_t) const
{
	ode2Lhs.SetNumberOfItems(ancfSize); //works both for ANCF and ALE-ANCF
	ode2Lhs.SetAll(0.);

	//compute work of elastic forces:
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	const Index nnc = dim * 2;  //number of node coordinates

	Real L = parameters.physicsLength;
	Real EA = parameters.physicsAxialStiffness;
	Real EI = parameters.physicsBendingStiffness;
	Real axialStrain0 = parameters.physicsReferenceAxialStrain;
	Real bendingDamping = parameters.physicsBendingDamping;
	Real axialDamping = parameters.physicsAxialDamping;

	Index cnt;
	Real a = 0; //integration interval [a,b]
	Real b = L;

	ConstSizeVector<2 * nnc> qANCFref;
	if (parameters.strainIsRelativeToReference != 0.)
	{
		LinkedDataVector qNode0ref(qANCFref, 0, nnc);		//link node values to element vector
		LinkedDataVector qNode1ref(qANCFref, nnc, nnc);		//link node values to element vector
		qNode0ref = ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector();
		qNode1ref = ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
	}

	ConstSizeVectorBase<TReal, ancfSize> elasticForces;

	//numerical integration:
	//accurate integration: axialStrain = order9, curvature = order5
	//reduced order 1: axialStrain = order7, curvature = order3 (lower Gauss order not possible, becomes unstable or very inaccurate ...
	//reduced order 2: axialStrain = order4, curvature = order3 (less oscillations in axial strains, if evaluated at [0,0.5L,L]
	//reduced order 3: axialStrain = order6, curvature = order5 
	//reduced order 4: axialStrain = order5, curvature = order6 

	const Index maxIntegrationPoints = 5;
	ConstSizeVector<maxIntegrationPoints> integrationPoints;
	ConstSizeVector<maxIntegrationPoints> integrationWeights;

	if (parameters.useReducedOrderIntegration == 0) //A9-B5 (max. integration axial order 9, bending order 5)
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder9Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder9Weights);
	}
	else if (parameters.useReducedOrderIntegration == 1) //A7-B3
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder7Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder7Weights);
	}
	else if (parameters.useReducedOrderIntegration == 2) //A4-B3 ; gives excellent axial strain at 0, L/2 and L !!
	{
		integrationPoints.CopyFrom(EXUmath::lobattoRuleOrder3Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::lobattoRuleOrder3Weights);
	}
	else { CHECKandTHROWstring("ObjectANCFThinPlate::ComputeODE2LHS: useReducedOrderIntegration must be between 0 and 2"); }

	//axial strain:
	cnt = 0;
	for (auto item : integrationPoints)
	{
		Real x = 0.5*(b - a)*item + 0.5*(b + a);
		Vector4D SVx = ComputeShapeFunctions_x(x, L);
		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);

		SlimVectorBase<TReal, dim> rx = MapCoordinatesElement<TReal, dim * ns>(SVx, qANCF);

		TReal rxNorm2 = rx.GetL2NormSquared();
		TReal rxNorm = sqrt(rxNorm2);

		TReal axialStrain = rxNorm - 1.; // axial strain
		TReal axialStrain_t = 0.; //rate of axial strain

		Real axialStrainRef = axialStrain0;
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = MapCoordinatesElement<Real, dim * ns>(SVx, qANCFref);
			axialStrainRef += parameters.strainIsRelativeToReference * (rxRef.GetL2Norm() - 1.);
		}

		if (axialDamping != 0.)
		{
			SlimVectorBase<TReal, dim> rx_t = MapCoordinatesElement<TReal, dim* ns>(SVx, qANCF_t);
			axialStrain_t = (rx * rx_t) / rxNorm; //rate of axial strain
		}

		//term due to variation of axialStrain
		for (Index i = 0; i < dim; i++)
		{
			for (Index j = 0; j < ns; j++)
			{
				elasticForces[j*dim + i] = 1. / rxNorm * SVx[j] * rx[i];
			}
		}

		//elasticForces *= integrationFactor * GetParameters().physicsAxialStiffness * (axialStrain - GetParameters().physicsReferenceAxialStrain);
		elasticForces *= integrationFactor * (EA * (axialStrain - axialStrainRef) + axialDamping * axialStrain_t);

		ode2Lhs += elasticForces;  //add to element elastic forces
	}

	//++++++++++++++++++++++++++++++
	//curvature:

	if (parameters.useReducedOrderIntegration == 0) //A9-B5 (max. integration axial order 9, bending order 5)
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder5Points); //copy is slower, but cannot link to variable size ==> LinkedDataVector ...
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder5Weights);
	}
	else if (parameters.useReducedOrderIntegration == 1) //A7-B3
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points); 
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
	}
	else if (parameters.useReducedOrderIntegration == 2) //A4-B3 ; gives excellent axial strain at 0, L/2 and L !!
	{
		integrationPoints.CopyFrom(EXUmath::gaussRuleOrder3Points); 
		integrationWeights.CopyFrom(EXUmath::gaussRuleOrder3Weights);
	}
	else { CHECKandTHROWstring("ObjectANCFThinPlate::ComputeODE2LHS: useReducedOrderIntegration must be between 0 and 2"); }

	cnt = 0;
	for (auto item : integrationPoints)
	{
		Real x = 0.5*(b - a)*item + 0.5*(b + a);
		Vector4D SVx = ComputeShapeFunctions_x(x, L);
		Vector4D SVxx = ComputeShapeFunctions_xx(x, L);
		Real integrationFactor = (0.5*(b - a)*integrationWeights[cnt++]);

		//Vector3D rx = MapCoordinates(SVx, q0, q1);
		//Vector3D rxx = MapCoordinates(SVxx, q0, q1);
		SlimVectorBase<TReal, dim> rx = MapCoordinatesElement<TReal, dim* ns>(SVx, qANCF);
		SlimVectorBase<TReal, dim> rxx = MapCoordinatesElement<TReal, dim* ns>(SVxx, qANCF);

		TReal rxNorm2 = rx.GetL2NormSquared();				//g
		//TReal rxNorm = sqrt(rxNorm2);				
		SlimVectorBase<TReal, dim> rxCrossRxx = rx.CrossProduct(rxx);			//f
		SlimVectorBase<TReal, dim> curvature = rxCrossRxx * (1. / rxNorm2);				//kappa = (rx x rxx)/rx^2       //material measure of curvature

		Vector3D curvatureRef(0.);
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = MapCoordinatesElement<Real, dim * ns>(SVx, qANCFref);
			Vector3D rxxRef = MapCoordinatesElement<Real, dim * ns>(SVxx, qANCFref);

			Real rxNorm2ref = rxRef.GetL2NormSquared();
			Vector3D rxCrossRxxRef = rxRef.CrossProduct(rxxRef);
			curvatureRef += parameters.strainIsRelativeToReference*(rxCrossRxxRef * (1. / rxNorm2ref) );
		}

		TReal inv2RxNorm2 = 1. / (rxNorm2*rxNorm2);			//g2inv
		SlimVectorBase<TReal, dim> tempF = 2. * rxCrossRxx*inv2RxNorm2;			//fn; f ... fraction numerator
		TReal tempG = rxNorm2 * inv2RxNorm2;				//gn; g ... fraction denominator
		SlimVectorBase<TReal, dim> df;

		SlimVectorBase<TReal, dim> curvature_t(0.); //rate of curvature
		if (bendingDamping != 0.)
		{
			//Vector3D rx_t = MapCoordinates(SVx, q0_t, q1_t);
			//Vector3D rxx_t = MapCoordinates(SVxx, q0_t, q1_t);
			SlimVectorBase<TReal, dim> rx_t = MapCoordinatesElement<TReal, dim* ns>(SVx, qANCF_t);
			SlimVectorBase<TReal, dim> rxx_t = MapCoordinatesElement<TReal, dim* ns>(SVxx, qANCF_t);

			SlimVectorBase<TReal, dim> rxCrossRxx_t = rx_t.CrossProduct(rxx) + rx.CrossProduct(rxx_t);	//f_t
			TReal rxNorm2_t = 2.*(rx*rx_t);												//g_t

			curvature_t = (rxCrossRxx_t * rxNorm2 - rxCrossRxx * rxNorm2_t) * (1. / EXUstd::Square(rxNorm2) ); //rate of bending strain; (f_t*g - f*g_t)/g^2
		}

		//precompute 3D torque times integration factor
		curvature[0] -= curvatureRef[0]; //needs to be done component-wise as it is Real and TReal
		curvature[1] -= curvatureRef[1];
		curvature[2] -= curvatureRef[2];
		SlimVectorBase<TReal, dim> curvatureFactor = integrationFactor * (EI * (curvature) + bendingDamping * curvature_t);

		for (Index i = 0; i < dim; i++)
		{
			for (Index j = 0; j < ns; j++)
			{
				switch (i) {
				case 0:
				{
					df[0] = 0.;
					df[1] = -SVx[j] * rxx.Z() + SVxx[j] * rx.Z();
					df[2] = SVx[j] * rxx.Y() - SVxx[j] * rx.Y();
					break;
				}
				case 1:
				{
					df[0] = SVx[j] * rxx.Z() - SVxx[j] * rx.Z();
					df[1] = 0;
					df[2] = -SVx[j] * rxx.X() + SVxx[j] * rx.X(); 
					break;
				}
				case 2:
				{
					df[0] = -SVx[j] * rxx.Y() + SVxx[j] * rx.Y();
					df[1] = +SVx[j] * rxx.X() - SVxx[j] * rx.X();
					df[2] = 0; 
					break;
				}
				default:;
				}
				TReal dg = rx[i] * SVx[j]; //derivative of denominator
				elasticForces[j*dim + i] = (df * tempG - tempF * dg) * curvatureFactor;
			}
		}

		ode2Lhs += elasticForces;  //add to element elastic forces
	}

}

//! jacobian of LHS, w.r.t. position AND velocity level coordinates
//void CObjectANCFThinPlate::ComputeJacobianODE2_ODE2(ResizableMatrix& jacobian, ResizableMatrix& jacobian_ODE2_t) const
void CObjectANCFThinPlate::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp, 
	Real factorODE2, Real factorODE2_t,
	Index objectNumber, const ArrayIndex& ltg) const
{
	const Index dim = 3;		//3D finite element
	const Index ns = 4;			//number of shape functions
	//const Index nnc = dim * 2;  //number of node coordinates

	ConstSizeVector<dim * ns> qANCF0;
	ConstSizeVector<dim * ns> qANCF0_t;
	ConstSizeVectorBase<DReal24, dim * ns> qANCF;
	ConstSizeVectorBase<DReal24, dim * ns> qANCF_t;
	ComputeCurrentObjectCoordinates(qANCF0);
	ComputeCurrentObjectVelocities(qANCF0_t);
	for (Index i = 0; i < dim * ns; i++)
	{
		qANCF[i] = qANCF0[i];
		qANCF_t[i] = qANCF0_t[i];
		qANCF[i].DValue((int)i) = 1; //mark that this is the corresponding derivative
		qANCF_t[i].DValue((int)(i + dim * ns)) = 1; //mark that this is the corresponding derivative; velocity derivatives are in second block
	}
	ConstSizeVectorBase<DReal24, dim * ns> ode2Lhs;
	LinkedDataVectorBase<DReal24> linkedOde2Lhs(ode2Lhs); //added because of decoupling of ConstSizeVectorBase

	ComputeODE2LHStemplate<DReal24>(linkedOde2Lhs, qANCF, qANCF_t);

	jacobianODE2.SetUseDenseMatrix(true);
	ResizableMatrix& jac = jacobianODE2.GetInternalDenseMatrix();
	jac.SetNumberOfRowsAndColumns(dim * ns, dim * ns);

	//now copy autodifferentiated result:
	for (Index i = 0; i < dim * ns; i++)
	{
		for (Index j = 0; j < dim * ns; j++)
		{
			jac(i, j) = factorODE2*ode2Lhs[i].DValue((int)j) + factorODE2_t*ode2Lhs[i].DValue((int)(j + dim * ns));
		}
	}
}


//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectANCFThinPlate::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt +
		//TODO: (Index)AccessFunctionType::JacobianTtimesVector_q +
		(Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectANCFThinPlate::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	Real L = GetLength();

	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		const Index dim = 3;		//3D finite element
		const Index ns = 4;			//number of shape functions

		Real x = localPosition[0]; //only x-coordinate
		Vector4D SV = ComputeShapeFunctions(x, L);
		value.SetNumberOfRowsAndColumns(dim, dim * ns); //3D velocity, 12 coordinates qt
		//pout << "inside ..." << localPosition << "\n";

		CHECKandTHROW(localPosition[1] == 0 && localPosition[2] == 0,
			"CObjectANCFThinPlate: markers, forces and constraints can only act at the beam centerline at Y=Z=0; check your code");

		value.SetAll(0.);
		value(0, 0) = SV[0];
		value(1, 1) = SV[0];
		value(2, 2) = SV[0];
		value(0, 3) = SV[1];
		value(1, 4) = SV[1];
		value(2, 5) = SV[1];
		value(0, 6) = SV[2];
		value(1, 7) = SV[2];
		value(2, 8) = SV[2];
		value(0, 9) = SV[3];
		value(1,10) = SV[3];
		value(2,11) = SV[3];

		break;
	}
	//thin ancf 3D cable: torque cannot be applied in such a way: 
	//case AccessFunctionType::AngularVelocity_qt: 
	//{
	//	//const Index dim = 3;		//3D finite element
	//	const Index ns = 4;			//number of shape functions
	//	//const Index nnc = dim * 2;  //number of node coordinates

	//	Real xLoc = localPosition[0]; //only x-coordinate
	//	Vector3D slope = ComputeSlopeVector(xLoc, ConfigurationType::Current);
	//	Real x = slope[0]; //x-slopex
	//	Real y = slope[1]; //y-slopex

	//	Vector4D SVx = ComputeShapeFunctions_x(xLoc, L);
	//	Real fact0 = -y / (x*x + y * y);
	//	Real fact1 = x / (x*x + y * y);

	//	value.SetNumberOfRowsAndColumns(3, 8);
	//	value.SetAll(0.); //last row not necessary to set to zero ... 
	//	for (Index i = 0; i < ns; i++)
	//	{
	//		value(2, i*2) = SVx[i] * fact0; //last row of jacobian
	//		value(2, i * 2 + 1) = SVx[i] * fact1;
	//		value(2, i * 2 + 1) = SVx[i] * fact1;
	//	}

	//	break;
	//}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		const Index dim = 3;		//3D finite element
		const Index ns = 4;			//number of shape functions

		value.SetNumberOfRowsAndColumns(dim, dim * ns); //3D velocity, 12 coordinates qt
		value.SetAll(0.);

		Real L = parameters.physicsLength;
		Real rhoA = parameters.physicsMassPerLength;

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;

		Vector4D SV({0.,0.,0.,0.});

		for (auto item : EXUmath::gaussRuleOrder3Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			Vector4D SVloc = ComputeShapeFunctions(x, L);
			SVloc *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder3Weights[cnt++]);
			SV += SVloc;
		}

		value(0, 0) = SV[0];
		value(1, 1) = SV[0];
		value(2, 2) = SV[0];
		value(0, 3) = SV[1];
		value(1, 4) = SV[1];
		value(2, 5) = SV[1];
		value(0, 6) = SV[2];
		value(1, 7) = SV[2];
		value(2, 8) = SV[2];
		value(0, 9) = SV[3];
		value(1,10) = SV[3];
		value(2,11) = SV[3];
		break;
	}
	default:
		SysError("CObjectANCFThinPlate:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectANCFThinPlate::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	//outputVariables = "{
	//'Position':'global position vector of local axis (1) and cross section (2) position', 
	//'Velocity':'global velocity vector of local axis (1) and cross section (2) position', 
	//'Director1':'(axial) slope vector of local axis position', 
	//'Strain':'axial strain (scalar)', 
	//'Curvature':'axial strain (scalar)', 
	//'Force':'(local) section normal force (scalar)', 
	//'Torque':'(local) bending moment (scalar)'}"
	Real x = localPosition[0];

	switch (variableType)
	{
	case OutputVariableType::Position:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration)); break;
	}
	case OutputVariableType::Displacement:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	}
	case OutputVariableType::Velocity:
	{
		value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::Acceleration:
	{
		//only for ANCFThinPlate, but not ALEANCF ==> not included in GetOutputVariableTypes(...)
		value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	}
	//case OutputVariableType::AngularVelocity:
	//{
	//	//independent of y, but correct
	//	value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	//}
	case OutputVariableType::Director1: {
		//CHECKandTHROW(y == 0., "CObjectANCFThinPlate::GetOutputVariableBody: Y-component of localPosition must be zero for Director1");
		Vector3D rx = ComputeSlopeVector(localPosition[0], configuration);
		value.SetVector({rx[0], rx[1] , rx[2]});
		break; }
	case OutputVariableType::StrainLocal:	
	{
		//CHECKandTHROW(y == 0., "CObjectANCFThinPlate::GetOutputVariableBody: Y-component of localPosition must be zero for StrainLocal");
		Real strain = ComputeAxialStrain(x, configuration);

		value.SetVector({ strain }); 
		break;
	}
	case OutputVariableType::CurvatureLocal:	
	{
		//CHECKandTHROW(y == 0., "CObjectANCFThinPlate::GetOutputVariableBody: Y-component of localPosition must be zero for CurvatureLocal");
		value.CopyFrom( ComputeCurvature(x, configuration) );
		break;
	}
	case OutputVariableType::ForceLocal: {
		//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFThinPlate::GetOutputVariableBody: Y-component of localPosition must be zero for ForceLocal");

		Real axialStrainRef = parameters.physicsReferenceAxialStrain;
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
			axialStrainRef += parameters.strainIsRelativeToReference*(rxRef.GetL2Norm() - 1.);
		}

		Real force = parameters.physicsAxialStiffness * (ComputeAxialStrain(x, configuration) - axialStrainRef);
		if (parameters.physicsAxialDamping != 0) { force += parameters.physicsAxialDamping * ComputeAxialStrain_t(x, configuration); }

		value.SetVector({ force }); break;
	}
	case OutputVariableType::TorqueLocal: {
		//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFThinPlate::GetOutputVariableBody: Y-component of localPosition must be zero for TorqueLocal");

		Vector3D curvatureRef(0.);
		if (parameters.strainIsRelativeToReference != 0.)
		{
			Vector3D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
			Vector3D rxxRef = ComputeSlopeVector_x(x, ConfigurationType::Reference);

			Real rxNorm2ref = rxRef.GetL2NormSquared();
			Vector3D rxCrossRxxRef = rxRef.CrossProduct(rxxRef);
			curvatureRef += parameters.strainIsRelativeToReference*(rxCrossRxxRef * (1. / rxNorm2ref) );
		}

		Vector3D torque = parameters.physicsBendingStiffness * (ComputeCurvature(x, configuration) - curvatureRef);
		if (parameters.physicsBendingDamping != 0) 
		{ 
			torque += parameters.physicsBendingDamping * ComputeCurvature_t(x, configuration); 
		}
		value.CopyFrom(torque); 
		break;
	}
	default:
		SysError("CObjectANCFThinPlate::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFThinPlate::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0]; //only x-coordinate
	Vector4D SV = ComputeShapeFunctions(x, GetLength());
	
	Vector3D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference)
	{
		v += MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return v;
}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectANCFThinPlate::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0]; 
	Vector4D SV = ComputeShapeFunctions(x, GetLength());

	Vector3D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));

	return v;
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectANCFThinPlate::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real x = localPosition[0];
	Vector4D SV = ComputeShapeFunctions(x, GetLength());

	//Vector3D v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	Vector3D a = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_tt(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_tt(configuration));

	return a;
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFThinPlate::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	if (localPosition[1] != 0.)
	{
		Real x = localPosition[0]; //only x-coordinate
		Vector4D SV = ComputeShapeFunctions(x, GetLength());

		Vector3D v(0.);
		if (configuration != ConfigurationType::Reference)
		{
			v = MapCoordinates(SV, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
		}
		return v;
	}
	else
	{
		//slower, but includes off-axis part
		return GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference);
	}
}

//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CObjectANCFThinPlate::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectANCFThinPlate::GetAngularVelocity: not implemented!!!");
	//for details see GetAngularVelocity in Point2DSlope1

	Real xLoc = localPosition[0]; //only x-coordinate
	Vector3D slope = ComputeSlopeVector(xLoc, configuration);
	Real x = slope[0]; //x-slopex
	Real y = slope[1]; //y-slopex
	//REQUIRES SOME 3D FORMULA!!!!!!!!!!!!!!!!!!

	Vector4D SVx = ComputeShapeFunctions_x(xLoc, GetLength());
	Vector3D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	//Vector3D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(), ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t());

	//compare this function to GetRotationMatrix(...)
	return Vector3D({ 0., 0., (-y * slope_t[0] + x * slope_t[1]) / (x*x + y * y) }); //!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

Vector3D CObjectANCFThinPlate::ComputeSlopeVector(Real x, ConfigurationType configuration) const
{
	Vector4D SVx = ComputeShapeFunctions_x(x, GetLength());

	Vector3D slope = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
	{
		slope += MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return slope;

}

Vector3D CObjectANCFThinPlate::ComputeSlopeVector_x(Real x, ConfigurationType configuration) const
{
	Vector4D SVxx = ComputeShapeFunctions_xx(x, GetLength());

	Vector3D slope_x = MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
	{
		slope_x += MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
	}

	return slope_x;

}

//!  compute the axial strain at a certain axial position, for given configuration
Real CObjectANCFThinPlate::ComputeAxialStrain(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared();
	Real rxNorm = sqrt(rxNorm2);
	return rxNorm - 1.; // axial strain
}

//!  compute the axial strain at a certain axial position, for given configuration
Real CObjectANCFThinPlate::ComputeAxialStrain_t(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);
	Vector3D rx_t = ComputeSlopeVector_t(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared();
	Real rxNorm = sqrt(rxNorm2);

	return (rx * rx_t) / rxNorm; //rate of axial strain
}


//!  compute the (bending) curvature at a certain axial position, for given configuration
Vector3D CObjectANCFThinPlate::ComputeCurvature(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);
	Vector3D rxx = ComputeSlopeVector_x(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared(); //computation see ComputeODE2LHS(...)

	Vector3D rxCrossRxx = rx.CrossProduct(rxx);
	return rxCrossRxx * (1. / rxNorm2); //curvature
}

//!  compute the (bending) curvature at a certain axial position, for given configuration
Vector3D CObjectANCFThinPlate::ComputeCurvature_t(Real x, ConfigurationType configuration) const
{
	Vector3D rx = ComputeSlopeVector(x, configuration);
	Vector3D rxx = ComputeSlopeVector_x(x, configuration);

	Vector3D rx_t = ComputeSlopeVector_t(x, configuration);
	Vector3D rxx_t = ComputeSlopeVector_xt(x, configuration);

	Real rxNorm2 = rx.GetL2NormSquared(); //computation see ComputeODE2LHS(...)

	Vector3D rxCrossRxx = rx.CrossProduct(rxx);

	//apply differentiation formula: (f/g)' = (f'g - fg') / g^2
	Real g = rx.GetL2NormSquared();				//g
	Vector3D f = rx.CrossProduct(rxx);			//f
	Vector3D f_t = rx_t.CrossProduct(rxx) + rx.CrossProduct(rxx_t);
	Real g_t = 2. * (rx_t * rx);

	return (f_t * g - f * g_t) * (1. / EXUstd::Square(g));
}

Vector3D CObjectANCFThinPlate::ComputeSlopeVector_t(Real x, ConfigurationType configuration) const
{
	Vector4D SVx = ComputeShapeFunctions_x(x, GetLength());

	return MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}

Vector3D CObjectANCFThinPlate::ComputeSlopeVector_xt(Real x, ConfigurationType configuration) const
{
	Vector4D SVxx = ComputeShapeFunctions_xx(x, GetLength());

	return MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}


#endif //USE_COBJECTANCFTHINPLATE
