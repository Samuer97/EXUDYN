/** ***********************************************************************************************
* @brief        Implementation of CObjectConnectorReevingSystemSprings
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorReevingSystemSprings.h"
#include "Linalg/RigidBodyMath.h"

#include "Linalg/Geometry.h"

Real CObjectConnectorReevingSystemSprings::ComputeForce(Real L, Real L0, Real L_t, Real L0_t, Real EA, Real DA) const
{
	if (parameters.activeConnector)
	{
		Real invL0 = 1e3; //use minimum reference length (1mm), leads to very high stiffness ... should never happen
		if (L0 != 0.) { invL0 = 1. / L0; }
		return ((L - L0)*EA + (L_t - L0_t) * DA) * invL0;
	}
	else { return 0.; }
}

//! compute reeving geometry based on localPositionsList, length, time derivative of length
void CObjectConnectorReevingSystemSprings::ComputeReevingGeometry(const MarkerDataStructure& markerData, Index itemIndex,
	Vector3DList& positionsList, Real& actualLength, Real& actualLength_t, bool storePositions) const
{
	//compute local (at according marker) position of tangent points to sheaves
	//for markers m0, m1, m2, m3, the tempPositionList contains positions p_m0, pA_m1, pB_m1, pA_m2, pB_m2, P_m3

	actualLength = 0.;
	actualLength_t = 0.;

	Index nRigidBodyMarkers = parameters.markerNumbers.NumberOfItems()-2*(Index)parameters.hasCoordinateMarkers;

	if (storePositions) { positionsList.SetNumberOfItems(nRigidBodyMarkers * 2 - 2); }
	Vector3D lastRB;
	//Vector3D lastRB_t;

	for (Index i = 0; i < nRigidBodyMarkers-1; i++)
	{
		Vector3D pA = markerData.GetMarkerData(i).position;
		Vector3D pB = markerData.GetMarkerData(i + 1).position;
		Vector3D vA = markerData.GetMarkerData(i).velocity;
		Vector3D vB = markerData.GetMarkerData(i + 1).velocity;
		Real RA = parameters.sheavesRadii[i];
		Real RB = parameters.sheavesRadii[i+1];
		Vector3D rA, rB;

		Vector3D aA = markerData.GetMarkerData(i).orientation*parameters.sheavesAxes[i];
		Vector3D aB = markerData.GetMarkerData(i + 1).orientation*parameters.sheavesAxes[i + 1];

		bool rv = HGeometry::CommonTangentOf2Circles(pA, pB, 
			aA, aB, RA, RB, rA, rB, 1, 1, true);
		if (!rv) { SysError("CObjectConnectorReevingSystemSprings::ComputeReevingGeometry: computation of common tangent of 2 circles failed; check the geometry of your reeving system!"); }

		if (true)
		{
			Vector3D dir = (pB+rB - pA-rA);
			Real dirLength = dir.GetL2Norm();
			actualLength += dirLength;
			Vector3D omegaA = markerData.GetMarkerData(i).orientation * markerData.GetMarkerData(i).angularVelocityLocal;
			Vector3D omegaB = markerData.GetMarkerData(i + 1).orientation * markerData.GetMarkerData(i + 1).angularVelocityLocal;

			Vector3D vAadd(0.);
			Vector3D vBadd(0.);
			if (dirLength != 0.)
			{
				dir *= 1. / dirLength;
				vAadd = omegaA.CrossProduct(rA);
				vBadd = omegaB.CrossProduct(rB);
				actualLength_t += (vB + vBadd - vA - vAadd) * dir; //CHECK: this may be too simplified, but should include main effects; winding cancels out
			}
			if (storePositions)
			{
				positionsList[2 * i] = rA;
				positionsList[2 * i + 1] = rB;
			}


			if (i > 0 && RA != 0.)
			{
				//compute contact angle
				Vector3D lastRB0 = (1. / RA) * lastRB;
				Vector3D lastNB0 = aA.CrossProduct(lastRB0);

				Vector3D rA0 = (1. / RA) * rA;
				Real phi = atan2(lastNB0*rA0, lastRB0*rA0); //atan2(y,x) = atan(y/x)
				if (phi < 0) { phi += 2.*EXUstd::pi; }

				actualLength += phi * RA;

				//compute time derivative of contact angle:
				//THIS APPROACH is wrong, as it MUST consider the change of contact points rA, rB with time => diff(CommonTangentOf2Circles) ...
				//diff(atan2(y,x),x)= -y/(x^2+y^2)
				//diff(atan2(y,x),y)= x/(x^2+y^2)

				//if (true)
				//{
				//	Vector3D lastRB0_t = (1. / RA) * lastRB_t;
				//	Vector3D lastNB0_t = aA.CrossProduct(lastRB0_t);

				//	Vector3D vA0 = (1. / RA) * vA;
				//	//Real phi_t = atan2(lastNB0*rA0, lastRB0*rA0);
				//	Real x = lastRB0 * rA0;
				//	Real y = lastNB0 * rA0;
				//	Real x_t = lastRB0_t * rA0 + lastRB0 * vA0;
				//	Real y_t = lastNB0_t * rA0 + lastNB0 * vA0;
				//	Real phi_t = -y / (x*x + y * y) * x_t + x / (x*x + y * y) * y_t;

				//	actualLength_t += phi_t * RA;
				//}
			}
			lastRB = rB;
			//lastRB_t= vBadd;

		}
		else
		{
			//without radius:
			Vector3D dir = (pB - pA);
			Real dirLength = dir.GetL2Norm();
			actualLength += dirLength;
			if (dirLength != 0.)
			{
				dir *= 1. / dirLength;
				actualLength_t += (vB - vA) * dir; //CHECK: this may be too simplified, but should include main effects; winding cancels out
			}
			if (storePositions)
			{
				positionsList[2 * i] = Vector3D(0.);
				positionsList[2 * i + 1] = Vector3D(0.);
			}
		}
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectConnectorReevingSystemSprings::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectConnectorReevingSystemSprings::ComputeODE2LHS: marker do not provide velocityLevel information");

	Index nRigidBodyMarkers = parameters.markerNumbers.NumberOfItems() - 2 * (Index)parameters.hasCoordinateMarkers;

	//link separate vectors to result (ode2Lhs) vector
	Index rhsSize = 0;
	for (Index i = 0; i < nRigidBodyMarkers; i++)
	{
		rhsSize += markerData.GetMarkerData(i).positionJacobian.NumberOfColumns();
	}
	if (parameters.hasCoordinateMarkers)
	{
		rhsSize += markerData.GetMarkerData(nRigidBodyMarkers).jacobian.NumberOfColumns();
		rhsSize += markerData.GetMarkerData(nRigidBodyMarkers+1).jacobian.NumberOfColumns();
	}
	ode2Lhs.SetNumberOfItems(rhsSize);
	ode2Lhs.SetAll(0.); //values added, some of them twice

	if (parameters.activeConnector)
	{

		Real actualLength, actualLength_t;
		ComputeReevingGeometry(markerData, objectNumber, tempPositionsList, actualLength, actualLength_t, true);

		CHECKandTHROW(tempPositionsList.NumberOfItems() == 2 * (nRigidBodyMarkers - 1), "CObjectConnectorReevingSystemSprings: Internal error; tempPositionsList inconsistent with number of rigid body markers");

		Real Lref = parameters.referenceLength;
		Real Lref_t = 0.;
		//Real invLref = 1e3; //use very high factor if length becomes zero; should never happen
		//if (Lref != 0.) { invLref = 1. / Lref; }
		Real cfA = parameters.coordinateFactors[0];
		Real cfB = parameters.coordinateFactors[1];

		if (parameters.hasCoordinateMarkers)
		{
			Index cm0 = nRigidBodyMarkers;
			Index cm1 = nRigidBodyMarkers + 1;
			Lref += cfA * markerData.GetMarkerData(cm0).vectorValue[0] + cfB * markerData.GetMarkerData(cm1).vectorValue[0];
			Lref_t += cfA * markerData.GetMarkerData(cm0).vectorValue_t[0] + cfB * markerData.GetMarkerData(cm1).vectorValue_t[0];
		}

		//Real force = (actualLength - Lref) * parameters.stiffnessPerLength * invLref 
		//	+ (actualLength_t - Lref_t) * parameters.dampingPerLength * invLref;

		Real force = ComputeForce(actualLength, Lref, actualLength_t, Lref_t,
			parameters.stiffnessPerLength, parameters.dampingPerLength);

		Index ode2LhsCnt = 0;
		//now compute generalized forces on sheaves
		for (Index i = 0; i < nRigidBodyMarkers - 1; i++)
		{
			const Vector3D& rA = tempPositionsList[i * 2];
			const Vector3D& rB = tempPositionsList[i * 2 + 1];
			//const Matrix3D& rotA = markerData.GetMarkerData(i).orientation;
			//const Matrix3D& rotB = markerData.GetMarkerData(i+1).orientation;

			Vector3D pA = rA + markerData.GetMarkerData(i).position;
			Vector3D pB = rB + markerData.GetMarkerData(i + 1).position;

			Vector3D dir = pB - pA;
			Real len = dir.GetL2Norm();
			if (len != 0.) { dir *= 1. / len; };

			Vector3D fPos = -force * dir; //force in rope
			Vector3D fRot = Vector3D(0.);

			if (parameters.dampingTorsional != 0. || parameters.dampingShear != 0.)
			{
				Vector3D omegaA = markerData.GetMarkerData(i).orientation * markerData.GetMarkerData(i).angularVelocityLocal;
				Vector3D omegaB = markerData.GetMarkerData(i + 1).orientation * markerData.GetMarkerData(i + 1).angularVelocityLocal;
				Vector3D vA = markerData.GetMarkerData(i).velocity + omegaA.CrossProduct(rA);
				Vector3D vB = markerData.GetMarkerData(i + 1).velocity + omegaB.CrossProduct(rB);
				fRot -= (((omegaB - omegaA)*dir) * parameters.dampingTorsional) * dir; //torsional damping, 
				if (len != 0.)
				{
					Vector3D vDiff = vB - vA;
					fPos -= (parameters.dampingShear / len) * (vDiff - (vDiff*dir)*dir); //includes distance, which approximates "shear" angle!
				}
			}

			Index nCols0 = markerData.GetMarkerData(i).positionJacobian.NumberOfColumns();
			Index nCols1 = markerData.GetMarkerData(i + 1).positionJacobian.NumberOfColumns();
			if (nCols0) //special case: COGround has (0,0) Jacobian
			{
				LinkedDataVector ldv0(ode2Lhs, ode2LhsCnt, nCols0);
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(i).positionJacobian, fPos, ldv0); //added, because two segments may act on one sheave

				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(i).rotationJacobian, fRot + rA.CrossProduct(fPos), ldv0);
			}
			if (nCols1) //special case: COGround has (0,0) Jacobian
			{
				LinkedDataVector ldv0(ode2Lhs, ode2LhsCnt + nCols0, nCols1);
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(i + 1).positionJacobian, -fPos, ldv0); //added, because two segments may act on one sheave

				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(i + 1).rotationJacobian, -fRot - rB.CrossProduct(fPos), ldv0);
			}

			ode2LhsCnt += nCols0; //increment offset only for first sheave, other sheave is affected in next iteration
		}

		//force on marker coordinates:
		if (parameters.hasCoordinateMarkers)
		{
			Index cm0 = nRigidBodyMarkers;
			Index cm1 = nRigidBodyMarkers + 1;
			Index nColsM0 = markerData.GetMarkerData(cm0).jacobian.NumberOfColumns();
			Index nColsM1 = markerData.GetMarkerData(cm1).jacobian.NumberOfColumns();
			if (nColsM0) //special case: COGround has (0,0) Jacobian
			{
				LinkedDataVector ldv0(ode2Lhs, rhsSize - nColsM0 - nColsM1, nColsM0);
				EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(cm0).jacobian, Vector1D(-cfA * force), ldv0); //negative, because Lref is negative in force computation
			}
			if (nColsM1) //special case: COGround has (0,0) Jacobian
			{
				LinkedDataVector ldv0(ode2Lhs, rhsSize - nColsM1, nColsM1);
				EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(cm1).jacobian, Vector1D(-cfB * force), ldv0); //negative, because Lref is negative in force computation
			}
		}
	}
}



//! provide according output variable in "value"
void CObjectConnectorReevingSystemSprings::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	Index nRigidBodyMarkers = parameters.markerNumbers.NumberOfItems() - 2 * (Index)parameters.hasCoordinateMarkers;

	Real actualLength, actualLength_t;
	Vector3DList tempList;
	ComputeReevingGeometry(markerData, itemIndex, tempList, actualLength, actualLength_t, false);

	Real Lref = parameters.referenceLength;
	Real Lref_t = 0.;

	if (parameters.hasCoordinateMarkers)
	{
		Index cm0 = nRigidBodyMarkers;
		Index cm1 = nRigidBodyMarkers + 1;
		Real cfA = parameters.coordinateFactors[0];
		Real cfB = parameters.coordinateFactors[1];
		Lref   += cfA * markerData.GetMarkerData(cm0).vectorValue[0]   + cfB * markerData.GetMarkerData(cm1).vectorValue[0];
		Lref_t += cfA * markerData.GetMarkerData(cm0).vectorValue_t[0] + cfB * markerData.GetMarkerData(cm1).vectorValue_t[0];
	}

	Real force = ComputeForce(actualLength, Lref, actualLength_t, Lref_t,
		parameters.stiffnessPerLength, parameters.dampingPerLength);


	switch (variableType)
	{
	case OutputVariableType::Distance: value.CopyFrom(Vector({ actualLength })); break;
	case OutputVariableType::VelocityLocal: value.CopyFrom(Vector({ actualLength_t })); break;
	case OutputVariableType::ForceLocal: value.CopyFrom(Vector({ force })); break;
	default:
		SysError("CObjectConnectorReevingSystemSprings::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}
}



