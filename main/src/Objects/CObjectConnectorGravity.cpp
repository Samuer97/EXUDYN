/** ***********************************************************************************************
* @brief        Implementation of CObjectConnectorGravity
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorGravity.h"


//compute the properties which are needed for computation of LHS and needed for OutputVariables
void CObjectConnectorGravity::ComputeConnectorProperties(const MarkerDataStructure& markerData, Index itemIndex,
	Vector3D& relPos, /*Vector3D& relVel, */Real& force, Vector3D& forceDirection) const
{
	relPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
	Real length = relPos.GetL2Norm();
	Real length2Inv;

	if (length > parameters.minDistanceRegularization)
	{
		length2Inv = 1. / (length*length);
	}
	else if (length <= parameters.minDistanceRegularization && parameters.minDistanceRegularization != 0)
	{
		length2Inv = 1. / (length*length + EXUstd::Square(length - parameters.minDistanceRegularization));
	}
	else
	{ 
		length2Inv = 1.; SysError("CObjectConnectorGravity::ComputeODE2LHS: length = 0; you may use minDistanceRegularization to regularize singularity"); 
	}

	Real lengthInv = 1.;
	if (length != 0.) { lengthInv = 1. / length; }

	//unit direction and relative velocity of spring-damper
	forceDirection = lengthInv * relPos;
	//relVel = (markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);

	force = 0;
	if (parameters.activeConnector)
	{
		//positive force = tension between objects
		force = parameters.gravitationalConstant*(parameters.mass0*parameters.mass1)*length2Inv;
	}
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectConnectorGravity::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	//relative position, spring length and inverse spring length
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectConnectorGravity::ComputeODE2LHS: marker do not provide velocityLevel information");

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.); //this is the default; used if !activeConnector

	if (parameters.activeConnector)
	{
		Real force;
		Vector3D relPos, forceDirection;
		ComputeConnectorProperties(markerData, objectNumber, relPos, force, forceDirection);
		Vector3D fVec = force * forceDirection;

		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(), markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());

			//ldv1 = (1.)*(markerData.GetMarkerData(1).positionJacobian.GetTransposed()*f); //slow version		
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fVec, ldv1);
		}

		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());

			//ldv0 = (-1.)*(jacobian0.GetTransposed()*f); //SLOW version
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, fVec, ldv0);
			ldv0 *= -1.;
		}
	}
}



//! AUTO:  return the available jacobian dependencies and the jacobians which are available as a function; if jacobian dependencies exist but are not available as a function, it is computed numerically; can be combined with 2^i enum flags
JacobianType::Type CObjectConnectorGravity::GetAvailableJacobians() const
{
	return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t);
}


//! provide according output variable in "value"
void CObjectConnectorGravity::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	Real force;
	Vector3D relPos, forceDirection;
	ComputeConnectorProperties(markerData, itemIndex, relPos, force, forceDirection);

	switch (variableType)
	{
	case OutputVariableType::Distance: value.SetVector({ relPos.GetL2Norm() }); break;
	case OutputVariableType::Displacement: value.CopyFrom(relPos); break;
	case OutputVariableType::Force: value.CopyFrom(force*forceDirection); break;
	default:
		SysError("CObjectConnectorGravity::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}

