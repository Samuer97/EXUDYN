/** ***********************************************************************************************
* @brief		Implementation for NodeRigidBodyEP
*
* @author		Gerstmayr Johannes
* @date			2019-10-19 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Linalg/RigidBodyMath.h"

#include "Utilities/TimerStructure.h" //for local CPU time measurement

//! provide nodal values efficiently for rigid body computation
void CNodeRigidBodyEP::CollectCurrentNodeData1(ConstSizeMatrix<maxRotationCoordinates * nDim3D>& Glocal, Vector3D& angularVelocityLocal) const
{
	//GetGlocal(Glocal);
	//angularVelocity = GetAngularVelocityLocal();

	LinkedDataVector refCoordinates = GetReferenceCoordinateVector();

	ConstSizeVector<maxRotationCoordinates> ep({ refCoordinates[nDisplacementCoordinates + 0], //these are the reference values
		refCoordinates[nDisplacementCoordinates + 1],
		refCoordinates[nDisplacementCoordinates + 2],
		refCoordinates[nDisplacementCoordinates + 3] }); //reference values for Euler Parameters

	LinkedDataVector coordinates = GetCurrentCoordinateVector();
		ep[0] += coordinates[nDisplacementCoordinates + 0];
		ep[1] += coordinates[nDisplacementCoordinates + 1];
		ep[2] += coordinates[nDisplacementCoordinates + 2];
		ep[3] += coordinates[nDisplacementCoordinates + 3];


	Glocal = RigidBodyMath::EP2Glocal(ep);

	LinkedDataVector ep_t(GetCurrentCoordinateVector_t(), nDisplacementCoordinates, nRotationCoordinates);

	EXUmath::MultMatrixVector(Glocal, ep_t, angularVelocityLocal);
}

//Index TSspecial;
//TimerStructureRegistrator TSRspecial("TSspecial", TSspecial, globalTimers);

void CNodeRigidBodyEP::CollectCurrentNodeMarkerData(ConstSizeMatrix<maxRotationCoordinates * nDim3D>& Glocal, ConstSizeMatrix<maxRotationCoordinates * nDim3D>& G,
	Vector3D& pos, Vector3D& vel, Matrix3D& A, Vector3D& angularVelocityLocal) const
{
	//********************************************************************
	//THIS FUNCTION HAS BEEN HIGHLY OPTIMIZED AS IT IS ONE OF THE MOST TIME CRITICAL FUNCTIONS FOR RIGID MULTIBODY SYSTEMS!
	//********************************************************************
	//STARTGLOBALTIMER(TSspecial);

	const Real* pRefXD = parameters.referenceCoordinates.GetDataPointer();
	//LinkedDataVector pRefXD = GetReferenceCoordinateVector();
	const Real* uXD = GetCurrentCoordinateVector().GetDataPointer();
	LinkedDataVector vXD = GetCurrentCoordinateVector_t();

	Real ep[4] = { pRefXD[nDisplacementCoordinates + 0]+ uXD[nDisplacementCoordinates + 0], //these are the reference values
		pRefXD[nDisplacementCoordinates + 1]+ uXD[nDisplacementCoordinates + 1],
		pRefXD[nDisplacementCoordinates + 2]+ uXD[nDisplacementCoordinates + 2],
		pRefXD[nDisplacementCoordinates + 3]+ uXD[nDisplacementCoordinates + 3] };

	//GetGlocal(Glocal);
	//GetG(G);

	//Glocal = RigidBodyMath::EP2GlocalTemplate<ConstSizeVector<maxRotationCoordinates>>(ep);
	//G = RigidBodyMath::EP2GTemplate<ConstSizeVector<maxRotationCoordinates>>(ep);

	//Glocal+G: 62ns in total ; tests for c=6414100 computations
	// 8ns: for 1 function call ( RigidBodyMath::EP2GTemplate<Real*>() )
	// ~0-1ns for 12 operator[] (negligible?)
	// 4.5ns for initializer list of 12 components
	// 10ns for 1 assignment operator: G = G_other;
	//Glocal = RigidBodyMath::EP2GlocalTemplate<Real*>(ep);
	//G = RigidBodyMath::EP2GTemplate<Real*>(ep);

	//G = ConstSizeMatrix<3 * RigidBodyMath::maxRotCoordinates>(3, 4, { -2.*ep[1], 2.*ep[0],-2.*ep[3], 2.*ep[2],
	//										-2.*ep[2], 2.*ep[3], 2.*ep[0],-2.*ep[1],
	//										-2.*ep[3],-2.*ep[2], 2.*ep[1], 2.*ep[0] }); //145
	//G = ConstSizeMatrix<3 * RigidBodyMath::maxRotCoordinates>(3, 4, { -2.*ep1, 2.*ep0,-2.*ep3, 2.*ep2,
	//										-2.*ep2, 2.*ep3, 2.*ep0,-2.*ep1,
	//										-2.*ep3,-2.*ep2, 2.*ep1, 2.*ep0 });//137 //operator[] just 1ns, probably no difference
	
	//5.5ns in total for both functions:
	RigidBodyMath::EP2Glocal(Glocal, ep[0], ep[1], ep[2], ep[3]);
	RigidBodyMath::EP2G(G, ep[0], ep[1], ep[2], ep[3]);

	//angularVelocityLocal = GetAngularVelocityLocal();
	//15ns:
	//EXUmath::MultMatrixVector(Glocal, LinkedDataVector(vXD, nDisplacementCoordinates, nRotationCoordinates), angularVelocityLocal);

	//3.3ns:
	Real* p = vXD.GetDataPointer() + nDisplacementCoordinates;
	angularVelocityLocal[0] = Glocal.GetUnsafe(0, 0) * p[0] + Glocal.GetUnsafe(0, 1) * p[1] + Glocal.GetUnsafe(0, 2) * p[2] + Glocal.GetUnsafe(0, 3) * p[3];
	angularVelocityLocal[1] = Glocal.GetUnsafe(1, 0) * p[0] + Glocal.GetUnsafe(1, 1) * p[1] + Glocal.GetUnsafe(1, 2) * p[2] + Glocal.GetUnsafe(1, 3) * p[3];
	angularVelocityLocal[2] = Glocal.GetUnsafe(2, 0) * p[0] + Glocal.GetUnsafe(2, 1) * p[1] + Glocal.GetUnsafe(2, 2) * p[2] + Glocal.GetUnsafe(2, 3) * p[3];


	//pos+vel computation: 3.1ns:
	//pos = GetPosition();
	pos[0] = pRefXD[0] + uXD[0];
	pos[1] = pRefXD[1] + uXD[1];
	pos[2] = pRefXD[2] + uXD[2];

	//vel = GetVelocity();
	vel[0] = vXD[0];
	vel[1] = vXD[1];
	vel[2] = vXD[2];

	RigidBodyMath::EP2RotationMatrix(A, ep[0], ep[1], ep[2], ep[3]); //3.3ns
	//A = GetRotationMatrix(); //65ns

	//STOPGLOBALTIMER(TSspecial); 
	//globalTimers.SetCounter(TSspecial, globalTimers.GetCounter(TSspecial) + 0.001);
}


// Compute vector to of 4 Euler Parameters from reference and configuration coordinates
ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> CNodeRigidBodyEP::GetRotationParameters(ConfigurationType configuration) const
{
	LinkedDataVector refCoordinates = GetReferenceCoordinateVector();
	
	ConstSizeVector<maxRotationCoordinates> ep({ refCoordinates[nDisplacementCoordinates + 0], //these are the reference values
		refCoordinates[nDisplacementCoordinates + 1],
		refCoordinates[nDisplacementCoordinates + 2],
		refCoordinates[nDisplacementCoordinates + 3] }); //reference values for Euler Parameters

	if (configuration != ConfigurationType::Reference)
	{
		LinkedDataVector coordinates = GetCoordinateVector(configuration);
		ep[0] += coordinates[nDisplacementCoordinates + 0];
		ep[1] += coordinates[nDisplacementCoordinates + 1];
		ep[2] += coordinates[nDisplacementCoordinates + 2];
		ep[3] += coordinates[nDisplacementCoordinates + 3];
	}

	return ep;
}

// Link vector to time derivative of 4 Euler Parameters in given configuration
LinkedDataVector CNodeRigidBodyEP::GetRotationParameters_t(ConfigurationType configuration) const
{
	return LinkedDataVector(GetCoordinateVector_t(configuration), nDisplacementCoordinates, nRotationCoordinates);
	//return ConstSizeVector<CNodeRigidBody::maxRotationCoordinates>({
	//	ep_t[nDisplacementCoordinates + 0], 
	//	ep_t[nDisplacementCoordinates + 1],
	//	ep_t[nDisplacementCoordinates + 2],
	//	ep_t[nDisplacementCoordinates + 3] }); 
}

//! Compute G matrix (=diff(angularVelocity, velocityParameters)) for given configuration
void CNodeRigidBodyEP::GetG(ConstSizeMatrix<maxRotationCoordinates * nDim3D>& matrix, ConfigurationType configuration) const
{
	matrix = RigidBodyMath::EP2G(GetRotationParameters(configuration));
}

//! Compute local G matrix for given configuration
void CNodeRigidBodyEP::GetGlocal(ConstSizeMatrix<maxRotationCoordinates * nDim3D>& matrix, ConfigurationType configuration) const
{
	matrix = RigidBodyMath::EP2Glocal(GetRotationParameters(configuration));
}

//! Compute G matrix (=diff(angularVelocity, velocityParameters)) for given configuration
void CNodeRigidBodyEP::GetG_t(ConstSizeMatrix<maxRotationCoordinates * nDim3D>& matrix, ConfigurationType configuration) const
{
	matrix = RigidBodyMath::EP_t2G_t(GetRotationParameters_t(configuration));
}

//! Compute local G matrix for given configuration
void CNodeRigidBodyEP::GetGlocal_t(ConstSizeMatrix<maxRotationCoordinates * nDim3D>& matrix, ConfigurationType configuration) const
{
	matrix = RigidBodyMath::EP_t2Glocal_t(GetRotationParameters_t(configuration));
}

//! compute d(G^T*v)/dq for Euler parameters; needed for jacobians
void CNodeRigidBodyEP::GetGTv_q(const Vector3D& v, ConstSizeMatrix<maxRotationCoordinates * maxRotationCoordinates>& matrix, ConfigurationType configuration) const
{
	matrix = RigidBodyMath::EPGTv_q(v);
}

//! compute d(G^T*v)/dq for Euler parameters; needed for jacobians
void CNodeRigidBodyEP::GetGlocalTv_q(const Vector3D& v, ConstSizeMatrix<maxRotationCoordinates * maxRotationCoordinates>& matrix, ConfigurationType configuration) const
{
	matrix = RigidBodyMath::EPGlocalTv_q(v);
}

Vector3D CNodeRigidBodyEP::GetPosition(ConfigurationType configuration) const
{
	//compute reference coordinate vector (this is the position/orientation of the node without displacements)
	LinkedDataVector pRef3D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef3D[0], pRef3D[1], pRef3D[2] });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	//compute displacement vector (this is the displacement/rotation superimposed to reference configuration)
	LinkedDataVector u3D = GetCoordinateVector(configuration);
	Vector3D displacement({ u3D[0], u3D[1], u3D[2] });
	
	return pRef + displacement; //valid, because position and displacement is still additive!
}

Vector3D CNodeRigidBodyEP::GetVelocity(ConfigurationType configuration) const
{
	LinkedDataVector u3D_t = GetCoordinateVector_t(configuration);
	return Vector3D({ u3D_t[0], u3D_t[1], u3D_t[2] });
}

Vector3D CNodeRigidBodyEP::GetAcceleration(ConfigurationType configuration) const
{
	LinkedDataVector u3D_tt = GetCoordinateVector_tt(configuration);
	return Vector3D({ u3D_tt[0], u3D_tt[1], u3D_tt[2] });
}

Matrix3D CNodeRigidBodyEP::GetRotationMatrix(ConfigurationType configuration) const
{
	ConstSizeVector<maxRotationCoordinates> ep(GetRotationParameters(configuration));
	return RigidBodyMath::EP2RotationMatrix(ep);
}

//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CNodeRigidBodyEP::GetAngularVelocity(ConfigurationType configuration) const
{
	ConstSizeVector<maxRotationCoordinates> ep(GetRotationParameters(configuration));
	LinkedDataVector ep_t(GetRotationParameters_t(configuration));
	//ConstSizeMatrix<nDim3D * nRotationCoordinates> G = RigidBodyMath::EP2G(ep);

	Vector3D omega;
	EXUmath::MultMatrixVector(RigidBodyMath::EP2G(ep), ep_t, omega);

	return omega;
}

//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CNodeRigidBodyEP::GetAngularAcceleration(ConfigurationType configuration) const
{
	ConstSizeVector<maxRotationCoordinates> ep(GetRotationParameters(configuration));
	//LinkedDataVector ep_t(GetRotationParameters_t(configuration));
	LinkedDataVector ep_tt(GetCoordinateVector_tt(configuration),nDisplacementCoordinates,nRotationCoordinates);

	//Vector3D omega;
	//EXUmath::MultMatrixVector(RigidBodyMath::EP2G(ep), ep_t, omega);
	Vector3D alpha;
	EXUmath::MultMatrixVector(RigidBodyMath::EP2G(ep), ep_tt, alpha); //EP2G_t not needed for Euler parameters as EP2G_t*ep_t=0!

	return alpha;
}

//! return configuration dependent local (=body fixed) angular velocity of node; returns always a 3D Vector
Vector3D CNodeRigidBodyEP::GetAngularVelocityLocal(ConfigurationType configuration) const
{
	ConstSizeVector<maxRotationCoordinates> ep(GetRotationParameters(configuration));
	LinkedDataVector ep_t(GetRotationParameters_t(configuration));
	//ConstSizeMatrix<nDim3D * nRotationCoordinates> Glocal = RigidBodyMath::EP2Glocal(ep);

	Vector3D omegaLocal;
	EXUmath::MultMatrixVector(RigidBodyMath::EP2Glocal(ep), ep_t, omegaLocal);

	return omegaLocal;
}

//! provide position jacobian of node; derivative of 3D Position with respect to 7 coordinates ux,uy,uz,ep0,...,ep3
void CNodeRigidBodyEP::GetPositionJacobian(Matrix& value) const
{
	value.SetNumberOfRowsAndColumns(3, nDisplacementCoordinates + nRotationCoordinates);
	value.SetAll(0.);
	value(0, 0) = 1.;
	value(1, 1) = 1.;
	value(2, 2) = 1.;
}

//! provide "rotation" jacobian \f$\Jm_R\f$ of node; derivative of 3D angular velocity vector with respect to all velocity coordinates ("G-matrix"); action of torque \f$\mv\f$: \f$\Qm_m = \Jm_R^T \mv\f$
void CNodeRigidBodyEP::GetRotationJacobian(Matrix& value) const
{
	value.SetNumberOfRowsAndColumns(3, nDisplacementCoordinates + nRotationCoordinates);
	value.SetAll(0.);

	ConstSizeMatrix<3 * maxRotationCoordinates> G;
	GetG(G);

	for (Index i = 0; i < 3; i++) //dimensionality
	{
		for (Index j = 0; j < nRotationCoordinates; j++)
		{
			value(i, j + nDisplacementCoordinates) = G(i, j);
		}
	}
}

//! provide derivative w.r.t. coordinates of rotation Jacobian times vector; for current configuration
void CNodeRigidBodyEP::GetRotationJacobianTTimesVector_q(const Vector3D& vector, Matrix& jacobian_q) const
{
	//omega = G*q_t
	//d(rot)/dq = [I_{3x3}, G]
	//d(rot^T*v)/dq = [0_{3x3}, 0_{3x4}]
	//                [0_{4x3}, GTv_theta]
	jacobian_q.SetNumberOfRowsAndColumns(nDisplacementCoordinates + nRotationCoordinates, nDisplacementCoordinates + nRotationCoordinates);
	jacobian_q.SetAll(0.);
	jacobian_q.SetSubmatrix(RigidBodyMath::EPGTv_q(vector), nDisplacementCoordinates, nDisplacementCoordinates, 1.);
}

//! provide according output variable in "value"
void CNodeRigidBodyEP::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	static_assert(maxRotationCoordinates == RigidBodyMath::maxRotCoordinates); //add this code to raise compiler error, if max. number of rotation coordiantes changes
	static_assert(nDim3D == 3); //add this code to raise compiler error, if nDim3D changes

	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
	case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(configuration)); break;
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(configuration)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetAngularVelocityLocal(configuration)); break;
	case OutputVariableType::AngularAcceleration: value.CopyFrom(GetAngularAcceleration(configuration)); break;
	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(configuration);
		value.SetVector(9, rot.GetDataPointer());
		break;
	}
	case OutputVariableType::Rotation: {
		Matrix3D rotMat = GetRotationMatrix(configuration);
		Vector3D rot = RigidBodyMath::RotationMatrix2RotXYZ(rotMat);
		value.SetVector(3, rot.GetDataPointer());
		break;
	}
	case OutputVariableType::Coordinates:
	{
		if (IsValidConfiguration(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodeRigidBodyEP::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsValidConfigurationButNotReference(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodeRigidBodyEP::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_tt:
	{
		if (IsValidConfigurationButNotReference(configuration))
		{
			value = GetCoordinateVector_tt(configuration);
		}
		else
		{
			PyError("CNodeRigidBodyEP::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodeRigidBodyEP::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}

void CNodeRigidBodyEP::ComputeAlgebraicEquations(Vector& algebraicEquations, bool useIndex2) const
{
	algebraicEquations.SetNumberOfItems(1);
	if (!useIndex2)
	{
		//position level constraint:

		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = GetRotationParameters();
		algebraicEquations[0] = ep * ep - 1.;
	}
	else
	{
		//velocity level constraint:
		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = GetRotationParameters();
		LinkedDataVector ep_t = GetRotationParameters_t();

		algebraicEquations[0] = 2. * (ep * ep_t);
	}
}

//! Compute jacobians of algebraic equations part of rigid body w.r.t. ODE2
void CNodeRigidBodyEP::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t,
	ResizableMatrix& jacobian_ODE1, ResizableMatrix& jacobian_AE,
	JacobianType::Type& filledJacobians) const
{
	jacobian_ODE2.SetNumberOfRowsAndColumns(GetNumberOfAECoordinates(), GetNumberOfODE2Coordinates());
	filledJacobians = JacobianType::AE_ODE2;

	ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = GetRotationParameters();

	//jacobian = [0 0 0 2*ep0 2*ep1 2*ep2 2*ep3]
	for (Index i = 0; i < nDisplacementCoordinates; i++) { jacobian_ODE2(0, i) = 0.; }
	for (Index i = 0; i < GetNumberOfRotationCoordinates(); i++)
	{
		jacobian_ODE2(0, 3 + i) = 2.*ep[i];
	}
}


