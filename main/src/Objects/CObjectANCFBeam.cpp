/** ***********************************************************************************************
* @brief        CObjectANCFBeam implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//for SetInternalBeamSection:
#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Pymodules/PyMatrixVector.h"

#include "Linalg/KinematicsBasics.h"
#include "Autogenerated/MainObjectANCFBeam.h"
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//without Main object:
//#include "Main/CSystemData.h"
//#include "Autogenerated/CObjectANCFBeam.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//for automatic diff, ...
#include "Utilities/AutomaticDifferentiation.h"
#include "Utilities/AdvancedMath.h"
#include "Utilities/Differentiation.h"


//! special function which writes pyObject into local data
void MainObjectANCFBeam::SetInternalBeamSection(const py::object& pyObject)
{
	if (py::isinstance<PyBeamSection>(pyObject)) //this must be the C-object
	{
		PyBeamSection bs(py::cast<PyBeamSection>(pyObject));
		GetCObjectANCFBeam()->GetParameters().physicsAxialShearStiffness =
			Vector3D({ bs.stiffnessMatrix(0,0),bs.stiffnessMatrix(1,1),bs.stiffnessMatrix(2,2) });
		GetCObjectANCFBeam()->GetParameters().physicsTorsionalBendingStiffness =
			Vector3D({ bs.stiffnessMatrix(3,3),bs.stiffnessMatrix(4,4),bs.stiffnessMatrix(5,5) });

		GetCObjectANCFBeam()->GetParameters().physicsCrossSectionInertia = bs.inertia;
		GetCObjectANCFBeam()->GetParameters().physicsMassPerLength = bs.massPerLength;

		//CHECK that there are no parameters in BeamSection which are not processed:
		PyBeamSection bsCheck;
		bsCheck = GetInternalBeamSection();
		if (!(bs.stiffnessMatrix == bsCheck.stiffnessMatrix))
		{
			PyError("ObjectANCFBeam: BeamSection stiffnessMatrix contains values which can not be used");
		}
		if (!(bs.inertia == bsCheck.inertia))
		{
			PyError("ObjectANCFBeam: BeamSection inertia contains values which can not be used");
		}
	}
	else
	{
		PyError("ObjectANCFBeam: expected BeamSection, but received: " + STDstring(py::str(pyObject)));
	}
}

//! AUTO: special function which returns BeamSection converted from local data
PyBeamSection MainObjectANCFBeam::GetInternalBeamSection() const
{
	PyBeamSection bs;
	Vector3D kAS = GetCObjectANCFBeam()->GetParameters().physicsAxialShearStiffness;
	bs.stiffnessMatrix(0, 0) = kAS[0];
	bs.stiffnessMatrix(1, 1) = kAS[1];
	bs.stiffnessMatrix(2, 2) = kAS[2];

	Vector3D kKappa = GetCObjectANCFBeam()->GetParameters().physicsTorsionalBendingStiffness;
	bs.stiffnessMatrix(3, 3) = kKappa[0];
	bs.stiffnessMatrix(4, 4) = kKappa[1];
	bs.stiffnessMatrix(5, 5) = kKappa[2];

	bs.inertia = GetCObjectANCFBeam()->GetParameters().physicsCrossSectionInertia;
	bs.massPerLength = GetCObjectANCFBeam()->GetParameters().physicsMassPerLength;

	return bs;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! get compressed shape function vector
SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> CObjectANCFBeam::ComputeShapeFunctions(const Vector3D& localPosition, Real L) 
{
	Real x0 = localPosition[0] / L; //dimension: [1], as this is multiplied with position
	Real y = localPosition[1];		//dimension: [m], as this is multiplied with slope vector
	Real z = localPosition[2];		//dimension: [m], as this is multiplied with slope vector
	Real val1 = 0.5 - x0;
	Real val4 = 0.5 + x0;

	return SlimVector<CObjectANCFBeam::nSFperNode * CObjectANCFBeam::nNodes>(
		{ val1, val1 * y, val1 * z, val4, val4 * y, val4 * z });
}


//! get derivative of compressed shape function vector for slopes
SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> CObjectANCFBeam::ComputeShapeFunctions_x(const Vector3D& localPosition, Real L) 
{
	Real fact = 1. / L;
	Real y = localPosition[1];
	Real z = localPosition[2];

	return SlimVector<CObjectANCFBeam::nSFperNode * CObjectANCFBeam::nNodes>(
		{ -fact, -fact * y, -fact * z, fact, fact * y, fact * z });
}

//! get derivative of compressed shape function vector for slopes
SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> CObjectANCFBeam::ComputeShapeFunctions_y(const Vector3D& localPosition, Real L) 
{
	Real x0 = localPosition[0] / L;
	Real val1 = 0.5 - x0;
	Real val4 = 0.5 + x0;

	return SlimVector<CObjectANCFBeam::nSFperNode * CObjectANCFBeam::nNodes>(
		{ 0., val1, 0., 0., val4, 0. });
}

//! get derivative of compressed shape function vector for slopes
SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> CObjectANCFBeam::ComputeShapeFunctions_z(const Vector3D& localPosition, Real L) 
{
	Real x0 = localPosition[0] / L;
	Real val1 = 0.5 - x0;
	Real val4 = 0.5 + x0;

	return SlimVector<CObjectANCFBeam::nSFperNode * CObjectANCFBeam::nNodes>(
		{ 0., 0., val1, 0., 0., val4 });
}

//! get derivative of compressed shape function vector for slopes
SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> CObjectANCFBeam::ComputeShapeFunctions_yx(const Vector3D& localPosition, Real L) 
{
	Real fact = 1. / L;
	return SlimVector<CObjectANCFBeam::nSFperNode * CObjectANCFBeam::nNodes>(
		{ 0., -fact, 0., 0., fact, 0. });
}

//! get derivative of compressed shape function vector for slopes
SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> CObjectANCFBeam::ComputeShapeFunctions_zx(const Vector3D& localPosition, Real L) 
{
	Real fact = 1. / L;
	return SlimVector<CObjectANCFBeam::nSFperNode * CObjectANCFBeam::nNodes>(
		{ 0., 0., -fact, 0., 0., fact });
}


void CObjectANCFBeam::ComputeCurrentNodeCoordinates(ConstSizeVector<CObjectANCFBeam::nODE2perNode>& qNode0, ConstSizeVector<CObjectANCFBeam::nODE2perNode>& qNode1) const
{
	((CNodeODE2*)GetCNode(0))->GetCurrentAndReferenceODE2CoordinateVector(qNode0);
	((CNodeODE2*)GetCNode(1))->GetCurrentAndReferenceODE2CoordinateVector(qNode1);
}

void CObjectANCFBeam::ComputeCurrentNodeVelocities(ConstSizeVector<CObjectANCFBeam::nODE2perNode>& qNode0, ConstSizeVector<CObjectANCFBeam::nODE2perNode>& qNode1) const
{
	qNode0.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t()); //velocity coordinates node 0
	qNode1.CopyFrom(((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t()); //velocity coordinates node 1
}

void CObjectANCFBeam::ComputeCurrentObjectCoordinates(ConstSizeVector<CObjectANCFBeam::nODE2coordinates>& qANCF) const
{
	LinkedDataVector qNode0(qANCF, 0, nODE2perNode);		//link node values to element vector
	LinkedDataVector qNode1(qANCF, nODE2perNode, nODE2perNode);		//link node values to element vector

	qNode0 = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector(); //displacement coordinates node 0
	qNode1 = ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector(); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector();
}

void CObjectANCFBeam::ComputeCurrentObjectVelocities(ConstSizeVector<CObjectANCFBeam::nODE2coordinates>& qANCF_t) const
{
	LinkedDataVector qNode0(qANCF_t, 0, nODE2perNode);		//link node values to element vector
	LinkedDataVector qNode1(qANCF_t, nODE2perNode, nODE2perNode);		//link node values to element vector

	qNode0 = ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(); //displacement coordinates node 0
	qNode1 = ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t(); //displacement coordinates node 1
}

//! AUTO:  compute the slope vector at a certain position, for given configuration
void CObjectANCFBeam::ComputeSlopeVectors(Real x, ConfigurationType configuration, Vector3D& slopeX, Vector3D& slopeY, Vector3D& slopeZ) const
{
	ConstSizeVector<nODE2perNode> q0;
	ConstSizeVector<nODE2perNode> q1;

	((CNodeODE2*)GetCNode(0))->GetODE2CoordinateVectorWithReference(q0, configuration);
	((CNodeODE2*)GetCNode(1))->GetODE2CoordinateVectorWithReference(q1, configuration);

	slopeX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_x(Vector3D({ x,0.,0. }), 
		parameters.physicsLength), q0, q1);
	slopeY = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_y(Vector3D({ x,0.,0. }), parameters.physicsLength), q0, q1);
	slopeZ = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_z(Vector3D({ x,0.,0. }), parameters.physicsLength), q0, q1);
}


//! Computational function: compute mass matrix
void CObjectANCFBeam::PreComputeMassTerms() const
{
	if (!massMatrixComputed)
	{
		precomputedMassMatrix.SetScalarMatrix(nODE2coordinates, 0.); //set 8x8 matrix
		Real L = parameters.physicsLength;
		Real rhoA = parameters.physicsMassPerLength;
		const Index ns = nSFperNode * nNodes;   //number of shape functions
		
		if (parameters.testBeamRectangularSize[0] <= 0.) //default, use new approach, with inertia and only integration along x-axis
		{
			Real a = -0.5*L; //integration interval [a,b]
			Real b = 0.5*L;
			Index cnt = 0;
			for (auto item : EXUmath::gaussRuleOrder3Points) //shape functions are linear, so order 3 shall be enough!
			{
				Real x = 0.5*(b - a)*item + 0.5*(b + a);
				SlimVector<ns> SV = ComputeShapeFunctions(x, L);
				SlimVector<ns> SVint = SV;
				SVint *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder3Weights[cnt++]);

				for (Index i = 0; i < nNodes; i++)
				{
					for (Index j = 0; j < nNodes; j++)
					{
						for (Index k = 0; k < EXUstd::dim3D; k++)
						{
							precomputedMassMatrix(i * EXUstd::dim3D*nSFperNode + k, j * EXUstd::dim3D*nSFperNode + k) += SV[i*nSFperNode] * SVint[j*nSFperNode];
						}
					}
				}
			}
			//*** add inertia tensor part ***

			//scaling matrix W only includes constant reference values
			//sYref=skew(slopeYref)
			//sZref=skew(slopeZref)
			//W=-(sY@sY+sZ@sZ)
			//inv(W)=diag([0.5,1.,1.])
			//sY_tt=skew(slopeY_tt)
			//sZ_tt=skew(slopeZ_tt)
			//omega_t = Winv@sY_tt + Winv@sZ_tt
			//==>inertiaMoment = inertiaTensor @ omega_t = inertiaTensor @ Winv @ (SY + SZ)
			//==>kinetic energy due to rotary inertia per cross section:
			//   0.5 * omega_t.T @ inertiaTensor @ omega_t
			//==> mass matrix: (SY + SZ).T @ Winv.T @ inertiaTensor @ Winv @ (SY + SZ)
			//distortion of slope vectors contributes to inertia => same as if integrated mass matrix directly + constant mass matrix

			//Matrix3D Winv = parameters.physicsCrossSectionInertia;
			//CHECKandTHROW(Winv.Invert(), "CObjectANCFBeam::PreComputeMassTerms: cross section inertia seems to be singular");

			Matrix3D Winv({ 0.5,0.,0., 0.,1.,0., 0.,0.,1. });
			Matrix3D WIW = Winv.GetTransposed()*parameters.physicsCrossSectionInertia*Winv;
			cnt = 0;
			for (auto item : EXUmath::gaussRuleOrder3Points) //shape functions are linear, so order 3 shall be enough!
			{
				Real x = 0.5*(b - a)*item + 0.5*(b + a);
				SlimVector<ns> SV_y = ComputeShapeFunctions_y(x, L);
				SlimVector<ns> SV_z = ComputeShapeFunctions_z(x, L);
				Real fact = (0.5*(b - a)*EXUmath::gaussRuleOrder3Weights[cnt++]);
				//SlimVector<ns> SVint_y = SV_y;
				//SlimVector<ns> SVint_z = SV_z;
				ConstSizeMatrix<EXUstd::dim3D* ns*EXUstd::dim3D> SY(EXUstd::dim3D, ns*EXUstd::dim3D, 0.);
				ConstSizeMatrix<EXUstd::dim3D* ns*EXUstd::dim3D> SZ(EXUstd::dim3D, ns*EXUstd::dim3D, 0.);
				for (Index i = 0; i < ns; i++)
				{
					for (Index k = 0; k < EXUstd::dim3D; k++)
					{
						SY(k, i*EXUstd::dim3D + k) = SV_y[i];
						SZ(k, i*EXUstd::dim3D + k) = SV_z[i];
					}
				}


				//SWS = (SY + SZ).GetTransposed() * WIW * (SY + SZ);
				SY += SZ; //SY=SY+SZ
				EXUmath::MultMatrixMatrixTemplate(fact * WIW, SY, SZ); //SZ=WIW*SY
				EXUmath::MultMatrixTransposedMatrixAddTemplate(SY, SZ, precomputedMassMatrix); //add to mass matrix
			}
		}
		else
		{ //alternative (for validation) using assumed height and width of beam:
			Real hY = parameters.testBeamRectangularSize[0]; //for testing !
			Real hZ = parameters.testBeamRectangularSize[1]; //for testing !

			Matrix Smat(EXUstd::dim3D, ns*EXUstd::dim3D); //shape matrix
			const Vector2D& pInt = EXUmath::gaussRuleOrder3Points;
			const Vector2D& wInt = EXUmath::gaussRuleOrder3Weights;
			for (Index ix = 0; ix < pInt.NumberOfItems(); ix++) //shape functions are linear, so order 3 shall be enough!
			{
				Real px = pInt[ix];
				Real wx = wInt[ix];
				Real ax = -0.5*L; //integration interval [a,b]
				Real bx = 0.5*L;
				Real x = 0.5*(bx - ax)*px + 0.5*(bx + ax);

				for (Index iy = 0; iy < pInt.NumberOfItems(); iy++) //shape functions are linear, so order 3 shall be enough!
				{
					Real py = pInt[iy];
					Real wy = wInt[iy];
					Real ay = -0.5*hY; //integration interval [a,b]
					Real by = 0.5*hY;
					Real y = 0.5*(by - ay)*py + 0.5*(by + ay);

					for (Index iz = 0; iz < pInt.NumberOfItems(); iz++) //shape functions are linear, so order 3 shall be enough!
					{
						Real pz = pInt[iz];
						Real wz = wInt[iz];
						Real az = -0.5*hZ; //integration interval [a,b]
						Real bz = 0.5*hZ;
						Real z = 0.5*(bz - az)*pz + 0.5*(bz + az);

						Smat.SetAll(0.);
						SlimVector<ns> SV = ComputeShapeFunctions(Vector3D({x,y,z}), L);
						Real fact = rhoA/(hY*hZ) * (0.5*L*wx) * (0.5*hY*wy) * (0.5*hZ*wz);
						for (Index i = 0; i < ns; i++)
						{
							for (Index k = 0; k < EXUstd::dim3D; k++)
							{
								Smat(k, i*EXUstd::dim3D + k) = SV[i];
							}
						}
						precomputedMassMatrix += (fact*Smat).GetTransposed() * Smat;
						//pout << "xyz=" << x << "," << y << "," << z << ":preM=" << precomputedMassMatrix << "\n\n";
					}
				}
			}

		}

		massMatrixComputed = true;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++
//similar to 2013 implementation (very inefficient, use Lie group approach!):
template<class TReal>
SlimVectorBase<TReal, 3> GetBasisI(Index i, TReal dr1dy, TReal dr2dy, TReal dr3dy, TReal dr1dz, TReal dr2dz, TReal dr3dz)
{
	switch (i)
	{
	case 0:
		return SlimVectorBase<TReal, 3>({ -(dr2dz*dr3dy) + dr2dy * dr3dz, dr1dz*dr3dy - dr1dy * dr3dz, -(dr1dz*dr2dy) + dr1dy * dr2dz });
		break;
	case 1:
		return SlimVectorBase<TReal, 3>({ -(dr1dz*(dr2dy*dr2dz + dr3dy * dr3dz)) + dr1dy * (EXUstd::Square(dr2dz) + EXUstd::Square(dr3dz)),
			EXUstd::Square(dr1dz)*dr2dy - dr1dy * dr1dz*dr2dz + dr3dz * (-(dr2dz*dr3dy) + dr2dy * dr3dz), 
			EXUstd::Square(dr1dz)*dr3dy - dr1dy * dr1dz*dr3dz + dr2dz * (dr2dz*dr3dy - dr2dy * dr3dz) });
		break;
	case 2:
		return SlimVectorBase<TReal, 3>({ dr1dz, dr2dz, dr3dz });
		break;
	default:
		CHECKandTHROWstring("GetBasisI");
		return SlimVectorBase<TReal, 3>();
		break;
	}
}

template<class TReal>
SlimVectorBase<TReal, 3> GetBasisI_xI(Index i, TReal dr1dy, TReal dr2dy, TReal dr3dy, TReal dr1dz, TReal dr2dz, TReal dr3dz, TReal ddr1dydxi, TReal ddr2dydxi, TReal ddr3dydxi, TReal ddr1dzdxi, TReal ddr2dzdxi, TReal ddr3dzdxi)
{
	switch (i)
	{
	case 0:
		return SlimVectorBase<TReal, 3>({ddr3dzdxi*dr2dy - ddr3dydxi * dr2dz - ddr2dzdxi * dr3dy + ddr2dydxi * dr3dz,
			-(ddr3dzdxi*dr1dy) + ddr3dydxi * dr1dz + ddr1dzdxi * dr3dy - ddr1dydxi * dr3dz,
			ddr2dzdxi*dr1dy - ddr2dydxi * dr1dz - ddr1dzdxi * dr2dy + ddr1dydxi * dr2dz});
		break;
	case 1:
		return SlimVectorBase<TReal, 3>({ -(dr1dz*(ddr2dzdxi*dr2dy + ddr2dydxi * dr2dz + ddr3dzdxi * dr3dy + ddr3dydxi * dr3dz)) + 2 * dr1dy*(ddr2dzdxi*dr2dz + ddr3dzdxi * dr3dz) - ddr1dzdxi * (dr2dy*dr2dz + dr3dy * dr3dz) + ddr1dydxi * (EXUstd::Square(dr2dz) + EXUstd::Square(dr3dz)),
			ddr2dydxi*EXUstd::Square(dr1dz) - ddr1dzdxi * dr1dy*dr2dz - dr1dz * (ddr2dzdxi*dr1dy - 2 * ddr1dzdxi*dr2dy + ddr1dydxi * dr2dz) - ddr3dzdxi * dr2dz*dr3dy + 2 * ddr3dzdxi*dr2dy*dr3dz - ddr3dydxi * dr2dz*dr3dz - ddr2dzdxi * dr3dy*dr3dz + ddr2dydxi * EXUstd::Square(dr3dz),
			ddr3dydxi*EXUstd::Square(dr1dz) - ddr3dzdxi * dr2dy*dr2dz + ddr3dydxi * EXUstd::Square(dr2dz) + 2 * ddr2dzdxi*dr2dz*dr3dy - ddr1dzdxi * dr1dy*dr3dz - ddr2dzdxi * dr2dy*dr3dz - ddr2dydxi * dr2dz*dr3dz - dr1dz * (ddr3dzdxi*dr1dy - 2 * ddr1dzdxi*dr3dy + ddr1dydxi * dr3dz) });
		break;
	case 2:
		return SlimVectorBase<TReal, 3>({ ddr1dzdxi, ddr2dzdxi, ddr3dzdxi });
		break;
	default:
		CHECKandTHROWstring("GetBasisI_xI");
		return SlimVectorBase<TReal, 3>();
		break;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! get vector of twist and curvature at position x
//templates need to be defined in .h file ==> put it outside of CObjectANCFBeam
template<class TReal=Real>
SlimVectorBase<TReal, 3> GetLocalTwistAndCurvature(Real x, SlimVectorBase<TReal, 3> slopeY, SlimVectorBase<TReal, 3> slopeZ,
	SlimVectorBase<TReal, 3> slopeYX, SlimVectorBase<TReal, 3> slopeZX)
{
	SlimVectorBase<TReal, 3> ei;
	SlimVectorBase<TReal, 3> deidxi;

	SlimVectorBase<TReal, 3> k((TReal)0.);
	for (Index i = 0; i < EXUstd::dim3D; i++)
	{
		ei = GetBasisI(i, slopeY.X(), slopeY.Y(), slopeY.Z(), slopeZ.X(), slopeZ.Y(), slopeZ.Z());
		deidxi = GetBasisI_xI(i, slopeY.X(), slopeY.Y(), slopeY.Z(), slopeZ.X(), slopeZ.Y(), slopeZ.Z(), slopeYX.X(), slopeYX.Y(), slopeYX.Z(), slopeZX.X(), slopeZX.Y(), slopeZX.Z());

		//**** NOTE: derivative of deidxi w.r.t. |ei| is missing in 2013 implementation
		//d(ei_N)dxi = 1/|ei|*(I - np.outer(ei_N,ei_N))* deidxi ==> kappa+= 0.5/|ei|^2 * ei_N x ((I - 1//|ei|^2 * outer(ei,ei))*d(ei)dxi)
		//should read: 
		TReal eiNorm2 = ei.GetL2NormSquared(); 
		//corrected version: (but not big difference ...):
		ConstSizeMatrixBase<TReal, 9> IsubEiEi;
		IsubEiEi.SetWithDiadicProduct(-ei, ei);
		IsubEiEi(0, 0) += 1.;
		IsubEiEi(1, 1) += 1.;
		IsubEiEi(2, 2) += 1.;//[1.99762284e+000 8.96763007e-002 3.97492136e-128]
		k += (0.5 / eiNorm2) * ei.CrossProduct(IsubEiEi * deidxi);  //k = 1/2 sum_i e_i x e_i' -> simplified written using e_i^{\bar}-Vectors (see the paper)
		//k += (0.5 / eiNorm2) * ei.CrossProduct(deidxi);  //k = 1/2 sum_i e_i x e_i' -> simplified written using e_i^{\bar}-Vectors (see the paper)
	}

	return k;
}

//function to make interface to Autodiff:
template <class TReal>
void GetLocalTwistAndCurvatureDiff(const ConstSizeVectorBase<TReal, CObjectANCFBeam::nODE2coordinates>& qANCF,
	ConstSizeVectorBase<TReal, EXUstd::dim3D>& f, Real L, Real x)
{
	const Index nSFperNode = CObjectANCFBeam::nSFperNode;
	Vector3D localPosition({ x,0.,0. });
	LinkedDataVectorBase<TReal> q0(qANCF, 0, CObjectANCFBeam::nODE2perNode);		//link node values to element vector
	LinkedDataVectorBase<TReal> q1(qANCF, CObjectANCFBeam::nODE2perNode, CObjectANCFBeam::nODE2perNode);		//link node values to element vector

	//SlimVectorBase<TReal, 3> slopeX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVectorBase<TReal>, nSFperNode, EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_x(localPosition, L), q0, q1);
	SlimVectorBase<TReal, 3> slopeY  = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, nSFperNode, EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_y(localPosition, L), q0, q1);
	SlimVectorBase<TReal, 3> slopeZ  = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, nSFperNode, EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_z(localPosition, L), q0, q1);
	SlimVectorBase<TReal, 3> slopeYX = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, nSFperNode, EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_yx(localPosition, L), q0, q1);
	SlimVectorBase<TReal, 3> slopeZX = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, nSFperNode, EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_zx(localPosition, L), q0, q1);

	SlimVectorBase<TReal, 3> kappa = GetLocalTwistAndCurvature(x, slopeY, slopeZ, slopeYX, slopeZX);
	f.CopyFrom(kappa);
}


void CObjectANCFBeam::GetDeltaLocalTwistAndCurvature(Real x, ConstSizeMatrix<EXUstd::dim3D * CObjectANCFBeam::nODE2coordinates>& deltaKappa, 
	ConstSizeVector<EXUstd::dim3D>& kappa) const
{
	//compute twist and curvature (kappa)
	//use automatic differentiation for deltaKappa!
	Real L = parameters.physicsLength;
	Vector3D localPosition({ x,0.,0. });
	const Index dim3D = EXUstd::dim3D;

	ConstSizeVector<nODE2coordinates> qANCF;
	ComputeCurrentObjectCoordinates(qANCF);

	EXUmath::AutoDiffVectors<dim3D, nODE2coordinates>(GetLocalTwistAndCurvatureDiff<EXUmath::AutoDiff<nODE2coordinates, Real>>, qANCF, deltaKappa, L, x);
	GetLocalTwistAndCurvatureDiff<Real>(qANCF, kappa, L, x);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//typedef Real TReal;
template <class TReal>
void GetLocalAxialShearDeformationDiff(const ConstSizeVectorBase<TReal, CObjectANCFBeam::nODE2coordinates>& qANCF,
	ConstSizeVectorBase<TReal, EXUstd::dim3D>& f, Real L, Real x)
{
	Vector3D localPosition({ x,0.,0. });
	LinkedDataVectorBase<TReal> q0(qANCF, 0, CObjectANCFBeam::nODE2perNode);		//link node values to element vector
	LinkedDataVectorBase<TReal> q1(qANCF, CObjectANCFBeam::nODE2perNode, CObjectANCFBeam::nODE2perNode);		//link node values to element vector

	SlimVectorBase<TReal, 3> slopeX = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, CObjectANCFBeam::nSFperNode,
		EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_x(localPosition, L), q0, q1);
	SlimVectorBase<TReal, 3> slopeY = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, CObjectANCFBeam::nSFperNode,
		EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_y(localPosition, L), q0, q1);
	SlimVectorBase<TReal, 3> slopeZ = ExuMath::MapCoordinates2Nodes<TReal, LinkedDataVectorBase<TReal>, CObjectANCFBeam::nSFperNode,
		EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_z(localPosition, L), q0, q1);
	//SlimVectorBase<TReal, 3> slopeYX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_yx(localPosition, L), q0, q1);
	//SlimVectorBase<TReal, 3> slopeZX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_zx(localPosition, L), q0, q1);

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//gamma1 = t1*slopeX - 1
	//gamma2 = t2*slopeX
	//gamma3 = t3*slopeX

	SlimVectorBase<TReal, 3> ti[3];
	for (Index i = 0; i < EXUstd::dim3D; i++)
	{
		ti[i] = GetBasisI(i,
			slopeY.X(), slopeY.Y(), slopeY.Z(),
			slopeZ.X(), slopeZ.Y(), slopeZ.Z());
		ti[i].Normalize();
	}

	f.SetVector({ ti[0] * slopeX - 1.,
				  ti[1] * slopeX,
				  ti[2] * slopeX });

}


void CObjectANCFBeam::GetDeltaLocalAxialShearDeformation(Real x, ConstSizeMatrix<EXUstd::dim3D * CObjectANCFBeam::nODE2coordinates>& deltaAxialShearDeformation,
	ConstSizeVector<EXUstd::dim3D>& axialShearDeformation) const
{
	//compute twist and curvature (kappa)
	//use automatic differentiation for deltaKappa!
	Real L = parameters.physicsLength;
	//Vector3D localPosition({ x,0.,0. });
	const Index dim3D = EXUstd::dim3D;

	ConstSizeVector<nODE2coordinates> qANCF;
	ComputeCurrentObjectCoordinates(qANCF);

	EXUmath::AutoDiffVectors<dim3D, nODE2coordinates>(GetLocalAxialShearDeformationDiff<EXUmath::AutoDiff<nODE2coordinates, Real>>, qANCF, deltaAxialShearDeformation, L, x);
	GetLocalAxialShearDeformationDiff<Real>(qANCF, axialShearDeformation, L, x);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
////typedef Real TReal;
//template <class TReal>
//void GetCrossSectionDeformationDiff(const ConstSizeVectorBase<TReal, CObjectANCFBeam::nODE2coordinates>& qANCF,
//	ConstSizeVectorBase<TReal, EXUstd::dim3D>& f, Real L, Real x)
//{
//	Vector3D localPosition({ x,0.,0. });
//	LinkedDataVector q0(qANCF, 0, CObjectANCFBeam::nODE2perNode);		//link node values to element vector
//	LinkedDataVector q1(qANCF, CObjectANCFBeam::nODE2perNode, CObjectANCFBeam::nODE2perNode);		//link node values to element vector
//
//	SlimVectorBase<TReal, 3> slopeX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, CObjectANCFBeam::nSFperNode,
//		EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_x(localPosition, L), q0, q1);
//	SlimVectorBase<TReal, 3> slopeY = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, CObjectANCFBeam::nSFperNode,
//		EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_y(localPosition, L), q0, q1);
//	SlimVectorBase<TReal, 3> slopeZ = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, CObjectANCFBeam::nSFperNode,
//		EXUstd::dim3D>(CObjectANCFBeam::ComputeShapeFunctions_z(localPosition, L), q0, q1);
//	//SlimVectorBase<TReal, 3> slopeYX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_yx(localPosition, L), q0, q1);
//	//SlimVectorBase<TReal, 3> slopeZX = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(ComputeShapeFunctions_zx(localPosition, L), q0, q1);
//
//	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	//gamma1 = t1*slopeX - 1
//	//gamma2 = t2*slopeX
//	//gamma3 = t3*slopeX
//
//	Vector3D ti[3];
//	for (Index i = 0; i < EXUstd::dim3D; i++)
//	{
//		ti[i] = GetBasisI(i,
//			slopeY.X(), slopeY.Y(), slopeY.Z(),
//			slopeZ.X(), slopeZ.Y(), slopeZ.Z());
//		ti[i].Normalize();
//	}
//
//	f.SetVector({ ti[0] * slopeX - 1.,
//				  ti[1] * slopeX,
//				  ti[2] * slopeX });
//
//}


void CObjectANCFBeam::GetDeltaCrossSectionDeformation(Real x, ConstSizeMatrix<EXUstd::dim3D * CObjectANCFBeam::nODE2coordinates>& deltaCrossSectionDeformation,
	ConstSizeVector<EXUstd::dim3D>& crossSectionDeformation) const
{
	//compute twist and curvature (kappa)
	//use automatic differentiation for deltaKappa!
	Real L = parameters.physicsLength;
	Vector3D localPosition({ x,0.,0. });
	const Index dim3D = EXUstd::dim3D;

	ConstSizeVector<nODE2coordinates> qANCF;
	ComputeCurrentObjectCoordinates(qANCF);

	//EXUmath::AutoDiffVectors<dim3D, nODE2coordinates>(GetCrossSectionDeformationDiff<EXUmath::AutoDiff<nODE2coordinates, Real>>, qANCF, deltaCrossSectionDeformation, L, x);
	//GetCrossSectionDeformationDiff<Real>(qANCF, crossSectionDeformation, L, x);

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	LinkedDataVector q0(qANCF, 0, nODE2perNode);		//link node values to element vector
	LinkedDataVector q1(qANCF, nODE2perNode, nODE2perNode);		//link node values to element vector

	SlimVector<nSFperNode*nNodes> SV_y = ComputeShapeFunctions_y(localPosition, L);
	SlimVector<nSFperNode*nNodes> SV_z = ComputeShapeFunctions_z(localPosition, L);

	Vector3D slopeY = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, dim3D>(SV_y, q0, q1);
	Vector3D slopeZ = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, dim3D>(SV_z, q0, q1);

	deltaCrossSectionDeformation.SetNumberOfRowsAndColumns(dim3D, nODE2coordinates);
	deltaCrossSectionDeformation.SetAll(0.);

	crossSectionDeformation.SetVector({
		0.5*(slopeY*slopeY - 1.),
		0.5*(slopeZ*slopeZ - 1.),
		0.5*(slopeY*slopeZ) }); //0.5 according to paper, but 1 in 2013 implementation

	//d(csd)/q = [slopeY.T*SV_y; slopeZ.T*SV_z; slopeY.T*SV_y + slopeZ.T*SV_z ] // ';' separates rows

	for (Index i = 0; i < dim3D; i++)
	{
		for (Index j = 0; j < nSFperNode*nNodes; j++)
		{
			Index col = j * dim3D + i;
			deltaCrossSectionDeformation(0, col) += slopeY[i] * SV_y[j];
			deltaCrossSectionDeformation(1, col) += slopeZ[i] * SV_z[j];
			deltaCrossSectionDeformation(2, col) += 0.5*(slopeY[i] * SV_z[j] + slopeZ[i] * SV_y[j]);
		}

	}
}



//! Computational function: compute mass matrix
void CObjectANCFBeam::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	PreComputeMassTerms();
	massMatrix.CopyFrom(precomputedMassMatrix); //copy
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectANCFBeam::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	ConstSizeVector<nODE2coordinates> qANCF;
	ConstSizeVector<nODE2coordinates> qANCF_t;
	ComputeCurrentObjectCoordinates(qANCF);
	ComputeCurrentObjectVelocities(qANCF_t);
	//ComputeODE2LHStemplate<Real>(ode2Lhs, qANCF, qANCF_t);

	typedef Real TReal;

	//this could be templated:
	ode2Lhs.SetNumberOfItems(nODE2coordinates);
	ode2Lhs.SetAll(0.);
	//compute work of elastic forces:

	Real L = parameters.physicsLength;
	const Index dim3D = EXUstd::dim3D;
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	const Index orderCurvature = 1; //reduced integration for two nodes, otherwise locking!
	const Index orderAxialShear = 1;
	const Index orderCrossSection = 1; //Lobatto!!!
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//for thickness stiffness, take average of shear stiffness: 0.5*(GAy+GAz)

	ConstSizeMatrixBase<TReal, dim3D * nODE2coordinates> deltaDeformation(dim3D, nODE2coordinates); //for deltaKappa, delta...
	ConstSizeVectorBase<TReal, dim3D> deformation; //kappa, axialShear, etc.

	ConstSizeVector<EXUmath::maxIntegrationPoints> intPoints;
	ConstSizeVector<EXUmath::maxIntegrationPoints> intWeights;
	EXUmath::SetGaussIntegrationRule(orderCurvature, intPoints, intWeights);
	Real a = -0.5*L; //integration interval [a,b]
	Real b = 0.5*L;

	//compute twist and curvature terms:
	for (Index ix = 0; ix < intPoints.NumberOfItems(); ix++) //shape functions are linear, so order 3 shall be enough!
	{
		Real factInt = intWeights[ix] * 0.5*(b - a);
		Real x = 0.5*(b - a)*intPoints[ix] + 0.5*(b + a);

		GetDeltaLocalTwistAndCurvature(x, deltaDeformation, deformation);

		deformation.MultComponentWise(factInt*parameters.physicsTorsionalBendingStiffness);

		EXUmath::MultMatrixTransposedVectorAddTemplate(deltaDeformation, deformation, ode2Lhs);
	}

	//compute axial and shear terms:
	EXUmath::SetGaussIntegrationRule(orderAxialShear, intPoints, intWeights);
	for (Index ix = 0; ix < intPoints.NumberOfItems(); ix++) //shape functions are linear, so order 3 shall be enough!
	{
		Real factInt = intWeights[ix] * 0.5*(b - a);
		Real x = 0.5*(b - a)*intPoints[ix] + 0.5*(b + a);

		GetDeltaLocalAxialShearDeformation(x, deltaDeformation, deformation);

		deformation.MultComponentWise(factInt*parameters.physicsAxialShearStiffness);

		EXUmath::MultMatrixTransposedVectorAddTemplate(deltaDeformation, deformation, ode2Lhs);
	}

	//compute cross section deformation terms:
	Real EA = parameters.physicsAxialShearStiffness[0];
	Real GA2 = parameters.physicsAxialShearStiffness[1] + parameters.physicsAxialShearStiffness[2]; //add both, if different
	Vector3D kCS({ EA,EA,GA2 }); //according to paper
	kCS.MultComponentWise(parameters.crossSectionPenaltyFactor); //additional factors

	//EXUmath::SetGaussIntegrationRule(orderCrossSection, intPoints, intWeights);
	EXUmath::SetLobattoIntegrationRule(orderCrossSection, intPoints, intWeights);
	for (Index ix = 0; ix < intPoints.NumberOfItems(); ix++) //shape functions are linear, so order 3 shall be enough!
	{
		Real factInt = intWeights[ix] * 0.5*(b - a);
		Real x = 0.5*(b - a)*intPoints[ix] + 0.5*(b + a);

		GetDeltaCrossSectionDeformation(x, deltaDeformation, deformation);


		deformation.MultComponentWise(factInt*kCS);
		//deformation *= kThickness * factInt;

		EXUmath::MultMatrixTransposedVectorAddTemplate(deltaDeformation, deformation, ode2Lhs);
	}


}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
template<class TReal>
void CObjectANCFBeam::ComputeODE2LHStemplate(VectorBase<TReal>& ode2Lhs, 
	const ConstSizeVectorBase<TReal, nODE2coordinates>& qANCF, const ConstSizeVectorBase<TReal, nODE2coordinates>& qANCF_t) const
{
	//currently all done in ComputeODE2LHS, which is already templated ...
	//would require to remove automatic differentiation from deltaKappa and deltaGamma terms ...
}

////! jacobian of LHS, w.r.t. position AND velocity level coordinates
////void CObjectANCFBeam::ComputeJacobianODE2_ODE2(ResizableMatrix& jacobian, ResizableMatrix& jacobian_ODE2_t) const
//void CObjectANCFBeam::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp, 
//	Real factorODE2, Real factorODE2_t,
//	Index objectNumber, const ArrayIndex& ltg) const
//{
//	const Index ns = 4;   //number of shape functions
//	ConstSizeVector<2*ns> qANCF0;
//	ConstSizeVector<2*ns> qANCF0_t;
//	ConstSizeVectorBase<DReal16, 2*ns> qANCF;
//	ConstSizeVectorBase<DReal16, 2*ns> qANCF_t;
//	ComputeCurrentObjectCoordinates(qANCF0);
//	ComputeCurrentObjectVelocities(qANCF0_t);
//	for (Index i = 0; i < 2 * ns; i++)
//	{
//		qANCF[i] = qANCF0[i];
//		qANCF_t[i] = qANCF0_t[i];
//		qANCF[i].DValue((int)i) = 1; //mark that this is the corresponding derivative
//		qANCF_t[i].DValue((int)(i+2*ns)) = 1; //mark that this is the corresponding derivative; velocity derivatives are in second block
//	}
//	ConstSizeVectorBase<DReal16, 2 * ns> ode2Lhs;
//	LinkedDataVectorBase<DReal16> linkedOde2Lhs(ode2Lhs); //added because of decoupling of ConstSizeVectorBase
//
//	ComputeODE2LHStemplate<DReal16>(linkedOde2Lhs, qANCF, qANCF_t);
//
//	jacobianODE2.SetUseDenseMatrix(true);
//	ResizableMatrix& jac = jacobianODE2.GetInternalDenseMatrix();
//	jac.SetNumberOfRowsAndColumns(2 * ns, 2 * ns);
//
//	//now copy autodifferentiated result:
//	for (Index i = 0; i < 2 * ns; i++)
//	{
//		for (Index j = 0; j < 2 * ns; j++)
//		{
//			jac(i, j) = factorODE2*ode2Lhs[i].DValue((int)j) + factorODE2_t*ode2Lhs[i].DValue((int)(j + 2 * ns));
//		}
//	}
//
//	//jacobian.SetNumberOfRowsAndColumns(2 * ns, 2 * ns);
//	//jacobian_ODE2_t.SetNumberOfRowsAndColumns(2 * ns, 2 * ns);
//
//	////now copy autodifferentiated result:
//	//for (Index i = 0; i < 2 * ns; i++)
//	//{
//	//	for (Index j = 0; j < 2 * ns; j++)
//	//	{
//	//		jacobian(i, j) = ode2Lhs[i].DValue((int)j);
//	//		jacobian_ODE2_t(i, j) = ode2Lhs[i].DValue((int)(j+2*ns));
//	//	}
//	//}
//}


//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectANCFBeam::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		//TODO: (Index)AccessFunctionType::AngularVelocity_qt +
		//TODO: (Index)AccessFunctionType::JacobianTtimesVector_q +
		(Index)AccessFunctionType::DisplacementMassIntegral_q);
}

////! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
//OutputVariableType CObjectANCFBeam::GetOutputVariableTypes() const
//{
//	return (OutputVariableType)((Index)OutputVariableType::Position + (Index)OutputVariableType::Velocity);
//}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectANCFBeam::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	Real L = parameters.physicsLength;

	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> SV = ComputeShapeFunctions(localPosition, L);
		value.SetNumberOfRowsAndColumns(3, 8); //3D velocity, 8 coordinates qt
		//pout << "inside ..." << localPosition << "\n";

		value.SetAll(0.);
		for (Index i = 0; i < EXUstd::dim3D; i++)
		{
			for (Index j = 0; j < nSFperNode*nNodes; j++)
			{
				value(i, j*EXUstd::dim3D + i) = SV[j];
			}
		}

		break;
	}
	case AccessFunctionType::AngularVelocity_qt:
	{
		CHECKandTHROWstring("CObjectANCFBeam::GetAccessFunctionBody(AngularVelocity_qt): not implemented!");

		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		//COM assumed to be at y=z=0 !!!

		//CHECKandTHROW((localPosition[1] == 0 && localPosition[2] == 0),
		//	"CObjectANCFBeam::GetAccessFunctionBody(DisplacementMassIntegral_q): only implemented for y=z=0!");

		value.SetNumberOfRowsAndColumns(3, 8); //3D velocity, 8 coordinates qt
		value.SetAll(0.);

		Real L = parameters.physicsLength;
		Real rhoA = parameters.physicsMassPerLength;

		Index cnt = 0;
		Real a = 0; //integration interval [a,b]
		Real b = L;

		SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> SV(0.);

		for (auto item : EXUmath::gaussRuleOrder3Points)
		{
			Real x = 0.5*(b - a)*item + 0.5*(b + a);
			SlimVector<CObjectANCFBeam::nSFperNode*CObjectANCFBeam::nNodes> SVloc = ComputeShapeFunctions(Vector3D({x,0.,0.}), L);
			SVloc *= rhoA * (0.5*(b - a)*EXUmath::gaussRuleOrder3Weights[cnt++]);
			SV += SVloc;
		}

		value.SetAll(0.);
		for (Index i = 0; i < EXUstd::dim3D; i++)
		{
			for (Index j = 0; j < nSFperNode*nNodes; j++)
			{
				value(i, j*EXUstd::dim3D + i) = SV[j];
			}
		}
		break;
	}
	default:
		SysError("CObjectANCFBeam:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectANCFBeam::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	//outputVariables = "{
	//'Position':'global position vector of local axis (1) and cross section (2) position', 
	//'Velocity':'global velocity vector of local axis (1) and cross section (2) position', 
	//'Director1':'(axial) slope vector of local axis position', 
	//'Strain':'axial strain (scalar)', 
	//'Curvature':'axial strain (scalar)', 
	//'Force':'(local) section normal force (scalar)', 
	//'Torque':'(local) bending moment (scalar)'}"
	//Real x = localPosition[0];
	//Real y = localPosition[1];

	switch (variableType)
	{
	case OutputVariableType::Position:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration)); break;
	}
	case OutputVariableType::Displacement:	
	{
		value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	}
	case OutputVariableType::Velocity:
	{
		value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::VelocityLocal:
	{
		value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed() * 
			GetVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::Acceleration:
	{
		//only for ANCFCable, but not ALEANCF ==> not included in GetOutputVariableTypes(...)
		value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	}
	case OutputVariableType::AngularVelocity:
	{
		//independent of y, but correct
		value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	}
	case OutputVariableType::AngularVelocityLocal:
	{
		//independent of y, but correct
		value.CopyFrom(GetAngularVelocityLocal(localPosition, configuration)); break;
	}
	//case OutputVariableType::AngularAcceleration:
	//{
	//	//only for ANCFCable, but not ALEANCF
	//	//independent of y, but correct
	//	value.CopyFrom(GetAngularAcceleration(localPosition, configuration)); break;
	//}
	case OutputVariableType::Rotation:
	{
		Matrix3D A = GetRotationMatrix(localPosition, configuration);
		value.CopyFrom(RigidBodyMath::RotationMatrix2RotXYZ(A)); break;
	}
	case OutputVariableType::RotationMatrix:
	{
		Matrix3D A = GetRotationMatrix(localPosition, configuration);
		value.SetVector(9, A.GetDataPointer());
	}
	//case OutputVariableType::Director1: {
	//	//CHECKandTHROW(y == 0., "CObjectANCFBeam::GetOutputVariableBody: Y-component of localPosition must be zero for Director1");
	//	Vector2D rx = ComputeSlopeVector(localPosition[0], configuration);
	//	value.SetVector({rx[0], rx[1], 0.});
	//	break; }
	//case OutputVariableType::StrainLocal:	
	//{
	//	//CHECKandTHROW(y == 0., "CObjectANCFBeam::GetOutputVariableBody: Y-component of localPosition must be zero for StrainLocal");
	//	Real strain = ComputeAxialStrain(x, configuration);
	//	if (y != 0.)
	//	{
	//		strain -= y * ComputeCurvature(x, configuration);
	//	}

	//	value.SetVector({ strain }); 
	//	break;
	//}
	//case OutputVariableType::CurvatureLocal:	
	//{
	//	//CHECKandTHROW(y == 0., "CObjectANCFBeam::GetOutputVariableBody: Y-component of localPosition must be zero for CurvatureLocal");
	//	value.SetVector({ ComputeCurvature(x, configuration) });
	//	break;
	//}
	//case OutputVariableType::ForceLocal: {
	//	//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFBeam::GetOutputVariableBody: Y-component of localPosition must be zero for ForceLocal");
	//	Real physicsBendingStiffness, physicsAxialStiffness, bendingDamping, axialDamping, physicsReferenceAxialStrain, physicsReferenceCurvature;
	//	GetMaterialParameters(physicsBendingStiffness, physicsAxialStiffness, bendingDamping, axialDamping, physicsReferenceAxialStrain, physicsReferenceCurvature);

	//	Real axialStrainRef = physicsReferenceAxialStrain;
	//	if (StrainIsRelativeToReference() != 0.)
	//	{
	//		Vector2D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
	//		axialStrainRef += StrainIsRelativeToReference()*(rxRef.GetL2Norm() - 1.);
	//	}

	//	Real force = physicsAxialStiffness * (ComputeAxialStrain(x, configuration) - axialStrainRef);
	//	if (axialDamping != 0) { force += axialDamping * ComputeAxialStrain_t(x, configuration); }

	//	value.SetVector({ force }); break;
	//}
	//case OutputVariableType::TorqueLocal: {
	//	//do not add this due to drawing function: CHECKandTHROW(y == 0., "CObjectANCFBeam::GetOutputVariableBody: Y-component of localPosition must be zero for TorqueLocal");
	//	Real physicsBendingStiffness, physicsAxialStiffness, physicsReferenceAxialStrain, physicsReferenceCurvature, bendingDamping, axialDamping;
	//	GetMaterialParameters(physicsBendingStiffness, physicsAxialStiffness, bendingDamping, axialDamping, physicsReferenceAxialStrain, physicsReferenceCurvature);

	//	Real curvatureRef = physicsReferenceCurvature;
	//	if (StrainIsRelativeToReference() != 0.)
	//	{
	//		Vector2D rxRef = ComputeSlopeVector(x, ConfigurationType::Reference);
	//		Vector2D rxxRef = ComputeSlopeVector_x(x, ConfigurationType::Reference);

	//		Real rxNorm2ref = rxRef.GetL2NormSquared();
	//		Real rxCrossRxxRef = rxRef.CrossProduct2D(rxxRef);
	//		curvatureRef += StrainIsRelativeToReference()*(rxCrossRxxRef / rxNorm2ref);
	//	}

	//	Real torque = physicsBendingStiffness * (ComputeCurvature(x, configuration) - curvatureRef);
	//	if (bendingDamping != 0) { torque += bendingDamping * ComputeCurvature_t(x, configuration); }
	//	value.SetVector({ torque }); break;
	//}
	default:
		SysError("CObjectANCFBeam::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFBeam::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	SlimVector<nSFperNode*nNodes> SV = ComputeShapeFunctions(localPosition, parameters.physicsLength);

	Vector3D v = ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(SV, 
		((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));

	if (configuration != ConfigurationType::Reference)
	{
		v += ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(SV,
			((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector(), ((CNodeODE2*)GetCNode(1))->GetReferenceCoordinateVector());
	}

	return v;

}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectANCFBeam::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	SlimVector<nSFperNode*nNodes> SV = ComputeShapeFunctions(localPosition, parameters.physicsLength);

	return ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(SV,
		((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectANCFBeam::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	SlimVector<nSFperNode*nNodes> SV = ComputeShapeFunctions(localPosition, parameters.physicsLength);

	return ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(SV,
		((CNodeODE2*)GetCNode(0))->GetCoordinateVector_tt(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_tt(configuration));
}

////  return the (global) acceleration of "localPosition" according to configuration type
//Vector3D CObjectANCFBeam::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
//{
//	SlimVector<nSFperNode*nNodes> SV = ComputeShapeFunctions(localPosition, parameters.physicsLength);
//
//	return ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(SV,
//		((CNodeODE2*)GetCNode(0))->GetCoordinateVector_tt(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_tt(configuration));
//}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectANCFBeam::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	SlimVector<nSFperNode*nNodes> SV = ComputeShapeFunctions(localPosition, parameters.physicsLength);

	return ExuMath::MapCoordinates2Nodes<Real, LinkedDataVector, nSFperNode, EXUstd::dim3D>(SV,
		((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
}

Matrix3D CObjectANCFBeam::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	//return ((CNodeODE2*)GetCNode(0))->GetRotationMatrix(configuration);

	//compute slope vector:
	Real x = localPosition[0]; //only x-coordinate
	Vector3D slopeX;
	Vector3D slopeY;
	Vector3D slopeZ;
	ComputeSlopeVectors(x, configuration, slopeX, slopeY, slopeZ);

	Matrix3D A;
	EXUmath::OrthogonalBasisFromVectorsZY(slopeY, slopeZ, A);
	return A;
}

HomogeneousTransformation CObjectANCFBeam::GetLocalPositionFrame(const Vector3D& localPosition,
	ConfigurationType configuration) const
{
	return HomogeneousTransformation(GetRotationMatrix(localPosition, configuration), GetPosition(localPosition, configuration));
}


//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CObjectANCFBeam::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("ObjectANCFBeamBase::GetAngularVelocity: not implemented!");
	return Vector3D();

	////for details see GetAngularVelocity in Point3DSlope23

	//Real xLoc = localPosition[0]; //only x-coordinate
	//Vector2D slope = ComputeSlopeVector(xLoc, configuration);
	//Real x = slope[0]; //x-slopex
	//Real y = slope[1]; //y-slopex

	//Vector4D SVx = ComputeShapeFunctions_x(xLoc, parameters.physicsLength);
	//Vector2D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector_t(configuration));
	////Vector2D slope_t = MapCoordinates(SVx, ((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t(), ((CNodeODE2*)GetCNode(1))->GetCurrentCoordinateVector_t());

	////compare this function to GetRotationMatrix(...)
	//return Vector3D({ 0., 0., (-y * slope_t[0] + x * slope_t[1]) / (x*x + y * y) });
}

////! return configuration dependent angular acceleration of node; returns always a 3D Vector
//Vector3D CObjectANCFBeam::GetAngularAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
//{
//	CHECKandTHROWstring("ObjectANCFBeamBase::GetAngularVelocity: not implemented!");
//	return Vector3D();
//}
//

//Vector2D CObjectANCFBeam::ComputeSlopeVector_x(Real x, ConfigurationType configuration) const
//{
//	Vector4D SVxx = ComputeShapeFunctions_xx(x, parameters.physicsLength);
//
//	Vector2D slope_x = MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(configuration));
//	if (configuration != ConfigurationType::Reference) //add reference configuration to any current, initial, visualization coordinates (except reference configuration!)
//	{
//		slope_x += MapCoordinates(SVxx, ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Reference), ((CNodeODE2*)GetCNode(1))->GetCoordinateVector(ConfigurationType::Reference));
//	}
//
//	return slope_x;
//
//}

////!  compute the axial strain at a certain axial position, for given configuration
//Real CObjectANCFBeam::ComputeAxialStrain(Real x, ConfigurationType configuration) const 
//{
//	Vector2D rx = ComputeSlopeVector(x, configuration);
//
//	Real rxNorm2 = rx.GetL2NormSquared();
//	Real rxNorm = sqrt(rxNorm2);
//	return rxNorm - 1.; // axial strain
//}
//
////!  compute the (bending) curvature at a certain axial position, for given configuration
//Real CObjectANCFBeam::ComputeCurvature(Real x, ConfigurationType configuration) const
//{
//	Vector2D rx = ComputeSlopeVector(x, configuration);
//	Vector2D rxx = ComputeSlopeVector_x(x, configuration);
//
//	Real rxNorm2 = rx.GetL2NormSquared(); //computation see ComputeODE2LHS(...)
//	//Real rxNorm = sqrt(rxNorm2);
//	Real rxCrossRxx = rx.CrossProduct2D(rxx);
//	return rxCrossRxx / rxNorm2; //curvature
//}


