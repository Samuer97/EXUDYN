/** ***********************************************************************************************
* @brief        CObjectKinematicTree implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"

#include "Main/CSystemData.h"
#include "Linalg/RigidBodyMath.h"
//#include "Linalg/KinematicsBasics.h" //included in CObjectKinematicTree.h

#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/CObjectKinematicTree.h"

//**delete
//#include <pybind11/pybind11.h>
//#include <pybind11/stl.h>
//#include <pybind11/stl_bind.h>
//#include <pybind11/operators.h>
//#include <pybind11/numpy.h>       //interface to numpy
//#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
//#include <pybind11/embed.h>       //scoped interpreter
////does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
////#include <pybind11/cast.h> //for arguments
//#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes



//! Computational function: compute mass matrix
void CObjectKinematicTree::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	//massMatrixC.SetUseDenseMatrix(true); //uses sparse matrix with no entries.
	//Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	//Index nODE2 = GetODE2Size();
	//massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
	//massMatrix.SetAll(0.);

	//LinkedDataVector q(GetCNode(0)->GetCurrentCoordinateVector());
	//LinkedDataVector q_t(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t());

	//LinkedDataVector qRef(GetCNode(0)->GetReferenceCoordinateVector());

	ComputeMassMatrixAndODE2LHS(&massMatrixC, &ltg, nullptr, objectNumber, true);

}

//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//in fact, this is the LHS function!
void CObjectKinematicTree::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	//done in ComputeMassMatrixAndODE2LHS:
	//ode2Lhs.SetNumberOfItems(nODE2);
	//ode2Lhs.SetAll(0.);

	ComputeMassMatrixAndODE2LHS(nullptr, nullptr, &ode2Lhs, objectNumber, false);


}

//! AUTO:  return the available jacobian dependencies and the jacobians which are available as a function; if jacobian dependencies exist but are not available as a function, it is computed numerically; can be combined with 2^i enum flags
JacobianType::Type CObjectKinematicTree::GetAvailableJacobians() const
{
	return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t);
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectKinematicTree::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt +
		(Index)AccessFunctionType::DisplacementMassIntegral_q + (Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectKinematicTree::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	SysError("CObjectKinematicTree:GetAccessFunctionBody not available");
}

//! provide according output variable in "value"
void CObjectKinematicTree::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	//Index nODE2 = GetODE2Size();

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(GetCNode(0)->GetCurrentCoordinateVector() + GetCNode(0)->GetReferenceCoordinateVector());	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t());	break;
	case OutputVariableType::Coordinates_tt: 
	{
		value.CopyFrom(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_tt());
		break;
	}
	case OutputVariableType::Force:			ComputeODE2LHS(value, objectNumber);	break;
	default:
		SysError("CObjectKinematicTree::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectKinematicTree::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	//CHECKandTHROWstring("CObjectKinematicTree::GetPosition: function not available");
	//return { 0,0,0 };
	return parameters.baseOffset; //used e.g. for Sensors!
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + localPosition;

}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectKinematicTree::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectKinematicTree::GetVelocity: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration);
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectKinematicTree::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectKinematicTree::GetDisplacement: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     KINEMATIC TREE MAIN FUNCTIONS     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! compute joint transformation T and motion subspace MS for jointType and joint value q
void CObjectKinematicTree::JointTransformMotionSubspace66(Joint::Type jointType, Real q, Transformation66& T, Vector6D& MS) const
{
	switch (jointType)
	{
	case Joint::RevoluteX:
	{
		T = RigidBodyMath::RotationTranslation2T66(RigidBodyMath::RotationMatrix1(-q), Vector3D({ 0.,0.,0. }));
		MS = Vector6D({ 1., 0., 0., 0., 0., 0. });
		break;
	}
	case Joint::RevoluteY:
	{
		T = RigidBodyMath::RotationTranslation2T66(RigidBodyMath::RotationMatrix2(-q), Vector3D({ 0.,0.,0. }));
		MS = Vector6D({ 0., 1., 0., 0., 0., 0. });
		break;
	}
	case Joint::RevoluteZ:
	{
		T = RigidBodyMath::RotationTranslation2T66(RigidBodyMath::RotationMatrix3(-q), Vector3D({ 0.,0.,0. }));
		MS = Vector6D({ 0., 0., 1., 0., 0., 0. });
		break;
	}
	case Joint::PrismaticX:
	{
		T = RigidBodyMath::RotationTranslation2T66(EXUmath::unitMatrix3D, Vector3D({ q, 0., 0. }));
		MS = Vector6D({ 0., 0., 0., 1., 0., 0. });
		break;
	}
	case Joint::PrismaticY:
	{
		T = RigidBodyMath::RotationTranslation2T66(EXUmath::unitMatrix3D, Vector3D({ 0., q, 0. }));
		MS = Vector6D({ 0., 0., 0., 0., 1., 0. });
		break;
	}
	case Joint::PrismaticZ:
	{
		T = RigidBodyMath::RotationTranslation2T66(EXUmath::unitMatrix3D, Vector3D({ 0., 0., q }));
		MS = Vector6D({ 0., 0., 0., 0., 0., 1. });
		break;
	}
	default:
		SysError("CObjectKinematicTree::JointTransformMotionSubspace66 failed"); //error should not occur, because types are checked!
	}

}

//! compute negative 6D gravity to be used in Pluecker transforms
void CObjectKinematicTree::GetNegativeGravity6D(Vector6D& gravity6D) const
{
	gravity6D[0] = 0.; 
	gravity6D[1] = 0.; 
	gravity6D[2] = 0.;
	gravity6D[3] = -parameters.gravity[0];
	gravity6D[4] = -parameters.gravity[1];
	gravity6D[5] = -parameters.gravity[2];
}


//! compute object coordinates composed from all nodal coordinates; does not include reference coordinates
void CObjectKinematicTree::ComputeTreeTransformations(ConfigurationType configuration, bool computeVelocitiesAccelerations, 
	Transformations66List& Xup, Vector6DList& V, Vector6DList& Avp) const
{
	Index n = GetODE2Size();
	if (computeVelocitiesAccelerations)
	{
		Xup.SetNumberOfItems(n);
		V.SetNumberOfItems(n);
	}
	Vector6D negGravity6D;
	GetNegativeGravity6D(negGravity6D);

	LinkedDataVector q(GetCNode(0)->GetCoordinateVector(configuration));
	LinkedDataVector q_t(((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration));
	LinkedDataVector qRef(GetCNode(0)->GetReferenceCoordinateVector());

	Vector6D MS; //motion subspace
	Transformation66 XJ; //transformation from previous to this link

	//iterate over all joints in kinematic tree
	for (Index i = 0; i < n; i++)
	{
		JointTransformMotionSubspace66(parameters.jointTypes[i], q[i]+qRef[i], XJ, MS);
		Transformation66 XL=RigidBodyMath::RotationTranslation2T66Inverse(parameters.jointTransformations[i], parameters.jointOffsets[i]);
		Xup[i] = XJ * XL; 

		if (computeVelocitiesAccelerations)
		{
			Vector6D avp;
			Vector6D vJ = MS * q_t[i];
			if (parameters.linkParents[i] == CObjectKinematicTree::noParent)
			{
				V[i] = vJ;
				avp = Xup[i] * negGravity6D;
			}
			else
			{
				V[i] = Xup[i] * V[parameters.linkParents[i]] + vJ;
				avp = Xup[i] * Avp[parameters.linkParents[i]] + RigidBodyMath::T66SkewMotion(V[i]) * vJ;
			}
		}
	}
}

//! compute object coordinates composed from all nodal coordinates; does not include reference coordinates
void CObjectKinematicTree::ComputeMassMatrixAndODE2LHS(EXUmath::MatrixContainer* massMatrixC, const ArrayIndex* ltg, Vector* ode2Lhs, 
	Index objectNumber, bool computeMass) const
{
	Index n = GetODE2Size();

	Transformations66List& Xup = jointTransformations;
	Vector6DList& MS = motionSubspaces;
	Vector6DList& V = jointVelocities;
	Vector6DList& Avp = jointAccelerations;
	Vector6DList& Fvp = jointForces;
	Transformations66List& IC = linkInertiasT66;

	Xup.SetNumberOfItems(n);
	MS.SetNumberOfItems(n);
	V.SetNumberOfItems(n);
	Avp.SetNumberOfItems(n);
	Fvp.SetNumberOfItems(n);
	IC.SetNumberOfItems(n);

	Vector6D negGravity6D;
	GetNegativeGravity6D(negGravity6D);

	//LinkedDataVector q(GetCNode(0)->GetCurrentCoordinateVector());
	//LinkedDataVector qRef(GetCNode(0)->GetReferenceCoordinateVector());
	tempVector.CopyFrom(GetCNode(0)->GetCurrentCoordinateVector());
	tempVector += GetCNode(0)->GetReferenceCoordinateVector();
	LinkedDataVector q(tempVector);
	LinkedDataVector q_t(((CNodeODE2*)GetCNode(0))->GetCurrentCoordinateVector_t());

	Transformation66 XJ; //transformation from previous to this link

	//iterate over all joints in kinematic tree
	//propagate velocities and accelerations from base to leaves, also propagate inertia forces to leaves
	for (Index i = 0; i < n; i++)
	{
		//pout << "*********************\nLINK" << i << "(computeMass=" << computeMass << "):\n";

		JointTransformMotionSubspace66(parameters.jointTypes[i], q[i], XJ, MS[i]);
		Transformation66 XL = RigidBodyMath::RotationTranslation2T66Inverse(parameters.jointTransformations[i], parameters.jointOffsets[i]);
		Xup[i] = XJ * XL;
		//pout << "XL=" << XL << "\n";
		//pout << "XJ=" << XJ << "\n";
		//pout << "MS=" << MS << "\n";
		//pout << "Xup=" << Xup << "\n";

		Vector6D vJ = MS[i] * q_t[i];
		if (parameters.linkParents[i] == CObjectKinematicTree::noParent)
		{
			V[i] = vJ;
			Avp[i] = Xup[i] * negGravity6D;
		}
		else
		{
			V[i] = Xup[i] * V[parameters.linkParents[i]] + vJ;
			Avp[i] = Xup[i] * Avp[parameters.linkParents[i]] + RigidBodyMath::T66SkewMotion(V[i]) * vJ;
		}
		IC[i] = RigidBodyMath::InertiaT66FromInertiaParameters(parameters.linkMasses[i], parameters.linkCOMs[i], parameters.linkInertiasCOM[i]);
		if (!computeMass)
		{
			Fvp[i] = IC[i]* Avp[i] + RigidBodyMath::T66SkewForce(V[i]) * (IC[i] * V[i]);
			//pout << "Fvp=" << Fvp[i] << "\n";
			//fvp[i] = self.inertias[i] @ avp[i] + CRF(v[i]) @ self.inertias[i] @ v[i]
		}
		//pout << "IC=" << IC[i] << "\n";
		//pout << "CRF=" << RigidBodyMath::T66SkewForce(V[i]) << "\n";

		//pout << "V=" << V[i] << "\n";
		//pout << "Avp=" << Avp[i] << "\n";

	}


	//	f = np.zeros(n)             #store joint forces
	//	M = np.zeros((n, n))         #store mass matrix
	if (!computeMass)
	{
		//+++++++++++++++++++++++++++++++++
		//add external forces to links
		AddExternalForces6D(Xup, Fvp); //adds global linkTorques / linkForces per link to Fvp using Xup transformations

		//+++++++++++++++++++++++++++++++++
		//now compute forces per joint:
		//propagate forces back from leaves to base:
		Vector& f = *ode2Lhs;
		f.SetNumberOfItems(n);
		f.SetAll(0.); //not needed, is directly written!

		for (Index i = n - 1; i >= 0; i--)
		{
			f[i] = MS[i] * Fvp[i];
			if (parameters.linkParents[i] != noParent)
			{
				Fvp[parameters.linkParents[i]] += Fvp[i] * Xup[i]; //Xup[i].T @ fvp[i]
				//Fvp[parameters.linkParents[i]] += Xup[i].GetTransposed() * Fvp[i]; //Xup[i].T @ fvp[i]
			}
		}

		//	#compute joint forces; REVERSED loop!
		//	for i in reversed(range(n)) :
		//		f[i] = MS[i].T @ fvp[i]
		//		if self.parents[i] != -1:
		//			fvp[self.parents[i]] += Xup[i].T @ fvp[i]

		if (parameters.jointForceVector.NumberOfItems() != 0)
		{
			f -= parameters.jointForceVector; //constant forces per coordinate (RevoluteJoint: local torque in joint)
		}

		for (Index i = 0; i < n; i++)
		{
			if (parameters.jointPositionOffsetVector.NumberOfItems() != 0) //P control checked automatically
			{
				f[i] -= parameters.jointPControlVector[i] * (parameters.jointPositionOffsetVector[i] - q[i]);
			}
			if (parameters.jointVelocityOffsetVector.NumberOfItems() != 0) //P control checked automatically
			{
				f[i] -= parameters.jointDControlVector[i] * (parameters.jointVelocityOffsetVector[i] - q_t[i]);
			}
		}

		//Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		//Real u = 0.25*M_PI*sin(t*0.1*M_PI);
		//Real u_t = 0.25*M_PI*cos(t*0.1*M_PI)*0.1*M_PI;
		//for (Index i = 0; i < n; i++)
		//{
		//	Real P = 1000*5;
		//	Real D = 50*5;
		//	f[i] -= P * (u - q[i]) + D * (u_t - q_t[i]);
		//}

		if (parameters.forceUserFunction)
		{
			Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
			Vector userForce;

			EvaluateUserFunctionForce(userForce, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempVector, tempVector2);
			CHECKandTHROW(userForce.NumberOfItems() == n, "CObjectKinematicTree: forceUserFunction return a vector with different size from ObjectKinematicTree system size");
			f -= userForce;
		}

	}
	else
	{
		massMatrixC->SetUseDenseMatrix();
		ResizableMatrix& M = massMatrixC->GetInternalDenseMatrix();
		M.SetScalarMatrix(n, 0.);

		//	#compute composite inertia
		//	#IC = deepcopy(self.inertias) #may cause problems if referenced np.arrays used!
		//	IC = [np.zeros((6, 6))] * n

		//	for i in range(n) :
		//		IC[i] = deepcopy(self.inertias[i])
		for (Index i = n - 1; i >= 0; i--)
		{
			if (parameters.linkParents[i] != noParent)
			{
				IC[parameters.linkParents[i]] += Xup[i].GetTransposed() * IC[i] * Xup[i];
			}
		}
		//	for i in reversed(range(n)) :
		//		if self.parents[i] != -1 :
		//			IC[self.parents[i]] += Xup[i].T @ IC[i] @ Xup[i]

		for (Index i = 0; i < n; i++)
		{
			Vector6D fh = IC[i] * MS[i];
			M(i, i) = MS[i] * fh;
			Index j = i;
			while (parameters.linkParents[j] != noParent)
			{
				fh = fh * Xup[j]; //Xup[j].T @ fh
				j = parameters.linkParents[j];
				M(i, j) = MS[i] * fh;
				M(j, i) = M(i, j);
			}
		}
		//	#compute generalized mass matrix and projected inertia
		//	for i in range(n) :
		//		fh = IC[i] @ MS[i]
		//		M[i, i] = MS[i].T @ fh
		//		j = i
		//		while self.parents[j] > -1:
		//			fh = Xup[j].T @ fh
		//			j = self.parents[j]
		//			M[i, j] = MS[j].T @ fh
		//			M[j, i] = M[i, j]

		//	return[M, f]
	}


}

//! compute object coordinates composed from all nodal coordinates; does not include reference coordinates
void CObjectKinematicTree::AddExternalForces6D(const Transformations66List& Xup, Vector6DList& Fvp) const
{
	Index n = GetODE2Size();
	Transformations66List& Xa = tempListT66;
	Xa.SetNumberOfItems(n);
	
	if (parameters.linkForces.NumberOfItems() != 0 || parameters.linkTorques.NumberOfItems())
	{
		for (Index i = 0; i < n; i++)
		{
			if (parameters.linkParents[i] == CObjectKinematicTree::noParent)
			{
				Xa[i] = Xup[i]; //not needed for forces: *baseTransform;
			}
			else
			{
				Xa[i] = Xup[i] * Xa[parameters.linkParents[i]];
			}
			Vector6D extForce6D(0.); //initialize with zeros, as only parts may be filled
			if (parameters.linkTorques.NumberOfItems())
			{
				extForce6D[0] = parameters.linkTorques[i][0];
				extForce6D[1] = parameters.linkTorques[i][1];
				extForce6D[2] = parameters.linkTorques[i][2];
			}
			if (parameters.linkForces.NumberOfItems() != 0)
			{
				extForce6D[3] = parameters.linkForces[i][0];
				extForce6D[4] = parameters.linkForces[i][1];
				extForce6D[5] = parameters.linkForces[i][2];
			}
			Fvp[i] += RigidBodyMath::T66MotionInverse(Xa[i].GetTransposed()) * extForce6D;
			
		}
	}

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! for definition see CObjectSuperElement
void CObjectKinematicTree::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, Matrix& value) const
{
	CHECKandTHROWstring("CObjectKinematicTree::GetAccessFunctionSuperElement: function not implemented");
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectKinematicTree::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	//independent of meshNodeNumber!!!
	OutputVariableType ovt = (OutputVariableType)(
		(Index)OutputVariableType::Position +
		(Index)OutputVariableType::Displacement +
		(Index)OutputVariableType::Velocity +
		(Index)OutputVariableType::Acceleration );

	return ovt;

}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectKinematicTree::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetOutputVariableSuperElement: meshNodeNumber out of range ");

	switch (variableType)
	{
	case OutputVariableType::Position:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration));	break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration) - GetMeshNodePosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::Velocity:	value.CopyFrom(GetMeshNodeVelocity(meshNodeNumber, configuration));	break;
	case OutputVariableType::Acceleration:	value.CopyFrom(GetMeshNodeAcceleration(meshNodeNumber, configuration));	break;
	default:
		SysError("CObjectKinematicTree::GetOutputVariableSuperElement failed"); //error should not occur, because types are checked!
	}
}

////! return the mesh node pointer; for consistency checks
//CNodeODE2* CObjectKinematicTree::GetMeshNode(Index meshNodeNumber) const
//{
//	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetMeshNode: meshNodeNumber out of range");
//
//	return nullptr; //there is no meshnode, its only virtual ...
//}

////! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
//Vector3D CObjectKinematicTree::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
//{
//	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetMeshNodeLocalPosition: meshNodeNumber out of range");
//	
//	CHECKandTHROWstring("CObjectKinematicTree::GetMeshNodeLocalPosition: not implemented");
//	return Vector3D();
//}

////! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
//Vector3D CObjectKinematicTree::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
//{
//	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetMeshNodeLocalVelocity: meshNodeNumber out of range ");
//
//	CHECKandTHROWstring("CObjectKinematicTree::GetMeshNodeLocalVelocity: not implemented");
//	return Vector3D();
//}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectKinematicTree::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetMeshNodePosition: meshNodeNumber out of range");

	CHECKandTHROWstring("CObjectKinematicTree::GetMeshNodePosition: not implemented");
	return Vector3D();
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectKinematicTree::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectKinematicTree::GetMeshNodeVelocity: meshNodeNumber out of range");

	CHECKandTHROWstring("CObjectKinematicTree::GetMeshNodeVelocity: not implemented");
	return Vector3D();
}

