/** ***********************************************************************************************
* @brief        Implementation of CObjectContactCurveCircles
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeGenericData.h"
#include "Autogenerated/CObjectContactCurveCircles.h"

#include "Linalg/Geometry.h"


//compute the properties which are needed for computation of LHS and needed for OutputVariables
//NOTE: all computations done in local 2D frame!
void CObjectContactCurveCircles::ComputeConnectorProperties(const MarkerDataStructure& markerData, Index itemIndex, LinkedDataVector& data, 
	bool useDataStates, Vector2D& forceMarker0, Real& torqueMarker0,
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize>& gapPerSegment,
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize>& gapPerSegment_t,
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize>& segmentsForceLocalX,
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize>& segmentsForceLocalY) const
{
	Index nSegments = GetNumberOfSegments();
	gapPerSegment.SetNumberOfItems(nSegments);
	gapPerSegment_t.SetNumberOfItems(nSegments);
	segmentsForceLocalX.SetNumberOfItems(nSegments);
	segmentsForceLocalY.SetNumberOfItems(nSegments);
	forceMarker0.SetAll(0.);
	torqueMarker0 = 0;


	Vector3D p0 = markerData.GetMarkerData(0).position;
	Vector3D v0 = markerData.GetMarkerData(0).velocity;
	Vector3D omega0local = markerData.GetMarkerData(0).angularVelocityLocal;
	
	//NOTE: here we need to include the rotationMarker0!
	Matrix3D A0 = markerData.GetMarkerData(0).orientation; //all quantities are rotated into the A0 frame!
	Matrix3D A0T = A0.GetTransposed();
	Vector3D v0Local = A0T * v0;
	Vector3D omega0 = A0 * omega0local;
	Vector2D v02D({ v0Local[0], v0Local[1] });
	Real omegaZ = omega0local[2];

	CHECKandTHROW(parameters.segmentsData.UseDenseMatrix(), "CObjectContactCurveCircles::ComputeConnectorProperties: segmentsData must be in dense matrix mode!");

	const ResizableMatrix& segData = parameters.segmentsData.GetInternalDenseMatrix();

	//pout << "****************************************\n";
	//initialize segments:
	for (Index jSeg = 0; jSeg < nSegments; jSeg++)
	{
		gapPerSegment[jSeg] = EXUstd::MAXREAL; //not needed in case that useDataStates=true, because gap not returned!
		gapPerSegment_t[jSeg] = EXUstd::MAXREAL;
		segmentsForceLocalX[jSeg] = 0;
		segmentsForceLocalY[jSeg] = 0;
		if (!useDataStates)
		{
			data[jSeg * nDataVariablesPerSegment + dataIndexCircle] = -1; //use invalid circle number; store only circles with collision
		}
	}

	for (Index iCircle = 0; iCircle < GetNumberOfCircles(); iCircle++)
	{
		Vector3D pc = A0T * (markerData.GetMarkerData(1 + iCircle).position - p0);
		Vector3D vc = A0T * markerData.GetMarkerData(1 + iCircle).velocity;
		Vector2D pc2D({ pc[0], pc[1] }); //circle position
		Vector2D vc2D({ vc[0], vc[1] }); //circle velocity
		Real radius = parameters.circlesRadii[iCircle];

		for (Index jSeg = 0; jSeg < nSegments; jSeg++)
		{
			if (!useDataStates || (useDataStates && data[jSeg * nDataVariablesPerSegment + dataIndexCircle] == iCircle) )
			{
				Vector2D p0({ segData(jSeg,0), segData(jSeg,1) });
				Vector2D p1({ segData(jSeg,2), segData(jSeg,3) });
				//compute shortest distance:
				//referenceCoordinatePerSegment is the relative position [0..1] of the shortest projected point at the line segment
				Real relPos;
				Vector2D contactVector; //points from projected segment point (or segment end point) to circle point
				Real distance = HGeometry::ShortestDistanceEndPointsRelativePosition(p0, p1, pc2D, relPos, contactVector);

				Vector2D segPoint = pc2D - contactVector;
				Vector2D n0 = contactVector;
				if (distance != 0.) { n0 *= 1. / distance; } //computes normal vector
				Real gap = distance - radius;

				//circle center vel - segment vel, both computed in local frame:
				Vector2D vRel = vc2D - (v02D + Vector2D({ -omegaZ * contactVector[1], omegaZ * contactVector[0] }));
				Real gap_t = vRel * n0;

				if (gap < gapPerSegment[jSeg]) //we only chose the segment with smallest gap!
				{
					gapPerSegment[jSeg] = gap;
					gapPerSegment_t[jSeg] = gap_t;
					if (!useDataStates && gap < 0)
					{
						data[jSeg * nDataVariablesPerSegment + dataIndexCircle] = iCircle;
					}
				}

				if ((!useDataStates && gap < 0) ||
					(useDataStates && data[jSeg * nDataVariablesPerSegment + dataIndexGap] < 0) ) //only follow decision of PostNewton step result!
				{
					Real fNormal = gap * parameters.contactStiffness + gap_t * parameters.contactDamping;

					if (!useDataStates && (segmentsForceLocalX[jSeg] != 0 || segmentsForceLocalY[jSeg] != 0) )
					{
						PyWarning(STDstring("CObjectContactCurveCircles::ComputeConnectorProperties: ") +
							"it seems that two circles contact segment " + EXUstd::ToString(jSeg) + " (current circle="+ EXUstd::ToString(iCircle) + ") at the same time; you have to use segments small enought that ONLY one circle may have contact with a segment at any time!");
					}
					//if (!useDataStates) {
					//	pout << "force: segment=" + EXUstd::ToString(jSeg) + ", circle=" + EXUstd::ToString(iCircle) << ", dist=" << distance << ", r=" << radius << "\n";}

					segmentsForceLocalX[jSeg] += fNormal * n0[0];
					segmentsForceLocalY[jSeg] += fNormal * n0[1];

					forceMarker0 += (-fNormal) * n0;

					//add torque on marker 0 ...!
					torqueMarker0 += segPoint.CrossProduct2D((-fNormal) * n0); //segPoint is given relative to Marker0!
				}
			}
		}
	}
	//if (!useDataStates)
	//{
	//	pout << "segments=";
	//	for (Index jSeg = 0; jSeg < nSegments; jSeg++)
	//	{
	//		pout << "  " << data[jSeg * nDataVariablesPerSegment + dataIndexCircle] << ":";
	//		pout << EXUstd::Num2String(data[jSeg * nDataVariablesPerSegment + dataIndexGap],3) << "\n";
	//	}
	//	pout << "\n";
	//}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectContactCurveCircles::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectContactCurveCircles::ComputeAlgebraicEquations: marker do not provide velocityLevel information");


	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	const bool useDataStates = true;
	Vector2D forceMarker0;
	Real torqueMarker0;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> gapPerSegment;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> gapPerSegment_t;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> segmentsForceLocalX;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> segmentsForceLocalY;

	ComputeConnectorProperties(markerData, objectNumber, data, useDataStates, forceMarker0, torqueMarker0,
		gapPerSegment, gapPerSegment_t, segmentsForceLocalX, segmentsForceLocalY);


	//link separate vectors to result (ode2Lhs) vector
	Index nODE2 = markerData.GetMarkerData(0).positionJacobian.NumberOfColumns();
	for (Index iCircle = 0; iCircle < GetNumberOfCircles(); iCircle++) 
	{
		nODE2 += markerData.GetMarkerData(1).positionJacobian.NumberOfColumns();
	}

	//ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetNumberOfItems(nODE2);
	ode2Lhs.SetAll(0.);

	////pout << "test\n";
	if (parameters.activeConnector)
	{
		Matrix3D A0 = markerData.GetMarkerData(0).orientation; //all quantities are rotated into the A0 frame!
		Vector3D p0 = markerData.GetMarkerData(0).position;

		//marker 1+iCircle / J (positive):    (according to computation of relative position)
		//now link ode2Lhs Vector to partial result using the two jacobians

		Index colOff = markerData.GetMarkerData(0).positionJacobian.NumberOfColumns();
		Index colsPerCircleMarker = markerData.GetMarkerData(1).positionJacobian.NumberOfColumns(); //must all be the same size!
		for (Index jSeg = 0; jSeg < GetNumberOfSegments(); jSeg++)
		{
			Index iCircle = (Index)data[jSeg * nDataVariablesPerSegment + dataIndexCircle];
			if (iCircle >= 0)
			{
				Index colsMarker = markerData.GetMarkerData(1+iCircle).positionJacobian.NumberOfColumns();
				CHECKandTHROW(colsPerCircleMarker == colsMarker, "CObjectContactCurveCircles::ComputeODE2LHS: circle markers must all have the same type and dimension!");

				Vector3D fVec3D({ segmentsForceLocalX[jSeg], segmentsForceLocalY[jSeg], 0. });
				fVec3D = A0 * fVec3D;

				LinkedDataVector ldv1(ode2Lhs, colOff + iCircle * colsPerCircleMarker, colsMarker);
				EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fVec3D, ldv1);


				//if (frictionCoeff != 0)
				//{
				//	Vector3D fRot = ((-parameters.spheresRadii[1] - 0.5 * gap) * n0).CrossProduct(fVec);
				//	EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, fRot, ldv1);
				//}
			}
		}


		////marker 0 / I (negative):
		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			Vector3D fVec3D({ forceMarker0[0], forceMarker0[1], 0. });
			fVec3D = A0 * fVec3D;
			Vector3D torqueVec3D({ 0., 0., torqueMarker0 });
			torqueVec3D = A0 * torqueVec3D;

			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, fVec3D, ldv0); //here we use no negative sign because forceMarker0 is already negative!

			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, torqueVec3D, ldv0);
		}
	}

}


//! provide according output variable in "value"
void CObjectContactCurveCircles::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();

	//ComputeConnectorProperties(markerData, itemIndex, data,
	//	frictionCoeff, gap, deltaP, deltaV, fVec, fFriction, n0);

	//switch (variableType)
	//{
	//case OutputVariableType::Displacement: value.CopyFrom(deltaP); break;
	//case OutputVariableType::DisplacementLocal: value.CopyFrom(Vector1D({gap})); break;
	//case OutputVariableType::Velocity: value.CopyFrom(deltaV); break;
	//case OutputVariableType::Director3: value.CopyFrom(n0); break;
	//case OutputVariableType::Force: value.CopyFrom(fVec); break;
	//case OutputVariableType::Torque: value.CopyFrom(((-parameters.spheresRadii[0] - 0.5 * gap) * n0).CrossProduct(fVec)); break;
	//default:
	//	SysError("CObjectContactCurveCircles::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	//}
}


//! function called after Newton method; returns a residual error (force); 
//! done for two different computation states in order to estimate the correct time of contact
Real CObjectContactCurveCircles::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
	//return force-type error in case of contact: in case that the assumed contact state has been wrong, 
	//  the contact force (also negative) is returned as measure of the error
	Real discontinuousError = 0;
	flags = PostNewtonFlags::_None;


	LinkedDataVector dataStartofStepState = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep);	//state0
	LinkedDataVector data = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current);			//state1

	const bool useDataStates = false;
	Vector2D forceMarker0;
	Real torqueMarker0;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> gapPerSegment;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> gapPerSegment_t;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> segmentsForceLocalX;
	ResizableConstVectorBase<Real, CObjectContactCurveCirclesMaxConstSize> segmentsForceLocalY;

	ComputeConnectorProperties(markerDataCurrent, itemIndex, data, useDataStates, forceMarker0, torqueMarker0,
		gapPerSegment, gapPerSegment_t, segmentsForceLocalX, segmentsForceLocalY);


	for (Index jSeg = 0; jSeg < GetNumberOfSegments(); jSeg++)
	{
		Real currentGap = gapPerSegment[jSeg];
		Index totalIndexGap = jSeg * nDataVariablesPerSegment + dataIndexGap;
		Real lastGap = data[totalIndexGap];
		//Real startofStepGap = dataStartofStepState[totalIndexGap];
		data[totalIndexGap] = currentGap;

		//compute error for gap:
		if ((currentGap > 0 && lastGap <= 0) || (currentGap <= 0 && lastGap > 0)) //action: state1=currentGapState, error = |currentGap*k|
		{
			discontinuousError = fabs(currentGap * parameters.contactStiffness);

			//in fact it is (0-startofStepState) which is the part of time to go in these steps!
			//startofStepGap<=0 caused in case of inappropriate initialization => no step recommendation, but try to re-iterate
			//if (gapPerSegment_t[jSeg] != 0 && startofStepGap > 0) { recommendedStepSize = fabs(startofStepGap / gapPerSegment_t[jSeg]); }

			flags = PostNewtonFlags::UpdateJacobian;
		}
	}


	return discontinuousError;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CObjectContactCurveCircles::PostDiscontinuousIterationStep() 
{

}





