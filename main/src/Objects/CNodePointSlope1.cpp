/** ***********************************************************************************************
* @brief		Implementation for NodePointSlope1
*
* @author		Gerstmayr Johannes
* @date			2019-06-15 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodePointSlope1.h"				//includes ReleaseAssert.h, BasicDefinitions.h, ResizeableArray.h, LinkedDataVector.h

Vector3D CNodePointSlope1::GetPosition(ConfigurationType configuration) const
{
	//p = pRef + u = reference position + displacement
	LinkedDataVector pRef3D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef3D[0], pRef3D[1] , pRef3D[2] });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	LinkedDataVector u3D = GetCoordinateVector(configuration);
	Vector3D displacement({ u3D[0], u3D[1] , u3D[2] });
	return pRef + displacement;
}

Vector3D CNodePointSlope1::GetVelocity(ConfigurationType configuration) const
{
    LinkedDataVector u3D_t = GetCoordinateVector_t(configuration);
    return Vector3D({ u3D_t[0], u3D_t[1] , u3D_t[2] });
}

Vector3D CNodePointSlope1::GetAcceleration(ConfigurationType configuration) const
{
    LinkedDataVector u3D_tt = GetCoordinateVector_tt(configuration);
    return Vector3D({ u3D_tt[0], u3D_tt[1] , u3D_tt[2] });
}

//! provide position jacobian of node; derivative of 3D Position with respect to 6 coordinates ux,uy and x/y "displacements" of slopex
void CNodePointSlope1::GetPositionJacobian(Matrix& value) const
{
	//derivative of position with respect to all coordinates
	value.SetMatrix(3, 6, {
		1.,0.,0.,0.,0.,0.,
		0.,1.,0.,0.,0.,0.,
		0.,0.,1.,0.,0.,0.});
}

Matrix3D CNodePointSlope1::GetRotationMatrix(ConfigurationType configuration) const
{
	//phi is the total angle
	return EXUmath::unitMatrix3D;
}
//
////! AUTO:  return configuration dependent velocity of node; returns always a 3D Vector
//Vector3D CNodePointSlope1::GetAngularVelocity(ConfigurationType configuration) const
//{
//	//atan2(y,x) = atan(y/x)
//	//diff(atan2(y,x),x) = -y/(x^2+y^2)
//	//diff(atan2(y,x),y) =  x/(x^2+y^2)
//	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
//	LinkedDataVector u = GetCoordinateVector(configuration);
//	LinkedDataVector u_t = GetCoordinateVector_t(configuration);
//
//	Real x = u[2]; //x-slopex
//	Real y = u[3]; //y-slopex
//	if (configuration != ConfigurationType::Reference)
//	{
//		x += ref[2];
//		y += ref[3];
//	}
//	//SysError("CNodePointSlope1::GetAngularVelocity: check if computation of angular velocity is correct!");
//	//Real diffX = -y / (x*x + y * y)*u_t[2];
//	//Real diffY =  x / (x*x + y * y)*u_t[3];
//
//	return Vector3D({ 0., 0., (-y*u_t[2] + x*u_t[3]) / (x*x + y*y) }); 
//}
//
//void CNodePointSlope1::GetRotationJacobian(Matrix& value) const
//{
//	//only in current configuration!
//	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
//	LinkedDataVector u = GetCurrentCoordinateVector();
//
//	Real x = u[2] + ref[2]; //x-slopex
//	Real y = u[3] + ref[3]; //y-slopex
//
//	Real g = (x*x + y * y);
//	CHECKandTHROW(g != 0., "CNodePointSlope1::GetRotationJacobian: slope vector has zero length; check initial values!");
//	value.SetMatrix(3, 4, { 0.,0.,0.,0., 
//							0.,0.,0.,0.,
//							0.,0.,-y / g, x / g });
//}
//
////! provide derivative w.r.t. coordinates of rotation Jacobian times vector; for current configuration
////! 4x4 matrix for all nodal coordinates
//void CNodePointSlope1::GetRotationJacobianTTimesVector_q(const Vector3D& vector, Matrix& jacobian_q) const 
//{ 
//	//only in current configuration!
//	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
//	LinkedDataVector u = GetCurrentCoordinateVector();
//
//	Real x = u[2] + ref[2]; //x-slopex
//	Real y = u[3] + ref[3]; //y-slopex
//
//	//{ 0.,0.,0.,
//	//  0.,0.,0.,
//	//	0.,0.,-y / (x*x + y * y), 
//	//  0.,0., x / (x*x + y * y) }^T * v = 
//	// [0.                     ]
//	// [0.                     ]
//	// [v[2]*(-y / (x*x + y * y))]
//	// [v[2]*( x / (x*x + y * y))]
//	//
//	// [ v[2]*(-u'[3] * (x*x + y*y) + y*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]   //(f'g-f*g')/g^2
//	// [ v[2]*(u'[2] * (x*x + y*y) - x*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]
//	//
//	// g2 = (x*x + y*y)^2 //(f'g-f*g')/g^2
//	// d(J^T*v) / q =
//	// [0.,0.,0.,0.]
//	// [0.,0.,0.,0.]
//	// [0.,0.,               v[2]*(y*(2*x) ) / g2, v[2]*(-(x*x + y*y) + y*(2*y) ) / g2]   
//	// [0.,0., v[2]*((x*x + y*y) - x*(2*x) ) / g2, v[2]*( - x*(2*y) ) / g2            ]
//
//	jacobian_q.SetNumberOfRowsAndColumns(4, 4);
//	jacobian_q.SetAll(0.);
//	Real g2 = EXUstd::Square(x*x + y * y);
//	CHECKandTHROW(g2 != 0., "CNodePointSlope1::GetRotationJacobianTTimesVector_q: slope vector has zero length; check initial values!");
//
//	Real divG2 = 1. / g2;
//	jacobian_q(2, 2) = vector[2] * (y*(2 * x)) * divG2;
//	jacobian_q(2, 3) = vector[2] * (-(x*x + y * y) + y * (2 * y)) * divG2;
//	jacobian_q(3, 2) = vector[2] * ((x*x + y * y) - x * (2 * x)) * divG2;
//	jacobian_q(3, 3) = vector[2] * (-x * (2 * y)) * divG2;
//}


//! provide according output variable in "value"
void CNodePointSlope1::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
    case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
    case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(configuration)); break;
    case OutputVariableType::Coordinates:
	{
		if (IsValidConfiguration(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodePointSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodePointSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_tt:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_tt(configuration);
		}
		else
		{
			PyError("CNodePointSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodePointSlope1::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}


