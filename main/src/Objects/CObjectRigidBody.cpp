/** ***********************************************************************************************
* @brief        CObjectRigidBody implementation
*
* @author       Gerstmayr Johannes
* @date         2019-10-19 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Linalg/RigidBodyMath.h"

#include "Utilities/TimerStructure.h" //for local CPU time measurement

//! number of ODE2 coordinates; depends on node
Index CObjectRigidBody::GetODE2Size() const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetNumberOfDisplacementCoordinates() + ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();
}

//! number of AE coordinates; depends on node
Index CObjectRigidBody::GetAlgebraicEquationsSize() const
{
	if (CNodeRigidBodyEP::useNodeAE)
	{
		return 0;
	}
	else
	{
		return ((CNodeRigidBody*)GetCNode(0))->GetNumberOfAECoordinates();
	}
}


bool CObjectRigidBody::HasConstantMassMatrix() const
{
	if (EXUstd::IsOfType(((CNodeRigidBody*)GetCNode(0))->GetType(), Node::RotationRotationVector) &&
		(parameters.physicsCenterOfMass == 0.))
	{
		return true;
	}
	return false;
}

//! Computational function: compute mass matrix
void CObjectRigidBody::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	//STARTGLOBALTIMER(TSrigidMass);
	static_assert(nDisplacementCoordinates == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!

	//set mass terms in first 3 diagonal entries and set remaining entries to zero (the last 4x4 entries will be overwritten when filling in inertia terms)
	massMatrix.SetScalarMatrix(GetODE2Size(), parameters.physicsMass);

	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> GlocalInertia;
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> GlocalInertia(CNodeRigidBody::maxRotationCoordinates, nDim3D);

	//Index nRotationCoordinates = ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();

	//ConstSizeMatrix<9> localInertia;
	//RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);
	////EXUmath::MultMatrixTransposedMatrix(Glocal, localInertia, GlocalInertia);

	GlocalInertia.SetNumberOfRowsAndColumns(Glocal.NumberOfColumns(), nDim3D);

	const Vector6D& J6D = parameters.physicsInertia;
	for (Index i = 0; i < Glocal.NumberOfColumns(); i++)
	{
		GlocalInertia(i, 0) = Glocal(0, i) * J6D[0] + Glocal(1, i) * J6D[5] + Glocal(2, i) * J6D[4];
		GlocalInertia(i, 1) = Glocal(0, i) * J6D[5] + Glocal(1, i) * J6D[1] + Glocal(2, i) * J6D[3];
		GlocalInertia(i, 2) = Glocal(0, i) * J6D[4] + Glocal(1, i) * J6D[3] + Glocal(2, i) * J6D[2];
	}


	EXUmath::MultMatrixMatrix2SubmatrixTemplate<ConstSizeMatrix<12>, ConstSizeMatrix<12>, Matrix>(GlocalInertia, Glocal, massMatrix, nDisplacementCoordinates, nDisplacementCoordinates);

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Terms for COM!=0
	if (!(parameters.physicsCenterOfMass == 0.)) //component-wise compare
	{
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> mRTheta; //off-diagonal mass term
		//–m * A * \tilde \bar u_{ COM } \bar G
		EXUmath::MultMatrixMatrix(RigidBodyMath::Vector2SkewMatrix((-parameters.physicsMass)*parameters.physicsCenterOfMass), Glocal, GlocalInertia);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), GlocalInertia, mRTheta);
		Index nRotationCoordinates = Glocal.NumberOfColumns();

		for (Index i = 0; i < nDim3D; i++)
		{
			for (Index j = 0; j < nRotationCoordinates; j++)
			{
				massMatrix(i, nDisplacementCoordinates + j) = mRTheta(i, j);
				massMatrix(nDisplacementCoordinates + j, i) = mRTheta(i, j);
			}
		}
	}

	//pout << "mass=" << massMatrix << "\n";
	//STOPGLOBALTIMER(TSrigidMass);
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectRigidBody::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	//STARTGLOBALTIMER(TSrigidInertia);
	ode2Lhs.SetNumberOfItems(GetODE2Size());
	ode2Lhs.SetAll(0.);

	//STOPGLOBALTIMER(TSrigidInertia);

	//STARTGLOBALTIMER(TSrigidPart1);
	//compute forces1 and forces2 on left-hand-side (M*a + forces1 + forces2)
	//compute: forces1 = Glocal^T * (omegaBar.Cross(localInertia*omegaBar))
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	//((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);
	//Vector3D omegaBar = ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal();

	Vector3D omegaBar;
	((CNodeRigidBody*)GetCNode(0))->CollectCurrentNodeData1(Glocal, omegaBar);

	//std::cout << "omegaBar=" << omegaBar << "\n";
	//+++++++++++++++++++++++++++++++++++++
	//Version1 (different to Version2 (gives different forces1; difference acting in the nullspace of rot):
	//Vector3D temp = omegaBar.CrossProduct(localInertia * omegaBar);

	//inertiaParameters[0], inertiaParameters[5], inertiaParameters[4],
	//inertiaParameters[5], inertiaParameters[1], inertiaParameters[3],
	//inertiaParameters[4], inertiaParameters[3], inertiaParameters[2] });
	//const Vector6D& J6D = parameters.physicsInertia;
	const Real* J6D = parameters.physicsInertia.GetDataPointer();

	Vector3D JomegaBar({ 
		J6D[0] * omegaBar[0] + J6D[5] * omegaBar[1] + J6D[4] * omegaBar[2],
		J6D[5] * omegaBar[0] + J6D[1] * omegaBar[1] + J6D[3] * omegaBar[2],
		J6D[4] * omegaBar[0] + J6D[3] * omegaBar[1] + J6D[2] * omegaBar[2] });
	Vector3D temp = omegaBar.CrossProduct(JomegaBar);

	ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on rotation coordinates
	EXUmath::MultMatrixTransposedVectorTemplate(Glocal, temp, forces1);

	Vector3D Glocal_tTheta_t(0.); //used twice!

	//additional term, if not Euler Parameters
	if ((((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationEulerParameters) == 0 && 
		(((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationRotationVector) == 0) //for Euler parameters or rotation vector, the following terms vanish
	{
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t; //store this term for case with COM!=0
		LinkedDataVector rot_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();//store this term for case with COM!=0
		ConstSizeMatrix<9> localInertia;
		RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia); //localInertia @ vector could be implemented as separate (hardcoded) function
			
		//compute: forces2 = Glocal^T * localInertia * Glocal_t * rot_t
		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces2;
		Vector3D temp2;

		((CNodeRigidBody*)GetCNode(0))->GetGlocal_t(Glocal_t);
		EXUmath::MultMatrixVector(Glocal_t, rot_t, Glocal_tTheta_t); //Glocal_tTheta_t stored for later usage!
		EXUmath::MultMatrixVector(localInertia, Glocal_tTheta_t, temp2);
		
		EXUmath::MultMatrixTransposedVectorTemplate(Glocal, temp2, forces2);
		forces1 += forces2;
		//pout << "forces2=" << forces2 << "\n";

	}
	//STOPGLOBALTIMER(TSrigidPart1);

	//+++++++++++++++++++++++++++++++++++++
	//alternative Version2, for completeness:
	////compute term: 2*Gbar_t^T*Ibar*omegaBar
	//omegaBar *= 2.;
	//Vector3D temp = localInertia * omegaBar;
	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on Euler parameter coordinates
	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
	//EXUmath::MultMatrixTransposedVector(Glocal_t, temp, forces1);

	//++++++++++++++
	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
	//Matrix Gbar_tT = Glocal_t;
	//Vector temp2; 
	//temp2.CopyFrom(temp);
	//Vector forces1 = Gbar_tT.GetTransposed() * temp2;



	//STARTGLOBALTIMER(TSrigidPart2);
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Terms for COM!=0
	if (!(parameters.physicsCenterOfMass == 0.)) //component-wise compare
	{
		//add terms with Ubar=m*xBar_COM != 0; addForce is put on left-hand-side
		//additional term: -A*[omegaBar x (Ubar x omegaBar) + Ubar x (Glocal_t * rot_t) ]
		Vector3D Ubar = -parameters.physicsMass * parameters.physicsCenterOfMass;	//negative sign of -A[...]
		Vector3D addForce = omegaBar.CrossProduct(Ubar.CrossProduct(omegaBar));		//omegaBar x (U x omegaBar)

		addForce += Ubar.CrossProduct(Glocal_tTheta_t);								//U x (Glocal_t * rot_t) (=0 if EulerParameters)
		addForce = ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix() * addForce;	//A*[...]

		for (Index i = 0; i < nDim3D; i++)
		{
			ode2Lhs[i] += addForce[i]; //positive sign, because object ODEforces are put on LHS; these terms only appear in case of COM!=0
		}
	}

	//for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++)
	for (Index i = 0; i < Glocal.NumberOfColumns(); i++)
	{
		ode2Lhs[i + nDisplacementCoordinates] += forces1[i]; //positive sign, because object ODEforces are put on LHS
	}

	//STOPGLOBALTIMER(TSrigidPart2);
	//pout << "ode2Lhs=" << ode2Lhs << "\n";
}

//! Compute algebraic equations part of rigid body
void CObjectRigidBody::ComputeAlgebraicEquations(Vector& algebraicEquations, bool useIndex2) const
{
	if (GetCNode(0)->GetNumberOfAECoordinates() != 0)
	{
		algebraicEquations.SetNumberOfItems(1);
		if (!useIndex2)
		{
			//position level constraint:

			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
			algebraicEquations[0] = ep * ep - 1.;
		}
		else
		{
			//velocity level constraint:
			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
			LinkedDataVector ep_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();

			algebraicEquations[0] = 2. * (ep * ep_t);
		}
	}
	else
	{
		CHECKandTHROWstring("CObjectRigidBody::ComputeAlgebraicEquations(...): invalid call");
	}
}

//! Compute jacobians of algebraic equations part of rigid body w.r.t. ODE2
void CObjectRigidBody::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, 
	ResizableMatrix& jacobian_ODE1, ResizableMatrix& jacobian_AE) const
{
	if (GetCNode(0)->GetNumberOfAECoordinates() != 0)
	{
		jacobian_ODE2.SetNumberOfRowsAndColumns(((CNodeRigidBody*)GetCNode(0))->GetNumberOfAECoordinates(), GetODE2Size());
		jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_ODE1.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_AE.SetNumberOfRowsAndColumns(0, 0);//for safety!

		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();

		//jacobian = [0 0 0 2*ep0 2*ep1 2*ep2 2*ep3]
		for (Index i = 0; i < nDisplacementCoordinates; i++) { jacobian_ODE2(0, i) = 0.; }
		for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++) 
		{ 
			jacobian_ODE2(0, 3 + i) = 2.*ep[i];
		}
	}
	else
	{
		CHECKandTHROWstring("CObjectRigidBody::ComputeJacobianAE(...): invalid call");
	}
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectRigidBody::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt +
		(Index)AccessFunctionType::JacobianTtimesVector_q + 
		(Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectRigidBody::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	//for rigid body, the accelerator function ComputeRigidBodyMarkerData(...) is called for position/orientation markers;
	//this function is mainly called for DisplacementMassIntegral_q
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -A*uLocalTilde*Glocal
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal
		//uLocalTilde *= -1.;//moved into (-localPosition)

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, nDisplacementCoordinates + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> G;
		((CNodeRigidBody*)GetCNode(0))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		for (Index i = 0; i < nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, nDisplacementCoordinates +j) = G(i,j);
			}
		}
		break;
	}
	case AccessFunctionType::JacobianTtimesVector_q: //jacobian w.r.t. global position and global orientation; HACK: Matrix value(0,0:6) contains 3D force + 3D torque
	{
		//value(0,0:6) must always be set prior to this call!
		Vector3D force({ value(0,0), value(0,1), value(0,2) });
		Vector3D torque({ value(0,3), value(0,4), value(0,5) }); 

		value.SetNumberOfRowsAndColumns(GetODE2Size(), GetODE2Size()); //6x6 or 7x7
		value.SetAll(0.);
		//d(A*uLocal) = -A * uLocalTilde * Glocal = -A * uLocalTilde * A^T * G = -uTilde * G
		//d(A^T*f) = A^T * fTilde * G

		//v=[f,t] (force f/torque t)
		//J^T*v = 
		//[0_{3x3} -A*(\tilde uLocal)*Glocal]^T * [f] = [0_{3x3}                      0_{3x3}] * [f] = 
		//[0_{3x3} G                        ]     [t] = [Glocal^T*(\tilde uLocal)*A^T   G^T    ] * [t]
		//
		//[0_{3} ]
		//[Glocal^T*(\tilde uLocal)*A^T*f + G^T*t]
		//
		//d(J^T*v)/dq = 
		//[0_{3x6} ]
		//[0_{Rx3} Glocal^T*(\tilde uLocal)* A^T*fTilde*G +  dGlocalT{(\tilde uLocal)*A^T*f}dq                  + dGTtdq] //R=3 or 4
		//

		//Glocal^T*(\tilde uLocal)* A^T*fTilde*G:
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> G;
		((CNodeRigidBody*)GetCNode(0))->GetG(G);
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);
		Matrix3D A = ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix();

		ConstSizeMatrix<9> fTilde = RigidBodyMath::Vector2SkewMatrix(force);
		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(localPosition);

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(fTilde, G, temp);
		EXUmath::MultMatrixMatrix(A.GetTransposed(), temp, G);
		EXUmath::MultMatrixMatrix(uLocalTilde, G, temp);
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::maxRotationCoordinates> temp2; //temporary matrix during computation
		EXUmath::MultMatrixTransposedMatrixTemplate< ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D>, 
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D>, 
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::maxRotationCoordinates>>(Glocal, temp, temp2);
		//==>temp2 contains result, is always defined!


		//dGlocalT{(\tilde uLocal)*A^T*f}dq:
		Vector3D v = A.GetTransposed() * force;
		v = localPosition.CrossProduct(v); //(\tilde uLocal)*A^T*f
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::maxRotationCoordinates> dGlocalTv_q;
		((CNodeRigidBody*)GetCNode(0))->GetGlocalTv_q(v, dGlocalTv_q);

		//dGTtdq:
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::maxRotationCoordinates> dGTv_q;
		((CNodeRigidBody*)GetCNode(0))->GetGTv_q(torque, dGTv_q);

		//pout << "  temp2      =" << temp2 << "\n";
		//pout << "  dGlocalTv_q=" << dGlocalTv_q << "\n";
		//pout << "  dGTv_q     =" << dGTv_q << "\n";

		Index nRot = ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();

		for (Index i = 0; i < nRot; i++)
		{
			for (Index j = 0; j < nRot; j++)
			{
				value(nDisplacementCoordinates + i, nDisplacementCoordinates + j) = temp2(i, j) + dGlocalTv_q(i, j) + dGTv_q(i,j);
			}
		}

		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{

		Real m = parameters.physicsMass;

		if (parameters.physicsCenterOfMass == 0.)
		{
			value.SetScalarMatrix(3, m); //no action on rotation parameters, not needed in CSystem.cpp implementation
		}
		else
		{
			value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
			//gives m* \partial p_COM / \partial q
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
			((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
			CHECKandTHROW(parameters.physicsCenterOfMass == localPosition, "CObjectRigidBody::GetAccessFunctionBody: inconsistent localPosition");


			ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*parameters.physicsCenterOfMass); //negative sign in -A*uLocalTilde*Glocal
			//uLocalTilde *= -1.;//moved into ((-m)*parameters.physicsCenterOfMass)

			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
			EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
			EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), temp, Glocal); //Glocal=A*(-m*uLocalTilde)*Glocal

			//unit matrix
			value(0, 0) = m ; value(0, 1) = 0.; value(0, 2) = 0.;
			value(1, 0) = 0.; value(1, 1) = m ; value(1, 2) = 0.;
			value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m ;

			//-A*uLocalTilde*Glocal part (=L) in this case
			for (Index i = 0; i < nDim3D; i++)
			{
				for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
				{
					value(i, nDisplacementCoordinates + j) = Glocal(i, j);
				}
			}
		}

		break;
	}
	default:
		SysError("CObjectRigidBody:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectRigidBody::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::VelocityLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetVelocity(localPosition, configuration)); break; //inefficient, but useful
	case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(localPosition, configuration)); break;
	case OutputVariableType::AccelerationLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetAcceleration(localPosition, configuration)); break;

	case OutputVariableType::Rotation: {
		Matrix3D rotMat = GetRotationMatrix(localPosition, configuration);
		Vector3D rot = RigidBodyMath::RotationMatrix2RotXYZ(rotMat);
		value.CopyFrom(rot);
		break;
	}
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetAngularVelocityLocal(localPosition, configuration)); break;
	case OutputVariableType::AngularAcceleration: value.CopyFrom(GetAngularAcceleration(localPosition, configuration)); break;
	case OutputVariableType::AngularAccelerationLocal: value.CopyFrom(GetRotationMatrix(localPosition, configuration).GetTransposed()*GetAngularAcceleration(localPosition, configuration)); break;

	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(localPosition, configuration);
		value.SetVector(9, rot.GetDataPointer());
		break;
	}
	default:
		SysError("CObjectRigidBody::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! @todo: add ConfigurationType to CObjectMassPoint::GetPosition; 
//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetPosition(configuration) + ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) * localPosition;

}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetPosition(configuration) - ((CNodeRigidBody*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(0))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \ddot R + \alpha x (A * \localPosition) + \omega x (\omega x (A * \localPosition))
	Vector3D relativePosition = ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) * localPosition;
	Vector3D omega = ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocity(configuration);
	return ((CNodeRigidBody*)GetCNode(0))->GetAcceleration(configuration) +
		((CNodeRigidBody*)GetCNode(0))->GetAngularAcceleration(configuration).CrossProduct(relativePosition) +
		omega.CrossProduct(omega.CrossProduct(relativePosition));
}

Matrix3D CObjectRigidBody::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal(configuration);
}

//! return configuration dependent angular acceleration of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularAcceleration(configuration);
}

//Index TSRBmarkerData1;
//TimerStructureRegistrator TSRRBmarkerData1("TSRBmarkerData1", TSRBmarkerData1, globalTimers);
//Index TSRBmarkerData1b;
//TimerStructureRegistrator TSRRBmarkerData1b("TSRBmarkerData1b", TSRBmarkerData1b, globalTimers);
//Index TSRBmarkerData2;
//TimerStructureRegistrator TSRRBmarkerData2("TSRBmarkerData2", TSRBmarkerData2, globalTimers);

//! accelerator function for faster computation of MarkerData for rigid bodies/joints
void CObjectRigidBody::ComputeRigidBodyMarkerData(const Vector3D& localPosition, bool computeJacobian, MarkerData& markerData) const
{
	//CObjectBody::ComputeRigidBodyMarkerData(localPosition, computeJacobian, markerData);
	//return;
	
	////compare:
	//MarkerData markerData2;
	//CObjectBody::ComputeRigidBodyMarkerData(localPosition, computeJacobian, markerData2);
	
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> G;
	Vector3D pos0;
	Vector3D vel0;

	//STARTGLOBALTIMER(TSRBmarkerData1);

	//39ns:
	((CNodeRigidBody*)GetCNode(0))->CollectCurrentNodeMarkerData(Glocal, G, pos0, vel0, markerData.orientation, markerData.angularVelocityLocal); 
	//STOPGLOBALTIMER(TSRBmarkerData1);

	//***********
	//40ns:
	Vector3D AlocalPosition = markerData.orientation * localPosition;

	markerData.position = pos0 + AlocalPosition;
	markerData.velocity = vel0 + markerData.orientation * markerData.angularVelocityLocal.CrossProduct(localPosition);

	markerData.velocityAvailable = true;
	//***********

	if (computeJacobian) //97ns //tested with c=6414100 evaluations
	{

		//GetAccessFunctionBody(AccessFunctionType::TranslationalVelocity_qt, localPosition, markerData.positionJacobian);
		//GetAccessFunctionBody(AccessFunctionType::AngularVelocity_qt, localPosition, markerData.rotationJacobian);
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -uTilde*G


		//ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal


		//39ns:
		//ConstSizeMatrix<9> uTilde = RigidBodyMath::Vector2SkewMatrix(-AlocalPosition); //negative sign in -uTilde*G
		//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		//EXUmath::MultMatrixMatrix(uTilde, G, temp); 


		ResizableMatrix& posJac = markerData.positionJacobian;
		posJac.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		//17ns:
		//this is the faster implementation without need to multiply with the rotation matrix;
		//HOWEVER, for larger constraint drifts in Index2 computation, gives considerably different solution from version with localPosition and Glocal
#undef doFastObjectRigidBodyMarker
#ifdef doFastObjectRigidBodyMarker
		RigidBodyMath::ApplySkewMatrixTemplate< ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D>,
			ResizableMatrix>(-AlocalPosition, G, posJac, nDisplacementCoordinates);
#else
		//STARTGLOBALTIMER(TSRBmarkerData1b);
		//slower version with local matrices; total: 40ns
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		RigidBodyMath::ApplySkewMatrixTemplate< ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D>,
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D>>(-localPosition, Glocal, temp);

		//25ns in new version with GetUnsafe in MultMatrixMatrix (40ns in old version with slower ConstSizeMatrix)
		EXUmath::MultMatrixMatrix(markerData.orientation, temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		for (Index j = 0; j < Glocal.NumberOfColumns(); j++) //4.6ns
		{
			posJac.GetUnsafe(0, nDisplacementCoordinates + j) = Glocal.GetUnsafe(0, j);
			posJac.GetUnsafe(1, nDisplacementCoordinates + j) = Glocal.GetUnsafe(1, j);
			posJac.GetUnsafe(2, nDisplacementCoordinates + j) = Glocal.GetUnsafe(2, j);
		}
		//STOPGLOBALTIMER(TSRBmarkerData1b);
#endif

		//STARTGLOBALTIMER(TSRBmarkerData2);
		//without GetUnsafe: 36ns from here till end (included commented filling of posJac) of jacobian, with GetUnsafe: 21ns; optimized: 14ns
		//unit matrix
		posJac.GetUnsafe(0, 0) = 1.; posJac.GetUnsafe(0, 1) = 0.; posJac.GetUnsafe(0, 2) = 0.;
		posJac.GetUnsafe(1, 0) = 0.; posJac.GetUnsafe(1, 1) = 1.; posJac.GetUnsafe(1, 2) = 0.;
		posJac.GetUnsafe(2, 0) = 0.; posJac.GetUnsafe(2, 1) = 0.; posJac.GetUnsafe(2, 2) = 1.;


		//ConstSizeMatrix<9> uTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -uTilde*G
		//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		//EXUmath::MultMatrixMatrix(uTilde, Glocal, temp); 
		//EXUmath::MultMatrixMatrix(markerData.orientation, temp, Glocal);

		////-A*uLocalTilde*Glocal part (=L in this case
		//for (Index i = 0; i < nDim3D; i++)
		//{
		//	for (Index j = 0; j < Glocal.NumberOfColumns(); j++)
		//	{
		//		posJac.GetUnsafe(i, nDisplacementCoordinates + j) = Glocal.GetUnsafe(i, j);
		//	}
		//}
		
		//pout << "diff=" << posJac - markerData2.positionJacobian << "\n"; //show differences of two versions


		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();

		ResizableMatrix& rotJac = markerData.rotationJacobian;
		rotJac.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		for (Index i = 0; i < nDim3D; i++)
		{
			rotJac.GetUnsafe(0, i) = 0;
			rotJac.GetUnsafe(1, i) = 0;
			rotJac.GetUnsafe(2, i) = 0;
		}
		for (Index j = 0; j < G.NumberOfColumns(); j++)
		{
			for (Index i = 0; i < nDim3D; i++)
			{
				rotJac.GetUnsafe(i, nDisplacementCoordinates + j) = G.GetUnsafe(i, j);
			}
		}
		//STOPGLOBALTIMER(TSRBmarkerData2);
	}


}
















//#define useNewCObjectRigidBody
//#ifndef useNewCObjectRigidBody
////! Computational function: compute mass matrix
//void CObjectRigidBody::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
//{
//	static_assert(nDisplacementCoordinates == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!
//
//	//set mass terms in first 3 diagonal entries and set remaining entries to zero (the last 4x4 entries will be overwritten when filling in inertia terms)
//	massMatrix.SetScalarMatrix(GetODE2Size(), parameters.physicsMass);
//
//	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
//	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
//
//	ConstSizeMatrix<9> localInertia;
//	RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);
//
//	//pout << "Glocal=" << Glocal << "\n";
//	//pout << "A=" << ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix() << "\n";
//	//pout << "Jbar=" << localInertia << "\n";
//
//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> GlocalInertia;			//temporary matrix
//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::maxRotationCoordinates> inertia; //final inertia term
//
//	EXUmath::MultMatrixTransposedMatrix(Glocal, localInertia, GlocalInertia);
//	EXUmath::MultMatrixMatrix(GlocalInertia, Glocal, inertia);
//
//	Index nRotationCoordinates = ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();
//	for (Index i = 0; i < nRotationCoordinates; i++)
//	{
//		for (Index j = 0; j < nRotationCoordinates; j++)
//		{
//			massMatrix(nDisplacementCoordinates + i, nDisplacementCoordinates + j) = inertia(i, j);
//		}
//	}
//
//	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	//Terms for COM!=0
//	if (!(parameters.physicsCenterOfMass == 0.)) //component-wise compare
//	{
//		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> mRTheta; //off-diagonal mass term
//		//–m * A * \tilde \bar u_{ COM } \bar G
//		EXUmath::MultMatrixMatrix(RigidBodyMath::Vector2SkewMatrix((-parameters.physicsMass)*parameters.physicsCenterOfMass), Glocal, GlocalInertia);
//		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), GlocalInertia, mRTheta);
//
//		for (Index i = 0; i < nDim3D; i++)
//		{
//			for (Index j = 0; j < nRotationCoordinates; j++)
//			{
//				massMatrix(i, nDisplacementCoordinates + j) = mRTheta(i, j);
//				massMatrix(nDisplacementCoordinates + j, i) = mRTheta(i, j);
//			}
//		}
//	}
//
//	//pout << "mass=" << massMatrix << "\n";
//}
//
////! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//void CObjectRigidBody::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
//{
//	ode2Lhs.SetNumberOfItems(GetODE2Size());
//	ode2Lhs.SetAll(0.);
//
//	ConstSizeMatrix<9> localInertia;
//	RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);
//
//	//compute forces1 and forces2 on left-hand-side (M*a + forces1 + forces2)
//	//compute: forces1 = Glocal^T * (omegaBar.Cross(localInertia*omegaBar))
//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
//	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);
//	Vector3D omegaBar = ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal();
//
//	//+++++++++++++++++++++++++++++++++++++
//	//Version1 (different to Version2 (gives different forces1; difference acting in the nullspace of rot):
//	Vector3D temp = omegaBar.CrossProduct(localInertia * omegaBar);
//	ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on rotation coordinates
//	EXUmath::MultMatrixTransposedVectorTemplate(Glocal, temp, forces1);
//
//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t; //store this term for case with COM!=0
//	LinkedDataVector rot_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();//store this term for case with COM!=0
//	Vector3D Glocal_tTheta_t(0); //used twice!
//
//	//additional term, if not Euler Parameters
//	if ((((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationEulerParameters) == 0 &&
//		(((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationRotationVector) == 0) //for Euler parameters or rotation vector, the following terms vanish
//	{
//		//compute: forces2 = Glocal^T * localInertia * Glocal_t * rot_t
//		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces2;
//		Vector3D temp2;
//
//		((CNodeRigidBody*)GetCNode(0))->GetGlocal_t(Glocal_t);
//		EXUmath::MultMatrixVector(Glocal_t, rot_t, Glocal_tTheta_t); //Glocal_tTheta_t stored for later usage!
//		EXUmath::MultMatrixVector(localInertia, Glocal_tTheta_t, temp2);
//
//		EXUmath::MultMatrixTransposedVectorTemplate(Glocal, temp2, forces2);
//		forces1 += forces2;
//		//pout << "forces2=" << forces2 << "\n";
//
//	}
//
//	//+++++++++++++++++++++++++++++++++++++
//	//alternative Version2, for completeness:
//	////compute term: 2*Gbar_t^T*Ibar*omegaBar
//	//omegaBar *= 2.;
//	//Vector3D temp = localInertia * omegaBar;
//	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on Euler parameter coordinates
//	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
//	//EXUmath::MultMatrixTransposedVector(Glocal_t, temp, forces1);
//
//	//++++++++++++++
//	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
//	//Matrix Gbar_tT = Glocal_t;
//	//Vector temp2; 
//	//temp2.CopyFrom(temp);
//	//Vector forces1 = Gbar_tT.GetTransposed() * temp2;
//
//	//+++++++++++++++++++++++++++++++++++++
//	//pout << "Qv = " << -1 * forces1 << "\n";
//
//	//*******************************
//	//original code H1:
//	//GetBetaP(betap);
//	//Matrix3D Gbar = GetGbar();
//	//Vector3D omegabar = Gbar * betap; //--->Mult is faster
//	//Vector3D temp = (omegabar.Cross(Iphi*omegabar));
//	//Mult(Gbar.GetTp(), temp, betap);
//
//	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	//Terms for COM!=0
//	if (!(parameters.physicsCenterOfMass == 0.)) //component-wise compare
//	{
//		//add terms with Ubar=m*xBar_COM != 0; addForce is put on left-hand-side
//		//additional term: -A*[omegaBar x (Ubar x omegaBar) + Ubar x (Glocal_t * rot_t) ]
//		Vector3D Ubar = -parameters.physicsMass * parameters.physicsCenterOfMass;	//negative sign of -A[...]
//		Vector3D addForce = omegaBar.CrossProduct(Ubar.CrossProduct(omegaBar));		//omegaBar x (U x omegaBar)
//
//		addForce += Ubar.CrossProduct(Glocal_tTheta_t);								//U x (Glocal_t * rot_t) (=0 if EulerParameters)
//		addForce = ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix() * addForce;	//A*[...]
//
//		for (Index i = 0; i < nDim3D; i++)
//		{
//			ode2Lhs[i] += addForce[i]; //positive sign, because object ODEforces are put on LHS
//		}
//	}
//
//	for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++)
//	{
//		ode2Lhs[i + nDisplacementCoordinates] += forces1[i]; //positive sign, because object ODEforces are put on LHS
//	}
//
//	//pout << "ode2Lhs=" << ode2Lhs << "\n";
//}
//
//
//
//
//#else
