/** ***********************************************************************************************
* @brief		Implementation for NodePointSlope12
*
* @author		Gerstmayr Johannes
* @date			2019-06-15 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Linalg/RigidBodyMath.h"
#include "Autogenerated/CNodePointSlope12.h"				//includes ReleaseAssert.h, BasicDefinitions.h, ResizeableArray.h, LinkedDataVector.h
#include "Utilities/Differentiation.h"

Vector3D CNodePointSlope12::GetPosition(ConfigurationType configuration) const
{
	//p = pRef + u = reference position + displacement
	LinkedDataVector pRef3D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef3D[0], pRef3D[1] , pRef3D[2] });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	LinkedDataVector u3D = GetCoordinateVector(configuration);
	Vector3D displacement({ u3D[0], u3D[1] , u3D[2] });
	return pRef + displacement;
}

Vector3D CNodePointSlope12::GetVelocity(ConfigurationType configuration) const
{
    LinkedDataVector u3D_t = GetCoordinateVector_t(configuration);
    return Vector3D({ u3D_t[0], u3D_t[1] , u3D_t[2] });
}

Vector3D CNodePointSlope12::GetAcceleration(ConfigurationType configuration) const
{
    LinkedDataVector u3D_tt = GetCoordinateVector_tt(configuration);
    return Vector3D({ u3D_tt[0], u3D_tt[1] , u3D_tt[2] });
}

//! provide position jacobian of node; derivative of 3D Position with respect to 9 coordinates ux,uy and x/y "displacements" of slopex
void CNodePointSlope12::GetPositionJacobian(Matrix& value) const
{
	//derivative of position with respect to all coordinates
	value.SetMatrix(3, 9, {
		1.,0.,0.,0.,0.,0.,0.,0.,0.,
		0.,1.,0.,0.,0.,0.,0.,0.,0.,
		0.,0.,1.,0.,0.,0.,0.,0.,0. });
}

//! local function for AutoDiff in GetRotationMatrix_t
template <class TReal>
void CNodePointSlope12FRot(const ConstSizeVectorBase<TReal, 6>& q, ConstSizeVectorBase<TReal, 9>& f)
{
	ConstSizeMatrixBase<TReal, 9> A;
	EXUmath::OrthogonalBasisFromVectorsXY(SlimVectorBase< TReal, 3>({ q[0],q[1],q[2] }), 
		SlimVectorBase< TReal, 3>({ q[3],q[4],q[5] }), A);
	f.CopyFrom(LinkedDataVectorBase<TReal>(A.GetDataPointer(), 9));
};


Matrix3D CNodePointSlope12::GetRotationMatrix(ConfigurationType configuration) const
{
	ConstSizeVector<nODE2coordinates> q;
	q.CopyFrom(GetCoordinateVector(ConfigurationType::Reference));
	if (!(configuration == ConfigurationType::Reference))
	{
		q += GetCoordinateVector(configuration);
	}

	Matrix3D A;
	EXUmath::OrthogonalBasisFromVectorsXY(Vector3D({ q[3],q[4],q[5] }), Vector3D({ q[6],q[7],q[8] }), A);

	return A;
}

Matrix3D CNodePointSlope12::GetRotationMatrix_t(ConfigurationType configuration) const
{
	//CHECKandTHROWstring("CNodePointSlope12::GetRotationMatrix_t: not implemented!");
	const Index nqSlope = 6;
	const Index dimRot = 9; //number of entries in rotation matrix A
	ConstSizeVector<nODE2coordinates> q0;
	q0.CopyFrom(GetCoordinateVector(ConfigurationType::Reference));
	if (!(configuration == ConfigurationType::Reference))
	{
		q0 += GetCoordinateVector(configuration);
	}

	ConstSizeVector<nqSlope> q12(LinkedDataVector(q0), 3); //fetch q_X and q_Y from q0
	ConstSizeVector<nqSlope> q12_t(GetCoordinateVector_t(configuration), 3);

	bool doNumDiff = false;
	if (doNumDiff)
	{
		auto fRot = [](const ConstSizeVector<6>& q12, ConstSizeVector<9>& f) //-> void
		{
			Matrix3D A;
			EXUmath::OrthogonalBasisFromVectorsXY(Vector3D({ q12[0],q12[1],q12[2] }), Vector3D({ q12[3],q12[4],q12[5] }), A);
			f.CopyFrom(LinkedDataVector(A.GetDataPointer(), 9));
		};

		ConstSizeMatrix<nqSlope*dimRot> jacobian;
		ConstSizeVector<dimRot> tempF0;
		ConstSizeVector<dimRot> tempF1;
		//EXUmath::NumDiff(fRotTest, dimRot, q, tempF0, tempF1, jacobian);
		EXUmath::NumDiffVectors<CSVector6D, CSVector9D, ConstSizeMatrix<6 * 9>, dimRot>(fRot, q12, tempF0, tempF1, jacobian);

		Matrix3D Ap(3, 3);
		LinkedDataVector result(Ap.GetDataPointer(), 9);
		EXUmath::MultMatrixVectorTemplate<ConstSizeMatrix<nqSlope*dimRot>, ConstSizeVector<nqSlope>, LinkedDataVector>(jacobian, q12_t, result);

		return Ap;
	}
	else
	{
		ConstSizeMatrix<nqSlope*dimRot> jacobian;
		EXUmath::AutoDiffVectors<dimRot, nqSlope>(CNodePointSlope12FRot<EXUmath::AutoDiff<nqSlope, Real>>, q12, jacobian);
		Matrix3D Ap(3, 3);
		LinkedDataVector result(Ap.GetDataPointer(), 9);
		EXUmath::MultMatrixVectorTemplate<ConstSizeMatrix<nqSlope*dimRot>, ConstSizeVector<nqSlope>, LinkedDataVector>(jacobian, q12_t, result);

		return Ap;
	}
}

//! return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CNodePointSlope12::GetAngularVelocity(ConfigurationType configuration) const
{
	//CHECKandTHROWstring("CNodePointSlope12::GetAngularVelocity: untested!");

	ConstSizeVector<nODE2coordinates> q;
	q.CopyFrom(GetCoordinateVector(ConfigurationType::Reference));
	if (!(configuration == ConfigurationType::Reference))
	{
		q += GetCoordinateVector(configuration);
	}
	LinkedDataVector q_t(GetCoordinateVector_t(configuration));

	Vector3D slopeX({ q[3], q[4], q[5] });
	Vector3D slopeY({ q[6], q[7], q[8] });
	Vector3D slopeX_t({ q_t[3], q_t[4], q_t[5] });
	Vector3D slopeY_t({ q_t[6], q_t[7], q_t[8] });

	//See MarkerSuperElementRigid
	//r_loc=slope, v_loc=slope_t
	//omega_loc_tilde * sum r_loc = sum v_loc = -sum r_loc_tilde * omega_loc
	//sum r_loc_tilde * v_loc = -sum r_loc_tilde * r_loc_tilde * omega_loc
	//==>omega = -sum r_loc_tilde * v_loc / (sum r_loc_tilde * r_loc_tilde)

	Matrix3D slopeXskew = RigidBodyMath::Vector2SkewMatrix(slopeX);
	Matrix3D slopeYskew = RigidBodyMath::Vector2SkewMatrix(slopeY);

	Matrix3D W = -1.*(slopeXskew * slopeXskew + slopeYskew*slopeYskew);
	return W.GetInverse() * (slopeXskew * slopeX_t + slopeYskew*slopeY_t);
}

//! AUTO:  return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CNodePointSlope12::GetAngularVelocityLocal(ConfigurationType configuration) const
{
	return GetRotationMatrix(configuration).GetTransposed() * GetAngularVelocity(configuration);
}

void CNodePointSlope12::GetRotationJacobian(Matrix& value) const
{
	//CHECKandTHROWstring("CNodePointSlope12::GetRotationJacobian: untested!");


	ConstSizeVector<nODE2coordinates> q;
	q.CopyFrom(GetReferenceCoordinateVector());
	q += GetCurrentCoordinateVector();
	
	LinkedDataVector q_t(GetCurrentCoordinateVector_t());

	Vector3D slopeX({ q[3], q[4], q[5] });
	Vector3D slopeY({ q[6], q[7], q[8] });


	//See MarkerSuperElementRigid
	//r_loc=slope, v_loc=slope_t
	//omega_loc_tilde * sum r_loc = sum v_loc = -sum r_loc_tilde * omega_loc
	//sum r_loc_tilde * v_loc = -sum r_loc_tilde * r_loc_tilde * omega_loc
	//==>omega = -sum r_loc_tilde * v_loc / (sum r_loc_tilde * r_loc_tilde)
	//==>jacobian is d(omega)/d(q_t) which has simple structure!

	Matrix3D slopeXskew = RigidBodyMath::Vector2SkewMatrix(slopeX);
	Matrix3D slopeYskew = RigidBodyMath::Vector2SkewMatrix(slopeY);

	Matrix3D Winv = -1.*(slopeXskew*slopeXskew + slopeYskew * slopeYskew);
	Winv.Invert();


	value.SetNumberOfRowsAndColumns(3, 9);
	value.SetAll(0.);

	value.SetSubmatrix(Winv*slopeXskew, 0, 3, 1.);
	value.SetSubmatrix(Winv*slopeYskew, 0, 6, 1.);
}

//! provide derivative w.r.t. coordinates of rotation Jacobian times vector; for current configuration
//! 4x4 matrix for all nodal coordinates
void CNodePointSlope12::GetRotationJacobianTTimesVector_q(const Vector3D& vector, Matrix& jacobian_q) const 
{ 
	CHECKandTHROWstring("CNodePointSlope12::GetRotationJacobianTTimesVector_q: not implemented!");

	////only in current configuration!
	//LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	//LinkedDataVector u = GetCurrentCoordinateVector();

	//Real x = u[2] + ref[2]; //x-slopex
	//Real y = u[3] + ref[3]; //y-slopex

	////{ 0.,0.,0.,
	////  0.,0.,0.,
	////	0.,0.,-y / (x*x + y * y), 
	////  0.,0., x / (x*x + y * y) }^T * v = 
	//// [0.                     ]
	//// [0.                     ]
	//// [v[2]*(-y / (x*x + y * y))]
	//// [v[2]*( x / (x*x + y * y))]
	////
	//// [ v[2]*(-u'[3] * (x*x + y*y) + y*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]   //(f'g-f*g')/g^2
	//// [ v[2]*(u'[2] * (x*x + y*y) - x*(2*x*u'[2] + 2*y*u'[3]) ) / (x*x + y*y)^2]
	////
	//// g2 = (x*x + y*y)^2 //(f'g-f*g')/g^2
	//// d(J^T*v) / q =
	//// [0.,0.,0.,0.]
	//// [0.,0.,0.,0.]
	//// [0.,0.,               v[2]*(y*(2*x) ) / g2, v[2]*(-(x*x + y*y) + y*(2*y) ) / g2]   
	//// [0.,0., v[2]*((x*x + y*y) - x*(2*x) ) / g2, v[2]*( - x*(2*y) ) / g2            ]

	//jacobian_q.SetNumberOfRowsAndColumns(4, 4);
	//jacobian_q.SetAll(0.);
	//Real g2 = EXUstd::Square(x*x + y * y);
	//CHECKandTHROW(g2 != 0., "CNodePointSlope12::GetRotationJacobianTTimesVector_q: slope vector has zero length; check initial values!");

	//Real divG2 = 1. / g2;
	//jacobian_q(2, 2) = vector[2] * (y*(2 * x)) * divG2;
	//jacobian_q(2, 3) = vector[2] * (-(x*x + y * y) + y * (2 * y)) * divG2;
	//jacobian_q(3, 2) = vector[2] * ((x*x + y * y) - x * (2 * x)) * divG2;
	//jacobian_q(3, 3) = vector[2] * (-x * (2 * y)) * divG2;
}


//! provide according output variable in "value"
void CNodePointSlope12::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
    case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
    case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(configuration)); break;

    case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(configuration)); break;
    case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetAngularVelocityLocal(configuration)); break;
    //missing: case OutputVariableType::AngularAcceleration: value.CopyFrom(GetAngularAcceleration(configuration)); break;

    case OutputVariableType::RotationMatrix: {
        Matrix3D rot = GetRotationMatrix(configuration);
        value.SetVector(9, rot.GetDataPointer());
        break;
    }
    case OutputVariableType::Rotation: {
        Matrix3D rotMat = GetRotationMatrix(configuration);
        Vector3D rot = RigidBodyMath::RotationMatrix2RotXYZ(rotMat);
        value.SetVector(3, rot.GetDataPointer());
        break;
    }
    case OutputVariableType::Coordinates:
	{
		if (IsValidConfiguration(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodePointSlope12::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodePointSlope12::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_tt:
	{
		if (IsValidConfigurationButNotReference(configuration)) 
		{
			value = GetCoordinateVector_tt(configuration);
		}
		else
		{
			PyError("CNodePointSlope12::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodePointSlope12::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}


