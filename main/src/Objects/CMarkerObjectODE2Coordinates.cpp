/** ***********************************************************************************************
* @brief        implementation for MarkerObjectODE2Coordinates
*
* @author       Gerstmayr Johannes
* @date         2019-05-02 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Linalg/RigidBodyMath.h"

//#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
//#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
//namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include "Autogenerated/CMarkerObjectODE2Coordinates.h"

//! return number of coordinates of the attached object
Index CMarkerObjectODE2Coordinates::GetDimension(const CSystemData& cSystemData) const
{
	Index objectNumber = GetObjectNumber();
	return cSystemData.GetCObjects()[objectNumber]->GetODE2Size();
}

//! return the ODE2 coordinate vectors (and derivative) of the attached object
void CMarkerObjectODE2Coordinates::GetObjectODE2Coordinates(const CSystemData& cSystemData, Vector& objectCoordinates, Vector& objectCoordinates_t) const
{
	Index objectNumber = GetObjectNumber();
	const CObject& cObject = *(cSystemData.GetCObjects()[objectNumber]);
	CHECKandTHROW(((Index)cObject.GetType() & (Index)CObjectType::Body) != 0, "CMarkerObjectODE2Coordinates::GetObjectODE2Coordinates: object must be a body!");

	Index nOC = GetDimension(cSystemData);
	objectCoordinates.SetNumberOfItems(nOC);
	objectCoordinates_t.SetNumberOfItems(nOC);

	//const CObjectBody& cObjectBody = (const CObjectBody&)cObject;

	Index cnt = 0; //marks offset in objectCoordinates / _t
	//consecutively work through nodes, as coordinate assembly in CSystem.cpp
	for (Index j = 0; j < cObject.GetNumberOfNodes(); j++)
	{
		const CNodeODE2* node = (const CNodeODE2*)cObject.GetCNode(j);
		Index nc = node->GetNumberOfODE2Coordinates();
		if (nc)
		{
			LinkedDataVector p(objectCoordinates, cnt, nc);  //position level coordinates
			LinkedDataVector v(objectCoordinates_t, cnt, nc);//velocity coordinates
			p = node->GetReferenceCoordinateVector(); //set all coordinates to reference values
			p += node->GetCurrentCoordinateVector();  //add current values
			v = node->GetCurrentCoordinateVector_t(); //set all coordinates to current velocity values
			cnt += nc;
		}
	}
	//alternatively:
	//use objectLTG to set coordinates
	//BUT: reference values must be used from stored global reference values, not from nodal reference values
}


void CMarkerObjectODE2Coordinates::ComputeMarkerData(const CSystemData& cSystemData, bool computeJacobian, MarkerData& markerData) const
{
	Index n = GetDimension(cSystemData); //works already for both cases
	if (n) //access to coordinates only, not ground node/body (which has no real coordinates, but it is allows to constrain to a ground node 'coordinate' being always zero
	{
		GetObjectODE2Coordinates(cSystemData, markerData.vectorValue, markerData.vectorValue_t);
		markerData.velocityAvailable = true;

		if (computeJacobian)
		{
			//zero-vector with 1 at parameters.coordinate => this is also done for velocity markers; this might not work for non-holonomic constraints
			//this could be optimized ...; leads to large computational efforts for larger objects
			markerData.jacobian.SetScalarMatrix(n, 1.);
		}
	}
	else //ground node/object
	{
		markerData.velocityAvailable = true;
		markerData.vectorValue.SetVector({});
		markerData.vectorValue_t.SetVector({}); //set this also for ground markers, because it could be asked for in connector!!!!
		markerData.jacobian.SetNumberOfRowsAndColumns(0, 0); //this signals the connector/system not to apply any load or Lagrange multiplier
	}
}

//! compute markerdata: fill in according data for derivative of jacobian times vector v, e.g.: d(Jpos.T @ v)/dq
void CMarkerObjectODE2Coordinates::ComputeMarkerDataJacobianDerivative(const CSystemData& cSystemData, const Vector6D& v6D, MarkerData& markerData) const
{
	markerData.jacobianDerivative.SetNumberOfRowsAndColumns(0, 0); //signals that there is no dependency!
}

