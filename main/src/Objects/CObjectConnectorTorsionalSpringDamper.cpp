/** ***********************************************************************************************
* @brief        Implementation of CObjectConnectorTorsionalSpringDamper
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorTorsionalSpringDamper.h"
#include "Linalg/RigidBodyMath.h"

void CObjectConnectorTorsionalSpringDamper::ComputeSpringTorque(const MarkerDataStructure& markerData, Index itemIndex,
	Matrix3D& A0all, Real& angle, Real& omega, Real& torque) const
{
	//spring is measured relative to marker0:

	const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
	const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	const Matrix3D& A0off = parameters.rotationMarker0;
	const Matrix3D& A1off = parameters.rotationMarker1;
	A0all = (A0*A0off);
	Matrix3D A1all = (A1*A1off);

	//relative rotation
	Matrix3D relRot = A0all.GetTransposed() * A1all;
	Vector3D vLocRot = RigidBodyMath::RotationMatrix2RotXYZ(relRot);
	Vector3D vLocAngVel = A0all.GetTransposed()*(A1*markerData.GetMarkerData(1).angularVelocityLocal - A0 * markerData.GetMarkerData(0).angularVelocityLocal);
	angle = vLocRot[2]; //z-component
	if (angle > EXUstd::pi) {angle -= 2. * EXUstd::pi; }
	omega = vLocAngVel[2]; //z-component

	if (parameters.nodeNumber != EXUstd::InvalidIndex)
	{ //Generic node for continuous rotation
		Real previousAngle = GetCNode(0)->GetCurrentCoordinate(0); //this is the continuous angle (of previous step during computation and of end of step for OutputVariable)
		if (fabs(angle - previousAngle) > EXUstd::pi)
		{
			Real delta = previousAngle - angle;
			Real off2pi = round(delta / (2.*EXUstd::pi));
			angle += off2pi * 2.*EXUstd::pi;
		}
		//pout << "prev angle=" << previousAngle << ", angle=" << angle << "\n";
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//compute resulting torque:
	if (!parameters.springTorqueUserFunction)
	{
		torque = parameters.stiffness * (angle - parameters.offset) + 
			parameters.damping * (omega - parameters.velocityOffset) + parameters.torque;
	}
	else
	{
		EvaluateUserFunctionForce(torque, cSystemData->GetMainSystemBacklink(), markerData.GetTime(), itemIndex, angle, omega);
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectConnectorTorsionalSpringDamper::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectConnectorTorsionalSpringDamper::ComputeODE2LHS: marker do not provide velocityLevel information");

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).rotationJacobian.NumberOfColumns() + markerData.GetMarkerData(1).rotationJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	if (parameters.activeConnector)
	{
		Real angle, omega, torque;
		Matrix3D A0all;

		//compute local torque
		ComputeSpringTorque(markerData, objectNumber, A0all, angle, omega, torque);
		Vector3D fRotLoc({0.,0.,torque}); //torque around joint0 Z-axis

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//transform to global coordinates (application of forces/torques always global):
		Vector3D fRot;
		EXUmath::MultMatrixVector(A0all, fRotLoc, fRot);

		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).rotationJacobian.NumberOfColumns(), markerData.GetMarkerData(1).rotationJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, fRot, ldv1);
		}

		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			fRot *= -1.;
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).rotationJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, fRot, ldv0);
		}
	}

}


//! provide according output variable in "value"
void CObjectConnectorTorsionalSpringDamper::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	Real angle, omega, torque;
	Matrix3D A0all;

	ComputeSpringTorque(markerData, itemIndex, A0all, angle, omega, torque);

	switch (variableType)
	{
	case OutputVariableType::Rotation: value.CopyFrom(Vector1D(angle)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(Vector1D(omega)); break;
	case OutputVariableType::TorqueLocal: value.CopyFrom(Vector1D(torque)); break;
	default:
		SysError("CObjectConnectorTorsionalSpringDamper::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}
}


//! function called after Newton method; returns a residual error (force); 
Real CObjectConnectorTorsionalSpringDamper::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
	Real discontinuousError = 0;
	flags = PostNewtonFlags::_None;

	if (parameters.nodeNumber != EXUstd::InvalidIndex /*&& parameters.activeConnector*/) //even do that if connector inactive ...
	{ //Generic node for continuous rotation
		LinkedDataVector dataCoordinates = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current);

		Real angle, omega, torque;
		Matrix3D A0all;

		ComputeSpringTorque(markerDataCurrent, itemIndex, A0all, angle, omega, torque);
		dataCoordinates[0] = angle; //already takes care for jumps based on previous value
	}

	return discontinuousError;
}

