/** ***********************************************************************************************
* @brief        Implementation of CObjectContactSphereTorus
*
* @author       Gerstmayr Johannes
* @date         2025-05-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Linalg/Geometry.h"
#include "Autogenerated/CNodeGenericData.h"
#include "Autogenerated/CObjectContactSphereTorus.h"

// compute the contact force acting on sphere 1; n0 points from center of spehere 0 to center of sphere 1
// gap is the distance between the two speheres (negative in case of contact)
// n0 is the vector pointing from center of spehere 0 to spehere 1
// deltaVnormal is the separation (gap) velocity (for sphere 1 positive in the case that the particles separate)
template<typename TReal>
TReal CObjectContactSphereTorus::ComputeContactForces(TReal gap, const SlimVectorBase<TReal, 3>& n0,
	TReal deltaVnormal, const SlimVectorBase<TReal, 3>& deltaVji, TReal dryFriction, bool frictionRegularizedRegion, 
	SlimVectorBase<TReal, 3>& fVec, SlimVectorBase<TReal, 3>& fFriction, bool forceFrictionMode) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Real k1 = parameters.contactStiffness;
	Real d1 = parameters.contactDamping;
	Real n = parameters.contactStiffnessExponent;
	TReal deltaExp = -gap; // overwrite this in case that n != 1 holds (see following line)
	if (n != 1) { deltaExp = EXUstd::SignReal(deltaExp) * pow(fabs(deltaExp), n); } // also respect sign
	// at first, just use the easierst spring damper model (damping acts against n0 for sphere 1 if deltaVnormal is positive)
	TReal fDamp = - d1 * deltaVnormal;
	TReal contactForce = k1 * deltaExp + fDamp;

	if (parameters.impactModel != 0)
	{
		// if impactModel != 0  treat the contact force with restitution model
		// for resititution coefficient < 1, lambda must be negative as component acting in direction of damping is added
		TReal minImpactVel = EXUstd::Maximum(parameters.minimumImpactVelocity, data[dataIndexImpactVel]); 
		if (minImpactVel > 0)
		{
			TReal lambda = k1 / minImpactVel;
			const Real& ee = parameters.restitutionCoefficient; 
			if (parameters.impactModel == 1) // Hunt-Crossley
			{
				lambda *= 3. / 2. * (ee - 1.);
			} else if (parameters.impactModel == 2) // mixed Gonthier/EtAl-Carvalho/Martins
			{
				if (ee > 1. / 3.)
				{
					lambda *= 3. / 2. * (ee - 1.) * (11. - ee)/(1. + 9. * ee);
				}
				else if (ee > 0)
				{
					lambda *= (ee * ee - 1.) / ee;
				} else {
					CHECKandTHROWstring("CObjectContactSphereTorus: coefficient of restitution must be > 0");
				}
			}
			contactForce += lambda * deltaExp * deltaVnormal;
		}
	}
	contactForce *= (-1); // this is the contact force acting on sphere 1 (and moved to the LHS of the ODE2)
	fVec = contactForce * n0; //fVec = f_m1
	////////////////////////// add tangential component for the force vector if friction should be added
	// note that for coulomb friction we need fR acting against the velocity
	// fR = - fN * deltaVtangent
	// since fN is already moved to LHS of ODE2, the negative sign is not necessary: fR = fN * deltaVtangent
	// since we then must also move fR to LHS of ODE2, the computation again gets a negative sign
	if (dryFriction != 0.)
	{
		// global tangent velocity of spehere 1 relative to spehere 0
		SlimVectorBase<TReal, 3> deltaVtangent = deltaVji - deltaVnormal * n0;	// tangent velocity
		TReal relVel = deltaVtangent.GetL2Norm();
		if (!forceFrictionMode) // if mode is not enforced, then we have to compute it (this is wrong in GeneralContact!)
		{
			frictionRegularizedRegion = (relVel < parameters.frictionProportionalZone);
		}
		if (frictionRegularizedRegion && parameters.frictionProportionalZone != 0)
		{
			//Warning: in the adhesive model, contactForce could become positive (=tension) and cause unphysical friction behavior
			// as long as relVel < frictionProportionalZone, friction force is computed linearily with deltaVtangent
			fFriction = (-dryFriction * contactForce / parameters.frictionProportionalZone) * deltaVtangent;
		} else 
		{
			if (relVel != 0.) //in case that frictionProportionalZone=0, this could happen!
			{
				// this is to scale the friction force with the relative velocity
				// the friction force is decreased for high relative velocities
				fFriction = (-dryFriction * contactForce / relVel) * deltaVtangent; //this should be put into the nonlinear iteration for better Newton convergence ...
			}
			else { fFriction.SetAll(0.); }
		}
		fVec += fFriction;
	}
	return contactForce;
}

//compute the properties which are needed for computation of LHS and needed for OutputVariables
void CObjectContactSphereTorus::ComputeConnectorProperties(const MarkerDataStructure& markerData, Index itemIndex, const LinkedDataVector& data, 
	Real& frictionCoeff, Real& gap, Vector3D& deltaP, Vector3D& deltaV, Vector3D& pCircle1, Vector3D& contactPoint,
	Vector3D& fVec, Vector3D& fFriction, Vector3D& n0, bool contactFromData) const
{
	//0=Sphere, 1=Torus
	const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	const Vector3D& p1 = markerData.GetMarkerData(1).position;
	const Vector3D& p0 = markerData.GetMarkerData(0).position;
	Vector3D vAxis = A1 * parameters.torusAxis; //normalized

	//
	Vector3D pp0;
	EGeometry::ProjectInPlane(p1, vAxis, p0, pp0);

	Vector3D rPC = (pp0 - p1);
	Real lenR = rPC.GetL2Norm();
	CHECKandTHROW(lenR > 0, "CObjectContactSphereTorus::ComputeConnectorProperties: sphere is exactly at axis of torus and therefore contact computations failed!");
	
	rPC *= parameters.torusMajorRadius / lenR; //now rPC points from p0 to center of circle at torus
	pCircle1 = p1 + rPC; //center of circle on torus, representing marker 1 as hollow sphere (or cylinder)

	deltaP = (p0 - pCircle1);

	Real dist = deltaP.GetL2Norm();
	gap = parameters.torusMinorRadius - parameters.radiusSphere - dist; //gap = -penetration
	//if (!contactFromData) pout << "gap=" << gap << ", rPC=" << rPC << ", p1=" << p1 << ", pp0=" << pp0 << "\n";

	//unit direction and relative velocity of spring-damper
	n0 = deltaP; //contact vector in torus "tube"; normal from sphere center (m0) to contact point
	if (dist != 0.)
	{
		n0 *= (1. / dist);
	}
	Vector3D vSphere0 = markerData.GetMarkerData(0).velocity;
	Vector3D vTorus1 = markerData.GetMarkerData(1).velocity;
	//for torus, we always need to compute the full velocity due to rotation of the torus; therefore we also compute full velocity of sphere:
	vSphere0 += (markerData.GetMarkerData(0).orientation * markerData.GetMarkerData(0).angularVelocityLocal).CrossProduct((parameters.radiusSphere + 0.5 * gap) * n0);
	vTorus1 += (markerData.GetMarkerData(1).orientation * markerData.GetMarkerData(1).angularVelocityLocal).CrossProduct(rPC + (parameters.torusMinorRadius - 0.5 * gap) * n0);

	contactPoint = p0 + (parameters.radiusSphere + 0.5 * gap) * n0; //needed for torque computation
	frictionCoeff = parameters.dynamicFriction; //this has to be computed depending on velocity, using Stribeck function ...

	deltaV = vTorus1 - vSphere0; //relative velocity in normal direction

	bool hasContact;
	if (contactFromData) { hasContact = (data[dataIndexGap] < 0);	}
	else { hasContact = (gap < 0); }

	if (hasContact)
	{
		Real deltaVnormal = n0 * deltaV; //relative velocity in normal direction

		//frictionRegularizedRegion is only used in case that contactFromData=true
		bool frictionRegularizedRegion = data[dataIndexVtangent] < parameters.frictionProportionalZone;

		//Real contactForce = 
		ComputeContactForces<Real>(gap, n0, deltaVnormal, deltaV,
			frictionCoeff, frictionRegularizedRegion, fVec, fFriction, contactFromData);
	}
	else //no contact
	{
		fVec.SetAll(0.);
		fFriction.SetAll(0.);
	}
	//in case that it is inactive, we only compute kinematical quantities, but no forces
	if (!parameters.activeConnector)
	{
		fVec *= 0;
		fFriction *= 0;
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectContactSphereTorus::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectContactSphereTorus::ComputeAlgebraicEquations: marker do not provide velocityLevel information");

	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D pCircle1;
	Vector3D contactPoint;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real gap;

	ComputeConnectorProperties(markerData, objectNumber, data, 
		frictionCoeff, gap, deltaP, deltaV, pCircle1, contactPoint, fVec, fFriction, n0);

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	if (parameters.activeConnector)
	{
		//marker 1 / torus / J (positive):    (according to computation of relative position)
		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			//positionJacobian.NumberOfColumns() == rotationJacobian.NumberOfColumns()
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(), markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fVec, ldv1); //fVec = f_m1
			if (frictionCoeff != 0)
			{
				Vector3D torque = (contactPoint - markerData.GetMarkerData(1).position).CrossProduct(fVec); //fVec = f_m1
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, torque, ldv1);
			}
		}


		////marker 0 / sphere / I (negative):
		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, -fVec, ldv0); //fVec = f_m1
			if (frictionCoeff != 0)
			{
				Vector3D torque = (-(parameters.radiusSphere + 0.5 * gap) * n0).CrossProduct(fVec); //fVec = f_m1
				EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, torque, ldv0);
			}
		}
	}

}


//! provide according output variable in "value"
void CObjectContactSphereTorus::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	LinkedDataVector data = GetCNode(0)->GetCurrentCoordinateVector();
	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D pCircle1;
	Vector3D contactPoint;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real gap;

	ComputeConnectorProperties(markerData, itemIndex, data,
		frictionCoeff, gap, deltaP, deltaV, pCircle1, contactPoint, fVec, fFriction, n0);

	const Vector3D& p0 = markerData.GetMarkerData(0).position;
	const Vector3D& p1 = markerData.GetMarkerData(1).position;

	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(contactPoint); break;
	case OutputVariableType::Displacement: value.CopyFrom(p1-p0); break;
	case OutputVariableType::DisplacementLocal: value.CopyFrom(Vector1D({gap})); break;
	case OutputVariableType::Velocity: value.CopyFrom(deltaV); break;
	case OutputVariableType::Director1: {
		Vector3D v = (p1 - p0);
		Real len = v.GetL2Norm();
		if (len != 0) { v /= len; }
		value.CopyFrom(v); break;
	}
	case OutputVariableType::Director2: value.CopyFrom((pCircle1 - p1) *(1. / parameters.torusMajorRadius) ); break;
	case OutputVariableType::Director3: value.CopyFrom(n0); break;
	case OutputVariableType::Force: value.CopyFrom(fVec); break;
	case OutputVariableType::Torque: value.CopyFrom(((-(parameters.radiusSphere + 0.5 * gap)) * n0).CrossProduct(fVec)); break;
	default:
		SysError("CObjectContactSphereTorus::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}
}


//! function called after Newton method; returns a residual error (force); 
//! done for two different computation states in order to estimate the correct time of contact
Real CObjectContactSphereTorus::PostNewtonStep(const MarkerDataStructure& markerDataCurrent, Index itemIndex, PostNewtonFlags::Type& flags, Real& recommendedStepSize)
{
	//return force-type error in case of contact: in case that the assumed contact state has been wrong, 
	//  the contact force (also negative) is returned as measure of the error
	Real discontinuousError = 0;
	flags = PostNewtonFlags::_None;


	LinkedDataVector dataStartofStepState = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::StartOfStep);	//state0
	LinkedDataVector data = ((CNodeData*)GetCNode(0))->GetCoordinateVector(ConfigurationType::Current);			//state1


	Vector3D deltaP;
	Vector3D deltaV;
	Vector3D pCircle1;
	Vector3D contactPoint;
	Vector3D fVec;
	Vector3D fFriction;
	Vector3D n0;

	Real frictionCoeff;
	Real currentGap;

	ComputeConnectorProperties(markerDataCurrent, itemIndex, data, frictionCoeff, currentGap, deltaP, deltaV, fVec, pCircle1, contactPoint, fFriction, n0, false);

	Real vGap = n0 * deltaV; //required for Hunt-Crossley and similar models


	Real lastGap = data[dataIndexGap];
	Real startofStepGap = dataStartofStepState[dataIndexGap];

	Real lastVtangent = data[dataIndexVtangent];

	data[dataIndexGap] = currentGap;
	data[dataIndexVtangent] = (deltaV - (vGap)*n0).GetL2Norm(); //tangent velocity norm
	Real deltaPlastic = 0;
	data[dataIndexDeltaPlastic] = deltaPlastic; //unused

	//compute error for gap:
	if ((currentGap > 0 && lastGap <= 0) || (currentGap <= 0 && lastGap > 0)) //action: state1=currentGapState, error = |currentGap*k|
	{
		discontinuousError = fabs(currentGap * parameters.contactStiffness);

		//in fact it is (0-startofStepState) which is the part of time to go in these steps!
		//startofStepGap<=0 caused in case of inappropriate initialization => no step recommendation, but try to re-iterate
		if (vGap != 0 && startofStepGap > 0) { recommendedStepSize = fabs(startofStepGap / vGap); }

		//pout << "curGap=" << currentGap << ", sosGap=" << startofStepGap << ", discErr=" << discontinuousError << ", recStep=" << recommendedStepSize << ", vGap=" << vGap << "\n";
		flags = PostNewtonFlags::UpdateJacobian;
	}

	//compute error for friction:
	if (currentGap < 0 && parameters.frictionProportionalZone != 0.)
	{
		if ( (data[dataIndexVtangent] < parameters.frictionProportionalZone && lastVtangent > parameters.frictionProportionalZone) ||
			(data[dataIndexVtangent] > parameters.frictionProportionalZone && lastVtangent < parameters.frictionProportionalZone) )
		{
			//we have switching between stick and slip => so estimate some force error
			//we use the erroneous change in the tangent velocity and estimate the error in the friction force
			discontinuousError += fabs((parameters.dynamicFriction * (fVec * n0) / parameters.frictionProportionalZone) * (data[dataIndexVtangent] - parameters.frictionProportionalZone));

			//here we do not use a recommendedStepSize!
		}
	}

	//update impact velocity, if impact occured:
	if (startofStepGap > 0 && currentGap <= 0)
	{
		data[dataIndexImpactVel] = -vGap;
		//pout << "Impact vel=" << -vGap << "\n";
	}
	else //else set back to start-of-step, as we shall not change this value during discontinuous iterations!
	{
		data[dataIndexImpactVel] = dataStartofStepState[dataIndexImpactVel];
	}

	//pout << "PNS: currentGap=" << currentGap << ", previousState=" << previousState << ", currentState=" << currentState << ", error=" << discontinuousError << "\n";
	return discontinuousError;
}

//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
void CObjectContactSphereTorus::PostDiscontinuousIterationStep() 
{

}





