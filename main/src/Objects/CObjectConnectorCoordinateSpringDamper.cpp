/** ***********************************************************************************************
* @brief        Implementation of CObjectConnectorCoordinateSpringDamper
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamper.h"

//DELETE:
#include "Main/MainSystem.h"

//! function provides the force, relative displacement and relative velocity of the connector
inline void CObjectConnectorCoordinateSpringDamper::ComputeSpringForce(const MarkerDataStructure& markerData, Index itemIndex,
	Real& relPos, Real& relVel, Real& force) const
{
	//relative position, spring length and inverse spring length
	relPos = (markerData.GetMarkerData(1).vectorValue[0] - markerData.GetMarkerData(0).vectorValue[0]);

	//unit direction and relative velocity of spring-damper
	relVel = (markerData.GetMarkerData(1).vectorValue_t[0] - markerData.GetMarkerData(0).vectorValue_t[0]);

	force = 0; //default; necessary, e.g. if computed in GetOutputVariable...
	if (parameters.activeConnector)
	{
		if (!parameters.springForceUserFunction)
		{
			//compute resulting force vector:
			force = parameters.stiffness * (relPos - parameters.offset) + parameters.damping * relVel;
			if (parameters.dryFriction != 0.)
			{
				if (fabs(relVel) < parameters.dryFrictionProportionalZone)
				{
					//as long as vVel < dryFrictionProportionalZone, friction force shall linearly increase
					force += relVel / parameters.dryFrictionProportionalZone * parameters.dryFriction;
				}
				else
				{
					force += parameters.dryFriction*EXUstd::Sgn(relVel); //this should be put into the nonlinear iteration for better Newton convergence ...
				}
			}
		}
		else
		{
			UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
			{
				//user function args:(deltaL, deltaL_t, Real stiffness, Real damping, Real offset, Real dryFriction, Real dryFrictionProportionalZone)
				force = parameters.springForceUserFunction((const MainSystem&)cSystemData->GetMainSystemBacklink(), markerData.GetTime(), itemIndex,
					relPos, relVel, parameters.stiffness, parameters.damping, parameters.offset, parameters.dryFriction, parameters.dryFrictionProportionalZone);
			}, "ObjectConnectorCoordinateSpringDamper::springForceUserFunction");
		}
	}
}



//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//  MODEL: f
void CObjectConnectorCoordinateSpringDamper::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData, Index objectNumber) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectConnectorCoordinateSpringDamper::ComputeODE2LHS: marker do not provide velocityLevel information");

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).jacobian.NumberOfColumns() + markerData.GetMarkerData(1).jacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	if (parameters.activeConnector)
	{
		Real relPos;
		Real relVel;
		Real force;
		ComputeSpringForce(markerData, objectNumber, relPos, relVel, force);


		Vector1D fVec(force); //convert to vector to allow matrix-multiplication as usual ...

		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).jacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).jacobian.NumberOfColumns(), markerData.GetMarkerData(1).jacobian.NumberOfColumns());

			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).jacobian, fVec, ldv1);
		}

		if (markerData.GetMarkerData(0).jacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).jacobian.NumberOfColumns());

			fVec *= -1.;
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).jacobian, fVec, ldv0);

		}
	}

}

//FUTURE: needed if MarkerNodeRotationCoordinate has jacDerivative: 
void CObjectConnectorCoordinateSpringDamper::ComputeJacobianForce6D(const MarkerDataStructure& markerData, Index objectNumber, Vector6D& force6D) const
{
	if (parameters.activeConnector)
	{
		Real relPos, relVel, force;
		ComputeSpringForce(markerData, objectNumber, relPos, relVel, force);
		force6D.SetVector({ force, 0., 0., 0., 0., 0. }); //for coordinate connectors, use only first coordinate
	}
	else { force6D.SetAll(0.); }
}

void CObjectConnectorCoordinateSpringDamper::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp,
	Real factorODE2, Real factorODE2_t,
	Index objectNumber, const ArrayIndex& ltg, const MarkerDataStructure& markerData) const
{
	if (parameters.activeConnector)
	{
		temp.localJacobian.SetNumberOfRowsAndColumns(1, 1);
		//compute inner jacobian: factorODE2 * d(F)/(dq) + factorODE2_t * d(F)/(dq_t)
		Real localJac = parameters.stiffness * factorODE2 + parameters.damping * factorODE2_t;

		if (parameters.dryFriction != 0.)
		{
			//this is one line code duplication:
			Real relVel = (markerData.GetMarkerData(1).vectorValue_t[0] - markerData.GetMarkerData(0).vectorValue_t[0]);
			Real smooth = 0.01; //add some smoothening of the proportional zone for the Jacobian, as it otherwise may cause problems with Newton (switching variable would be better!)
			if (fabs(relVel) < parameters.dryFrictionProportionalZone*(1.-smooth))
			{
				//as long as vVel < dryFrictionProportionalZone, friction force shall linearly increase
				localJac += 1. / parameters.dryFrictionProportionalZone * parameters.dryFriction;
			}
			else if (fabs(relVel) < parameters.dryFrictionProportionalZone*(1. + smooth))
			{
				//untested!
				Real fact = (parameters.dryFrictionProportionalZone*(1. + smooth) - fabs(relVel)) / (2 * smooth*parameters.dryFrictionProportionalZone);
				localJac += fact / parameters.dryFrictionProportionalZone * parameters.dryFriction;
			}
			//otherwise zero

		}
		temp.localJacobian(0, 0) = localJac;
		//pout << "inside, localJac=" << localJac << "\n";
	}
	//compute jacobianODE2 in dense mode; temp.localJacobian is modified!
	ComputeJacobianODE2_ODE2generic(temp.localJacobian, jacobianODE2, temp, factorODE2, factorODE2_t, objectNumber, markerData, 
		parameters.activeConnector, true, false);
}


JacobianType::Type CObjectConnectorCoordinateSpringDamper::GetAvailableJacobians() const
{
	if (!parameters.springForceUserFunction)
	{
		return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t + JacobianType::ODE2_ODE2_function + JacobianType::ODE2_ODE2_t_function);
	}
	else 
	{
		return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t);
	}
}

//! provide according output variable in "value"
void CObjectConnectorCoordinateSpringDamper::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	Real relPos;
	Real relVel;
	Real force;
	ComputeSpringForce(markerData, itemIndex, relPos, relVel, force);

	switch (variableType)
	{
	case OutputVariableType::Displacement: value = Vector({ relPos }); break;
	case OutputVariableType::Velocity: value = Vector({ relVel }); break;
	case OutputVariableType::Force: value = Vector({ force }); break;
	default:
		SysError("CObjectConnectorCoordinateSpringDamper::GetOutputVariable failed"); //error should not occur, because types are checked!
	}

}

