/** ***********************************************************************************************
* @brief        CObjectGenericODE2 implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"

#include "Main/CSystemData.h"
#include "Linalg/RigidBodyMath.h"

#include "Autogenerated/CObjectGenericODE2.h"
#include "Pymodules/PybindUtilities.h"

//**delete
//#include <pybind11/pybind11.h>
//#include <pybind11/stl.h>
//#include <pybind11/stl_bind.h>
//#include <pybind11/operators.h>
//#include <pybind11/numpy.h>       //interface to numpy
//#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
//#include <pybind11/embed.h>       //scoped interpreter
////does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
////#include <pybind11/cast.h> //for arguments
//#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes


void CObjectGenericODE2::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE2Size());
	coordinates_t.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}

}

void CObjectGenericODE2::ComputeObjectCoordinates_tt(Vector& coordinates_tt, ConfigurationType configuration) const
{
	coordinates_tt.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode_tt(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_tt(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates_tt[cnt + i] = vNode_tt[i];
		}
		cnt += nc;
	}
}

//! Computational function: compute mass matrix
void CObjectGenericODE2::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber) const
{
	if (parameters.massMatrixUserFunction)
	{
		Index nODE2 = GetODE2Size();
		//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		//Vector coordinates_t(nODE2);
		tempCoordinates.SetNumberOfItems(nODE2);
		tempCoordinates_t.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		//Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();

		//massMatrixC is set with user function, chosing the correct type of matrix
		//massMatrixC sparse/dense matrix type is set in user function!
		EvaluateUserFunctionMassMatrix(massMatrixC, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t, ltg);

	}
	else //standard constant matrix
	{
		if (parameters.massMatrix.NumberOfRows() != 0)
		{
			massMatrixC.CopyOrAddTriplets(parameters.massMatrix, ltg);
		}
		else //set zero mass matrix, e.g. for static computation
		{
			massMatrixC.SetUseDenseMatrix(false); //uses sparse matrix with no entries.

			//OLD, DELETE:
			//Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
			//Index nODE2 = GetODE2Size();
			//massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
			//massMatrix.SetAll(0.);
		}
	}
}

//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//in fact, this is the LHS function!
void CObjectGenericODE2::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	Index nODE2 = GetODE2Size();
	ode2Lhs.SetNumberOfItems(nODE2);
	ode2Lhs.SetAll(0.);

	//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	//Vector coordinates_t(nODE2);
	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

	//K*q and D*q_T put to LHS !!!

	if (parameters.stiffnessMatrix.NumberOfRows() != 0)
	{
		//EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrix, tempCoordinates, ode2Lhs);
		parameters.stiffnessMatrix.MultMatrixVectorAdd(tempCoordinates, ode2Lhs);
	}

	if (parameters.dampingMatrix.NumberOfRows() != 0)
	{
		//EXUmath::MultMatrixVectorAdd(parameters.dampingMatrix, tempCoordinates_t, ode2Lhs);
		parameters.dampingMatrix.MultMatrixVectorAdd(tempCoordinates_t, ode2Lhs);
	}

	if (parameters.forceVector.NumberOfItems() != 0)
	{
		ode2Lhs -= parameters.forceVector;
	}

	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce;

		EvaluateUserFunctionForce(userForce, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t);
		CHECKandTHROW(userForce.NumberOfItems() == nODE2, "CObjectGenericODE2: forceUserFunction return a vector with different size from ObjectGenericODE2 system size");
		ode2Lhs -= userForce;
	}

}

//! Computational function: compute mass matrix
void CObjectGenericODE2::ComputeJacobianODE2_ODE2(EXUmath::MatrixContainer& jacobianODE2, JacobianTemp& temp, 
	Real factorODE2, Real factorODE2_t, Index objectNumber, const ArrayIndex& ltg) const
{
	//Index columnsStiff = parameters.stiffnessMatrix.NumberOfColumns();
	Index rowsStiff = parameters.stiffnessMatrix.NumberOfRows();
	//Index columnsDamp = parameters.dampingMatrix.NumberOfColumns();
	Index rowsDamp = parameters.dampingMatrix.NumberOfRows();
	//Index nODE2 = GetNumberOfCoordinates();
	bool addStiffnessMatrix = true;
	bool addDampingMatrix = true;

	if (parameters.jacobianUserFunction)
	{
		Index nODE2 = GetODE2Size();
		//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		//Vector coordinates_t(nODE2);
		tempCoordinates.SetNumberOfItems(nODE2);
		tempCoordinates_t.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		//jacobian is computed in user function, chosing the correct type of matrix
		//EvaluateUserFunctionJacobian does the correct adding to jacobianODE2 depending on sparse/dense mode
		EvaluateUserFunctionJacobian(jacobianODE2, cSystemData->GetMainSystemBacklink(), t, objectNumber, 
			tempCoordinates, tempCoordinates_t, factorODE2, factorODE2_t, ltg);
		//pout << "nODE2=" << nODE2 << ", rows=" << jacobianODE2.NumberOfRows() << ", cols=" << jacobianODE2.NumberOfColumns() << "\n";

		//checks performed only in dense mode :
		//(in sparse mode the jacobianODE2 is a link to the sparseTriplets of the system matrix and has size 0):
		if (jacobianODE2.UseDenseMatrix() && (jacobianODE2.NumberOfRows() != nODE2 || jacobianODE2.NumberOfColumns() != nODE2))
		{
			CHECKandTHROWstring("CObjectGenericODE2::ComputeJacobianODE2_ODE2: jacobianUserFunction must return square matrix with size according to ObjectGenericODE2 coordinates!");
		}
	}
	else
	{
		//add stiffness matrix as first matrix and set type with it:
		//jacobianODE2.SetUseDenseMatrix(parameters.stiffnessMatrix.UseDenseMatrix()); //use just type of stiffnessMatrix
		if (rowsStiff)
		{ 
			jacobianODE2.CopyOrAddTripletsWithFactor(parameters.stiffnessMatrix, ltg, factorODE2); 		
			addStiffnessMatrix = false;
		}
		else if (rowsDamp) 
		{
			jacobianODE2.CopyOrAddTripletsWithFactor(parameters.dampingMatrix, ltg, factorODE2_t);
			addStiffnessMatrix = false; //not needed, because rowsStiff = 0
			addDampingMatrix = false;
		}
	}

	if (jacobianODE2.UseDenseMatrix())
	{
		if (!parameters.stiffnessMatrix.UseDenseMatrix() && parameters.stiffnessMatrix.NumberOfRows() != 0)
		{
			CHECKandTHROWstring("CObjectGenericODE2::ComputeJacobianODE2_ODE2: jacobianUserFunction must return same format (dense/sparse triplets) as in stiffnessMatrix!");
		}
		if (rowsStiff && addStiffnessMatrix) 
		{ 
			//jacobianODE2.GetInternalDenseMatrix() += factorODE2 * parameters.stiffnessMatrix.GetInternalDenseMatrix(); 
			EXUmath::FactorTimesMatrixAddTemplate< ResizableMatrix, ResizableMatrix>(factorODE2, 
				parameters.stiffnessMatrix.GetInternalDenseMatrix(), jacobianODE2.GetInternalDenseMatrix());
		}
		if (rowsDamp && addDampingMatrix) 
		{ 
			//jacobianODE2.GetInternalDenseMatrix() += factorODE2_t * parameters.dampingMatrix.GetInternalDenseMatrix(); 
			EXUmath::FactorTimesMatrixAddTemplate< ResizableMatrix, ResizableMatrix>(factorODE2_t, 
				parameters.dampingMatrix.GetInternalDenseMatrix(), jacobianODE2.GetInternalDenseMatrix());
		}
	}
	else
	{
		if (parameters.stiffnessMatrix.UseDenseMatrix() && parameters.stiffnessMatrix.NumberOfRows() != 0)
		{
			CHECKandTHROWstring("CObjectGenericODE2::ComputeJacobianODE2_ODE2: jacobianUserFunction must return same format (dense/sparse triplets) as in stiffnessMatrix!");
		}
		if (rowsStiff && addStiffnessMatrix)
		{
			SparseTripletVector& triplets = jacobianODE2.GetInternalSparseTripletMatrix().GetTriplets();
			for (const SparseTriplet& item : parameters.stiffnessMatrix.GetInternalSparseTripletMatrix().GetTriplets())
			{
				triplets.AppendPure(SparseTriplet(ltg[item.row()], ltg[item.col()], factorODE2*item.value()));
			}
		}
		if (rowsDamp && addDampingMatrix)
		{
			SparseTripletVector& triplets = jacobianODE2.GetInternalSparseTripletMatrix().GetTriplets();
			for (const SparseTriplet& item : parameters.dampingMatrix.GetInternalSparseTripletMatrix().GetTriplets())
			{
				triplets.AppendPure(SparseTriplet(ltg[item.row()], ltg[item.col()], factorODE2_t*item.value()));
			}
		}

	}


}

//! AUTO:  return the available jacobian dependencies and the jacobians which are available as a function; if jacobian dependencies exist but are not available as a function, it is computed numerically; can be combined with 2^i enum flags
JacobianType::Type CObjectGenericODE2::GetAvailableJacobians() const
{
	//if user function is supplied, then the analytical (function) jacobian is available
	if (parameters.jacobianUserFunction) 
	{
		return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t + JacobianType::ODE2_ODE2_function + JacobianType::ODE2_ODE2_t_function);
	}
	else 
	{
		return (JacobianType::Type)(JacobianType::ODE2_ODE2 + JacobianType::ODE2_ODE2_t);
	}
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectGenericODE2::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt +
		(Index)AccessFunctionType::DisplacementMassIntegral_q + (Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectGenericODE2::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	SysError("CObjectGenericODE2:GetAccessFunctionBody not available");
}

//! provide according output variable in "value"
void CObjectGenericODE2::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	Index nODE2 = GetODE2Size();
	//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	//Vector coordinates_t(nODE2);
	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(tempCoordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(tempCoordinates_t);	break;
	case OutputVariableType::Coordinates_tt: 
	{
		//Vector coordinates_tt(nODE2);
		tempCoordinates_tt.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates_tt(tempCoordinates_tt, configuration);
		value.CopyFrom(tempCoordinates_tt);
		break;
	}
	case OutputVariableType::Force:			ComputeODE2LHS(value, objectNumber);	break;
	default:
		SysError("CObjectGenericODE2::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetPosition: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + localPosition;

}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetVelocity: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration);
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetDisplacement: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

Index CObjectGenericODE2::GetODE2Size() const
{
	//Index s = 0;
	//for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	//{
	//	s += GetCNode(i)->GetNumberOfODE2Coordinates();
	//}
	//return s;

	//faster version, does not require iterations:
	Index nn = parameters.nodeNumbers.NumberOfItems();
	if (nn) { return parameters.coordinateIndexPerNode.Last() + GetCNode(nn - 1)->GetNumberOfODE2Coordinates(); }
	else { return 0; }
}

void CObjectGenericODE2::InitializeCoordinateIndices()
{
	parameters.coordinateIndexPerNode.SetNumberOfItems(parameters.nodeNumbers.NumberOfItems());

	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		parameters.coordinateIndexPerNode[i] = s;
		if (!EXUstd::IndexIsInRange(parameters.nodeNumbers[i], 0, cSystemData->GetCNodes().NumberOfItems()))
		{
			PyError("ObjectGenericODE2: invalid node number detected; all nodes used in ObjectGenericODE2 must already exist");
		}
		else
		{
			s += GetCNode(i)->GetNumberOfODE2Coordinates();
		}
	}
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! for definition see CObjectSuperElement
void CObjectGenericODE2::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, const Vector3D& localOffset, Matrix& value) const
{
	CObjectSuperElement::GetAccessFunctionSuperElement(accessType, weightingMatrix, meshNodeNumbers, localOffset, value);
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectGenericODE2::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetOutputVariableTypesSuperElement: meshNodeNumber out of range ");

	return GetCNode(meshNodeNumber)->GetOutputVariableTypes();
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectGenericODE2::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	return GetCNode(meshNodeNumber)->GetOutputVariable(variableType, configuration, value);
}

//! return the mesh node pointer; for consistency checks
CNodeODE2* CObjectGenericODE2::GetMeshNode(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNode: meshNodeNumber out of range");

	return (CNodeODE2*)(GetCNode(meshNodeNumber));
}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeLocalPosition: meshNodeNumber out of range");
	
	return ((CNodeODE2*)(GetCNode(meshNodeNumber)))->GetPosition(configuration);
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeLocalVelocity: meshNodeNumber out of range ");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber)))->GetVelocity(configuration);
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodePosition: meshNodeNumber out of range");
	return GetMeshNodeLocalPosition(meshNodeNumber, configuration);
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeVelocity: meshNodeNumber out of range");

	return GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
}

