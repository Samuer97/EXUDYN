/** ***********************************************************************************************
* @brief        CObjectJointPrismatic2D implementation
*
* @author       Gerstmayr Johannes
* @date         2018-12-09 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectJointPrismatic2D.h"


//! Computational function: compute algebraic equations and write residual into "algebraicEquations"
void CObjectJointPrismatic2D::ComputeAlgebraicEquations(Vector& algebraicEquations, const MarkerDataStructure& markerData, Real t, Index itemIndex, bool velocityLevel) const
{
	if (parameters.activeConnector)
	{
		if (!velocityLevel)
		{
			Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
			//Matrix3D A0 = markerData.GetMarkerData(0).orientation;
			//Matrix3D A1 = markerData.GetMarkerData(1).orientation;
			Vector3D t0 = markerData.GetMarkerData(0).orientation * parameters.axisMarker0; //parameters.axisMarker0 = tangent vector (in direction of prismatic axis) at marker0 (in local coordinates)
			Vector3D n1 = markerData.GetMarkerData(1).orientation * parameters.normalMarker1; //parameters.normalMarker1 = normal vector at marker1 (in local coordinates)

			algebraicEquations.SetNumberOfItems(2);
			algebraicEquations[0] = vPos*n1;
			if (parameters.constrainRotation)
			{ 
				algebraicEquations[1] = t0 * n1;
			}
			else
			{
				algebraicEquations[1] = markerData.GetLagrangeMultipliers()[1];
			}
		}
		else
		{
			CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable, "CObjectJointPrismatic2D::ComputeAlgebraicEquations: marker do not provide velocityLevel information");
			Vector3D vVel = (markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);
			Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
			Vector3D omega0 = markerData.GetMarkerData(0).angularVelocityLocal;
			Vector3D omega1 = markerData.GetMarkerData(1).angularVelocityLocal;
			Matrix3D A0 = markerData.GetMarkerData(0).orientation;
			Matrix3D A1 = markerData.GetMarkerData(1).orientation;
			Vector3D t0 = A0 * parameters.axisMarker0; //parameters.axisMarker0 = tangent vector (in direction of prismatic axis) at marker0 (in local coordinates)
			Vector3D n1 = A1 * parameters.normalMarker1; //parameters.normalMarker1 = normal vector at marker1 (in local coordinates)

			Vector3D t0_t = A0 * (omega0.CrossProduct(parameters.axisMarker0)); //=d(t0)/dt; -A0*lt0 x omega0
			Vector3D n1_t = A1 * (omega1.CrossProduct(parameters.normalMarker1));			//-A1*ln1 x omega1

			algebraicEquations.SetNumberOfItems(2);
			algebraicEquations[0] = vVel*n1 + vPos*n1_t;
			if (parameters.constrainRotation)
			{
				algebraicEquations[1] = t0_t * n1 + t0 * n1_t;
			}
			else
			{
				algebraicEquations[1] = markerData.GetLagrangeMultipliers()[1];
			}
		}
	}
	else
	{
		algebraicEquations.CopyFrom(markerData.GetLagrangeMultipliers()); //equation [lambda0,lambda1]^T = [0,0]^T, means that the current values need to be copied
	}
}


void CObjectJointPrismatic2D::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, ResizableMatrix& jacobian_ODE1,
	ResizableMatrix& jacobian_AE, const MarkerDataStructure& markerData, Real t, Index itemIndex) const
{
	if (parameters.activeConnector)
	{
		//markerData contains already the correct jacobians ==> transformed to constraint jacobian
		Index cols0 = markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(); //equal to rotationJacobian.NumberOfColumns() !
		Index cols1 = markerData.GetMarkerData(1).positionJacobian.NumberOfColumns(); //equal to rotationJacobian.NumberOfColumns() !
		jacobian_ODE2.SetNumberOfRowsAndColumns(2, cols0 + cols1);

		Vector3D vPos = (markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position);
		Matrix3D A0 = markerData.GetMarkerData(0).orientation;
		Matrix3D A1 = markerData.GetMarkerData(1).orientation;
		Vector3D t0 = A0 * parameters.axisMarker0; //parameters.axisMarker0 = tangent vector (in direction of prismatic axis) at marker0 (in local coordinates)
		Vector3D n1 = A1 * parameters.normalMarker1; //parameters.normalMarker1 = normal vector at marker1 (in local coordinates)

		const ResizableMatrix& posJac0 = markerData.GetMarkerData(0).positionJacobian;
		const ResizableMatrix& posJac1 = markerData.GetMarkerData(1).positionJacobian;
		const ResizableMatrix& rotJac0 = markerData.GetMarkerData(0).rotationJacobian; 
		const ResizableMatrix& rotJac1 = markerData.GetMarkerData(1).rotationJacobian;

		//algebraicEquations[0] = vPos * A1* ln1; ==> (posJac1-posJac0)*(n1) - vPos*A1*(ln1 x rotJac1)
		//algebraicEquations[1] = t0 * n1;		  ==> -A0*(lt0 x rotJac0) * n1  - t0 * A1*(ln1 x rotJac1)

		for (Index i = 0; i < cols0; i++) //derivatives for marker0
		{
			Vector3D vRotJac0({rotJac0(0,i), rotJac0(1,i), rotJac0(2,i) }); //temporary vector
			jacobian_ODE2(0, i) = -posJac0(0, i)*n1[0] - posJac0(1, i)*n1[1];// +vPos * (A1*parameters.normalMarker1.CrossProduct(vRotJac1));
			if (parameters.constrainRotation)
			{
				jacobian_ODE2(1, i) = -(A0*(parameters.axisMarker0.CrossProduct(vRotJac0))*n1);
			}
			else { jacobian_ODE2(1, i) = 0; }
		}
		for (Index i = 0; i < cols1; i++) //derivatives for marker1
		{
			Vector3D vRotJac1({ rotJac1(0,i), rotJac1(1,i), rotJac1(2,i) }); //temporary vector
			//jacobian_ODE2(0, i + cols0) = posJac1(0, i)*n1[0] + posJac1(1, i)*n1[1] + vPos * (A1*parameters.normalMarker1.CrossProduct(vRotJac1));
			jacobian_ODE2(0, i + cols0) = posJac1(0, i)*n1[0] + posJac1(1, i)*n1[1] - vPos * (A1*parameters.normalMarker1.CrossProduct(vRotJac1));
			if (parameters.constrainRotation)
			{
				jacobian_ODE2(1, i + cols0) = -(t0 * (A1*parameters.normalMarker1.CrossProduct(vRotJac1)));
			}
			else { jacobian_ODE2(1, i + cols0) = 0; }

		}

		//pout << "jac=" << jacobian << "\n";
		//jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); 
		
		if (!parameters.constrainRotation)
		{
			jacobian_AE.SetScalarMatrix(2, 0.);
			jacobian_AE(1,1) = 1.;
		}
	}
	else
	{
		jacobian_AE.SetScalarMatrix(2, 1.); //represents derivative of algebraic equation '[lambda0,lambda1]^T = [0,0]^T'
	}
}

JacobianType::Type CObjectJointPrismatic2D::GetAvailableJacobians() const
{
	if (parameters.activeConnector)
	{
		if (parameters.constrainRotation)
		{ return (JacobianType::Type)(JacobianType::AE_ODE2 + JacobianType::AE_ODE2_function);}
		else
		{ return (JacobianType::Type)(JacobianType::AE_ODE2 + JacobianType::AE_ODE2_function + JacobianType::AE_AE + JacobianType::AE_AE_function);}
	}
	else //deactivated constraint means that only the lagrange multiplier needs to be set to zero
	{
		return (JacobianType::Type)(JacobianType::AE_AE + JacobianType::AE_AE_function);
	}
}


//! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
OutputVariableType CObjectJointPrismatic2D::GetOutputVariableTypes() const
{
	return (OutputVariableType)((Index)OutputVariableType::Distance + (Index)OutputVariableType::Rotation); //Distance contains movement along prismatic axis
}

//! provide according output variable in "value"
void CObjectJointPrismatic2D::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Index itemIndex, Vector& value) const
{
	SysError("CObjectJointPrismatic2D::GetOutputVariableConnector not implemented");
}



