\mysection{Overview on \codeName }
%
\mysubsection{Module structure} \label{sec:programStructure}
This section will show:
\bi
  \item Overview of modules
  \item Conventions: dimension of nodes, objects and vectors
  \item Coordinates: reference coordinates and displacements
  \item Nodes, Objects, Markers and Loads
\ei
For an introduction to the solvers, see \refSection{sec:solvers}.

\mysubsubsection{Overview of modules}
Currently, the module structure is simple:
\bi
  \item \mybold{C++ parts}, see Figs.\ \ref{fig_exudyn_overview} and \ref{fig_system_overview}:
  \bi
    \item[--] \texttt{exudyn}:
    on this level, there are just very few functions: \texttt{SystemContainer()}, \texttt{StartRenderer()}, \texttt{StopRenderer()}, \texttt{GetVersionString()}, \texttt{SolveStatic(...)}, \texttt{SolveDynamic(...)}, ... as well as system and user variable dictionaries \texttt{exudyn.variables} and \texttt{exudyn.sys}
    \item[--] \texttt{SystemContainer}: contains the systems (most important), solvers (static, dynamics, ...), visualization settings
    \item[--] \texttt{mbs}: system created with \texttt{mbs = SC.AddSystem()}, this structure contains everything that defines a solvable multibody system; a large set of nodes, objects, markers, 
    loads can added to the system, see \refSection{sec:item:reference:manual};
    \item[--] \texttt{mbs.systemData}: contains the initial, current, visualization, ... states of the system and holds the items, see \fig{fig_system_overview}
  \ei
  \item \mybold{Python parts} (this list is continuously extended, see \refSection{sec:pythonUtilityFunctions}), sorted by importance:
  \bi
    \item[--] \texttt{exudyn.utilities}: constains helper classes in Python and includes \codeName\ modules \texttt{basicUtilities}, \texttt{rigidBodyUtilities}, \texttt{graphicsDataUtilities}, and \texttt{itemInterface}, which is recommended to be loaded at beginning of your model file
    \item[--] \texttt{exudyn.itemInterface}: contains the interface, which transfers Python classes (e.g., of a NodePoint) to dictionaries that can be understood by the C++ module
    \item[--] \texttt{exudyn.basicUtilities}: contains basic helper classes, without importing numpy
    \item[--] \texttt{exudyn.rigidBodyUtilities}: contains important helper classes for creation of rigid body inertia, rigid bodies, and rigid body joints; includes helper functions for rotation parameterization, rotation matrices, homogeneous transformations, etc.
    \item[--] \texttt{exudyn.graphicsDataUtilities}: provides some basic drawing utilities, definition of colors and basic drawing objects (including \acs{STL} import); rotation/translation of graphicsData objects
    \item[--] \texttt{exudyn.plot}: containing helper functions, which are physics related such as friction
    \item[--] \texttt{exudyn.processing}: methods for optimization, parameter variation, sensitivity analysis, etc.
    \item[--] \texttt{exudyn.FEM}: everything related to finite element import and creation of model order reduction flexible bodies
    \item[--] \texttt{exudyn.robotics}: submodule containing several helper modules related to manipulators (\texttt{robotics}, \texttt{robotics.models}), mobile robots (\texttt{robotics.mobile}), trajectory generation (\texttt{robotics.motion}), etc.
    \item[--] \texttt{exudyn.beams}: helper functions for creation of beams along straight lines and curves, sliding joints, etc.
    \item[--] \texttt{exudyn.interactive}: helper classes to create interactive models (e.g. for teaching or demos)
    \item[--] \texttt{exudyn.physics}: containing helper functions, which are physics related such as friction
    \item[--] \texttt{exudyn.signalProcessing}: filters, FFT, etc.; interfaces to scipy and numpy methods
    \item[--] \texttt{exudyn.solver}: functions imported when loading \texttt{exudyn}, containing main solvers
  \ei
\ei
%
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\begin{figure}
  \centering
  \begin{tikzpicture}[node distance = 2cm, auto]
      % Place nodes
      \node [cloud] (exu) {exudyn};
      \node [wideblock, below of=exu] (systemContainer) {SystemContainer};
      \node [wideblock, below of=systemContainer] (system) {MainSystem (e.g. 'mbs')};
      \node [wideblock, right of=systemContainer,  node distance=6cm] (visualizationSettings) {visualizationSettings};
      \node [block, below of=system] (systemData) {systemData};
      \node [wideblock, below of=systemData] (systemStates) {system states (initial, current, ...)};
      
      \node [wideblock, dashed, fill=gray!10, right of=system,  node distance=6cm] (anotherSystem) {MainSystem (e.g. 'anotherMbs')};
      \node [block, dashed, fill=gray!10, below of=anotherSystem] (anotherSystemData) {systemData};
      \node [wideblock, dashed, fill=gray!10, below of=anotherSystemData] (anotherSystemStates) {system states (initial, current, ...)};

      %\node [cloud, right of=exu] (itemInterface) {itemInterface.py};
      %\node [cloud, right of=itemInterface] (exudynUtilities) {exudynUtilities.py};

      % Draw edges
      \path [line] (exu) -- (systemContainer);
      \path [line] (systemContainer) -- (system);
      \path [line] (systemContainer) -- (visualizationSettings);
      \path [line] (system) -- (systemData);
      \path [line] (systemData) -- (systemStates);

      \path [line, dashed] (systemContainer) -- (anotherSystem);
      \path [line, dashed] (anotherSystem) -- (anotherSystemData);
      \path [line, dashed] (anotherSystemData) -- (anotherSystemStates);
  \end{tikzpicture}
  \caption{Overview of exudyn module.}
  \label{fig_exudyn_overview}
\end{figure}
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\begin{figure}
  \centering
  \begin{tikzpicture}[node distance = 2cm, auto]
      % 
      \node [cloud] (system) {MainSystem ('mbs')};
      \node [wideblock, below of=system] (systemData) {systemData};
      \node [wideblock, left of=systemData, node distance=5cm] (systemStates) {system states};
      \node [wideblock, text width=3cm, below of=systemStates, xshift=-2cm] (current) {current state};
      \node [wideblock, text width=3cm, below of=current] (initial) {initial state};
      \node [wideblock, text width=3cm, below of=initial] (reference) {reference state};
      \node [wideblock, text width=3cm, dashed, fill=gray!10, below of=reference] (otherStates) {other states};
      
      \node [wideblock, right of=systemData, node distance=5cm] (ltg) {\acs{LTG} coordinate index lists};
      
      \node [wideblock, below of=systemData, xshift=2.4cm] (nodes) {list of nodes};
      \node [wideblock, below of=nodes] (objects) {list of objects};
      \node [wideblock, below of=objects] (markers) {list of markers};
      \node [wideblock, below of=markers] (loads) {list of loads};
      \node [wideblock, below of=loads] (sensors) {list of sensors};

      % Draw edges
      \path [line] (system) -- (systemData);
      \path [line] (systemData) -- (systemStates);
      \path [line] (systemStates) |- (current);
      \path [line] (systemStates) |- (initial);
      \path [line] (systemStates) |- (reference);
      \path [line, dashed] (systemStates) |- (otherStates);

      \path [line] (systemData) -- (ltg);

      \path [line] (systemData) |- (nodes);
      \path [line] (systemData) |- (objects);
      \path [line] (systemData) |- (markers);
      \path [line] (systemData) |- (loads);
      \path [line] (systemData) |- (sensors);
%
  \end{tikzpicture}
  \caption{Overview of systemData, which connects items, states and stores the \acs{LTG}. Note that access to items is provided via functions in \texttt{system}.}
  \label{fig_system_overview}

\end{figure}
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\mysubsubsection{Conventions: items, indexes, coordinates}
In this documentation, we will use the term \mybold{item} to identify nodes, objects, markers, loads and sensors:
\be
  \mathrm{item} \in \{\mathrm{node}, \mathrm{object}, \mathrm{marker}, \mathrm{load}, \mathrm{sensor} \}
\ee
\vspace{12pt}\\
\mybold{Indexes: arrays and vectors starting with 0:} \vspace{6pt}\\
As known from Python, all \mybold{indexes} of arrays, vectors, matrices, ...\ are starting with 0. This means that the first component of the vector \texttt{v=[1,2,3]} is accessed with \texttt{v[0]} in Python (and also in the C++ part of \codeName ). The range is usually defined as \texttt{range(0,3)}, in which '3' marks the index after the last valid component of an array or vector.
\ignoreRST{\vspace{12pt}\\}
%
\mybold{Dimensionality of objects and vectors:} \ignoreRST{\vspace{6pt}}\\ 
\ac{2D} vs.\ \ac{3D}
\ignoreRST{\vspace{6pt}\\}
As a convention, quantities in \codeName\ are 3D, such as nodes, objects, markers, loads, measured quantities, etc. 
For that reason, we denote planar nodes, objects, etc.\ with the suffix 2D, but 3D objects do not get this suffix.

Output and input to objects, markers, loads, etc.\ is usually given by 3D vectors (or matrices), such as (local) position, force, torque, rotation, etc. However, initial and reference values for nodes depend on their dimensionality.
As an example, consider a \texttt{NodePoint2D}:
\bi
  \item \texttt{referenceCoordinates} is a 2D vector (but could be any dimension in general nodes)
  \item measuring the current position of \texttt{NodePoint2D} gives a 3D vector
  \item when attaching a \texttt{MarkerNodePosition} and a \texttt{LoadForceVector}, the force will be still a 3D vector
\ei
Furthermore, the local position in 2D objects is provided by a 3D vector. Usually, the dimensionality is given in the reference manual. User errors in the dimensionality will be usually detected either by the Python interface (i.e., at the time the item is created) or by the system-preprocessor

\mysubsection{Items: Nodes, Objects, Loads, Markers, Sensors, ...} \label{sec:items}
%
In this section, the most important part of \codeName\ are provided. An overview of the interaction of the items is given in \fig{fig_items_interaction}

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\begin{figure}
  \centering
  \begin{tikzpicture}[node distance = 2cm, auto, thick,scale=0.7, every node/.style={scale=0.7}]
      % Place nodes
      \node [nodeBlock] (node0) {node 0};
      \node [nodeBlock, below of=node0, node distance=2cm] (node1) {node 1};
      \node [nodeBlock, below of=node1, node distance=2cm] (node2) {node 2};

      \node [objectBlock, right of=node0] (object0) {object 0 (body)};
      \node [objectBlock, right of=node1, yshift = -1cm] (object1) {object 1 (body)};
      
      \node [markerBlock, right of=object0] (marker0) {marker 0};
      \node [loadBlock, right of=marker0, node distance=3cm] (load0) {load 0};
      
      \node [markerBlock, left of=node2, yshift = -2cm, xshift = 1cm] (marker1) {marker 1};
      \node [markerBlock, right of=node2, yshift = -2cm] (marker2) {marker 2};

      \node [connectorBlock, below of=node2] (connector) {connector};


      \path [arrow] (object0) -- (node0);
      \path [arrow] (marker0) -- (object0);
      \path [arrow] (load0) -- (marker0);
      \path [arrow] (object1) -- (node1);
      \path [arrow] (object1) -- (node2);
      \path [arrow] (marker1) |- (node0);
      \path [arrow] (marker2) -- (object1);
      \path [arrow] (connector) -- (marker1);
      \path [arrow] (connector) -- (marker2);
      %\path [line] (systemData) |- (objects);
      %\path [line] (systemData) |- (markers);
      %\path [line] (systemData) |- (loads);

  \end{tikzpicture}
  \caption{Typical interaction of items in a multibody system. Note that both, bodies and connectors/constraints are (computational) objects. The arrows indicate, that, e.g., object 1 has node 1 and node 2 (indexes) and that marker 0 is attached to object 0, while load 0 uses marker 0 to apply the load. Sensors could additionally be attached to certain items.}
  \label{fig_items_interaction}

\end{figure}
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\mysubsubsection{Nodes}
Nodes provide the coordinates (and the degrees of freedom) to the system. They have no mass, stiffness or whatsoever assigned.
Without nodes, the system has no unknown coordinates.
Adding a node provides (for the system unknown) coordinates. In addition we also need equations for every nodal coordinate -- otherwise the system cannot be computed (NOTE: this is currently not checked by the preprocessor).

\mysubsubsection{Objects}
Objects are 'computational objects' and they provide equations to your system. Objects often provide derivatives and have measurable quantities (e.g. displacement) and they provide access, which can be used to apply, e.g., forces. Some of this functionality is only available in C++, but not in Python.

Objects can be a:
\bi
  \item general object (e.g.\ a controller, user defined object, ...; no example yet)
  \item body: has a mass or mass distribution; markers can be placed on bodies; loads can be applied; constraints can be attached via markers; bodies can be:
  \bi
    \item[--] ground object: has no nodes
    \item[--] simple body: has one node (e.g. mass point, rigid body)
    \item[--] finite element and more complicated body (e.g. FFRF-object): has more than one node
  \ei
  \item connector: uses markers to connect nodes and/or bodies; adds additional terms to system equations either based on stiffness/damping or with constraints (and Lagrange multipliers). Possible connectors:
  \bi
    \item[--] algebraic constraint (e.g. constrain two coordinates: $q_1 = q_2$)
    \item[--] classical joint
    \item[--] spring-damper or penalty constraint
  \ei
\ei

\mysubsubsection{Markers}
Markers are interfaces between objects/nodes and constraints/loads.
A constraint (which is also an object) or load cannot act directly on a node or object without a marker.
As a benefit, the constraint or load does not need to know whether it is applied, e.g., to a node or to a local position of a body.

Typical situations are:
\bi
  \item Node -- Marker -- Load
  \item Node -- Marker -- Constraint (object)
  \item Body(object) -- Marker -- Load
  \item Body1 -- Marker1 -- Joint(object) -- Marker2 -- Body2
\ei

\mysubsubsection{Loads}
Loads are used to apply forces and torques to the system. The load values are static values. However, you can use Python functionality to modify loads either by linearly increasing them during static computation or by using the 'mbs.SetPreStepUserFunction(...)' structure in order to modify loads in every integration step depending on time or on measured quantities (thus, creating a controller).

\mysubsubsection{Sensors}
Sensors are only used to measure output variables (values) in order to simpler generate the requested output quantities.
They have a very weak influence on the system, because they are only evaluated after certain solver steps as requested by the user.

\mysubsubsection{Reference coordinates and displacements}
Nodes usually have separated reference and initial quantities. Here, 
\texttt{referenceCoordinates} are the coordinates for which the system is defined upon creation. Reference coordinates are needed, e.g., for definition of joints and for the reference configuration of finite elements. In many cases it marks the undeformed configuration (e.g., with finite elements), but not, e.g., for \texttt{ObjectConnectorSpringDamper}, which has its own reference length. 

Initial displacement (or rotation) values are provided separately, in order to start a system from a configuration different from the reference configuration.
As an example, the initial configuration of a \texttt{NodePoint} is given by \texttt{referenceCoordinates + initialCoordinates}, while the initial state of a dynamic system additionally needs \texttt{initialVelocities}.

\mysubsection{Mapping between local and global coordinate indices} \label{sec:systemData:LTG}
%
The \ac{LTG}-index-mappings\footnote{local-to-global coordinate index mappings containing transformation from local object coordinate indices to global (system) coordinate indices; this is different for \mybold{coordinate transformations}!} between local coordinate \mybold{indices}, on node or object level, and global (=system) coordinate \mybold{indices} follows the following rules:
\bi
\item \ac{LTG}-index-mappings are computed during \texttt{mbs.Assemble()} and are not available before.
\item Nodes own a global index which relates the local coordinates to global (system) coordinate. E.g., for a \ac{ODE2} node with node number \texttt{i}, this index can be obtained via the function \texttt{mbs.GetNodeODE2Index(i)}.
\item The order of global coordinates is simply following the node numbering. If we add three nodes \texttt{NodePoint}, the system will contain 9 coordinates, where the first triple (starting index 0) belongs to node 0, the second triple (starting index 3) belongs to node 1 and the third triple (starting index 6) belongs to node 2. After \texttt{mbs.Assemble()}, you can access the system coordinates via \texttt{mbs.systemData.GetODE2Coordinates()}, which returns a numpy array with 9 coordinates, containing the initial values provided in \texttt{NodePoint} (default: zero).
\item Objects have their own \ac{LTG}-index-mappings for their respective coordinate types. The \ac{ODE2} coordinates of an object \texttt{j} can be retrieved via \texttt{mbs.systemData.GetObjectLTGODE2(j)}. For a body, these are the global \ac{ODE2} coordinates representing the body; for a connector, these are the coordinates to which the connector is linked (usually coordinates of two bodies); for a ground object, the \ac{LTG}-index-mapping is empty; see also \refSection{sec:systemData:ObjectLTG}.
\item Constraints create algebraic variables (Lagrange multipliers) automatically. For a constraint with object number \texttt{k}, the global index to algebraic variables (of \ac{AE}-type) can be accessed via \texttt{mbs.systemData.GetObjectLTGAE(k)}.
\ei


\mysubsection{Exudyn Basics} \label{sec:exudynBasics}
This section will show:
\bi
  \item Interaction with the \codeName\ module
  \item Simulation settings
  \item Visualization settings
  \item Generating output and results
  \item Graphics pipeline
  \item Generating animations
\ei


\mysubsubsection{Interaction with the \codeName\ module}
It is important that the \codeName\ module is basically a state machine, where you create items on the C++ side using the Python interface. This helps you to easily set up models using many other Python modules (numpy, sympy, matplotlib, ...) while the computation will be performed in the end on the C++ side in a very efficient manner. 
\vspace{12pt}\\
\mybold{Where do objects live?}\vspace{6pt}\\
%(where do objects live? state machine; graphics interaction)
Whenever a system container is created with \texttt{SC = exu.SystemContainer()}, the structure \texttt{SC} becomes a variable in the Python interpreter, but it is managed inside the C++ code and it can be modified via the Python interface.
Usually, the system container will hold at least one system, usually called \texttt{mbs}.
Commands such as \texttt{mbs.AddNode(...)} add objects to the system \texttt{mbs}. 
The system will be prepared for simulation by \texttt{mbs.Assemble()} and can be solved (e.g., using \texttt{exu.SolveDynamic(...)}) and evaluated hereafter using the results files.
Using \texttt{mbs.Reset()} will clear the system and allows to set up a new system. Items can be modified (\texttt{ModifyObject(...)}) after first initialization, even during simulation.
%

\mysubsubsection{Simulation settings}
The simulation settings consists of a couple of substructures, e.g., for \texttt{solutionSettings}, \texttt{staticSolver}, \texttt{timeIntegration} as well as a couple of general options -- for details see Sections \ref{sec:SolutionSettings} -- \ref{sec:SimulationSettings}.

Simulation settings are needed for every solver. They contain solver-specific parameters (e.g., the way how load steps are applied), information on how solution files are written, and very specific control parameters, e.g., for the Newton solver. 

\noindent The simulation settings structure is created with 
\pythonstyle\begin{lstlisting}
  simulationSettings = exu.SimulationSettings()
\end{lstlisting}
%
Hereafter, values of the structure can be modified, e.g.,
\pythonstyle\begin{lstlisting}
  tEnd = 10 #10 seconds of simulation time:
  h = 0.01  #step size (gives 1000 steps)
  simulationSettings.timeIntegration.endTime = tEnd
  #steps for time integration must be integer:
  simulationSettings.timeIntegration.numberOfSteps = int(tEnd/h)
  #assigns a new tolerance for Newton's method:
  simulationSettings.timeIntegration.newton.relativeTolerance = 1e-9 
  #write some output while the solver is active (SLOWER):
  simulationSettings.timeIntegration.verboseMode = 2                 
  #write solution every 0.1 seconds:
  simulationSettings.solutionSettings.solutionWritePeriod = 0.1      
  #use sparse matrix storage and solver (package Eigen):
  simulationSettings.linearSolverType = exu.LinearSolverType.EigenSparse 
\end{lstlisting}

\mysubsubsection{Generating output and results}
%
The solvers provide a number of options in \texttt{solutionSettings} to generate a solution file. As a default, exporting solution to the solution file is activated with a writing period of 0.01 seconds.

\noindent Typical output settings are:
\pythonstyle\begin{lstlisting}
  #create a new simulationSettings structure:
  simulationSettings = exu.SimulationSettings()
  
  #activate writing to solution file:
  simulationSettings.solutionSettings.writeSolutionToFile = True
  #write results every 1ms:
  simulationSettings.solutionSettings.solutionWritePeriod = 0.001
  
  #assign new filename to solution file
  simulationSettings.solutionSettings.coordinatesSolutionFileName= "myOutput.txt"

  #do not export certain coordinates:
  simulationSettings.solutionSettings.exportDataCoordinates = False
\end{lstlisting}



\mysubsubsection{Visualization settings}
%
Visualization settings are used for user interaction with the model. E.g., the nodes, markers, loads, etc., can be visualized for every model. There are default values, e.g., for the size of nodes, which may be inappropriate for your model. Therefore, you can adjust those parameters. In some cases, huge models require simpler graphics representation, in order not to slow down performance -- e.g., the number of faces to represent a cylinder should be small if there are 10000s of cylinders drawn. Even computation performance can be slowed down, if visualization takes lots of CPU power. However, visualization is performed in a separate thread, which usually does not influence the computation exhaustively.
Details on visualization settings and its substructures are provided in Sections \ref{sec:VSettingsGeneral} -- \ref{sec:VisualizationSettings}.

The visualization settings structure can be accessed in the system container \texttt{SC} (access per reference, no copying!), accessing every value or structure directly, e.g.,
\pythonstyle\begin{lstlisting}
  SC.visualizationSettings.nodes.defaultSize = 0.001      #draw nodes very small

  #change openGL parameters; current values can be obtained from SC.GetRenderState()
  #change zoom factor:
  SC.visualizationSettings.openGL.initialZoom = 0.2       
  #set the center point of the scene (can be attached to moving object):
  SC.visualizationSettings.openGL.initialCenterPoint = [0.192, -0.0039,-0.075]

  #turn of auto-fit:
  SC.visualizationSettings.general.autoFitScene = False

  #change smoothness of a cylinder:
  SC.visualizationSettings.general.cylinderTiling = 100
  
  #make round objects flat:
  SC.visualizationSettings.openGL.shadeModelSmooth = False

  #turn on coloured plot, using y-component of displacements:
  SC.visualizationSettings.contour.outputVariable = exu.OutputVariableType.Displacement
  SC.visualizationSettings.contour.outputVariableComponent = 1 #0=x, 1=y, 2=z
\end{lstlisting}

\mysubsubsubsection{Storing the model view}
\label{sec:storing:modelview}
There is a simple way to store the current view (zoom, centerpoint, orientation, etc.) by using \texttt{SC.GetRenderState()} and \texttt{SC.SetRenderState()}.
%
A simple way is to reload the stored render state (model view) after simulating your model once at the end of the simulation\footnote{
note that \texttt{visualizationSettings.general.autoFitScene} should be set False if you want to use the stored zoom factor}:
\pythonstyle\begin{lstlisting}
  import exudyn as exu
  SC=exu.SystemContainer()
  SC.visualizationSettings.general.autoFitScene = False #prevent from autozoom
  exu.StartRenderer()
  if 'renderState' in exu.sys:
      SC.SetRenderState(exu.sys['renderState']) 
  #+++++++++++++++
  #do simulation here and adjust model view settings with mouse
  #+++++++++++++++

  #store model view for next run:
  StopRenderer() #stores render state in exu.sys['renderState']
\end{lstlisting}
\horizontalRuler \\
%
Alternatively, you can obtain the current model view from the console after a simulation, e.g.,
\pythonstyle\begin{lstlisting}
  In[1] : SC.GetRenderState()
  Out[1]: 
  {'centerPoint': [1.0, 0.0, 0.0],
   'maxSceneSize': 2.0,
   'zoom': 1.0,
   'currentWindowSize': [1024, 768],
   'modelRotation': [[ 0.34202015,  0.        , 0.9396926 ],
                     [-0.60402274,  0.76604444, 0.21984631],
                     [-0.7198463 , -0.6427876 , 0.26200265]])}
\end{lstlisting}
%
which contains the last state of the renderer.
Now copy the output and set this with \texttt{SC.SetRenderState} in your Python code to have a fixed model view in every simulation (\texttt{SC.SetRenderState} AFTER \texttt{exu.StartRenderer()}):
\pythonstyle\begin{lstlisting}
  SC.visualizationSettings.general.autoFitScene = False #prevent from autozoom
  exu.StartRenderer()
  renderState={'centerPoint': [1.0, 0.0, 0.0],
               'maxSceneSize': 2.0,
               'zoom': 1.0,
               'currentWindowSize': [1024, 768],
               'modelRotation':     [[ 0.34202015,  0.        ,  0.9396926 ],
                                    [-0.60402274,  0.76604444,  0.21984631],
                                    [-0.7198463 , -0.6427876 ,  0.26200265]])
  SC.SetRenderState(renderState)
  #.... further code for simulation here
\end{lstlisting}
\horizontalRuler
%
%

\mysubsubsection{Graphics pipeline}
%deprecated, since there are user functions!: The user cannot interact with the visualization part for now.
There are basically two loops during simulation, which feed the graphics pipeline.
The solver runs a loop:
\bi
  \item compute new step
  \item finish computation step; results are in current state
  \item copy current state to visualization state (thread safe)
  \item signal graphics pipeline that new visualization data is available
\ei
The openGL graphics thread (=separate thread) runs the following loop:
\bi
  \item render openGL scene with a given graphicsData structure (containing lines, faces, text, ...)
  \item go idle for some milliseconds
  \item check if openGL rendering needs an update (e.g. due to user interaction)
  \item[] $\ra$ if update is needed, the visualization of all items is updated -- stored in a graphicsData structure)
  \item check if new visualization data is available and the time since last update is larger than a presribed value, the graphicsData structure is updated with the new visualization state
\ei

\mysubsubsection{Graphics user Python functions}
There are some user functions in order to customize drawing:
\bi
  \item You can assign graphicsData to the visualization to most bodies, such as rigid bodies in order to change the shape. Graphics can also be imported from files (\texttt{GraphicsDataFromSTLfileTxt}) using the established format \ac{STL}\footnote{STereoLithography or Standard Triangle Language; file format available in nearly all CAD systems}.
  \item Some objects, e.g., \texttt{ObjectGenericODE2} or \texttt{ObjectRigidBody}, provide customized a function \texttt{graphicsDataUserFunction}. This user function just returns a list of GraphicsData, see \refSection{sec:graphicsData}. With this function you can change the shape of the body in every step of the computation.
  \item Specifically, the \texttt{graphicsDataUserFunction} in \texttt{ObjectGround} can be used to draw any moving background in the scene.
\ei
Note that all kinds of \texttt{graphicsDataUserFunction}s need to be called from the main (=computation) process as Python functions may not be called from separate threads (GIL). Therefore, the computation thread is interrupted to execute the \texttt{graphicsDataUserFunction} between two time steps, such that the graphics Python user function can be executed. There is a timeout variable for this interruption of the computation with a warning if scenes get too complicated.

\mysubsubsection{Color and RGBA}
Many functions and objects include color information. In order to allow transparency, all colors contain a list of 4 RGBA values, all values being in the range [0..1]:
\bi
  \item red (R) channel 
  \item green (G) channel  
  \item blue (B) channel 
  \item alpha (A) value, representing transparency (A=0: fully transparent, A=1: solid)
\ei
E.g., red color with no transparency is obtained by the color=[1,0,0,1]. Color predefinitions are found in \texttt{exudynGraphicsDataUtilities.py}, e.g., \texttt{color4red} or \texttt{color4steelblue} as well a list of 10 colors \texttt{color4list}, which is convenient to be used in a loop creating objects.

\mysubsubsection{Camera following objects and interacting with model view}
\label{secInteractModelView}
For some models, it may be advantageous to track the translation and/or rotation of certain bodies, e.g., for cars, (wheeled) robots or bicycles. 
To do so, the current render state (\texttt{SC.GetRenderState()}, \texttt{SC.SetRenderState(...)}) can be obtained and modified, in order to always follow a certain position.
As this needs to be done during redraw of every frame, it is conveniently done in a graphicsUserFunction, e.g., within the ground body. This is shown in the following example, in which \texttt{mbs.variables['nTrackNode']} is a node number to be tracked:
%
\pythonstyle\begin{lstlisting}
  #mbs.variables['nTrackNode'] contains node number
  def UFgraphics(mbs, objectNum):
      n = mbs.variables['nTrackNode']
      p = mbs.GetNodeOutput(n,exu.OutputVariableType.Position, 
                            configuration=exu.ConfigurationType.Visualization)
      rs=SC.GetRenderState() #get current render state
      A = np.array(rs['modelRotation'])
      p = A.T @ p #transform point into model view coordinates
      rs['centerPoint']=[p[0],p[1],p[2]]
      SC.SetRenderState(rs)  #modify render state
      return []

  #add object with graphics user function
  oGround2 = mbs.AddObject(ObjectGround(visualization=
                 VObjectGround(graphicsDataUserFunction=UFgraphics)))
  #.... further code for simulation here
\end{lstlisting}

\mysubsubsection{Solution viewer}
\label{secSolutionViewer}
\codeName\ offers a convenient WYSIWYS -- 'What you See is What you Simulate' interface, showing you the computation results during simulation.
If you are running large models, it may be more convenient to watch results after simulation has been finished.
For this, you can use
\bi
  \item \texttt{utilities.AnimateSolution}, see Section \ref{sec:utilities:AnimateSolution}
  \item \texttt{interactive.SolutionViewer}, see Section \ref{sec:interactive:SolutionViewer}
  \item \texttt{interactive.AnimateModes}, lets you view the animation of computed modes, see Section \ref{sec:interactive:AnimateModes}
\ei
The function \texttt{AnimateSolution} allows to directly visualize the stored solution for according stored time frames.
The \texttt{SolutionViewer} adds a \texttt{tkinter} interactive dialog, which lets you interact with the model ('Player').
In both methods \texttt{AnimateSolution} and \texttt{SolutionViewer}, the solution needs to be loaded with
\texttt{LoadSolutionFile('coordinatesSolution.txt')}, where 'coordinatesSolution.txt' represents the stored solution file, 
see 
\bi
  \item \texttt{exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName}
\ei
You can call the \texttt{SolutionViewer} either in the model, or at the command line / IPython to load a previous solution (belonging to the same mbs underlying the solution!):
\pythonstyle\begin{lstlisting}
  from exudyn.interactive import SolutionViewer
  sol = LoadSolutionFile('coordinatesSolution.txt')
  SolutionViewer(mbs, sol)
\end{lstlisting}
\mybold{Alternatively}, you can just reload the last stored solution (according to your \texttt{simulationSettings}):
\pythonstyle\begin{lstlisting}
  from exudyn.interactive import SolutionViewer
  SolutionViewer(mbs)
\end{lstlisting}
An example for the \texttt{SolutionViewer} is integrated into the \texttt{Examples/} directory, see \texttt{solutionViewerTest.py}. 

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\mysubsubsection{Generating animations}
\label{secGeneratingAnimations}
%
In many dynamics simulations, it is very helpful to create animations in order to better understand the motion of bodies. Specifically, the animation can be used to visualize the model much slower or faster than the model is computed.

Animations are created based on a series of images (frames, snapshots) taken during simulation. It is important, that the current view is used to record these images -- this means that the view should not be changed during the recording of images.
To turn on recording of images during solving, set the following flag to a positive value
\bi
  \item \texttt{simulationSettings.solutionSettings.recordImagesInterval = 0.01}
\ei
which means, that after every 0.01 seconds of simulation time, an image of the current view is taken and stored in the directory and filename (without filename ending) specified by 
\bi
  \item \texttt{SC.visualizationSettings.exportImages.saveImageFileName = "myFolder/frame"}
\ei
By default, a consecutive numbering is generated for the image, e.g., 'frame0000.png, frame0001.png,...'. Note that the standard file format PNG with ending '.png' uses compression libraries included in glfw, while the alternative TGA format produces '.tga' files which contain raw image data and therefore can become very large.

To create animation files, an external tool FFMPEG is used to efficiently convert a series of images into an animation.
\onlyRST{$\ra$ see theDoc.pdf !}
\ignoreRST{
In windows, simple DOS batch files can do the job to convert frames given in the local directory to animations, e.g.:
\plainlststyle
\lstinputlisting[breaklines=true, basicstyle=\ttm]{../userTools/makeAnimations/convertToVideo.bat}
After the video has been created, you should delete the single images:
\plainlststyle
\lstinputlisting[breaklines=true, basicstyle=\ttm]{../userTools/makeAnimations/deletePNGimages.bat}
}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\mysubsubsection{Examples, test models and test suite}
\label{secExamplesTestModels}

The main collection of examples and models is available under
\bi
  \item \texttt{main/pythonDev/Examples}
  \item \texttt{main/pythonDev/TestModels}
\ei
You can use these examples to build up your own realistic models of multibody systems.
Very often, these models show the way which already works. Alternative ways may exist, but
sometimes there are limitations in the underlying C++ code, such that they won't work as you expect.

We would like to note that, even that some examples and test models contain comparison to 
papers of the literature or analytical solutions, there are many models which may not contain real
mechanical values and these models may not be converged in space or time 
(in order to keep running our test suite in less than a minute).

Finally, note that the \texttt{main/pythonDev/TestModels} are often only intended to preserve functionality
in the Python and C++ code (e.g., if global methods are changed), but they should not be misinterpreted as validation of the 
implemented methods. The \texttt{TestModels} are used in the \codeName\ \mybold{TestSuite} \texttt{TestModels/runTestSuite.py}
which is run after a full build of Python versions. Output for very version is written
to \texttt{main/pythonDev/TestSuiteLogs} containing the \codeName\ version and Python version. At the end of these
files, a summary is included to show if all models completed successfully (which means that a certain error level is achieved, which is rather small and different for the models).
There are also performance tests (e.g., if a certain implementation leads to a significant drop of performance).
However, the output of the performance tests is not stored on github.

We are trying hard to achieve error-free algorithms of physically correct models, but there may always be some errors in the code.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\mysubsubsection{Contact problems}
%
Since Q4 2021 a contact module is available in \codeName. 
This separate module \texttt{GeneralContact} is highly optimized and implemented with parallelization (multi-threaded) for certain types of contact elements.
\onlyRST{

.. |cpic1| image:: docs/theDoc/figures/contactTests.png
   :width: 45%

.. |cpic2| image:: docs/theDoc/figures/contactTests2.jpg
   :width: 45%

|cpic1| |cpic2|

[Some tests and examples using \texttt{GeneralContact}]

}
\ignoreRST{
\begin{figure}[tbh]%
\begin{center}
\includegraphics[width=0.35\columnwidth]{figures/contactTests} \hspace{1cm}%
\includegraphics[width=0.35\columnwidth]{figures/contactTests2}%
\end{center}
\caption{Some tests and examples using \texttt{GeneralContact}.}%
\label{fig:contactExamples}%
\end{figure}
}

\noindent \mybold{Note}:
\bi
\item \texttt{GeneralContact} is (in most cases) restricted to dynamic simulation (explicit or implicit) if friction is used; without friction, it also works in the static case
\item in addition to \texttt{GeneralContact} there are special objects, in particular for rolling and simple 1D contacts, that are available as single objects, cf.\ \texttt{ObjectConnectorRollingDiscPenalty}
\item \texttt{GeneralContact} is recommended to be used for large numbers of contacts, while the single objects are integrated more directly into mbs.
\ei

\noindent Currently, \texttt{GeneralContact} includes:
\bi
  \item Sphere-Sphere contact (attached to any marker); may represent circle-circle contact in 2D
  \item Triangles mounted on rigid bodies, in contact with Spheres
  \item ANCFCable2D contacting with spheres (which then represent circles in 2D)
\ei
For details on the contact formulations, see \refSection{secContactTheory}.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\mysubsubsection{Removing convergence problems and solver failures}
\label{secConvergenceProblems}
Nonlinear formulations (such as most multibody systems, especially nonlinear finite elements) cause problems and there is no general nonlinear solver which may reliably and accurately solve such problems.
Tuning solver parameters is at hand of the user. 
In general, the Newton solver tries to reduce the error by the factor given in \texttt{simulationSettings.staticSolver.newton.relativeTolerance} (for static solver), which is not possible for very small (or zero) initial residuals. The absolute tolerance is helping out as a lower bound for the error, given in \texttt{simulationSettings.staticSolver.newton.absoluteTolerance} (for static solver), which is by default rather low (1e-10) -- in order to achieve accurate results for small systems or small motion (in mm or $\mu$m regime). Increasing this value helps to solve such problems. Nevertheless, you should usually set tolerances as low as possible because otherwise, your solution may become inaccurate.

\noindent The following hints shall be followed (also some solver hints).
\bi
  \item \mybold{static solver}: load steps are reduced even if the solution seems to be smooth and less steps are expected; larger number of steps may happen for finer discretization; you may adjust (increase) \texttt{.newton.relativeTolerance} / \texttt{.newton.absoluteTolerance} in static solver or in time integration to resolve such problems, but check if solution achieves according accuracy
  \item \mybold{static solver}: load steps are reduced significantly for highly nonlinear problems; solver repeatedly writes that steps are reduced $\ra$ try to use \texttt{loadStepGeometric} and use a large \texttt{loadStepGeometricRange}: this allows to start with very small loads in which the system is nearly linear (e.g. for thin strings or belts under gravity).
  \item \mybold{static solver}: in case that your system is (nearly) kinematic, a static solution can be achieved using \texttt{stabilizerODE2term}, which adds mass-proportional stiffness terms during load steps $< 1$.
  \item very small loads or even \mybold{zero loads} do not converge: \texttt{SolveDynamic} or \texttt{SolveStatic} \mybold{terminated due to errors}
  \bi
  \item[$\ra$] the reason is the nonlinearity of formulations (nonlinear kinematics, nonlinear beam, etc.) and round off errors, which restrict Newton to achieve desired tolerances
  \item[$\ra$] adjust (increase) \texttt{.newton.relativeTolerance} / \texttt{.newton.absoluteTolerance} in static solver or in time integration
  \item[$\ra$] in many cases, especially for static problems, the \texttt{.newton.newtonResidualMode = 1} evaluates the increments; the nonlinear problems is assumed to be converged, if increments are within given absolute/relative tolerances; this also works usually better for kinematic solutions
  \ei
  \item for \mybold{discontinuous problems}: try to adjust solver parameters; especially the \texttt{discontinuous.iterationTolerance} and \texttt{discontinuous.maxIterations}; try to make smaller load or time steps in order to resolve switching points of contact or friction; generalized alpha solvers may cause troubles when reducing step sizes $\ra$ use TrapezoidalIndex2 solver
  \item if you see further problems, please post them (including relevant example) at the \codeName\ github page!
\ei

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\mysubsubsection{Performance and ways to speed up computations}
\label{secSpeedUp}
%
Multibody dynamics simulation should be accurate and reliable on the one hand side. Most solver settings are such that they lead to comparatively reliable results.
However, in some cases there is a significant possibility for speeding up computations, which are described in the following list. Not all recommendations may apply to your models.

The following examples refer to \texttt{simulationSettings = exu.SimulationSettings()}.
In general, to see where CPU time is lost, use the option turn on \texttt{simulationSettings.displayComputationTime = True} to see which parts of the solver need most of the time (deactivated in current Python3.8 version!).

\noindent \mybold{Possible speed ups in general}:
\bi
  \item for models with more than 50 coordinates, switching to sparse solvers might greatly improve speed: \texttt{simulationSettings.linearSolverType = exu.LinearSolverType.EigenSparse}
  \item try to avoid Python function or try to speed up Python functions
  \item instead of user functions in objects or loads (computed in every iteration), some problems would also work if these parameters are only updated in \texttt{mbs.SetPreStepUserFunction(...)}
  \item for \mybold{discontinuous problems}, try to adjust solver parameters; especially the discontinuous.iterationTolerance which may be too tight and cause many iterations; iterations may be limited by discontinuous.maxIterations, which at larger values solely multiplies the computation time with a factor if all iterations are performed
  \item For multiple computations / multiple runs of Exudyn (parameter variation, optimization, compute sensitivities), you can use the processing sub module of \codeName\ to parallelize computations and achieve speedups proporional to the number of cores/threads of your computer; specifically using the \texttt{multiThreading} option or even using a cluster (using \texttt{dispy}, see \texttt{ParameterVariation(...)} function)
  \item In case of multiprocessing and cluster computing, you may see a very high CPU usage of "Antimalware Service Executable", which is the Microsoft Defender Antivirus; you can turn off such problems by excluding \texttt{python.exe} from the defender (on your own risk!) in your settings:\\
  Settings $\ra$ Update \& Security $\ra$ Windows Security $\ra$ Virus \& threat protection settings $\ra$ Manage settings $\ra$ Exclusions $\ra$ Add or remove exclusions 
\ei
\mybold{Possible speed ups for dynamic simulations}:
\bi
  \item for implicit integration, turn on \mybold{modified Newton}, which updates jacobians only if needed: \texttt{simulationSettings.timeIntegration.newton.useModifiedNewton = True}
  \item switch to Python3.8: this version excludes range checks and timings; usually 30\% faster
  \item use \mybold{multi-threading}: \texttt{simulationSettings.parallel.numberOfThreads = ...}, depending on the number of cores (larger values usually do not help); improves greatly for contact problems, but also for some objects computed in parallel; will improve significantly in future
  \item decrease number of steps (\texttt{simulationSettings.timeIntegration.numberOfSteps = int(tEnd/h)}) by increasing the step size $h$ if not needed for accuracy reasons; not that in general, the solver will reduce steps in case of divergence, but not for accuracy reasons, which may still lead to divergence if step sizes are too large
  \item switch off measuring computation time, if not needed: \texttt{simulationSettings.displayComputationTime = False}
  \item try to switch to \mybold{explicit solvers}, if problem has no constraints and if problem is not stiff
  \item try to have \mybold{constant mass matrices} (see according objects, which have constant mass matrices; e.g. rigid bodies using RotationVector Lie group node have constant mass matrix)
  \item for explicit integration, set \texttt{computeEndOfStepAccelerations = False}, if you do not need accurate evaluation of accelerations at end of time step (will then be taken from beginning)
  \item if you are sure that your mass matrix is constant, set \texttt{simulationSettings.timeIntegration.reuseConstantMassMatrix = True}; check results!
  \item check that \texttt{simulationSettings.timeIntegration.simulateInRealtime = False}; if set True, it breaks down simulation to real time
  \item do not record images, if not needed: \texttt{simulationSettings.solutionSettings.recordImagesInterval = -1}
  \item in case of bad convergence, decreasing the step size might also help; check also other flags for adaptive step size and for Newton
  \item use \texttt{simulationSettings.timeIntegration.verboseMode = 1}; larger values create lots of output which drastically slows down
  \item use \texttt{simulationSettings.timeIntegration.verboseModeFile = 0}, otherwise output written to file
  \item adjust \texttt{simulationSettings.solutionSettings.sensorsWritePeriod} to avoid time spent on writing sensor files
  \item use \texttt{simulationSettings.timeIntegration.writeSolutionToFile = False}, otherwise much output may be written to file; 
  \item if solution file is needed, adjust \texttt{simulationSettings.solutionSettings.solutionWritePeriod} to larger values and also adjust \texttt{simulationSettings.solutionSettings.outputPrecision}, e.g., to 6, in order to avoid larger files; also adjust \texttt{simulationSettings.solutionSettings.exportVelocities = False} and \texttt{simulationSettings.solutionSettings.exportAccelerations = False} to avoid large output files
\ei











%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\mysubsection{C++ Code}
This section covers some information on the C++ code. For more information see the Open source code and use doxygen.

Exudyn was developed for the efficient simulation of flexible multi-body systems. Exudyn was designed for rapid implementation and testing of new formulations and algorithms in multibody systems, whereby these algorithms can be easily implemented in efficient C++ code. The code is applied to industry-related research projects and applications.

\mysubsubsection{Focus of the C++ code}
\mybold{Four principles}: 
\bn
  \item developer-friendly
  \item error minimization
  \item efficiency
  \item user-friendliness
\en
The focus is therefore on:
\bi
    \item A developer-friendly basic structure regarding the C++ class library and the possibility to add new components.
    \item The basic libraries are slim, but extensively tested; only the necessary components are available
    \item Complete unit tests are added to new program parts during development; for more complex processes, tests are available in Python
    \item In order to implement the sometimes difficult formulations and algorithms without errors, error avoidance is always prioritized.
    \item To generate efficient code, classes for parallelization (vectorization and multithreading) are provided. We live the principle that parallelization takes place on multi-core processors with a central main memory, and thus an increase in efficiency through parallelization is only possible with small systems, as long as the program runs largely in the cache of the processor cores. Vectorization is tailored to SIMD commands as they have Intel processors, but could also be extended to GPGPUs in the future.
    \item The user interface (Python) provides a 1:1 image of the system and the processes running in it, which can be controlled with the extensive possibilities of Python.
\ei

\mysubsubsection{C++ Code structure}
%
The following \mybold{entry points} into the C++ code can be found:
\bi
  \item Python -- C++: the creation of the module \texttt{exudyn} is found in:\\
    \texttt{main/src/Pymodules/PybindModule.cpp}\\
  it includes large header files, which are automatically created for binding C++ code with Python.
  \item The object factory for creation of items (calling \texttt{mbs.AddNode(...)} and similar): \\
    \texttt{main/src/Main/MainObjectFactory.h / .cpp}
  \item Using the VisualStudio \texttt{.sln} file and using the Debug mode allows you to smoothly walk from Python to C++ code (though that this takes 
  some time to start up and it does not work always; and it does not work for graphics if it runs in a separate thread).
\ei

The functionality of the code is mainly based on systems (MainSystem and CSystem), items and solvers representing the multibody system or similar physical systems to be simulated. Parts of the core structure of Exudyn are:
\bi
  \item CSystem / MainSystem: a multibody system which consists of nodes, objects, markers, loads, etc.
  \item SystemContainer: holds a set of systems; connects to visualization (container)
  \item items: node, (computational) object, marker, load, sensor
  \item computational objects: efficient objects for computation = bodies, connectors, connectors, loads, nodes, ...
  \item visualization objects: interface between computational objects and 3D graphics
  \item main (manager) objects: do all tasks (e.g. interface to visualization objects, GUI, Python, ...) which are not needed during computation
  \item static solver, kinematic solver, time integration
  \item Python interface via pybind11; items are accessed with a dictionary interface; system structures and settings read/written by direct access to the structure (e.g. SimulationSettings, VisualizationSettings)
  \item interfaces to linear solvers; future: optimizer, eigenvalue solver, ... (mostly external or in Python)
  \item \mybold{autogenerated}: this folder in \texttt{main/src} contains many item definitions as well as other interface files; they are all automatically generated by some Python code and should not be changed manually as they will be overwritten.
\ei


\mysubsubsection{C++ Code: Modules}
The following internal modules are used, which are represented by directories in \texttt{main/src}:
\bi
  \item Autogenerated: item (nodes, objects, markers and loads) classes split into main (management, Python connection), visualization and computation
  \item Graphics: a general data structure for 2D and 3D graphical objects and a tiny openGL visualization; linkage to GLFW
    \item Linalg: Linear algebra with vectors and matrices; separate classes for small vectors (SlimVector), large vectors (Vector and ResizableVector), vectors without copying data (LinkedDataVector), and vectors with constant size (ConstVector)
  \item Main: mainly contains SystemContainer, System and ObjectFactory
  \item Objects: contains the implementation part of the autogenerated items
  \item Pymodules: manually created libraries for linkage to Python via pybind; remaining linking to Python is located in autogenerated folder
  \item pythonGenerator: contains Python files for automatic generation of C++ interfaces and Python interfaces of items;
  \item Solver: contains all solvers for solving a CSystem
  \item System: contains core item files (e.g., MainNode, CNode, MainObject, CObject, ...)
  \item Tests: files for testing of internal linalg (vector/matrix), data structure libraries (array, etc.) and functions
    \item Utilities: array structures for administrative/managing tasks (indexes of objects ... bodies, forces, connectors, ...); basic classes with templates and definitions
\ei

The following main external libraries are linked to Exudyn:
\bi
  \item LEST: for testing of internal functions (e.g. linalg)
  \item GLFW: 3D graphics with openGL; cross-platform capabilities
  \item Eigen: linear algebra for large matrices, linear solvers, sparse matrices and link to special solvers
  \item pybind11: linking of C++ to Python
\ei

\mysubsubsection{Code style and conventions}
%
This section provides general coding rules and conventions, partly applicable to the C++ and Python parts of the code. Many rules follow common conventions (e.g., google code style, but not always -- see notation):
\bi
    \item write simple code (no complicated structures or uncommon coding)
    \item write readable code (e.g., variables and functions with names that represent the content or functionality; AVOID abbreviations)
    \item put a header in every file, according to Doxygen format
    \item put a comment to every (global) function, member function, data member, template parameter
    \item ALWAYS USE curly brackets for single statements in 'if', 'for', etc.; example: if (i<n) \{i += 1;\}
    \item use Doxygen-style comments (use '//!' Qt style and '@ date' with '@' instead of '\' for commands)
    \item use Doxygen (with preceeding '@') 'test' for tests, 'todo' for todos and 'bug' for bugs
    \item USE 4-spaces-tab
    \item use C++11 standards when appropriate, but not exhaustively
    \item ONE class ONE file rule (except for some collectors of single implementation functions)
    \item add complete unit test to every function (every file has link to LEST library)
    \item avoid large classes (>30 member functions; > 15 data members)
    \item split up god classes (>60 member functions)
    \item mark changed code with your name and date
    \item REPLACE tabs by spaces: Extras->Options->C/C++->Tabstopps: tab stopp size = 4 (=standard) +  KEEP SPACES=YES
\ei

\mysubsubsection{Notation conventions}
%
The following notation conventions are applied (\mybold{no exceptions!}):
\bi
    \item use lowerCamelCase for names of variables (including class member variables), consts, c-define variables, ...; EXCEPTION: for algorithms following formulas, e.g., $f = M*q_{tt} + K*q$, GBar, ...
    \item use UpperCamelCase for functions, classes, structs, ...
    \item Special cases for CamelCase (with some exceptions that happened in the past ...): 
    \bi
    \item continue upper case after upper case abbreviations in case of \mybold{functions or classes}: 'ODESystem', 'Point2DClass', 'ANCFCable2D', 'ANCFALE', 'ComputeODE1Equations', ... (this is not always nice to read, but has become a standard and will be further used!) 
    \item for variables and class member variables continue \mybold{lower case}: 'nODE1variables', 'dim2Dspecial', 'ANCFsize'
    \item abbreviations at beginning of expressions: for functions or classes use \texttt{ODEComputeCoords()}, for variables avoid 'ODE' at beginning: use 'nODE' or write 'odeCoordinates'
    \ei
    \item '[...]Init' ... in arguments, for initialization of variables; e.g. 'valueInit' for initialization of member variable 'value'
    \item use American English throughout: Visualization, etc.
    \item AVOID consecutive capitalized words, e.g., avoid 'ODEAE'
    \item do not use '\_' within variable or function names; exception: derivatives
    \item use name which exactly describes the function/variable: 'numberOfItems' instead of 'size' or 'l'
    \item examples for variable names: secondOrderSize, massMatrix, mThetaTheta
    \item examples for function/class names: \texttt{SecondOrderSize}, \texttt{EvaluateMassMatrix}, \texttt{Position(const Vector3D\& localPosition)}
    \item use the Get/Set...() convention if data is retrieved from a class (Get) or something is set in a class (Set); Use \texttt{const T\& Get()/T\& Get} if direct access to variables is needed; Use Get/Set for pybind11
    \item example Get/Set: \texttt{Real* GetDataPointer()}, \texttt{Vector::SetAll(Real)}, \texttt{GetTransposed()}, \texttt{SetRotationalParameters(...)}, \texttt{SetColor(...)}, ...
    \item use 'Real' instead of double or float: for compatibility, also for AVX with SP/DP
    \item use 'Index' for array/vector size and index instead of size\_t or int
    \item item: object, node, marker, load: anything handled within the computational/visualization systems
    \item Do not use numbers (3 for 3D or any other number which represents, e.g., the number of rotation parameters). Use const Index or constexpr to define constants.
\ei

\mysubsubsection{No-abbreviations-rule}
%
The code uses a \mybold{minimum set of abbreviations}; however, the following abbreviation rules are used throughout:
In general: DO NOT ABBREVIATE function, class or variable names: GetDataPointer() instead of GetPtr(); exception: cnt, i, j, k, x or v in cases where it is really clear (short, 5-line member functions).

\mybold{Exceptions} to the NO-ABBREVIATIONS-RULE, see also \hyperref[sec:listOfAbbreviations]{\underline{List of Abbreviations}}: %no section number!!!: \refSection{sec:listOfAbbreviations}
\bi
    \item \ac{ODE}
    \item \ac{ODE2}: marks parts related to second order differential equations (SOS2, EvalF2 in HOTINT)
    \item \ac{ODE1}: marks parts related to first order differential equations (ES, EvalF in HOTINT)
    \item \ac{AE}; note: using the term 'AEcoordinates' for 'algebraicEquationsCoordinates'
    \item 'C[...]' ... Computational, e.g. for ComputationalNode ==> use 'CNode'
    \item \ac{min}, \ac{max}
    \item \ac{abs}, \ac{rel}
    \item \ac{trig} 
    \item \ac{quad}
    \item \ac{RHS}
    \item \ac{LHS}
    \item \ac{EP}
    \item \ac{Rxyz}%: consecutive rotations around x, y and z-axis (Tait-Bryan rotations);
    \item \ac{coeffs}
    \item \ac{pos}
    \item write time derivatives with underscore: \_t, \_tt; example: Position\_t, Position\_tt, ...
    \item write space-wise derivatives ith underscore: \_x, \_xx, \_y, ...
    \item if a scalar, write coordinate derivative with underscore: \_q, \_v (derivative w.r.t. velocity coordinates)
    \item for components, elements or entries of vectors, arrays, matrices: use 'item' throughout
    \item '[...]Init' ... in arguments, for initialization of variables; e.g. 'valueInit' for initialization of member variable 'value'
\ei


%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\ignoreRST{
\mysubsection{Changes}
\label{sec:changes}
For continuous tracking of changes, see \refSection{sec:issueTracker}.
}
%
%The following list covers changes in the Python interface and functionality:
%\bi \small
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %%\item \mybold{Version 0.1.2xx $\ra$ Version 0.1.2yy}
  %%\item[] Changes in the implementation / solver (LEADS TO DIFFERENT RESULTS):
  %%\bi
    %%\item \mybold{xxxx}: 
  %%\ei
  %%\item[] Changes in the Python interface:
  %%\bi \ttfamily
    %%\item $\ra$ 
  %%\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.59$\ra$ Version 1.0.61}
  %\bi
    %\item \mybold{Major changes}: Changed interface of \texttt{processing.GeneticOptimization()}; 
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.56$\ra$ Version 1.0.57}
  %\bi
    %\item \mybold{Major changes}: added new submodule \texttt{exudyn.signal}; 
    %\item \mybold{Major changes}: \texttt{FilterSignal} renamed into \texttt{FilterSensorOutput} and moved from \texttt{exudyn.utilities} to \texttt{exudyn.signal}
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.49$\ra$ Version 1.0.51}
  %\bi
  %\item user functions can now be set to zero, e.g.:
  %\item[] \phantom{XXXX} \texttt{mbs.AddObject(CoordinateSpringDamper(markerNumbers=[m0,m1],
  %\item[] \phantom{XXXXXXXX} stiffness=k, damping=0.01*k, 
  %\item[] \phantom{XXXXXXXX} springForceUserFunction=0)}
  %\item Exception: for \texttt{visualizationSettings.window.keyPressUserFunction} use \\ \texttt{SC.visualizationSettings.window.ResetKeyPressUserFunction()} to set it to zero
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.42$\ra$ Version 1.0.49}
  %\bi
  %\item \mybold{Major changes}: OpenGL default settings for lights and material have been changed; slightly different appearance might result from that! per default, light1 is active as well.
  %\item \mybold{Major changes}: Added key callback functionality \texttt{keyPressUserFunction} to \texttt{VisualizationSettings.window}
  %\item added mouse coordinates (OpenGL and screen pixels) to renderState and added a \texttt{GetCurrentMouseCoordinates()} function to SystemContainer
  %\item added mouse coordinates to renderer window (press 'F3')
  %\item identified problems with OpenGL lights; light1 is now working
  %\item solved problems with coordinateSystem
  %\item added a world basis (coordinate system) at origin of model (0,0,0); \\see \texttt{VisualizationSettings.general.drawWorldBasis}
  %\item added flag \texttt{simulateInRealtime} to \texttt{simulationSettings.timeIntegration}
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.38$\ra$ Version 1.0.42}
  %\bi
  %\item completed \texttt{Acceleration} output variables for all relevant objects and nodes; 
  %\item added FilterSignal(...) (\refSection{sec:signal:FilterSignal}) functionality to utilities, which enables numerical differentiation and filtering, using savgol filter, applied to all output values of data loaded from sensors.
  %\item for example, see \texttt{TestModels/objectFFRFreducedOrderAccelerations.py}.
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.37$\ra$ Version 1.0.38}
  %\bi
  %\item \texttt{SC.StopRenderer()} now stores the last renderState in \texttt{exu.sys['renderState']}, which can be used in subsequent simulations to always have the same view and zoom; 
  %for an example, see \refSection{sec:storing:modelview}.
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.32$\ra$ Version 1.0.37}
  %\bi
  %\item added Python interfaces (exudyn/solver.py) for static/dynamic solvers and eigensolvers: exu.SolveStatic(mbs) and exu.SolveDynamic(mbs) $\ra$ recommended to be used in future
  %\item TimeIntegrationSolve and StaticSolve $\ra$ deprecated; get additional return value for success
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.17 $\ra$ Version 1.0.18}
  %\bi
  %\item \mybold{removed} AVX compilation flag for Python 3.6 32bits version due to incompatibility on older Celeron processors
  %\item added acceleration sensor functionality to most objects and nodes
  %\item added Lie group utilities (see \texttt{exudyn.lieGroup})
  %\item added processing utilities for parameter variation and optimization (see \texttt{exudyn.processing})
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.12 $\ra$ Version 1.0.13}
  %\item[] corrected LHS (left-hand-side) and RHS (right-hand-side) terminology (issue: 330), see \refSection{eq_equationLHSRHS}:
  %\bi
    %\item objects, connectors, etc., use LHS conventions: all terms (mass, stiffness, elastic forces, damping) are computed at LHS of equation
    %\item forces are written at the RHS
    %\item system quantities are always written on RHS: $m \ddot q = f_{RHS}$
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.8 $\ra$ Version 1.0.9}
  %\item[] change from Index in mbs.AddNode(...), mbs.AddObject, ... to special 'item indexes' (issue: 333):
  %\bi %\ttfamily
  %\item before: \texttt{mbs.AddNode(...)} $\ra$ Index; \mybold{now}: \texttt{mbs.AddNode(...)} $\ra$ NodeIndex
  %\item before: \texttt{mbs.AddObject(...)} $\ra$ Index; \mybold{now}: \texttt{mbs.AddObject(...)} $\ra$ ObjectIndex
  %\item before: \texttt{mbs.AddMarker(...)} $\ra$ Index; \mybold{now}: \texttt{mbs.AddMarker(...)} $\ra$ MarkerIndex
  %\item before: \texttt{mbs.AddLoad(...)} $\ra$ Index; \mybold{now}: \texttt{mbs.AddLoad(...)} $\ra$ LoadIndex
  %\item before: \texttt{mbs.AddSensor(...)} $\ra$ Index; \mybold{now}: \texttt{mbs.AddSensor(...)} $\ra$ SensorIndex
  %\item Functions previously requiring an itemNumber have been changed to the according itemIndex, e.g., 
    %\texttt{mbs.SetNodeParameter(nodeNumber=...,...)} now requires a \texttt{nodeNumber} of type \texttt{NodeIndex} in order
    %to avoid mistakes due to wrong types of indexes.
  %\item for further details and specific usage, see beginning of \refSection{sec:PCpp:command:interface}!
  %%\item \mybold{NOTE}: e.g., an index type returned by \texttt{mbs.AddObject(...)} cannot be used as \texttt{nodeNumber}
  %%\item You can create any item index, e.g., using \texttt{ni = NodeIndex(42)} or \texttt{oi = ObjectIndex(42)}
  %%\item Still, you can convert any item index, e.g., NodeIndex \texttt{ni} into an integer number using \texttt{int(ni)}
  %%\item You can also print item indexes, e.g., \texttt{print(ni)} as it converts to string by default
  %%\item If you are unsure about the type of an index, use \texttt{ni.GetTypeString()} to show the index type
  %\ei
  %\item[] finally removed functions mbs.CallNodeFunction(...) and mbs.CallObjectFunction(...) (issue: 288)
  %\item[] removed functions mbs.GetNodeByName(...), GetObjectByName(...), etc. (issue: 445)
  %%
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 1.0.6 $\ra$ Version 1.0.7}
  %\item[] autocreate directories (issue: 431):
  %\bi %\ttfamily
  %\item directories (folders) will be created for given paths
  %\item this applies, e.g., to sensor's \texttt{fileName} or simulation settings \texttt{coordinatesSolutionFileName}
  %\item previously, a non-existing directory led to an exception
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.368 $\ra$ Version 1.0.0}
  %\item[] \mybold{Major changes} in the Python interface, as the utilities moved into the exudyn package:
  %\bi \ttfamily
    %\item \texttt{from itemInterface import *} $\ra$ \texttt{from exudyn.itemInterface import *}
    %\item \texttt{from exudynUtilities import *} $\ra$ \texttt{from exudyn.utilities import *}
    %\item \texttt{from exudynBasicUtilities import *} $\ra$ \texttt{from exudyn.basicUtilities import *}
    %\item \texttt{from exudynFEM import *} $\ra$ \texttt{from exudyn.FEM import *}
    %\item \texttt{from exudynGraphicsDataUtilities import *} $\ra$ \texttt{from exudyn.graphicsDataUtilities import *}
    %\item \texttt{from exudynGUI import *} $\ra$ \texttt{from exudyn.GUI import *}
    %\item \texttt{from exudynLieGroupIntegration import *} $\ra$ \texttt{from exudyn.lieGroupIntegration import *}
    %\item \texttt{from exudynRigidBodyUtilities import *} $\ra$ \texttt{from exudyn.rigidBodyUtilities import *}
    %\item \texttt{from exudynRobotics import *} $\ra$ \texttt{from exudyn.robotics import *}
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.360 $\ra$ Version 0.1.361}
  %\item[] Changes in the Python interface:
  %\bi \ttfamily
    %\item \texttt{simulationSettings.timeIntegration.preStepPyExecute} and \\
    %\texttt{simulationSettings.staticSolver.preStepPyExecute}
    %are deprecated, DON'T USE any more
    %\item Use \texttt{mbs.SetPreStepUserFunction(...)} instead!
  %\ei
  %%\bf & reset rotation & set rotation such that the scene is oriented in the x/y plane \\ \hline
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.352 $\ra$ Version 0.1.353}
  %\item[] Changes in the renderer screen:
  %\bi \ttfamily
    %\item Keys '0' and 'KEYPAD 0' $\ra$ not available any more (set default rotation x/y)
    %\item Use keys CTRL+'1', SHIFT+CTRL+'1', CTRL+'2', ...  $\ra$ keys for new standard views!
  %\ei
  %%\bf & reset rotation & set rotation such that the scene is oriented in the x/y plane \\ \hline
%
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.288 $\ra$ Version 0.1.289}
  %\item[] Changes in the Python interface \mybold{(ESSENTIAL!)}:
  %\bi \ttfamily
    %\item Added time 't' as additional first argument in user functions: ObjectCoordinateSpringDamper, ObjectConnectorCoordinateSpringDamper, ObjectConnectorCartesianSpringDamper
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.287 $\ra$ Version 0.1.288}
  %\item[] Changes in the Python interface \mybold{(ESSENTIAL!)}:
  %\bi \ttfamily
    %\item changed the name of \mybold{initialDisplacements} to {initialCoordinates} in all Nodes for consistency reasons with rotation parameters!
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.282 $\ra$ Version 0.1.284}
  %\item[] Changes in the Python interface:
  %\bi \ttfamily
    %\item all bodyFixed parameters in MarkerRigidBody, which were inactive so far, have been eliminated
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.260 $\ra$ Version 0.1.263}
  %\item[] Changes in the Python interface:
  %\bi \ttfamily
    %\item mbs.systemData.GetCurrentTime() $\ra$ mbs.systemData.GetTime()
    %\item mbs.systemData.GetVisualizationTime() $\ra$ mbs.systemData.GetTime(configurationType=exu.ConfigurationType.Visualization)
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.244 $\ra$ Version 0.1.245}
  %\item[] Changes in the implementation / solver (LEADS TO DIFFERENT RESULTS):
  %\bi
    %\item \mybold{Solvers updated}: static solver and time integration have been updated; old solvers are still available with the 'OldSolver' extension
  %\ei
  %\item[] Changes in the Python interface (new functions / interface to call the old solvers):
  %\bi \ttfamily
    %\item SC.SolveStaticOldSolver(...)
    %\item SC.TimeIntegrationSolve(mbs, 'GeneralizedAlphaOldSolver', simulationSettings) 
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   %\item \mybold{Version 0.1.243 $\ra$ Version 0.1.244}
  %\item[] Changes in the Python interface:
  %\bi \ttfamily
    %\item simulationSettings.staticSolver.pauseAfterEachStep \\$\ra$ simulationSettings.pauseAfterEachStep (merged with timeIntegration.pauseAfterEachStep)
  %\ei
  %%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  %\item \mybold{Version 0.1.238 $\ra$ Version 0.1.240}
  %\item[] Changes in the implementation / solver (LEADS TO DIFFERENT RESULTS):
  %\bi
    %\item \mybold{generalizedAlpha}: corrected initialization of algorithmic acceleration for discontinuous iteration
    %\item \mybold{time integration}: corrected time $t$ for evaluation of RHS from beginning to end of time step (improves accuracy for time-dependent loads significantly)
  %\ei
  %\item[] Changes in the Python interface:
  %\bi \ttfamily
    %\item simulationSettings.timeIntegration.pauseAfterEachStep \\$\ra$ simulationSettings.pauseAfterEachStep 
    %\item ADDED: simulationSettings.timeIntegration.verboseModeFile
    %\item ADDED: simulationSettings.staticSolver.verboseModeFile
  %\ei
%\ei
