\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/interactive.py\#L752}{SolutionViewer}{}}}\label{sec:mainsystemextensions:SolutionViewer}
({\it solution}= [], {\it rowIncrement}= 1, {\it timeout}= 0.04, {\it runOnStart}= True, {\it runMode}= 2, {\it fontSize}= 12, {\it title}= '', {\it checkRenderEngineStopFlag}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]open interactive dialog and visulation (animate) solution loaded with LoadSolutionFile(...); Change slider 'Increment' to change the automatic increment of time frames; Change mode between continuous run, one cycle (fits perfect for animation recording) or 'Static' (to change Solution steps manually with the mouse); update period also lets you change the speed of animation; Press Run / Stop button to start/stop interactive mode (updating of grpahics)
\item[]- NOTE that this function is added to MainSystem via Python function SolutionViewer.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it solution}: solution dictionary previously loaded with exudyn.utilities.LoadSolutionFile(...); will be played from first to last row; if solution=='', it tries to load the file coordinatesSolutionFileName as stored in mbs.sys['simulationSettings'], which are the simulationSettings of the previous simulation
\item[]{\it rowIncrement}: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
\item[]{\it timeout}: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
\item[]{\it runOnStart}: immediately go into 'Run' mode
\item[]{\it runMode}: 0=continuous run, 1=one cycle, 2=static (use slider/mouse to vary time steps)
\item[]{\it fontSize}: define font size for labels in InteractiveDialog
\item[]{\it title}: if empty, it uses default; otherwise define specific title
\item[]{\it checkRenderEngineStopFlag}: if True, stopping renderer (pressing Q or Escape) also causes stopping the interactive dialog
\end{itemize}
\item[--]
{\bf output}: None; updates current visualization state, renders the scene continuously (after pressing button 'Run')
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  #HERE, mbs must contain same model as solution stored in coordinatesSolution.txt
  #adjust autoFitScence, otherwise it may lead to unwanted fit to scene
  SC.visualizationSettings.general.autoFitScene = False
  from exudyn.interactive import SolutionViewer #import function
  sol = LoadSolutionFile('coordinatesSolution.txt') #load solution: adjust to your file name
  mbs.SolutionViewer(sol) #call via MainSystem
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on SolutionViewer see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addPrismaticJoint.py}{\texttt{addPrismaticJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addRevoluteJoint.py}{\texttt{addRevoluteJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDriveALE.py}{\texttt{beltDriveALE.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDriveReevingSystem.py}{\texttt{beltDriveReevingSystem.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDrivesComparison.py}{\texttt{beltDrivesComparison.py}} (Ex), 
 ...
, 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ACFtest.py}{\texttt{ACFtest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFbeltDrive.py}{\texttt{ANCFbeltDrive.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFgeneralContactCircle.py}{\texttt{ANCFgeneralContactCircle.py}} (TM), 
 ...

\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L118}{CreateMassPoint}{}}}\label{sec:mainsystemextensions:CreateMassPoint}
({\it name}= '', {\it referenceCoordinates}= [0.,0.,0.], {\it initialCoordinates}= [0.,0.,0.], {\it initialVelocities}= [0.,0.,0.], {\it physicsMass}= 0, {\it gravity}= [0.,0.,0.], {\it graphicsDataList}= [], {\it drawSize}= -1, {\it color}= [-1.,-1.,-1.,-1.], {\it show}= True, {\it create2D}= False, {\it returnDict}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]helper function to create 2D or 3D mass point object and node, using arguments as in NodePoint and MassPoint
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateMassPoint.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for object, node is 'Node:'+name
\item[]{\it referenceCoordinates}: reference coordinates for point node (always a 3D vector, no matter if 2D or 3D mass)
\item[]{\it initialCoordinates}: initial displacements for point node (always a 3D vector, no matter if 2D or 3D mass)
\item[]{\it initialVelocities}: initial velocities for point node (always a 3D vector, no matter if 2D or 3D mass)
\item[]{\it physicsMass}: mass of mass point
\item[]{\it gravity}: gravity vevtor applied (always a 3D vector, no matter if 2D or 3D mass)
\item[]{\it graphicsDataList}: list of GraphicsData for optional mass visualization
\item[]{\it drawSize}: general drawing size of node
\item[]{\it color}: color of node
\item[]{\it show}: True: if graphicsData list is empty, node is shown, otherwise body is shown; otherwise, nothing is shown
\item[]{\it create2D}: if False, create NodePoint2D and MassPoint2D
\item[]{\it returnDict}: if False, returns object index; if True, returns dict of all information on created object and node
\end{itemize}
\item[--]
{\bf output}: Union[dict, ObjectIndex]; returns mass point object index or dict with all data on request (if returnDict=True)
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0=mbs.CreateMassPoint(referenceCoordinates = [0,0,0],
                         initialVelocities = [2,5,0],
                         physicsMass = 1, gravity = [0,-9.81,0],
                         drawSize = 0.5, color=color4blue)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateMassPoint see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/springDamperTutorialNew.py}{\texttt{springDamperTutorialNew.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L247}{CreateRigidBody}{}}}\label{sec:mainsystemextensions:CreateRigidBody}
({\it name}= '', {\it referencePosition}= [0.,0.,0.], {\it referenceRotationMatrix}= np.eye(3), {\it initialVelocity}= [0.,0.,0.], {\it initialAngularVelocity}= [0.,0.,0.], {\it initialDisplacement}= None, {\it initialRotationMatrix}= None, {\it inertia}= None, {\it gravity}= [0.,0.,0.], {\it nodeType}= exudyn.NodeType.RotationEulerParameters, {\it graphicsDataList}= [], {\it drawSize}= -1, {\it color}= [-1.,-1.,-1.,-1.], {\it show}= True, {\it create2D}= False, {\it returnDict}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]helper function to create 3D (or 2D) rigid body object and node; all quantities are global (angular velocity, etc.)
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateRigidBody.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for object, node is 'Node:'+name
\item[]{\it referencePosition}: reference position vector for rigid body node (always a 3D vector, no matter if 2D or 3D body)
\item[]{\it referenceRotationMatrix}: reference rotation matrix for rigid body node (always 3D matrix, no matter if 2D or 3D body)
\item[]{\it initialVelocity}: initial translational velocity vector for node (always a 3D vector, no matter if 2D or 3D body)
\item[]{\it initialAngularVelocity}: initial angular velocity vector for node (always a 3D vector, no matter if 2D or 3D body)
\item[]{\it initialDisplacement}: initial translational displacement vector for node (always a 3D vector, no matter if 2D or 3D body); these displacements are deviations from reference position, e.g. for a finite element node [None: unused]
\item[]{\it initialRotationMatrix}: initial rotation provided as matrix (always a 3D matrix, no matter if 2D or 3D body); this rotation is superimposed to reference rotation [None: unused]
\item[]{\it inertia}: an instance of class RigidBodyInertia, see rigidBodyUtilities; may also be from derived class (InertiaCuboid, InertiaMassPoint, InertiaCylinder, ...)
\item[]{\it gravity}: gravity vevtor applied (always a 3D vector, no matter if 2D or 3D mass)
\item[]{\it graphicsDataList}: list of GraphicsData for rigid body visualization; use graphicsDataUtilities function GraphicsData...(...)
\item[]{\it drawSize}: general drawing size of node
\item[]{\it color}: color of node
\item[]{\it show}: True: if graphicsData list is empty, node is shown, otherwise body is shown; False: nothing is shown
\item[]{\it create2D}: if False, create NodePoint2D and MassPoint2D
\item[]{\it returnDict}: if False, returns object index; if True, returns dict of all information on created object and node
\end{itemize}
\item[--]
{\bf output}: Union[dict, ObjectIndex]; returns rigid body object index (or dict with 'nodeNumber', 'objectNumber' and possibly 'loadNumber' and 'markerBodyMass' if returnDict=True)
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                   sideLengths=[1,0.1,0.1]),
                           referencePosition = [1,0,0],
                           initialVelocity = [2,5,0],
                           initialAngularVelocity = [5,0.5,0.7],
                           gravity = [0,-9.81,0],
                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4red)])
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateRigidBody see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addPrismaticJoint.py}{\texttt{addPrismaticJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addRevoluteJoint.py}{\texttt{addRevoluteJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/graphicsDataExample.py}{\texttt{graphicsDataExample.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/rigidBodyTutorial3.py}{\texttt{rigidBodyTutorial3.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/rigidBodyTutorial3withMarkers.py}{\texttt{rigidBodyTutorial3withMarkers.py}} (Ex), 
 ...
, 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/driveTrainTest.py}{\texttt{driveTrainTest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/perf3DRigidBodies.py}{\texttt{perf3DRigidBodies.py}} (TM), 
 ...

\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L469}{CreateSpringDamper}{}}}\label{sec:mainsystemextensions:CreateSpringDamper}
({\it name}= '', {\it bodyOrNodeList}= [None, None], {\it localPosition0}= [0.,0.,0.], {\it localPosition1}= [0.,0.,0.], {\it referenceLength}= None, {\it stiffness}= 0., {\it damping}= 0., {\it force}= 0., {\it velocityOffset}= 0., {\it show}= True, {\it drawSize}= -1, {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]helper function to create SpringDamper connector, using arguments from ObjectConnectorSpringDamper; similar interface as CreateDistanceConstraint(...)
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateSpringDamper.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for connector; markers get Marker0:name and Marker1:name
\item[]{\it bodyOrNodeList}: a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types
\item[]{\it localPosition0}: local position (as 3D list or numpy array) on body0, if not a node number
\item[]{\it localPosition1}: local position (as 3D list or numpy array) on body1, if not a node number
\item[]{\it referenceLength}: if None, length is computed from reference position of bodies or nodes; if not None, this scalar reference length is used for spring
\item[]{\it stiffness}: scalar stiffness coefficient
\item[]{\it damping}: scalar damping coefficient
\item[]{\it force}: scalar additional force applied
\item[]{\it velocityOffset}: scalar offset: if referenceLength is changed over time, the velocityOffset may be changed accordingly to emulate a reference motion
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it drawSize}: general drawing size of connector
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: ObjectIndex; returns index of newly created object
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateMassPoint(referenceCoordinates = [2,0,0],
                           initialVelocities = [2,5,0],
                           physicsMass = 1, gravity = [0,-9.81,0],
                           drawSize = 0.5, color=color4blue)
  oGround = mbs.AddObject(ObjectGround())
  #add vertical spring
  oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
                               localPosition0=[2,1,0],
                               localPosition1=[0,0,0],
                               stiffness=1e4, damping=1e2,
                               drawSize=0.2)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  SC.visualizationSettings.nodes.drawNodesAsPoint=False
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateSpringDamper see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/springDamperTutorialNew.py}{\texttt{springDamperTutorialNew.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L605}{CreateCartesianSpringDamper}{}}}\label{sec:mainsystemextensions:CreateCartesianSpringDamper}
({\it name}= '', {\it bodyOrNodeList}= [None, None], {\it localPosition0}= [0.,0.,0.], {\it localPosition1}= [0.,0.,0.], {\it stiffness}= [0.,0.,0.], {\it damping}= [0.,0.,0.], {\it offset}= [0.,0.,0.], {\it show}= True, {\it drawSize}= -1, {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]helper function to create CartesianSpringDamper connector, using arguments from ObjectConnectorCartesianSpringDamper
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateCartesianSpringDamper.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for connector; markers get Marker0:name and Marker1:name
\item[]{\it bodyOrNodeList}: a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types
\item[]{\it localPosition0}: local position (as 3D list or numpy array) on body0, if not a node number
\item[]{\it localPosition1}: local position (as 3D list or numpy array) on body1, if not a node number
\item[]{\it stiffness}: stiffness coefficients (as 3D list or numpy array)
\item[]{\it damping}: damping coefficients (as 3D list or numpy array)
\item[]{\it offset}: offset vector (as 3D list or numpy array)
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it drawSize}: general drawing size of connector
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: ObjectIndex; returns index of newly created object
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateMassPoint(referenceCoordinates = [7,0,0],
                            physicsMass = 1, gravity = [0,-9.81,0],
                            drawSize = 0.5, color=color4blue)
  oGround = mbs.AddObject(ObjectGround())
  oSD = mbs.CreateCartesianSpringDamper(bodyOrNodeList=[oGround, b0],
                                localPosition0=[7.5,1,0],
                                localPosition1=[0,0,0],
                                stiffness=[200,2000,0], damping=[2,20,0],
                                drawSize=0.2)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  SC.visualizationSettings.nodes.drawNodesAsPoint=False
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateCartesianSpringDamper see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L712}{CreateRevoluteJoint}{}}}\label{sec:mainsystemextensions:CreateRevoluteJoint}
({\it name}= '', {\it bodyNumbers}= [None, None], {\it position}= [], {\it axis}= [], {\it useGlobalFrame}= True, {\it show}= True, {\it axisRadius}= 0.1, {\it axisLength}= 0.4, {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Create revolute joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateRevoluteJoint.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for joint; markers get Marker0:name and Marker1:name
\item[]{\it bodyNumbers}: a list of object numbers for body0 and body1; must be rigid body or ground object
\item[]{\it position}: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
\item[]{\it axis}: a 3D vector as list or np.array: if  useGlobalFrame=True it describes the global rotation axis of the joint in reference configuration; else: local axis in body0
\item[]{\it useGlobalFrame}: if False, the point and axis vectors are defined in the local coordinate system of body0
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it axisRadius}: radius of axis for connector graphical representation
\item[]{\it axisLength}: length of axis for connector graphical representation
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                   sideLengths=[1,0.1,0.1]),
                           referencePosition = [3,0,0],
                           gravity = [0,-9.81,0],
                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4steelblue)])
  oGround = mbs.AddObject(ObjectGround())
  mbs.CreateRevoluteJoint(bodyNumbers=[oGround, b0], position=[2.5,0,0], axis=[0,0,1],
                          useGlobalFrame=True, axisRadius=0.02, axisLength=0.14)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateRevoluteJoint see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addRevoluteJoint.py}{\texttt{addRevoluteJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/rigidBodyTutorial3.py}{\texttt{rigidBodyTutorial3.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/solutionViewerTest.py}{\texttt{solutionViewerTest.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/perf3DRigidBodies.py}{\texttt{perf3DRigidBodies.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L810}{CreatePrismaticJoint}{}}}\label{sec:mainsystemextensions:CreatePrismaticJoint}
({\it name}= '', {\it bodyNumbers}= [None, None], {\it position}= [], {\it axis}= [], {\it useGlobalFrame}= True, {\it show}= True, {\it axisRadius}= 0.1, {\it axisLength}= 0.4, {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Create prismatic joint between two bodies; definition of joint position and axis in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers, markerRotation and other quantities are automatically computed
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreatePrismaticJoint.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for joint; markers get Marker0:name and Marker1:name
\item[]{\it bodyNumbers}: a list of object numbers for body0 and body1; must be rigid body or ground object
\item[]{\it position}: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
\item[]{\it axis}: a 3D vector as list or np.array containing the global translation axis of the joint in reference configuration
\item[]{\it useGlobalFrame}: if False, the point and axis vectors are defined in the local coordinate system of body0
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it axisRadius}: radius of axis for connector graphical representation
\item[]{\it axisLength}: length of axis for connector graphical representation
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                   sideLengths=[1,0.1,0.1]),
                           referencePosition = [4,0,0],
                           initialVelocity = [0,4,0],
                           gravity = [0,-9.81,0],
                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4steelblue)])
  oGround = mbs.AddObject(ObjectGround())
  mbs.CreatePrismaticJoint(bodyNumbers=[oGround, b0], position=[3.5,0,0], axis=[0,1,0],
                           useGlobalFrame=True, axisRadius=0.02, axisLength=1)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreatePrismaticJoint see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addPrismaticJoint.py}{\texttt{addPrismaticJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L900}{CreateSphericalJoint}{}}}\label{sec:mainsystemextensions:CreateSphericalJoint}
({\it name}= '', {\it bodyNumbers}= [None, None], {\it position}= [], {\it constrainedAxes}= [1,1,1], {\it useGlobalFrame}= True, {\it show}= True, {\it jointRadius}= 0.1, {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Create spherical joint between two bodies; definition of joint position in global coordinates (alternatively in body0 local coordinates) for reference configuration of bodies; all markers are automatically computed
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateSphericalJoint.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for joint; markers get Marker0:name and Marker1:name
\item[]{\it bodyNumbers}: a list of object numbers for body0 and body1; must be mass point, rigid body or ground object
\item[]{\it position}: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
\item[]{\it constrainedAxes}: flags, which determines which (global) translation axes are constrained; each entry may only be 0 (=free) axis or 1 (=constrained axis)
\item[]{\it useGlobalFrame}: if False, the point and axis vectors are defined in the local coordinate system of body0
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it jointRadius}: radius of sphere for connector graphical representation
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                   sideLengths=[1,0.1,0.1]),
                           referencePosition = [5,0,0],
                           initialAngularVelocity = [5,0,0],
                           gravity = [0,-9.81,0],
                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4orange)])
  oGround = mbs.AddObject(ObjectGround())
  mbs.CreateSphericalJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
                           useGlobalFrame=True, jointRadius=0.06)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateSphericalJoint see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/driveTrainTest.py}{\texttt{driveTrainTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L983}{CreateGenericJoint}{}}}\label{sec:mainsystemextensions:CreateGenericJoint}
({\it name}= '', {\it bodyNumbers}= [None, None], {\it position}= [], {\it rotationMatrixAxes}= np.eye(3), {\it constrainedAxes}= [1,1,1, 1,1,1], {\it useGlobalFrame}= True, {\it show}= True, {\it axesRadius}= 0.1, {\it axesLength}= 0.4, {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Create generic joint between two bodies; definition of joint position (position) and axes (rotationMatrixAxes) in global coordinates (useGlobalFrame=True) or in local coordinates of body0 (useGlobalFrame=False), where rotationMatrixAxes is an additional rotation to body0; all markers, markerRotation and other quantities are automatically computed
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateGenericJoint.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for joint; markers get Marker0:name and Marker1:name
\item[]{\it bodyNumber0}: a object number for body0, must be rigid body or ground object
\item[]{\it bodyNumber1}: a object number for body1, must be rigid body or ground object
\item[]{\it position}: a 3D vector as list or np.array: if useGlobalFrame=True it describes the global position of the joint in reference configuration; else: local position in body0
\item[]{\it rotationMatrixAxes}: rotation matrix which defines orientation of constrainedAxes; if useGlobalFrame, this rotation matrix is global, else the rotation matrix is post-multiplied with the rotation of body0, identical with rotationMarker0 in the joint
\item[]{\it constrainedAxes}: flag, which determines which translation (0,1,2) and rotation (3,4,5) axes are constrained; each entry may only be 0 (=free) axis or 1 (=constrained axis); ALL constrained Axes are defined relative to reference rotation of body0 times rotation0
\item[]{\it useGlobalFrame}: if False, the position is defined in the local coordinate system of body0, otherwise it is defined in global coordinates
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it axesRadius}: radius of axes for connector graphical representation
\item[]{\it axesLength}: length of axes for connector graphical representation
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                   sideLengths=[1,0.1,0.1]),
                           referencePosition = [6,0,0],
                           initialAngularVelocity = [0,8,0],
                           gravity = [0,-9.81,0],
                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4orange)])
  oGround = mbs.AddObject(ObjectGround())
  mbs.CreateGenericJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
                         constrainedAxes=[1,1,1, 1,0,0],
                         rotationMatrixAxes=RotationMatrixX(0.125*pi), #tilt axes
                         useGlobalFrame=True, axesRadius=0.02, axesLength=0.2)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateGenericJoint see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/driveTrainTest.py}{\texttt{driveTrainTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/rigidBodyCOMtest.py}{\texttt{rigidBodyCOMtest.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/mainSystemExtensions.py\#L1086}{CreateDistanceConstraint}{}}}\label{sec:mainsystemextensions:CreateDistanceConstraint}
({\it name}= '', {\it bodyOrNodeList}= [None, None], {\it localPosition0}= [0.,0.,0.], {\it localPosition1}= [0.,0.,0.], {\it distance}= None, {\it show}= True, {\it drawSize}= -1., {\it color}= color4default)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Create distance joint between two bodies; definition of joint positions in local coordinates of bodies or nodes; if distance=None, it is computed automatically from reference length; all markers are automatically computed
\item[]- NOTE that this function is added to MainSystem via Python function MainSystemCreateDistanceConstraint.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it name}: name string for joint; markers get Marker0:name and Marker1:name
\item[]{\it bodyOrNodeList}: a list of object numbers (with specific localPosition0/1) or node numbers; may also be of mixed types
\item[]{\it localPosition0}: local position (as 3D list or numpy array) on body0, if not a node number
\item[]{\it localPosition1}: local position (as 3D list or numpy array) on body1, if not a node number
\item[]{\it distance}: if None, distance is computed from reference position of bodies or nodes; if not None, this distance (which must be always larger than zero) is prescribed between the two positions
\item[]{\it show}: if True, connector visualization is drawn
\item[]{\it drawSize}: general drawing size of node
\item[]{\it color}: color of connector
\end{itemize}
\item[--]
{\bf output}: [ObjectIndex, MarkerIndex, MarkerIndex]; returns list [oJoint, mBody0, mBody1], containing the joint object number, and the two rigid body markers on body0/1 for the joint
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                    sideLengths=[1,0.1,0.1]),
                            referencePosition = [6,0,0],
                            gravity = [0,-9.81,0],
                            graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4orange)])
  m1 = mbs.CreateMassPoint(referenceCoordinates=[5.5,-1,0],
                           physicsMass=1, drawSize = 0.2)
  n1 = mbs.GetObject(m1)['nodeNumber']
  oGround = mbs.AddObject(ObjectGround())
  mbs.CreateDistanceConstraint(bodyOrNodeList=[oGround, b0],
                               localPosition0 = [6.5,1,0],
                               localPosition1 = [0.5,0,0],
                               distance=None, #automatically computed
                               drawSize=0.06)
  mbs.CreateDistanceConstraint(bodyOrNodeList=[b0, n1],
                               localPosition0 = [-0.5,0,0],
                               localPosition1 = [0.,0.,0.], #must be [0,0,0] for Node
                               distance=None, #automatically computed
                               drawSize=0.06)
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings() #takes currently set values or default values
  simulationSettings.timeIntegration.numberOfSteps = 1000
  simulationSettings.timeIntegration.endTime = 2
  mbs.SolveDynamic(simulationSettings = simulationSettings)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateDistanceConstraint see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/plot.py\#L229}{PlotSensor}{}}}\label{sec:mainsystemextensions:PlotSensor}
({\it sensorNumbers}= [], {\it components}= 0, {\it xLabel}= 'time (s)', {\it yLabel}= None, {\it labels}= [], {\it colorCodeOffset}= 0, {\it newFigure}= True, {\it closeAll}= False, {\it componentsX}= [], {\it title}= '', {\it figureName}= '', {\it fontSize}= 16, {\it colors}= [], {\it lineStyles}= [], {\it lineWidths}= [], {\it markerStyles}= [], {\it markerSizes}= [], {\it markerDensity}= 0.08, {\it rangeX}= [], {\it rangeY}= [], {\it majorTicksX}= 10, {\it majorTicksY}= 10, {\it offsets}= [], {\it factors}= [], {\it subPlot}= [], {\it sizeInches}= [6.4,4.8], {\it fileName}= '', {\it useXYZcomponents}= True, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Helper function for direct and easy visualization of sensor outputs, without need for loading text files, etc.; PlotSensor can be used to simply plot, e.g., the measured x-Position over time in a figure. PlotSensor provides an interface to matplotlib (which needs to be installed). Default values of many function arguments can be changed using the exudyn.plot function PlotSensorDefaults(), see there for usage.
\item[]- NOTE that this function is added to MainSystem via Python function PlotSensor.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it sensorNumbers}: consists of one or a list of sensor numbers (type SensorIndex or int) as returned by the mbs function AddSensor(...); sensors need to set writeToFile=True and/or storeInternal=True for PlotSensor to work; alternatively, it may contain FILENAMES (incl. path) to stored sensor or solution files OR a numpy array instead of sensor numbers; the format of data (file or numpy array) must contain per row the time and according solution values in columns; if components is a list and sensorNumbers is a scalar, sensorNumbers is adjusted automatically to the components
\item[]{\it components}: consists of one or a list of components according to the component of the sensor to be plotted at y-axis; if components is a list and sensorNumbers is a scalar, sensorNumbers is adjusted automatically to the components; as always, components are zero-based, meaning 0=X, 1=Y, etc.; for regular sensor files, time will be component=-1; to show the norm (e.g., of a force vector), use component=[plot.componentNorm] for according sensors; norm will consider all values of sensor except time (for 3D force, it will be $\sqrt{f_0^2+f_1^2+f_2^2}$); offsets and factors are mapped on norm (plot value=factor*(norm(values) + offset) ), not on component values
\item[]{\it componentsX}: default componentsX=[] uses time in files; otherwise provide componentsX as list of components (or scalar) representing x components of sensors in plotted curves; DON'T forget to change xLabel accordingly!
\item[]Using componentsX=[...] with a list of column indices specifies the respective columns used for the x-coordinates in all sensors; by default, values are plotted against the first column in the files, which is time; according to counting in PlotSensor, this represents componentX=-1;
\item[]plotting y over x in a position sensor thus reads: components=[1], componentsX=[0];
\item[]plotting time over x reads: components=[-1], componentsX=[0];
\item[]the default value reads componentsX=[-1,-1,...]
\item[]{\it xLabel}: string for text at x-axis
\item[]{\it yLabel}: string for text at y-axis (default: None==> label is automatically computed from sensor value types)
\item[]{\it labels}: string (for one sensor) or list of strings (according to number of sensors resp. components) representing the labels used in legend; if labels=[], automatically generated legend is used
\item[]{\it rangeX}: default rangeX=[]: computes range automatically; otherwise use rangeX to set range (limits) for x-axis provided as sorted list of two floats, e.g., rangeX=[0,4]
\item[]{\it rangeY}: default rangeY=[]: computes range automatically; otherwise use rangeY to set range (limits) for y-axis provided as sorted list of two floats, e.g., rangeY=[-1,1]
\item[]{\it figureName}: optional name for figure, if newFigure=True
\item[]{\it fontSize}: change general fontsize of axis, labels, etc. (matplotlib default is 12, default in PlotSensor: 16)
\item[]{\it title}: optional string representing plot title
\item[]{\it offsets}: provide as scalar, list of scalars (per sensor) or list of 2D numpy.arrays (per sensor, having same rows/columns as sensor data; in this case it will also influence x-axis if componentsX is different from -1) to add offset to each sensor output; for an original value fOrig, the new value reads fNew = factor*(fOrig+offset); for offset provided as numpy array (with same time values), the 'time' column is ignored in the offset computation; can be used to compute difference of sensors; if offsets=[], no offset is used
\item[]{\it factors}: provide as scalar or list (per sensor) to add factor to each sensor output; for an original value fOrig, the new value reads fNew = factor*(fOrig+offset); if factor=[], no factor is used
\item[]{\it majorTicksX}: number of major ticks on x-axis; default: 10
\item[]{\it majorTicksY}: number of major ticks on y-axis; default: 10
\item[]{\it colorCodeOffset}: int offset for color code, color codes going from 0 to 27 (see PlotLineCode(...)); automatic line/color codes are used if no colors and lineStyles are used
\item[]{\it colors}: color is automatically selected from colorCodeOffset if colors=[]; otherwise chose from 'b', 'g', 'r', 'c', 'm', 'y', 'k' and many other colors see https://matplotlib.org/stable/gallery/color/named\_colors.html
\item[]{\it lineStyles}: line style is automatically selected from colorCodeOffset if lineStyles=[]; otherwise define for all lines with string or with list of strings, chosing from '-', '--', '-.', ':', or ''
\item[]{\it lineWidths}: float to define line width by float (default=1); either use single float for all sensors or list of floats with length >= number of sensors
\item[]{\it markerStyles}: if different from [], marker styles are defined as list of marker style strings or single string for one sensor; chose from '.', 'o', 'x', '+' ... check listMarkerStylesFilled and listMarkerStyles in exudyn.plot and see https://matplotlib.org/stable/api/markers\_api.html ; ADD a space to markers to make them empty (transparent), e.g. 'o ' will create an empty circle
\item[]{\it markerSizes}: float to define marker size by float (default=6); either use single float for all sensors or list of floats with length >= number of sensors
\item[]{\it markerDensity}: if int, it defines approx. the total number of markers used along each graph; if float, this defines the distance of markers relative to the diagonal of the plot (default=0.08); if None, it adds a marker to every data point if marker style is specified for sensor
\item[]{\it newFigure}: if True, a new matplotlib.pyplot figure is created; otherwise, existing figures are overwritten
\item[]{\it subPlot}: given as list [nx, ny, position] with nx, ny being the number of subplots in x and y direction (nx=cols, ny=rows), and position in [1,..., nx*ny] gives the position in the subplots; use the same structure for first PlotSensor (with newFigure=True) and all subsequent PlotSensor calls with newFigure=False, which creates the according subplots; default=[](no subplots)
\item[]{\it sizeInches}: given as list [sizeX, sizeY] with the sizes per (sub)plot given in inches; default: [6.4, 4.8]; in case of sub plots, the total size of the figure is computed from nx*sizeInches[0] and ny*sizeInches[1]
\item[]{\it fileName}: if this string is non-empty, figure will be saved to given path and filename (use figName.pdf to safe as PDF or figName.png to save as PNG image); use matplotlib.use('Agg') in order not to open figures if you just want to save them
\item[]{\it useXYZcomponents}: of True, it will use X, Y and Z for sensor components, e.g., measuring Position, Velocity, etc. wherever possible
\item[]{\it closeAll}: if True, close all figures before opening new one (do this only in first PlotSensor command!)
\item[]{\it [*kwargs]}:
\item[]{\it minorTicksXon}: if True, turn minor ticks for x-axis on
\item[]{\it minorTicksYon}: if True, turn minor ticks for y-axis on
\item[]{\it fileCommentChar}: if exists, defines the comment character in files (\#, %, ...)
\item[]{\it fileDelimiterChar}: if exists, defines the character indicating the columns for data (',', ' ', ';', ...)
\end{itemize}
\item[--]
{\bf output}: [Any, Any, Any, Any]; plots the sensor data; returns [plt, fig, ax, line] in which plt is matplotlib.pyplot, fig is the figure (or None), ax is the axis (or None) and line is the return value of plt.plot (or None) which could be changed hereafter
\item[--]
{\bf notes}: adjust default values by modifying the variables exudyn.plot.plotSensorDefault..., e.g., exudyn.plot.plotSensorDefaultFontSize
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  #assume to have some position-based nodes 0 and 1:
  s0=mbs.AddSensor(SensorNode(nodeNumber=0, fileName='s0.txt',
                              outputVariableType=exu.OutputVariableType.Position))
  s1=mbs.AddSensor(SensorNode(nodeNumber=1, fileName='s1.txt',
                              outputVariableType=exu.OutputVariableType.Position))
  mbs.PlotSensor(s0, 0) #plot x-coordinate
  #plot x for s0 and z for s1:
  mbs.PlotSensor(sensorNumbers=[s0,s1], components=[0,2], yLabel='this is the position in meter')
  mbs.PlotSensor(sensorNumbers=s0, components=plot.componentNorm) #norm of position
  mbs.PlotSensor(sensorNumbers=s0, components=[0,1,2], factors=1000., title='Answers to the big questions')
  mbs.PlotSensor(sensorNumbers=s0, components=[0,1,2,3],
             yLabel='Coordantes with offset 1\nand scaled with $\\frac{1}{1000}$',
             factors=1e-3, offsets=1,fontSize=12, closeAll=True)
  #assume to have body sensor sBody, marker sensor sMarker:
  mbs.PlotSensor(sensorNumbers=[sBody]*3+[sMarker]*3, components=[0,1,2,0,1,2],
             colorCodeOffset=3, newFigure=False, fontSize=10,
             yLabel='Rotation $\\alpha, \\beta, \\gamma$ and\n Position $x,y,z$',
             title='compare marker and body sensor')
  #assume having file plotSensorNode.txt:
  mbs.PlotSensor(sensorNumbers=[s0]*3+ [filedir+'plotSensorNode.txt']*3,
             components=[0,1,2]*2)
  #plot y over x:
  mbs.PlotSensor(sensorNumbers=s0, componentsX=[0], components=[1], xLabel='x-Position', yLabel='y-Position')
  #for further examples, see also Examples/plotSensorExamples.py
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on PlotSensor see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ANCFALEtest.py}{\texttt{ANCFALEtest.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDriveALE.py}{\texttt{beltDriveALE.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDriveReevingSystem.py}{\texttt{beltDriveReevingSystem.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDrivesComparison.py}{\texttt{beltDrivesComparison.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/bicycleIftommBenchmark.py}{\texttt{bicycleIftommBenchmark.py}} (Ex), 
 ...
, 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ACFtest.py}{\texttt{ACFtest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFbeltDrive.py}{\texttt{ANCFbeltDrive.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFgeneralContactCircle.py}{\texttt{ANCFgeneralContactCircle.py}} (TM), 
 ...

\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L153}{SolveStatic}{}}}\label{sec:mainsystemextensions:SolveStatic}
({\it simulationSettings}= exudyn.SimulationSettings(), {\it updateInitialValues}= False, {\it storeSolver}= True, {\it showHints}= False, {\it showCausingItems}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]solves the static mbs problem using simulationSettings; check theDoc.pdf for MainSolverStatic for further details of the static solver; this function is also available in exudyn (using exudyn.SolveStatic(...))
\item[]- NOTE that this function is added to MainSystem via Python function SolveStatic.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it simulationSettings}: specific simulation settings out of exu.SimulationSettings(), as described in \refSection{sec:SolutionSettings}; use options for newton, discontinuous settings, etc., from staticSolver sub-items
\item[]{\it updateInitialValues}: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
\item[]{\it storeSolver}: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver'], and simulationSettings are stored as mbs.sys['simulationSettings']
\end{itemize}
\item[--]
{\bf output}: bool; returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.itemInterface import *
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  #create simple system:
  ground = mbs.AddObject(ObjectGround())
  mbs.AddNode(NodePoint())
  body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
  m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
  m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
  mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
  mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings()
  simulationSettings.timeIntegration.endTime = 10
  success = mbs.SolveStatic(simulationSettings, storeSolver = True)
  print("success =", success)
  print("iterations = ", mbs.sys['staticSolver'].it)
  print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0],
        variableType=exu.OutputVariableType.Position))
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on SolveStatic see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/3SpringsDistance.py}{\texttt{3SpringsDistance.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ALEANCFpipe.py}{\texttt{ALEANCFpipe.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ANCFALEtest.py}{\texttt{ANCFALEtest.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ANCFcantileverTest.py}{\texttt{ANCFcantileverTest.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ANCFcontactCircle.py}{\texttt{ANCFcontactCircle.py}} (Ex), 
 ...
, 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFBeamTest.py}{\texttt{ANCFBeamTest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFbeltDrive.py}{\texttt{ANCFbeltDrive.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFcontactCircleTest.py}{\texttt{ANCFcontactCircleTest.py}} (TM), 
 ...

\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L218}{SolveDynamic}{}}}\label{sec:mainsystemextensions:SolveDynamic}
({\it simulationSettings}= exudyn.SimulationSettings(), {\it solverType}= exudyn.DynamicSolverType.GeneralizedAlpha, {\it updateInitialValues}= False, {\it storeSolver}= True, {\it showHints}= False, {\it showCausingItems}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]solves the dynamic mbs problem using simulationSettings and solver type; check theDoc.pdf for MainSolverImplicitSecondOrder for further details of the dynamic solver; this function is also available in exudyn (using exudyn.SolveDynamic(...))
\item[]- NOTE that this function is added to MainSystem via Python function SolveDynamic.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it simulationSettings}: specific simulation settings out of exu.SimulationSettings(), as described in \refSection{sec:SolutionSettings}; use options for newton, discontinuous settings, etc., from timeIntegration; therein, implicit second order solvers use settings from generalizedAlpha and explict solvers from explicitIntegration; be careful with settings, as the influence accuracy (step size!), convergence and performance (see special \refSection{sec:overview:basics:speedup})
\item[]{\it solverType}: use exudyn.DynamicSolverType to set specific solver (default=generalized alpha)
\item[]{\it updateInitialValues}: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
\item[]{\it storeSolver}: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver'], and simulationSettings are stored as mbs.sys['simulationSettings']
\item[]{\it showHints}: show additional hints, if solver fails
\item[]{\it showCausingItems}: if linear solver fails, this option helps to identify objects, etc. which are related to a singularity in the linearized system matrix
\end{itemize}
\item[--]
{\bf output}: bool; returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.itemInterface import *
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  #create simple system:
  ground = mbs.AddObject(ObjectGround())
  mbs.AddNode(NodePoint())
  body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
  m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
  m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
  mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
  mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
  #
  mbs.Assemble()
  simulationSettings = exu.SimulationSettings()
  simulationSettings.timeIntegration.endTime = 10
  success = mbs.SolveDynamic(simulationSettings, storeSolver = True)
  print("success =", success)
  print("iterations = ", mbs.sys['dynamicSolver'].it)
  print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0],
        variableType=exu.OutputVariableType.Position))
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on SolveDynamic see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/3SpringsDistance.py}{\texttt{3SpringsDistance.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addPrismaticJoint.py}{\texttt{addPrismaticJoint.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/addRevoluteJoint.py}{\texttt{addRevoluteJoint.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ALEANCFpipe.py}{\texttt{ALEANCFpipe.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/ANCFALEtest.py}{\texttt{ANCFALEtest.py}} (Ex), 
 ...
, 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/abaqusImportTest.py}{\texttt{abaqusImportTest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ACFtest.py}{\texttt{ACFtest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFBeamEigTest.py}{\texttt{ANCFBeamEigTest.py}} (TM), 
 ...

\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L364}{ComputeLinearizedSystem}{}}}\label{sec:mainsystemextensions:ComputeLinearizedSystem}
({\it simulationSettings}= exudyn.SimulationSettings(), {\it useSparseSolver}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]compute linearized system of equations for ODE2 part of mbs, not considering the effects of algebraic constraints
\item[]- NOTE that this function is added to MainSystem via Python function ComputeLinearizedSystem.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it simulationSettings}: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
\item[]{\it useSparseSolver}: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
\end{itemize}
\item[--]
{\bf output}: [ArrayLike, ArrayLike, ArrayLike]; [M, K, D]; list containing numpy mass matrix M, stiffness matrix K and damping matrix D
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  #
  b0 = mbs.CreateMassPoint(referenceCoordinates = [2,0,0],
                           initialVelocities = [2*0,5,0],
                           physicsMass = 1, gravity = [0,-9.81,0],
                           drawSize = 0.5, color=color4blue)
  #
  oGround = mbs.AddObject(ObjectGround())
  #add vertical spring
  oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
                               localPosition0=[2,1,0],
                               localPosition1=[0,0,0],
                               stiffness=1e4, damping=1e2,
                               drawSize=0.2)
  #
  mbs.Assemble()
  [M,K,D] = mbs.ComputeLinearizedSystem()
  exu.Print('M=\n',M,'\nK=\n',K,'\nD=\n',D)
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on ComputeLinearizedSystem see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFBeamEigTest.py}{\texttt{ANCFBeamEigTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFBeamTest.py}{\texttt{ANCFBeamTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/geometricallyExactBeamTest.py}{\texttt{geometricallyExactBeamTest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L437}{ComputeODE2Eigenvalues}{}}}\label{sec:mainsystemextensions:ComputeODE2Eigenvalues}
({\it simulationSettings}= exudyn.SimulationSettings(), {\it useSparseSolver}= False, {\it numberOfEigenvalues}= 0, {\it constrainedCoordinates}= [], {\it convert2Frequencies}= False, {\it useAbsoluteValues}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]compute eigenvalues for unconstrained ODE2 part of mbs, not considering the effects of algebraic constraints; the computation is done for the initial values of the mbs, independently of previous computations. If you would like to use the current state for the eigenvalue computation, you need to copy the current state to the initial state (using GetSystemState,SetSystemState, see \refSection{sec:mbs:systemData}); note that mass and stiffness matrix are computed in dense mode so far, while eigenvalues are computed according to useSparseSolver.
\item[]- NOTE that this function is added to MainSystem via Python function ComputeODE2Eigenvalues.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it simulationSettings}: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
\item[]{\it useSparseSolver}: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
\item[]{\it numberOfEigenvalues}: number of eigenvalues and eivenvectors to be computed; if numberOfEigenvalues==0, all eigenvalues will be computed (may be impossible for larger problems!)
\item[]{\it constrainedCoordinates}: if this list is non-empty, the integer indices represent constrained coordinates of the system, which are fixed during eigenvalue/vector computation; according rows/columns of mass and stiffness matrices are erased
\item[]{\it convert2Frequencies}: if True, the eigen values are converted into frequencies (Hz) and the output is [eigenFrequencies, eigenVectors]
\item[]{\it useAbsoluteValues}: if True, abs(eigenvalues) is used, which avoids problems for small (close to zero) eigen values; needed, when converting to frequencies
\end{itemize}
\item[--]
{\bf output}: [ArrayLike, ArrayLike]; [eigenValues, eigenVectors]; eigenValues being a numpy array of eigen values ($\omega_i^2$, being the squared eigen frequencies in ($\omega_i$ in rad/s)!), eigenVectors a numpy array containing the eigenvectors in every column
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
   #take any example from the Examples or TestModels folder, e.g., 'cartesianSpringDamper.py' and run it
   #specific example:
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  #
  b0 = mbs.CreateMassPoint(referenceCoordinates = [2,0,0],
                           initialVelocities = [2*0,5,0],
                           physicsMass = 1, gravity = [0,-9.81,0],
                           drawSize = 0.5, color=color4blue)
  #
  oGround = mbs.AddObject(ObjectGround())
  #add vertical spring
  oSD = mbs.CreateSpringDamper(bodyOrNodeList=[oGround, b0],
                               localPosition0=[2,1,0],
                               localPosition1=[0,0,0],
                               stiffness=1e4, damping=1e2,
                               drawSize=0.2)
  #
  mbs.Assemble()
  #
  [eigenvalues, eigenvectors] = mbs.ComputeODE2Eigenvalues()
   #==>eigenvalues contain the eigenvalues of the ODE2 part of the system in the current configuration
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on ComputeODE2Eigenvalues see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/nMassOscillatorInteractive.py}{\texttt{nMassOscillatorInteractive.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFBeamEigTest.py}{\texttt{ANCFBeamEigTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFBeamTest.py}{\texttt{ANCFBeamTest.py}} (TM), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/computeODE2EigenvaluesTest.py}{\texttt{computeODE2EigenvaluesTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/geometricallyExactBeamTest.py}{\texttt{geometricallyExactBeamTest.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L558}{ComputeSystemDegreeOfFreedom}{}}}\label{sec:mainsystemextensions:ComputeSystemDegreeOfFreedom}
({\it simulationSettings}= exudyn.SimulationSettings(), {\it threshold}= 1e-12, {\it verbose}= False, {\it useSVD}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]compute system DOF numerically, considering Gr{\"u}bler-Kutzbach formula as well as redundant constraints; uses numpy matrix rank or singular value decomposition of scipy (useSVD=True)
\item[]- NOTE that this function is added to MainSystem via Python function ComputeSystemDegreeOfFreedom.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it simulationSettings}: used e.g. for settings regarding numerical differentiation; default settings may be used in most cases
\item[]{\it threshold}: threshold factor for singular values which estimate the redundant constraints
\item[]{\it useSVD}: use singular value decomposition directly, also showing SVD values if verbose=True
\item[]{\it verbose}: if True, it will show the singular values and one may decide if the threshold shall be adapted
\end{itemize}
\item[--]
{\bf output}: List[int]; returns list of [dof, nRedundant, nODE2, nODE1, nAE, nPureAE], where: dof = the degree of freedom computed numerically, nRedundant=the number of redundant constraints, nODE2=number of ODE2 coordinates, nODE1=number of ODE1 coordinates, nAE=total number of constraints, nPureAE=number of constraints on algebraic variables (e.g., lambda=0) that are not coupled to ODE2 coordinates
\item[--]
{\bf notes}: this approach may not always work! Currently only works with dense matrices, thus it will be slow for larger systems
\item[--]
{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
  import exudyn as exu
  from exudyn.utilities import * #includes itemInterface, graphicsDataUtilities and rigidBodyUtilities
  import numpy as np
  SC = exu.SystemContainer()
  mbs = SC.AddSystem()
  #
  b0 = mbs.CreateRigidBody(inertia = InertiaCuboid(density=5000,
                                                   sideLengths=[1,0.1,0.1]),
                           referencePosition = [6,0,0],
                           initialAngularVelocity = [0,8,0],
                           gravity = [0,-9.81,0],
                           graphicsDataList = [GraphicsDataOrthoCubePoint(size=[1,0.1,0.1],
                                                                        color=color4orange)])
  oGround = mbs.AddObject(ObjectGround())
  mbs.CreateGenericJoint(bodyNumbers=[oGround, b0], position=[5.5,0,0],
                         constrainedAxes=[1,1,1, 1,0,0],
                         rotationMatrixAxes=RotationMatrixX(0.125*pi), #tilt axes
                         useGlobalFrame=True, axesRadius=0.02, axesLength=0.2)
  #
  mbs.Assemble()
  res = mbs.ComputeSystemDegreeOfFreedom(verbose=1) #print out details
\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%

%
\noindent For examples on ComputeSystemDegreeOfFreedom see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/fourBarMechanism3D.py}{\texttt{fourBarMechanism3D.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/rigidBodyTutorial3.py}{\texttt{rigidBodyTutorial3.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L160}{CreateDistanceSensorGeometry}{}}}\label{sec:mainsystemextensions:CreateDistanceSensorGeometry}
({\it meshPoints}, {\it meshTrigs}, {\it rigidBodyMarkerIndex}, {\it searchTreeCellSize}= [8,8,8])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Add geometry for distance sensor given by points and triangles (point indices) to mbs; use a rigid body marker where the geometry is put on;
\item[]Creates a GeneralContact for efficient search on background. If you have several sets of points and trigs, first merge them or add them manually to the contact
\item[]- NOTE that this function is added to MainSystem via Python function CreateDistanceSensorGeometry.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it meshPoints}: list of points (3D), as returned by GraphicsData2PointsAndTrigs()
\item[]{\it meshTrigs}: list of trigs (3 node indices each), as returned by GraphicsData2PointsAndTrigs()
\item[]{\it rigidBodyMarkerIndex}: rigid body marker to which the triangles are fixed on (ground or moving object)
\item[]{\it searchTreeCellSize}: size of search tree (X,Y,Z); use larger values in directions where more triangles are located
\end{itemize}
\item[--]
{\bf output}: int; returns ngc, which is the number of GeneralContact in mbs, to be used in CreateDistanceSensor(...); keep the gContact as deletion may corrupt data
\item[--]
{\bf notes}: should be used by CreateDistanceSensor(...) and AddLidar(...) for simple initialization of GeneralContact; old name: DistanceSensorSetupGeometry(...)
\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateDistanceSensorGeometry see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/laserScannerTest.py}{\texttt{laserScannerTest.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L193}{CreateDistanceSensor}{}}}\label{sec:mainsystemextensions:CreateDistanceSensor}
({\it generalContactIndex}, {\it positionOrMarker}, {\it dirSensor}, {\it minDistance}= -1e7, {\it maxDistance}= 1e7, {\it cylinderRadius}= 0, {\it selectedTypeIndex}= exudyn.ContactTypeIndex.IndexEndOfEnumList, {\it storeInternal}= False, {\it fileName}= '', {\it measureVelocity}= False, {\it addGraphicsObject}= False, {\it drawDisplaced}= True, {\it color}= color4red)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]Function to create distance sensor based on GeneralContact in mbs; sensor can be either placed on absolute position or attached to rigid body marker; in case of marker, dirSensor is relative to the marker
\item[]- NOTE that this function is added to MainSystem via Python function CreateDistanceSensor.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it generalContactIndex}: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
\item[]{\it positionOrMarker}: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
\item[]{\it dirSensor}: the direction (no need to normalize) along which the distance is measured (must not be normalized); in case of marker, the direction is relative to marker orientation if marker contains orientation (BodyRigid, NodeRigid)
\item[]{\it minDistance}: the minimum distance which is accepted; smaller distance will be ignored
\item[]{\it maxDistance}: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
\item[]{\it cylinderRadius}: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
\item[]{\it selectedTypeIndex}: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
\item[]{\it storeInternal}: like with any SensorUserFunction, setting to True stores sensor data internally
\item[]{\it fileName}: if defined, recorded data of SensorUserFunction is written to specified file
\item[]{\it measureVelocity}: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
\item[]{\it addGraphicsObject}: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
\item[]{\it drawDisplaced}: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
\item[]{\it color}: optional color for 'laser beam' to be drawn
\end{itemize}
\item[--]
{\bf output}: SensorIndex; creates sensor and returns according sensor number of SensorUserFunction
\item[--]
{\bf notes}: use generalContactIndex = CreateDistanceSensorGeometry(...) before to create GeneralContact module containing geometry; old name: AddDistanceSensor(...)
\vspace{12pt}\end{itemize}
%

%
\noindent For examples on CreateDistanceSensor see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/distanceSensor.py}{\texttt{distanceSensor.py}} (TM), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/laserScannerTest.py}{\texttt{laserScannerTest.py}} (TM)
\ei

%
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L847}{DrawSystemGraph}{}}}\label{sec:mainsystemextensions:DrawSystemGraph}
({\it showLoads}= True, {\it showSensors}= True, {\it useItemNames}= False, {\it useItemTypes}= False, {\it addItemTypeNames}= True, {\it multiLine}= True, {\it fontSizeFactor}= 1., {\it layoutDistanceFactor}= 3., {\it layoutIterations}= 100, {\it showLegend}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
\item[--]
{\bf function description}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]helper function which draws system graph of a MainSystem (mbs); several options let adjust the appearance of the graph; the graph visualization uses randomizer, which results in different graphs after every run!
\item[]- NOTE that this function is added to MainSystem via Python function DrawSystemGraph.
\end{itemize}
\item[--]
{\bf input}: \vspace{-6pt}
\begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
\item[]{\it showLoads}: toggle appearance of loads in mbs
\item[]{\it showSensors}: toggle appearance of sensors in mbs
\item[]{\it useItemNames}: if True, object names are shown instead of basic object types (Node, Load, ...)
\item[]{\it useItemTypes}: if True, object type names (MassPoint, JointRevolute, ...) are shown instead of basic object types (Node, Load, ...); Note that Node, Object, is omitted at the beginning of itemName (as compared to theDoc.pdf); item classes become clear from the legend
\item[]{\it addItemTypeNames}: if True, type nymes (Node, Load, etc.) are added
\item[]{\it multiLine}: if True, labels are multiline, improving readability
\item[]{\it fontSizeFactor}: use this factor to scale fonts, allowing to fit larger graphs on the screen with values < 1
\item[]{\it showLegend}: shows legend for different item types
\item[]{\it layoutDistanceFactor}: this factor influences the arrangement of labels; larger distance values lead to circle-like results
\item[]{\it layoutIterations}: more iterations lead to better arrangement of the layout, but need more time for larger systems (use 1000-10000 to get good results)
\end{itemize}
\item[--]
{\bf output}: [Any, Any, Any]; returns [networkx, G, items] with nx being networkx, G the graph and item what is returned by nx.draw\_networkx\_labels(...)
\vspace{12pt}\end{itemize}
%

%
\noindent For examples on DrawSystemGraph see Relevant Examples (Ex) and TestModels (TM) with weblink to github:
\bi
 \item \footnotesize \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/fourBarMechanism3D.py}{\texttt{fourBarMechanism3D.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/rigidBodyTutorial3.py}{\texttt{rigidBodyTutorial3.py}} (Ex), 
\exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/rigidBodyTutorial3withMarkers.py}{\texttt{rigidBodyTutorial3withMarkers.py}} (Ex), 
\\ \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/mainSystemExtensionsTests.py}{\texttt{mainSystemExtensionsTests.py}} (TM)
\ei

%
